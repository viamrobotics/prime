var Y6 = (s, e) => () => (e || s((e = { exports: {} }).exports, e), e.exports);
var rme = Y6((Dv, q6) => {
  (function() {
    const s = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), h = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap(), g = { attributes: !0, attributeFilter: ["disabled"] }, _ = new MutationObserver((Y) => {
      for (const G of Y) {
        const de = G.target;
        if (de.constructor.formAssociated) {
          const Ae = de.hasAttribute("disabled");
          de.toggleAttribute("internals-disabled", Ae), Ae ? de.setAttribute("aria-disabled", "true") : de.removeAttribute("aria-disabled"), de.formDisabledCallback && de.formDisabledCallback.apply(de, [Ae]);
        }
      }
    }), b = (Y) => {
      t.get(Y).forEach((de) => {
        de.remove();
      }), t.set(Y, []);
    }, C = (Y, G) => {
      const de = document.createElement("input");
      return de.type = "hidden", de.name = Y.getAttribute("name"), Y.after(de), t.get(G).push(de), de;
    }, v = (Y, G) => {
      t.set(G, []);
      const de = Y.hasAttribute("disabled");
      Y.toggleAttribute("internals-disabled", de), _.observe(Y, g);
    }, w = (Y, G) => {
      if (G.length) {
        Array.from(G).forEach((Ae) => Ae.addEventListener("click", Y.focus.bind(Y)));
        let de = G[0].id;
        G[0].id || (de = `${G[0].htmlFor}_Label`, G[0].id = de), Y.setAttribute("aria-labelledby", de);
      }
    }, S = (Y) => {
      const G = Array.from(Y.elements).filter((yt) => yt.validity).map((yt) => yt.validity.valid), de = Array.from(a.get(Y)).filter((yt) => yt.isConnected).map((yt) => i.get(yt).validity.valid), Ae = [...G, ...de].includes(!1);
      Y.toggleAttribute("internals-invalid", Ae), Y.toggleAttribute("internals-valid", !Ae);
    }, L = (Y) => {
      S(F(Y.target));
    }, x = (Y) => {
      S(F(Y.target));
    }, y = (Y) => {
      const G = Y.target, de = a.get(G);
      G.noValidate || de.size && (Array.from(de).reverse().map((mi) => i.get(mi).reportValidity()).includes(!1) ? (Y.stopImmediatePropagation(), Y.stopPropagation(), Y.preventDefault()) : f.get(G) && f.get(G).call(G, Y) === !1 && Y.preventDefault());
    }, k = (Y) => {
      const G = a.get(Y.target);
      G && G.size && G.forEach((de) => {
        de.constructor.formAssociated && de.formResetCallback && de.formResetCallback.apply(de);
      });
    }, I = (Y, G, de) => {
      if (G) {
        G.onsubmit && (f.set(G, G.onsubmit.bind(G)), G.onsubmit = null);
        const Ae = a.get(G);
        if (Ae)
          Ae.add(Y);
        else {
          const yt = /* @__PURE__ */ new Set();
          yt.add(Y), a.set(G, yt), G.addEventListener("submit", y), G.addEventListener("reset", k), G.addEventListener("input", L), G.addEventListener("change", x);
        }
        o.set(G, { ref: Y, internals: de }), Y.constructor.formAssociated && Y.formAssociatedCallback && setTimeout(() => {
          Y.formAssociatedCallback.apply(Y, [G]);
        }, 0), S(G);
      }
    }, F = (Y) => {
      let G = Y.parentNode;
      return G && G.tagName !== "FORM" && (G = F(G)), G;
    }, R = (Y, G, de = DOMException) => {
      if (!Y.constructor.formAssociated)
        throw new de(G);
    }, $ = (Y, G, de) => {
      const Ae = a.get(Y);
      return Ae && Ae.size && Ae.forEach((yt) => {
        i.get(yt)[de]() || (G = !1);
      }), G;
    }, j = (Y) => {
      if (Y.constructor.formAssociated) {
        const G = i.get(Y), { labels: de, form: Ae } = G;
        w(Y, de), I(Y, Ae, G);
      }
    }, le = {
      ariaAtomic: "aria-atomic",
      ariaAutoComplete: "aria-autocomplete",
      ariaBusy: "aria-busy",
      ariaChecked: "aria-checked",
      ariaColCount: "aria-colcount",
      ariaColIndex: "aria-colindex",
      ariaColSpan: "aria-colspan",
      ariaCurrent: "aria-current",
      ariaDisabled: "aria-disabled",
      ariaExpanded: "aria-expanded",
      ariaHasPopup: "aria-haspopup",
      ariaHidden: "aria-hidden",
      ariaKeyShortcuts: "aria-keyshortcuts",
      ariaLabel: "aria-label",
      ariaLevel: "aria-level",
      ariaLive: "aria-live",
      ariaModal: "aria-modal",
      ariaMultiLine: "aria-multiline",
      ariaMultiSelectable: "aria-multiselectable",
      ariaOrientation: "aria-orientation",
      ariaPlaceholder: "aria-placeholder",
      ariaPosInSet: "aria-posinset",
      ariaPressed: "aria-pressed",
      ariaReadOnly: "aria-readonly",
      ariaRelevant: "aria-relevant",
      ariaRequired: "aria-required",
      ariaRoleDescription: "aria-roledescription",
      ariaRowCount: "aria-rowcount",
      ariaRowIndex: "aria-rowindex",
      ariaRowSpan: "aria-rowspan",
      ariaSelected: "aria-selected",
      ariaSetSize: "aria-setsize",
      ariaSort: "aria-sort",
      ariaValueMax: "aria-valuemax",
      ariaValueMin: "aria-valuemin",
      ariaValueNow: "aria-valuenow",
      ariaValueText: "aria-valuetext",
      role: "role"
    }, he = (Y, G) => {
      for (let de in le) {
        G[de] = null;
        let Ae = null;
        const yt = le[de];
        Object.defineProperty(G, de, {
          get() {
            return Ae;
          },
          set(mi) {
            Ae = mi, Y.isConnected ? Y.setAttribute(yt, mi) : c.set(Y, G);
          }
        });
      }
    };
    class Ce {
      constructor() {
        this.badInput = !1, this.customError = !1, this.patternMismatch = !1, this.rangeOverflow = !1, this.rangeUnderflow = !1, this.stepMismatch = !1, this.tooLong = !1, this.tooShort = !1, this.typeMismatch = !1, this.valid = !0, this.valueMissing = !1, Object.seal(this);
      }
    }
    const Ne = (Y) => (Y.badInput = !1, Y.customError = !1, Y.patternMismatch = !1, Y.rangeOverflow = !1, Y.rangeUnderflow = !1, Y.stepMismatch = !1, Y.tooLong = !1, Y.tooShort = !1, Y.typeMismatch = !1, Y.valid = !0, Y.valueMissing = !1, Y), xe = (Y, G, de) => (Y.valid = Ve(G), Object.keys(G).forEach((Ae) => Y[Ae] = G[Ae]), de && S(de), Y), Ve = (Y) => {
      let G = !0;
      for (let de in Y)
        de !== "valid" && Y[de] !== !1 && (G = !1);
      return G;
    };
    function Ct(Y) {
      Y.forEach((G) => {
        const { addedNodes: de, removedNodes: Ae } = G, yt = Array.from(de), mi = Array.from(Ae);
        yt.forEach((ei) => {
          if (i.has(ei) && ei.constructor.formAssociated) {
            const ti = i.get(ei), { form: Ei } = ti;
            I(ei, Ei, ti), w(ei, ti.labels);
          }
          if (c.has(ei)) {
            const ti = c.get(ei);
            Object.keys(le).filter((K) => ti[K] !== null).forEach((K) => {
              ei.setAttribute(le[K], ti[K]);
            }), c.delete(ei);
          }
        }), mi.forEach((ei) => {
          const ti = i.get(ei);
          ti && t.get(ti) && b(ti), r.has(ei) && r.get(ei).disconnect();
        });
      });
    }
    function bt(Y) {
      Y.forEach((G) => {
        const { removedNodes: de } = G;
        de.forEach((Ae) => {
          const yt = u.get(G.target);
          i.has(Ae) && j(Ae), yt.disconnect();
        });
      });
    }
    const ve = (Y) => {
      const G = new MutationObserver(bt);
      G.observe(Y, { childList: !0 }), u.set(Y, G);
    };
    new MutationObserver(Ct);
    const pe = {
      childList: !0,
      subtree: !0
    }, ft = /* @__PURE__ */ new WeakMap();
    class Hi extends Set {
      static get isPolyfilled() {
        return !0;
      }
      constructor(G) {
        if (super(), !G || !G.tagName || G.tagName.indexOf("-") === -1)
          throw new TypeError("Illegal constructor");
        ft.set(this, G);
      }
      add(G) {
        if (!/^--/.test(G) || typeof G != "string")
          throw new DOMException(`Failed to execute 'add' on 'CustomStateSet': The specified value ${G} must start with '--'.`);
        const de = super.add(G), Ae = ft.get(this);
        return Ae.toggleAttribute(`state${G}`, !0), Ae.part && Ae.part.add(`state${G}`), de;
      }
      clear() {
        for (let [G] of this.entries())
          this.delete(G);
        super.clear();
      }
      delete(G) {
        const de = super.delete(G), Ae = ft.get(this);
        return Ae.toggleAttribute(`state${G}`, !1), Ae.part && Ae.part.remove(`state${G}`), de;
      }
    }
    class Ri {
      constructor(G) {
        if (!G || !G.tagName || G.tagName.indexOf("-") === -1)
          throw new TypeError("Illegal constructor");
        const de = G.getRootNode(), Ae = new Ce();
        this.states = new Hi(G), s.set(this, G), e.set(this, Ae), i.set(G, this), he(G, this), v(G, this), Object.seal(this), j(G), de instanceof DocumentFragment && ve(de);
      }
      static get isPolyfilled() {
        return !0;
      }
      checkValidity() {
        const G = s.get(this);
        if (R(G, "Failed to execute 'checkValidity' on 'ElementInternals': The target element is not a form-associated custom element."), !this.willValidate)
          return !0;
        const de = e.get(this);
        if (!de.valid) {
          const Ae = new Event("invalid", {
            bubbles: !1,
            cancelable: !0,
            composed: !1
          });
          G.dispatchEvent(Ae);
        }
        return de.valid;
      }
      get form() {
        const G = s.get(this);
        R(G, "Failed to read the 'form' property from 'ElementInternals': The target element is not a form-associated custom element.");
        let de;
        return G.constructor.formAssociated === !0 && (de = F(G)), de;
      }
      get labels() {
        const G = s.get(this);
        R(G, "Failed to read the 'labels' property from 'ElementInternals': The target element is not a form-associated custom element.");
        const de = G.getAttribute("id"), Ae = G.getRootNode();
        return Ae && de ? Ae.querySelectorAll(`[for=${de}]`) : [];
      }
      reportValidity() {
        const G = s.get(this);
        if (R(G, "Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element."), !this.willValidate)
          return !0;
        const de = this.checkValidity(), Ae = h.get(this);
        if (Ae && !G.constructor.formAssociated)
          throw new DOMException("Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.");
        return !de && Ae && (G.focus(), Ae.focus()), de;
      }
      setFormValue(G) {
        const de = s.get(this);
        if (R(de, "Failed to execute 'setFormValue' on 'ElementInternals': The target element is not a form-associated custom element."), b(this), G != null && !(G instanceof FormData)) {
          if (de.getAttribute("name")) {
            const Ae = C(de, this);
            Ae.value = G;
          }
        } else
          G != null && G instanceof FormData && G.forEach((Ae, yt) => {
            if (typeof Ae == "string") {
              const mi = C(de, this);
              mi.name = yt, mi.value = Ae;
            }
          });
        l.set(de, G);
      }
      setValidity(G, de, Ae) {
        const yt = s.get(this);
        if (R(yt, "Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element."), !G)
          throw new TypeError("Failed to execute 'setValidity' on 'ElementInternals': 1 argument required, but only 0 present.");
        h.set(this, Ae);
        const mi = e.get(this), ei = {};
        for (const K in G)
          ei[K] = G[K];
        Object.keys(ei).length === 0 && Ne(mi);
        const ti = { ...mi, ...ei };
        delete ti.valid;
        const { valid: Ei } = xe(mi, ti, this.form);
        if (!Ei && !de)
          throw new DOMException("Failed to execute 'setValidity' on 'ElementInternals': The second argument should not be empty if one or more flags in the first argument are true.");
        n.set(this, Ei ? "" : de), yt.toggleAttribute("internals-invalid", !Ei), yt.toggleAttribute("internals-valid", Ei), yt.setAttribute("aria-invalid", `${!Ei}`);
      }
      get shadowRoot() {
        const G = s.get(this), de = d.get(G);
        return de || null;
      }
      get validationMessage() {
        const G = s.get(this);
        return R(G, "Failed to read the 'validationMessage' property from 'ElementInternals': The target element is not a form-associated custom element."), n.get(this);
      }
      get validity() {
        const G = s.get(this);
        return R(G, "Failed to read the 'validity' property from 'ElementInternals': The target element is not a form-associated custom element."), e.get(this);
      }
      get willValidate() {
        const G = s.get(this);
        return R(G, "Failed to read the 'willValidate' property from 'ElementInternals': The target element is not a form-associated custom element."), !(G.disabled || G.hasAttribute("disabled") || G.hasAttribute("readonly"));
      }
    }
    function ms() {
      if (!window.ElementInternals)
        return !1;
      class Y extends HTMLElement {
        constructor() {
          super(), this.internals = this.attachInternals();
        }
      }
      const G = `element-internals-feature-detection-${Math.random().toString(36).replace(/[^a-z]+/g, "")}`;
      customElements.define(G, Y);
      const de = new Y();
      return [
        "shadowRoot",
        "form",
        "willValidate",
        "validity",
        "validationMessage",
        "labels",
        "setFormValue",
        "setValidity",
        "checkValidity",
        "reportValidity"
      ].every((Ae) => Ae in de.internals);
    }
    if (ms()) {
      if (!window.CustomStateSet) {
        window.CustomStateSet = Hi;
        const Y = HTMLElement.prototype.attachInternals;
        HTMLElement.prototype.attachInternals = function(...G) {
          const de = Y.call(this, G);
          return de.states = new Hi(this), de;
        };
      }
    } else {
      let Y = function(...ti) {
        const Ei = Ae.apply(this, ti), K = new MutationObserver(Ct);
        return d.set(this, Ei), window.ShadyDOM ? K.observe(this, pe) : K.observe(Ei, pe), r.set(this, K), Ei;
      }, G = function(...ti) {
        let Ei = mi.apply(this, ti);
        return $(this, Ei, "checkValidity");
      }, de = function(...ti) {
        let Ei = ei.apply(this, ti);
        return $(this, Ei, "reportValidity");
      };
      var Ao = Y, Ia = G, Ro = de;
      window.ElementInternals = Ri, HTMLElement.prototype.attachInternals = function() {
        if (this.tagName.indexOf("-") === -1)
          throw new Error("Failed to execute 'attachInternals' on 'HTMLElement': Unable to attach ElementInternals to non-custom elements.");
        if (i.has(this))
          throw new DOMException("DOMException: Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.");
        return new Ri(this);
      };
      const Ae = Element.prototype.attachShadow;
      Element.prototype.attachShadow = Y, new MutationObserver(Ct).observe(document.documentElement, pe);
      const mi = HTMLFormElement.prototype.checkValidity;
      HTMLFormElement.prototype.checkValidity = G;
      const ei = HTMLFormElement.prototype.reportValidity;
      HTMLFormElement.prototype.reportValidity = de, window.CustomStateSet || (window.CustomStateSet = Hi);
    }
  })();
  function Le() {
  }
  function nI(s) {
    return s();
  }
  function C2() {
    return /* @__PURE__ */ Object.create(null);
  }
  function Cl(s) {
    s.forEach(nI);
  }
  function P4(s) {
    return typeof s == "function";
  }
  function F4(s, e) {
    return s != s ? e == e : s !== e || s && typeof s == "object" || typeof s == "function";
  }
  function Cn(s, e) {
    return s != s ? e == e : s !== e;
  }
  function X6(s) {
    return Object.keys(s).length === 0;
  }
  function Q6(s, ...e) {
    if (s == null)
      return Le;
    const t = s.subscribe(...e);
    return t.unsubscribe ? () => t.unsubscribe() : t;
  }
  const B4 = typeof window < "u";
  let w2 = B4 ? () => window.performance.now() : () => Date.now(), W4 = B4 ? (s) => requestAnimationFrame(s) : Le;
  const Hu = /* @__PURE__ */ new Set();
  function V4(s) {
    Hu.forEach((e) => {
      e.c(s) || (Hu.delete(e), e.f());
    }), Hu.size !== 0 && W4(V4);
  }
  function J6(s) {
    let e;
    return Hu.size === 0 && W4(V4), {
      promise: new Promise((t) => {
        Hu.add(e = { c: s, f: t });
      }),
      abort() {
        Hu.delete(e);
      }
    };
  }
  function _e(s, e) {
    s.appendChild(e);
  }
  function Te(s, e, t) {
    s.insertBefore(e, t || null);
  }
  function Qe(s) {
    s.parentNode.removeChild(s);
  }
  function xv(s, e) {
    for (let t = 0; t < s.length; t += 1)
      s[t] && s[t].d(e);
  }
  function Ie(s) {
    return document.createElement(s);
  }
  function Hd(s) {
    return document.createElementNS("http://www.w3.org/2000/svg", s);
  }
  function Mi(s) {
    return document.createTextNode(s);
  }
  function Kt() {
    return Mi(" ");
  }
  function sI() {
    return Mi("");
  }
  function bi(s, e, t, i) {
    return s.addEventListener(e, t, i), () => s.removeEventListener(e, t, i);
  }
  function S2(s) {
    return function(e) {
      return e.preventDefault(), s.call(this, e);
    };
  }
  function X(s, e, t) {
    t == null ? s.removeAttribute(e) : s.getAttribute(e) !== t && s.setAttribute(e, t);
  }
  function eB(s) {
    return Array.from(s.childNodes);
  }
  function Zi(s, e) {
    e = "" + e, s.wholeText !== e && (s.data = e);
  }
  function co(s, e, t, i) {
    t === null ? s.style.removeProperty(e) : s.style.setProperty(e, t, i ? "important" : "");
  }
  function ji(s, e, t) {
    s.classList[t ? "add" : "remove"](e);
  }
  function ln(s) {
    const e = {};
    for (const t of s)
      e[t.name] = t.value;
    return e;
  }
  let Fm;
  function im(s) {
    Fm = s;
  }
  function Xf() {
    if (!Fm)
      throw new Error("Function called outside component initialization");
    return Fm;
  }
  function tB(s) {
    Xf().$$.on_mount.push(s);
  }
  function iB(s) {
    Xf().$$.after_update.push(s);
  }
  function nB(s) {
    Xf().$$.on_destroy.push(s);
  }
  const jg = [], ds = [], Zb = [], y2 = [], sB = Promise.resolve();
  let Fy = !1;
  function oB() {
    Fy || (Fy = !0, sB.then(we));
  }
  function By(s) {
    Zb.push(s);
  }
  const Lw = /* @__PURE__ */ new Set();
  let W_ = 0;
  function we() {
    const s = Fm;
    do {
      for (; W_ < jg.length; ) {
        const e = jg[W_];
        W_++, im(e), rB(e.$$);
      }
      for (im(null), jg.length = 0, W_ = 0; ds.length; )
        ds.pop()();
      for (let e = 0; e < Zb.length; e += 1) {
        const t = Zb[e];
        Lw.has(t) || (Lw.add(t), t());
      }
      Zb.length = 0;
    } while (jg.length);
    for (; y2.length; )
      y2.pop()();
    Fy = !1, Lw.clear(), im(s);
  }
  function rB(s) {
    if (s.fragment !== null) {
      s.update(), Cl(s.before_update);
      const e = s.dirty;
      s.dirty = [-1], s.fragment && s.fragment.p(s.ctx, e), s.after_update.forEach(By);
    }
  }
  const aB = /* @__PURE__ */ new Set();
  function H4(s, e) {
    s && s.i && (aB.delete(s), s.i(e));
  }
  const lB = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : global;
  function oI(s, e) {
    s.d(1), e.delete(s.key);
  }
  function rI(s, e, t, i, n, o, r, a, l, c, d, h) {
    let u = s.length, f = o.length, g = u;
    const _ = {};
    for (; g--; )
      _[s[g].key] = g;
    const b = [], C = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
    for (g = f; g--; ) {
      const x = h(n, o, g), y = t(x);
      let k = r.get(y);
      k ? i && k.p(x, e) : (k = c(y, x), k.c()), C.set(y, b[g] = k), y in _ && v.set(y, Math.abs(g - _[y]));
    }
    const w = /* @__PURE__ */ new Set(), S = /* @__PURE__ */ new Set();
    function L(x) {
      H4(x, 1), x.m(a, d), r.set(x.key, x), d = x.first, f--;
    }
    for (; u && f; ) {
      const x = b[f - 1], y = s[u - 1], k = x.key, I = y.key;
      x === y ? (d = x.first, u--, f--) : C.has(I) ? !r.has(k) || w.has(k) ? L(x) : S.has(I) ? u-- : v.get(k) > v.get(I) ? (S.add(k), L(x)) : (w.add(I), u--) : (l(y, r), u--);
    }
    for (; u--; ) {
      const x = s[u];
      C.has(x.key) || l(x, r);
    }
    for (; f; )
      L(b[f - 1]);
    return b;
  }
  function cB(s, e, t, i) {
    const { fragment: n, on_mount: o, on_destroy: r, after_update: a } = s.$$;
    n && n.m(e, t), i || By(() => {
      const l = o.map(nI).filter(P4);
      r ? r.push(...l) : Cl(l), s.$$.on_mount = [];
    }), a.forEach(By);
  }
  function dB(s, e) {
    const t = s.$$;
    t.fragment !== null && (Cl(t.on_destroy), t.fragment && t.fragment.d(e), t.on_destroy = t.fragment = null, t.ctx = []);
  }
  function hB(s, e) {
    s.$$.dirty[0] === -1 && (jg.push(s), oB(), s.$$.dirty.fill(0)), s.$$.dirty[e / 31 | 0] |= 1 << e % 31;
  }
  function cn(s, e, t, i, n, o, r, a = [-1]) {
    const l = Fm;
    im(s);
    const c = s.$$ = {
      fragment: null,
      ctx: null,
      props: o,
      update: Le,
      not_equal: n,
      bound: C2(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(e.context || (l ? l.$$.context : [])),
      callbacks: C2(),
      dirty: a,
      skip_bound: !1,
      root: e.target || l.$$.root
    };
    r && r(c.root);
    let d = !1;
    if (c.ctx = t ? t(s, e.props || {}, (h, u, ...f) => {
      const g = f.length ? f[0] : u;
      return c.ctx && n(c.ctx[h], c.ctx[h] = g) && (!c.skip_bound && c.bound[h] && c.bound[h](g), d && hB(s, h)), u;
    }) : [], c.update(), d = !0, Cl(c.before_update), c.fragment = i ? i(c.ctx) : !1, e.target) {
      if (e.hydrate) {
        const h = eB(e.target);
        c.fragment && c.fragment.l(h), h.forEach(Qe);
      } else
        c.fragment && c.fragment.c();
      e.intro && H4(s.$$.fragment), cB(s, e.target, e.anchor, e.customElement), we();
    }
    im(l);
  }
  let Yi;
  typeof HTMLElement == "function" && (Yi = class extends HTMLElement {
    constructor() {
      super(), this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount: s } = this.$$;
      this.$$.on_disconnect = s.map(nI).filter(P4);
      for (const e in this.$$.slotted)
        this.appendChild(this.$$.slotted[e]);
    }
    attributeChangedCallback(s, e, t) {
      this[s] = t;
    }
    disconnectedCallback() {
      Cl(this.$$.on_disconnect);
    }
    $destroy() {
      dB(this, 1), this.$destroy = Le;
    }
    $on(s, e) {
      const t = this.$$.callbacks[s] || (this.$$.callbacks[s] = []);
      return t.push(e), () => {
        const i = t.indexOf(e);
        i !== -1 && t.splice(i, 1);
      };
    }
    $set(s) {
      this.$$set && !X6(s) && (this.$$.skip_bound = !0, this.$$set(s), this.$$.skip_bound = !1);
    }
  });
  const z4 = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}.pointer-events-none{pointer-events:none}.invisible{visibility:hidden}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.right-0{right:0}.top-1{top:.25rem}.bottom-auto{bottom:auto}.bottom-1{bottom:.25rem}.left-1\\/2{left:50%}.bottom-full{bottom:100%}.-top-0\\.5{top:-.125rem}.-top-0{top:-0px}.top-\\[calc\\(50\\%-9px\\)\\]{top:calc(50% - 9px)}.top-0{top:0}.right-0\\.5{right:.125rem}.bottom-0{bottom:0}.isolate{isolation:isolate}.z-10{z-index:10}.z-\\[2\\]{z-index:2}.z-\\[1\\]{z-index:1}.-mt-px{margin-top:-1px}.-mt-0\\.5{margin-top:-.125rem}.-mt-0{margin-top:-0px}.mt-1{margin-top:.25rem}.mt-7{margin-top:1.75rem}.mb-3{margin-bottom:.75rem}.mt-px{margin-top:1px}.ml-px{margin-left:1px}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.hidden{display:none}.h-\\[60\\%\\]{height:60%}.h-full{height:100%}.h-0\\.5{height:.125rem}.h-0{height:0px}.h-5{height:1.25rem}.h-1{height:.25rem}.h-2{height:.5rem}.h-\\[4px\\]{height:4px}.h-4{height:1rem}.max-h-0{max-height:0px}.max-h-fit{max-height:fit-content}.w-px{width:1px}.w-full{width:100%}.w-5{width:1.25rem}.w-\\[1px\\]{width:1px}.w-11{width:2.75rem}.w-4{width:1rem}.max-w-\\[14rem\\]{max-width:14rem}.flex-shrink-0{flex-shrink:0}.table-fixed{table-layout:fixed}.-translate-x-1\\/2{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-1\\/2{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-1\\.5{--tw-translate-y: -.375rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-1{--tw-translate-y: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.translate-x-1\\/2{--tw-translate-x: 50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.translate-x-0{--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.translate-x-6{--tw-translate-x: 1.5rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-rotate-\\[30deg\\]{--tw-rotate: -30deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.rotate-\\[30deg\\]{--tw-rotate: 30deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.rotate-0{--tw-rotate: 0deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.rotate-180{--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.cursor-not-allowed{cursor:not-allowed}.select-none{user-select:none}.appearance-none{appearance:none}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-between{justify-content:space-between}.gap-3{gap:.75rem}.gap-2{gap:.5rem}.gap-1\\.5{gap:.375rem}.gap-1{gap:.25rem}.overflow-hidden{overflow:hidden}.whitespace-nowrap{white-space:nowrap}.rounded-full{border-radius:9999px}.rounded-none{border-radius:0}.border{border-width:1px}.border-y{border-top-width:1px;border-bottom-width:1px}.border-l{border-left-width:1px}.border-l-4{border-left-width:4px}.border-r{border-right-width:1px}.border-b{border-bottom-width:1px}.border-black{--tw-border-opacity: 1;border-color:rgb(0 0 0 / var(--tw-border-opacity))}.border-red\\/90{--tw-border-opacity: 1;border-color:rgb(190 48 38 / var(--tw-border-opacity))}.border-orange\\/90{--tw-border-opacity: 1;border-color:rgb(255 153 0 / var(--tw-border-opacity))}.border-green\\/90{--tw-border-opacity: 1;border-color:rgb(57 127 72 / var(--tw-border-opacity))}.border-blue\\/90{--tw-border-opacity: 1;border-color:rgb(4 86 129 / var(--tw-border-opacity))}.border-black\\/70{--tw-border-opacity: 1;border-color:rgb(85 85 85 / var(--tw-border-opacity))}.border-green\\/100{--tw-border-opacity: 1;border-color:rgb(41 91 51 / var(--tw-border-opacity))}.border-x-black{--tw-border-opacity: 1;border-left-color:rgb(0 0 0 / var(--tw-border-opacity));border-right-color:rgb(0 0 0 / var(--tw-border-opacity))}.border-t-black{--tw-border-opacity: 1;border-top-color:rgb(0 0 0 / var(--tw-border-opacity))}.border-b-white{--tw-border-opacity: 1;border-bottom-color:rgb(255 255 255 / var(--tw-border-opacity))}.border-l-gray-300{--tw-border-opacity: 1;border-left-color:rgb(209 213 219 / var(--tw-border-opacity))}.border-r-gray-300{--tw-border-opacity: 1;border-right-color:rgb(209 213 219 / var(--tw-border-opacity))}.bg-green-200{--tw-bg-opacity: 1;background-color:rgb(187 247 208 / var(--tw-bg-opacity))}.bg-orange-200{--tw-bg-opacity: 1;background-color:rgb(254 215 170 / var(--tw-bg-opacity))}.bg-red-200{--tw-bg-opacity: 1;background-color:rgb(254 202 202 / var(--tw-bg-opacity))}.bg-gray-200{--tw-bg-opacity: 1;background-color:rgb(229 231 235 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-gray-100{--tw-bg-opacity: 1;background-color:rgb(243 244 246 / var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.bg-black\\/50{--tw-bg-opacity: 1;background-color:rgb(157 157 157 / var(--tw-bg-opacity))}.bg-gray-400{--tw-bg-opacity: 1;background-color:rgb(156 163 175 / var(--tw-bg-opacity))}.bg-green\\/80{--tw-bg-opacity: 1;background-color:rgb(73 162 92 / var(--tw-bg-opacity))}.bg-black\\/20{--tw-bg-opacity: 1;background-color:rgb(233 233 233 / var(--tw-bg-opacity))}.bg-red\\/90{--tw-bg-opacity: 1;background-color:rgb(190 48 38 / var(--tw-bg-opacity))}.bg-green\\/90{--tw-bg-opacity: 1;background-color:rgb(57 127 72 / var(--tw-bg-opacity))}.p-3{padding:.75rem}.p-2{padding:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.py-0\\.5{padding-top:.125rem;padding-bottom:.125rem}.py-0{padding-top:0;padding-bottom:0}.px-4{padding-left:1rem;padding-right:1rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-2\\.5{padding-left:.625rem;padding-right:.625rem}.px-1\\.5{padding-left:.375rem;padding-right:.375rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-1{padding-bottom:.25rem}.text-left{text-align:left}.text-center{text-align:center}.text-xs{font-size:.75rem;line-height:1rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-base{font-size:1rem;line-height:1.5rem}.text-\\[15px\\]{font-size:15px}.font-bold{font-weight:700}.font-normal{font-weight:400}.uppercase{text-transform:uppercase}.capitalize{text-transform:capitalize}.text-green-900{--tw-text-opacity: 1;color:rgb(20 83 45 / var(--tw-text-opacity))}.text-orange-900{--tw-text-opacity: 1;color:rgb(124 45 18 / var(--tw-text-opacity))}.text-red-900{--tw-text-opacity: 1;color:rgb(127 29 29 / var(--tw-text-opacity))}.text-gray-800{--tw-text-opacity: 1;color:rgb(31 41 55 / var(--tw-text-opacity))}.text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.text-black\\/70{--tw-text-opacity: 1;color:rgb(85 85 85 / var(--tw-text-opacity))}.text-red\\/90{--tw-text-opacity: 1;color:rgb(190 48 38 / var(--tw-text-opacity))}.text-neutral-600{--tw-text-opacity: 1;color:rgb(82 82 82 / var(--tw-text-opacity))}.opacity-50{opacity:.5}.opacity-0{opacity:0}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.ring-0{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.duration-200{transition-duration:.2s}.duration-500{transition-duration:.5s}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}*,input,button{font-family:Space Mono,monospace}:host{display:contents}[class^=icon-],[class*=" icon-"]{font-family:icons!important;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon-error-outline:before{content:"\\e912"}.icon-warning:before{content:"\\e916"}.icon-disconnected:before{content:"\\e919"}.icon-send:before{content:"\\e91b"}.icon-undo:before{content:"\\e91c"}.icon-connected:before{content:"\\e91a"}.icon-download:before{content:"\\e913"}.icon-camera:before{content:"\\e914"}.icon-center:before{content:"\\e915"}.icon-arrow-up:before{content:"\\e917"}.icon-settings:before{content:"\\e918"}.icon-refresh:before{content:"\\e911"}.icon-info-outline:before{content:"\\e910"}.icon-pause-circle-filled:before{content:"\\e90e"}.icon-play-circle-filled:before{content:"\\e90f"}.icon-logout:before{content:"\\e900"}.icon-instagram:before{content:"\\e901"}.icon-social-medium:before{content:"\\e906"}.icon-copy:before{content:"\\e907"}.icon-save:before{content:"\\e909"}.icon-edit:before{content:"\\e90a";color:#555}.icon-stop-circle:before{content:"\\e903"}.icon-twitter:before{content:"\\e902"}.icon-linkedin:before{content:"\\e90b"}.icon-trash:before{content:"\\e905"}.icon-alert:before{content:"\\e904"}.icon-ask:before{content:"\\e908"}.icon-x:before{content:"\\e942"}.icon-chevron-down:before{content:"\\e90c"}.icon-checkmark:before{content:"\\e90d"}.first\\:ml-4:first-child{margin-left:1rem}.last\\:border-r:last-child{border-right-width:1px}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}@media (prefers-reduced-motion: no-preference){.motion-safe\\:transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.motion-safe\\:transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}}
`;
  let Wy, U4 = !1;
  try {
    Wy = new CSSStyleSheet(), Wy.replaceSync(z4);
  } catch {
    U4 = !0;
  }
  const dn = () => {
    const s = Xf();
    if (U4) {
      const e = document.createElement("style");
      e.innerHTML = z4, s.shadowRoot.append(e);
    } else
      s.shadowRoot.adoptedStyleSheets = [Wy];
  }, { base: L2 = "", query: k2 = "", workers: cme = {} } = window.PRIME_CONFIG ?? {}, uB = async () => {
    const s = new FontFace("icons", L2 ? `url(${L2}/icons.woff2${k2})` : `url(icons.woff2${k2})`);
    await s.load(), document.fonts.add(s);
  };
  function fB(s, e) {
    let t;
    return e.length === 0 ? t = s : t = s.replace(/\{(\d+)\}/g, function(i, n) {
      const o = n[0];
      return typeof e[o] < "u" ? e[o] : i;
    }), t;
  }
  function m(s, e, ...t) {
    return fB(e, t);
  }
  class gB {
    constructor() {
      this.listeners = [], this.unexpectedErrorHandler = function(e) {
        setTimeout(() => {
          throw e.stack ? new Error(e.message + `

` + e.stack) : e;
        }, 0);
      };
    }
    emit(e) {
      this.listeners.forEach((t) => {
        t(e);
      });
    }
    onUnexpectedError(e) {
      this.unexpectedErrorHandler(e), this.emit(e);
    }
    onUnexpectedExternalError(e) {
      this.unexpectedErrorHandler(e);
    }
  }
  const $4 = new gB();
  function We(s) {
    va(s) || $4.onUnexpectedError(s);
  }
  function Xi(s) {
    va(s) || $4.onUnexpectedExternalError(s);
  }
  function D2(s) {
    if (s instanceof Error) {
      let { name: e, message: t } = s;
      const i = s.stacktrace || s.stack;
      return {
        $isError: !0,
        name: e,
        message: t,
        stack: i
      };
    }
    return s;
  }
  const R0 = "Canceled";
  function va(s) {
    return s instanceof Dh ? !0 : s instanceof Error && s.name === R0 && s.message === R0;
  }
  class Dh extends Error {
    constructor() {
      super(R0), this.name = this.message;
    }
  }
  function aI() {
    const s = new Error(R0);
    return s.name = s.message, s;
  }
  function fr(s) {
    return s ? new Error(`Illegal argument: ${s}`) : new Error("Illegal argument");
  }
  function mB(s) {
    return s ? new Error(`Illegal state: ${s}`) : new Error("Illegal state");
  }
  class pB extends Error {
    constructor(e) {
      super("NotSupported"), e && (this.message = e);
    }
  }
  function ul(s) {
    const e = this;
    let t = !1, i;
    return function() {
      return t || (t = !0, i = s.apply(e, arguments)), i;
    };
  }
  var rt;
  (function(s) {
    function e(v) {
      return v && typeof v == "object" && typeof v[Symbol.iterator] == "function";
    }
    s.is = e;
    const t = Object.freeze([]);
    function i() {
      return t;
    }
    s.empty = i;
    function* n(v) {
      yield v;
    }
    s.single = n;
    function o(v) {
      return v || t;
    }
    s.from = o;
    function r(v) {
      return !v || v[Symbol.iterator]().next().done === !0;
    }
    s.isEmpty = r;
    function a(v) {
      return v[Symbol.iterator]().next().value;
    }
    s.first = a;
    function l(v, w) {
      for (const S of v)
        if (w(S))
          return !0;
      return !1;
    }
    s.some = l;
    function c(v, w) {
      for (const S of v)
        if (w(S))
          return S;
    }
    s.find = c;
    function* d(v, w) {
      for (const S of v)
        w(S) && (yield S);
    }
    s.filter = d;
    function* h(v, w) {
      let S = 0;
      for (const L of v)
        yield w(L, S++);
    }
    s.map = h;
    function* u(...v) {
      for (const w of v)
        for (const S of w)
          yield S;
    }
    s.concat = u;
    function* f(v) {
      for (const w of v)
        for (const S of w)
          yield S;
    }
    s.concatNested = f;
    function g(v, w, S) {
      let L = S;
      for (const x of v)
        L = w(L, x);
      return L;
    }
    s.reduce = g;
    function* _(v, w, S = v.length) {
      for (w < 0 && (w += v.length), S < 0 ? S += v.length : S > v.length && (S = v.length); w < S; w++)
        yield v[w];
    }
    s.slice = _;
    function b(v, w = Number.POSITIVE_INFINITY) {
      const S = [];
      if (w === 0)
        return [S, v];
      const L = v[Symbol.iterator]();
      for (let x = 0; x < w; x++) {
        const y = L.next();
        if (y.done)
          return [S, s.empty()];
        S.push(y.value);
      }
      return [S, { [Symbol.iterator]() {
        return L;
      } }];
    }
    s.consume = b;
    function C(v, w, S = (L, x) => L === x) {
      const L = v[Symbol.iterator](), x = w[Symbol.iterator]();
      for (; ; ) {
        const y = L.next(), k = x.next();
        if (y.done !== k.done)
          return !1;
        if (y.done)
          return !0;
        if (!S(y.value, k.value))
          return !1;
      }
    }
    s.equals = C;
  })(rt || (rt = {}));
  class _B extends Error {
    constructor(e) {
      super(`Encountered errors while disposing of store. Errors: [${e.join(", ")}]`), this.errors = e;
    }
  }
  function lI(s) {
    return typeof s.dispose == "function" && s.dispose.length === 0;
  }
  function at(s) {
    if (rt.is(s)) {
      let e = [];
      for (const t of s)
        if (t)
          try {
            t.dispose();
          } catch (i) {
            e.push(i);
          }
      if (e.length === 1)
        throw e[0];
      if (e.length > 1)
        throw new _B(e);
      return Array.isArray(s) ? [] : s;
    } else if (s)
      return s.dispose(), s;
  }
  function ol(...s) {
    return qe(() => at(s));
  }
  function qe(s) {
    return {
      dispose: ul(() => {
        s();
      })
    };
  }
  class te {
    constructor() {
      this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
    }
    dispose() {
      this._isDisposed || (this._isDisposed = !0, this.clear());
    }
    get isDisposed() {
      return this._isDisposed;
    }
    clear() {
      try {
        at(this._toDispose.values());
      } finally {
        this._toDispose.clear();
      }
    }
    add(e) {
      if (!e)
        return e;
      if (e === this)
        throw new Error("Cannot register a disposable on itself!");
      return this._isDisposed ? te.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
    }
  }
  te.DISABLE_DISPOSED_WARNING = !1;
  class z {
    constructor() {
      this._store = new te(), this._store;
    }
    dispose() {
      this._store.dispose();
    }
    _register(e) {
      if (e === this)
        throw new Error("Cannot register a disposable on itself!");
      return this._store.add(e);
    }
  }
  z.None = Object.freeze({ dispose() {
  } });
  class Gn {
    constructor() {
      this._isDisposed = !1;
    }
    get value() {
      return this._isDisposed ? void 0 : this._value;
    }
    set value(e) {
      var t;
      this._isDisposed || e === this._value || ((t = this._value) === null || t === void 0 || t.dispose(), this._value = e);
    }
    clear() {
      this.value = void 0;
    }
    dispose() {
      var e;
      this._isDisposed = !0, (e = this._value) === null || e === void 0 || e.dispose(), this._value = void 0;
    }
    clearAndLeak() {
      const e = this._value;
      return this._value = void 0, e;
    }
  }
  class bB {
    constructor() {
      this.dispose = () => {
      }, this.unset = () => {
      }, this.isset = () => !1;
    }
    set(e) {
      let t = e;
      return this.unset = () => t = void 0, this.isset = () => t !== void 0, this.dispose = () => {
        t && (t(), t = void 0);
      }, this;
    }
  }
  class vB {
    constructor(e) {
      this.object = e;
    }
    dispose() {
    }
  }
  class si {
    constructor(e) {
      this.element = e, this.next = si.Undefined, this.prev = si.Undefined;
    }
  }
  si.Undefined = new si(void 0);
  class $s {
    constructor() {
      this._first = si.Undefined, this._last = si.Undefined, this._size = 0;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._first === si.Undefined;
    }
    clear() {
      let e = this._first;
      for (; e !== si.Undefined; ) {
        const t = e.next;
        e.prev = si.Undefined, e.next = si.Undefined, e = t;
      }
      this._first = si.Undefined, this._last = si.Undefined, this._size = 0;
    }
    unshift(e) {
      return this._insert(e, !1);
    }
    push(e) {
      return this._insert(e, !0);
    }
    _insert(e, t) {
      const i = new si(e);
      if (this._first === si.Undefined)
        this._first = i, this._last = i;
      else if (t) {
        const o = this._last;
        this._last = i, i.prev = o, o.next = i;
      } else {
        const o = this._first;
        this._first = i, i.next = o, o.prev = i;
      }
      this._size += 1;
      let n = !1;
      return () => {
        n || (n = !0, this._remove(i));
      };
    }
    shift() {
      if (this._first !== si.Undefined) {
        const e = this._first.element;
        return this._remove(this._first), e;
      }
    }
    pop() {
      if (this._last !== si.Undefined) {
        const e = this._last.element;
        return this._remove(this._last), e;
      }
    }
    _remove(e) {
      if (e.prev !== si.Undefined && e.next !== si.Undefined) {
        const t = e.prev;
        t.next = e.next, e.next.prev = t;
      } else
        e.prev === si.Undefined && e.next === si.Undefined ? (this._first = si.Undefined, this._last = si.Undefined) : e.next === si.Undefined ? (this._last = this._last.prev, this._last.next = si.Undefined) : e.prev === si.Undefined && (this._first = this._first.next, this._first.prev = si.Undefined);
      this._size -= 1;
    }
    *[Symbol.iterator]() {
      let e = this._first;
      for (; e !== si.Undefined; )
        yield e.element, e = e.next;
    }
  }
  var kw;
  const Yb = "en";
  let O0 = !1, P0 = !1, Xb = !1, j4 = !1, cI = !1, dI = !1, V_, Qb = Yb, CB, Al;
  const gi = typeof self == "object" ? self : typeof global == "object" ? global : {};
  let Hn;
  typeof gi.vscode < "u" && typeof gi.vscode.process < "u" ? Hn = gi.vscode.process : typeof process < "u" && (Hn = process);
  const wB = typeof ((kw = Hn?.versions) === null || kw === void 0 ? void 0 : kw.electron) == "string", SB = wB && Hn?.type === "renderer";
  if (typeof navigator == "object" && !SB)
    Al = navigator.userAgent, O0 = Al.indexOf("Windows") >= 0, P0 = Al.indexOf("Macintosh") >= 0, dI = (Al.indexOf("Macintosh") >= 0 || Al.indexOf("iPad") >= 0 || Al.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, Xb = Al.indexOf("Linux") >= 0, cI = !0, V_ = navigator.language, Qb = V_;
  else if (typeof Hn == "object") {
    O0 = Hn.platform === "win32", P0 = Hn.platform === "darwin", Xb = Hn.platform === "linux", Xb && !!Hn.env.SNAP && Hn.env.SNAP_REVISION, Hn.env.CI || Hn.env.BUILD_ARTIFACTSTAGINGDIRECTORY, V_ = Yb, Qb = Yb;
    const s = Hn.env.VSCODE_NLS_CONFIG;
    if (s)
      try {
        const e = JSON.parse(s), t = e.availableLanguages["*"];
        V_ = e.locale, Qb = t || Yb, CB = e._translationsConfigFile;
      } catch {
      }
    j4 = !0;
  } else
    console.error("Unable to resolve platform.");
  const rn = O0, Ye = P0, Nn = Xb, gr = j4, Pc = cI, yB = cI && typeof gi.importScripts == "function", aa = dI, la = Al, LB = Qb, K4 = (() => {
    if (typeof gi.postMessage == "function" && !gi.importScripts) {
      let s = [];
      gi.addEventListener("message", (t) => {
        if (t.data && t.data.vscodeScheduleAsyncWork)
          for (let i = 0, n = s.length; i < n; i++) {
            const o = s[i];
            if (o.id === t.data.vscodeScheduleAsyncWork) {
              s.splice(i, 1), o.callback();
              return;
            }
          }
      });
      let e = 0;
      return (t) => {
        const i = ++e;
        s.push({
          id: i,
          callback: t
        }), gi.postMessage({ vscodeScheduleAsyncWork: i }, "*");
      };
    }
    return (s) => setTimeout(s);
  })(), oo = P0 || dI ? 2 : O0 ? 1 : 3;
  let x2 = !0, I2 = !1;
  function q4() {
    if (!I2) {
      I2 = !0;
      const s = new Uint8Array(2);
      s[0] = 1, s[1] = 2, x2 = new Uint16Array(s.buffer)[0] === (2 << 8) + 1;
    }
    return x2;
  }
  const G4 = !!(la && la.indexOf("Chrome") >= 0), kB = !!(la && la.indexOf("Firefox") >= 0), DB = !!(!G4 && la && la.indexOf("Safari") >= 0), xB = !!(la && la.indexOf("Edg/") >= 0);
  la && la.indexOf("Android") >= 0;
  const IB = gi.performance && typeof gi.performance.now == "function";
  class hs {
    constructor(e) {
      this._highResolution = IB && e, this._startTime = this._now(), this._stopTime = -1;
    }
    static create(e = !0) {
      return new hs(e);
    }
    stop() {
      this._stopTime = this._now();
    }
    elapsed() {
      return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
    }
    _now() {
      return this._highResolution ? gi.performance.now() : Date.now();
    }
  }
  var be;
  (function(s) {
    s.None = () => z.None;
    function e(S) {
      return (L, x = null, y) => {
        let k = !1, I;
        return I = S((F) => {
          if (!k)
            return I ? I.dispose() : k = !0, L.call(x, F);
        }, null, y), k && I.dispose(), I;
      };
    }
    s.once = e;
    function t(S, L, x) {
      return l((y, k = null, I) => S((F) => y.call(k, L(F)), null, I), x);
    }
    s.map = t;
    function i(S, L, x) {
      return l((y, k = null, I) => S((F) => {
        L(F), y.call(k, F);
      }, null, I), x);
    }
    s.forEach = i;
    function n(S, L, x) {
      return l((y, k = null, I) => S((F) => L(F) && y.call(k, F), null, I), x);
    }
    s.filter = n;
    function o(S) {
      return S;
    }
    s.signal = o;
    function r(...S) {
      return (L, x = null, y) => ol(...S.map((k) => k((I) => L.call(x, I), null, y)));
    }
    s.any = r;
    function a(S, L, x, y) {
      let k = x;
      return t(S, (I) => (k = L(k, I), k), y);
    }
    s.reduce = a;
    function l(S, L) {
      let x;
      const y = {
        onFirstListenerAdd() {
          x = S(k.fire, k);
        },
        onLastListenerRemove() {
          x.dispose();
        }
      }, k = new B(y);
      return L && L.add(k), k.event;
    }
    function c(S, L, x = 100, y = !1, k, I) {
      let F, R, $, j = 0;
      const le = {
        leakWarningThreshold: k,
        onFirstListenerAdd() {
          F = S((Ce) => {
            j++, R = L(R, Ce), y && !$ && (he.fire(R), R = void 0), clearTimeout($), $ = setTimeout(() => {
              const Ne = R;
              R = void 0, $ = void 0, (!y || j > 1) && he.fire(Ne), j = 0;
            }, x);
          });
        },
        onLastListenerRemove() {
          F.dispose();
        }
      }, he = new B(le);
      return I && I.add(he), he.event;
    }
    s.debounce = c;
    function d(S, L = (y, k) => y === k, x) {
      let y = !0, k;
      return n(S, (I) => {
        const F = y || !L(I, k);
        return y = !1, k = I, F;
      }, x);
    }
    s.latch = d;
    function h(S, L, x) {
      return [
        s.filter(S, L, x),
        s.filter(S, (y) => !L(y), x)
      ];
    }
    s.split = h;
    function u(S, L = !1, x = []) {
      let y = x.slice(), k = S((R) => {
        y ? y.push(R) : F.fire(R);
      });
      const I = () => {
        y && y.forEach((R) => F.fire(R)), y = null;
      }, F = new B({
        onFirstListenerAdd() {
          k || (k = S((R) => F.fire(R)));
        },
        onFirstListenerDidAdd() {
          y && (L ? setTimeout(I) : I());
        },
        onLastListenerRemove() {
          k && k.dispose(), k = null;
        }
      });
      return F.event;
    }
    s.buffer = u;
    class f {
      constructor(L) {
        this.event = L;
      }
      map(L) {
        return new f(t(this.event, L));
      }
      forEach(L) {
        return new f(i(this.event, L));
      }
      filter(L) {
        return new f(n(this.event, L));
      }
      reduce(L, x) {
        return new f(a(this.event, L, x));
      }
      latch() {
        return new f(d(this.event));
      }
      debounce(L, x = 100, y = !1, k) {
        return new f(c(this.event, L, x, y, k));
      }
      on(L, x, y) {
        return this.event(L, x, y);
      }
      once(L, x, y) {
        return e(this.event)(L, x, y);
      }
    }
    function g(S) {
      return new f(S);
    }
    s.chain = g;
    function _(S, L, x = (y) => y) {
      const y = (...R) => F.fire(x(...R)), k = () => S.on(L, y), I = () => S.removeListener(L, y), F = new B({ onFirstListenerAdd: k, onLastListenerRemove: I });
      return F.event;
    }
    s.fromNodeEventEmitter = _;
    function b(S, L, x = (y) => y) {
      const y = (...R) => F.fire(x(...R)), k = () => S.addEventListener(L, y), I = () => S.removeEventListener(L, y), F = new B({ onFirstListenerAdd: k, onLastListenerRemove: I });
      return F.event;
    }
    s.fromDOMEventEmitter = b;
    function C(S) {
      return new Promise((L) => e(S)(L));
    }
    s.toPromise = C;
    function v(S, L) {
      return L(void 0), S((x) => L(x));
    }
    s.runAndSubscribe = v;
    function w(S, L) {
      let x = null;
      function y(I) {
        x?.dispose(), x = new te(), L(I, x);
      }
      y(void 0);
      const k = S((I) => y(I));
      return qe(() => {
        k.dispose(), x?.dispose();
      });
    }
    s.runAndSubscribeWithStore = w;
  })(be || (be = {}));
  class Iv {
    constructor(e) {
      this._listenerCount = 0, this._invocationCount = 0, this._elapsedOverall = 0, this._name = `${e}_${Iv._idPool++}`;
    }
    start(e) {
      this._stopWatch = new hs(!0), this._listenerCount = e;
    }
    stop() {
      if (this._stopWatch) {
        const e = this._stopWatch.elapsed();
        this._elapsedOverall += e, this._invocationCount += 1, console.info(`did FIRE ${this._name}: elapsed_ms: ${e.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`), this._stopWatch = void 0;
      }
    }
  }
  Iv._idPool = 0;
  class hI {
    constructor(e) {
      this.value = e;
    }
    static create() {
      var e;
      return new hI((e = new Error().stack) !== null && e !== void 0 ? e : "");
    }
    print() {
      console.warn(this.value.split(`
`).slice(2).join(`
`));
    }
  }
  class EB {
    constructor(e, t, i) {
      this.callback = e, this.callbackThis = t, this.stack = i, this.subscription = new bB();
    }
    invoke(e) {
      this.callback.call(this.callbackThis, e);
    }
  }
  class B {
    constructor(e) {
      var t;
      this._disposed = !1, this._options = e, this._leakageMon = void 0, this._perfMon = !((t = this._options) === null || t === void 0) && t._profName ? new Iv(this._options._profName) : void 0;
    }
    dispose() {
      var e, t, i, n;
      this._disposed || (this._disposed = !0, this._listeners && this._listeners.clear(), (e = this._deliveryQueue) === null || e === void 0 || e.clear(), (i = (t = this._options) === null || t === void 0 ? void 0 : t.onLastListenerRemove) === null || i === void 0 || i.call(t), (n = this._leakageMon) === null || n === void 0 || n.dispose());
    }
    get event() {
      return this._event || (this._event = (e, t, i) => {
        var n, o, r;
        this._listeners || (this._listeners = new $s());
        const a = this._listeners.isEmpty();
        a && ((n = this._options) === null || n === void 0 ? void 0 : n.onFirstListenerAdd) && this._options.onFirstListenerAdd(this);
        let l, c;
        this._leakageMon && this._listeners.size >= 30 && (c = hI.create(), l = this._leakageMon.check(c, this._listeners.size + 1));
        const d = new EB(e, t, c), h = this._listeners.push(d);
        a && ((o = this._options) === null || o === void 0 ? void 0 : o.onFirstListenerDidAdd) && this._options.onFirstListenerDidAdd(this), !((r = this._options) === null || r === void 0) && r.onListenerDidAdd && this._options.onListenerDidAdd(this, e, t);
        const u = d.subscription.set(() => {
          l && l(), this._disposed || (h(), this._options && this._options.onLastListenerRemove && (this._listeners && !this._listeners.isEmpty() || this._options.onLastListenerRemove(this)));
        });
        return i instanceof te ? i.add(u) : Array.isArray(i) && i.push(u), u;
      }), this._event;
    }
    fire(e) {
      var t, i;
      if (this._listeners) {
        this._deliveryQueue || (this._deliveryQueue = new $s());
        for (let n of this._listeners)
          this._deliveryQueue.push([n, e]);
        for ((t = this._perfMon) === null || t === void 0 || t.start(this._deliveryQueue.size); this._deliveryQueue.size > 0; ) {
          const [n, o] = this._deliveryQueue.shift();
          try {
            n.invoke(o);
          } catch (r) {
            We(r);
          }
        }
        (i = this._perfMon) === null || i === void 0 || i.stop();
      }
    }
  }
  class F0 extends B {
    constructor(e) {
      super(e), this._isPaused = 0, this._eventQueue = new $s(), this._mergeFn = e?.merge;
    }
    pause() {
      this._isPaused++;
    }
    resume() {
      if (this._isPaused !== 0 && --this._isPaused === 0)
        if (this._mergeFn) {
          const e = Array.from(this._eventQueue);
          this._eventQueue.clear(), super.fire(this._mergeFn(e));
        } else
          for (; !this._isPaused && this._eventQueue.size !== 0; )
            super.fire(this._eventQueue.shift());
    }
    fire(e) {
      this._listeners && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
    }
  }
  class NB extends F0 {
    constructor(e) {
      var t;
      super(e), this._delay = (t = e.delay) !== null && t !== void 0 ? t : 100;
    }
    fire(e) {
      this._handle || (this.pause(), this._handle = setTimeout(() => {
        this._handle = void 0, this.resume();
      }, this._delay)), super.fire(e);
    }
  }
  class uI {
    constructor() {
      this.buffers = [];
    }
    wrapEvent(e) {
      return (t, i, n) => e((o) => {
        const r = this.buffers[this.buffers.length - 1];
        r ? r.push(() => t.call(i, o)) : t.call(i, o);
      }, void 0, n);
    }
    bufferEvents(e) {
      const t = [];
      this.buffers.push(t);
      const i = e();
      return this.buffers.pop(), t.forEach((n) => n()), i;
    }
  }
  class E2 {
    constructor() {
      this.listening = !1, this.inputEvent = be.None, this.inputEventListener = z.None, this.emitter = new B({
        onFirstListenerDidAdd: () => {
          this.listening = !0, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
        },
        onLastListenerRemove: () => {
          this.listening = !1, this.inputEventListener.dispose();
        }
      }), this.event = this.emitter.event;
    }
    set input(e) {
      this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
    }
    dispose() {
      this.inputEventListener.dispose(), this.emitter.dispose();
    }
  }
  class Vy {
    constructor() {
      this._zoomFactor = 1;
    }
    getZoomFactor() {
      return this._zoomFactor;
    }
  }
  Vy.INSTANCE = new Vy();
  class TB extends z {
    constructor() {
      super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._listener = () => this._handleChange(!0), this._mediaQueryList = null, this._handleChange(!1);
    }
    _handleChange(e) {
      this._mediaQueryList && this._mediaQueryList.removeEventListener("change", this._listener), this._mediaQueryList = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener("change", this._listener), e && this._onDidChange.fire();
    }
  }
  class MB extends z {
    constructor() {
      super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._value = this._getPixelRatio();
      const e = this._register(new TB());
      this._register(e.onDidChange(() => {
        this._value = this._getPixelRatio(), this._onDidChange.fire(this._value);
      }));
    }
    get value() {
      return this._value;
    }
    _getPixelRatio() {
      const e = document.createElement("canvas").getContext("2d"), t = window.devicePixelRatio || 1, i = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
      return t / i;
    }
  }
  class AB {
    constructor() {
      this._pixelRatioMonitor = null;
    }
    _getOrCreatePixelRatioMonitor() {
      return this._pixelRatioMonitor || (this._pixelRatioMonitor = new MB()), this._pixelRatioMonitor;
    }
    get value() {
      return this._getOrCreatePixelRatioMonitor().value;
    }
    get onDidChange() {
      return this._getOrCreatePixelRatioMonitor().onDidChange;
    }
  }
  const hf = new AB();
  function Z4() {
    return Vy.INSTANCE.getZoomFactor();
  }
  const Qf = navigator.userAgent, Xs = Qf.indexOf("Firefox") >= 0, Ql = Qf.indexOf("AppleWebKit") >= 0, fI = Qf.indexOf("Chrome") >= 0, Zo = !fI && Qf.indexOf("Safari") >= 0, gI = !fI && !Zo && Ql, RB = Qf.indexOf("Electron/") >= 0, Y4 = Qf.indexOf("Android") >= 0, mI = window.matchMedia && window.matchMedia("(display-mode: standalone)").matches, OB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    PixelRatio: hf,
    getZoomFactor: Z4,
    isFirefox: Xs,
    isWebKit: Ql,
    isChrome: fI,
    isSafari: Zo,
    isWebkitWebView: gI,
    isElectron: RB,
    isAndroid: Y4,
    isStandalone: mI
  }, Symbol.toStringTag, { value: "Module" }));
  function X4(s) {
    return Array.isArray(s);
  }
  function vo(s) {
    return typeof s == "string";
  }
  function ls(s) {
    return typeof s == "object" && s !== null && !Array.isArray(s) && !(s instanceof RegExp) && !(s instanceof Date);
  }
  function zd(s) {
    return typeof s == "number" && !isNaN(s);
  }
  function N2(s) {
    return !!s && typeof s[Symbol.iterator] == "function";
  }
  function Q4(s) {
    return s === !0 || s === !1;
  }
  function Ss(s) {
    return typeof s > "u";
  }
  function PB(s) {
    return !Ws(s);
  }
  function Ws(s) {
    return Ss(s) || s === null;
  }
  function Nt(s, e) {
    if (!s)
      throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type");
  }
  function H_(s) {
    if (Ws(s))
      throw new Error("Assertion Failed: argument is undefined or null");
    return s;
  }
  function B0(s) {
    return typeof s == "function";
  }
  function FB(s, e) {
    const t = Math.min(s.length, e.length);
    for (let i = 0; i < t; i++)
      BB(s[i], e[i]);
  }
  function BB(s, e) {
    if (vo(e)) {
      if (typeof s !== e)
        throw new Error(`argument does not match constraint: typeof ${e}`);
    } else if (B0(e)) {
      try {
        if (s instanceof e)
          return;
      } catch {
      }
      if (!Ws(s) && s.constructor === e || e.length === 1 && e.call(void 0, s) === !0)
        return;
      throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
    }
  }
  function WB(s) {
    let e = [], t = Object.getPrototypeOf(s);
    for (; Object.prototype !== t; )
      e = e.concat(Object.getOwnPropertyNames(t)), t = Object.getPrototypeOf(t);
    return e;
  }
  function pI(s) {
    const e = [];
    for (const t of WB(s))
      typeof s[t] == "function" && e.push(t);
    return e;
  }
  function VB(s, e) {
    const t = (n) => function() {
      const o = Array.prototype.slice.call(arguments, 0);
      return e(n, o);
    };
    let i = {};
    for (const n of s)
      i[n] = t(n);
    return i;
  }
  function ys(s) {
    return s === null ? void 0 : s;
  }
  function _I(s, e = "Unreachable") {
    throw new Error(e);
  }
  const Ev = {
    clipboard: {
      writeText: gr || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
      readText: gr || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
    },
    keyboard: (() => gr || mI ? 0 : navigator.keyboard || Zo ? 1 : 2)(),
    touch: "ontouchstart" in window || navigator.maxTouchPoints > 0,
    pointerEvents: window.PointerEvent && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0)
  };
  class bI {
    constructor() {
      this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
    }
    define(e, t) {
      this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
    }
    keyCodeToStr(e) {
      return this._keyCodeToStr[e];
    }
    strToKeyCode(e) {
      return this._strToKeyCode[e.toLowerCase()] || 0;
    }
  }
  const Jb = new bI(), Hy = new bI(), zy = new bI(), J4 = new Array(230), HB = /* @__PURE__ */ Object.create(null), zB = /* @__PURE__ */ Object.create(null), vI = [];
  for (let s = 0; s <= 193; s++)
    vI[s] = -1;
  (function() {
    const s = "", e = [
      [0, 1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", s, s],
      [0, 1, 1, "Hyper", 0, s, 0, s, s, s],
      [0, 1, 2, "Super", 0, s, 0, s, s, s],
      [0, 1, 3, "Fn", 0, s, 0, s, s, s],
      [0, 1, 4, "FnLock", 0, s, 0, s, s, s],
      [0, 1, 5, "Suspend", 0, s, 0, s, s, s],
      [0, 1, 6, "Resume", 0, s, 0, s, s, s],
      [0, 1, 7, "Turbo", 0, s, 0, s, s, s],
      [0, 1, 8, "Sleep", 0, s, 0, "VK_SLEEP", s, s],
      [0, 1, 9, "WakeUp", 0, s, 0, s, s, s],
      [31, 0, 10, "KeyA", 31, "A", 65, "VK_A", s, s],
      [32, 0, 11, "KeyB", 32, "B", 66, "VK_B", s, s],
      [33, 0, 12, "KeyC", 33, "C", 67, "VK_C", s, s],
      [34, 0, 13, "KeyD", 34, "D", 68, "VK_D", s, s],
      [35, 0, 14, "KeyE", 35, "E", 69, "VK_E", s, s],
      [36, 0, 15, "KeyF", 36, "F", 70, "VK_F", s, s],
      [37, 0, 16, "KeyG", 37, "G", 71, "VK_G", s, s],
      [38, 0, 17, "KeyH", 38, "H", 72, "VK_H", s, s],
      [39, 0, 18, "KeyI", 39, "I", 73, "VK_I", s, s],
      [40, 0, 19, "KeyJ", 40, "J", 74, "VK_J", s, s],
      [41, 0, 20, "KeyK", 41, "K", 75, "VK_K", s, s],
      [42, 0, 21, "KeyL", 42, "L", 76, "VK_L", s, s],
      [43, 0, 22, "KeyM", 43, "M", 77, "VK_M", s, s],
      [44, 0, 23, "KeyN", 44, "N", 78, "VK_N", s, s],
      [45, 0, 24, "KeyO", 45, "O", 79, "VK_O", s, s],
      [46, 0, 25, "KeyP", 46, "P", 80, "VK_P", s, s],
      [47, 0, 26, "KeyQ", 47, "Q", 81, "VK_Q", s, s],
      [48, 0, 27, "KeyR", 48, "R", 82, "VK_R", s, s],
      [49, 0, 28, "KeyS", 49, "S", 83, "VK_S", s, s],
      [50, 0, 29, "KeyT", 50, "T", 84, "VK_T", s, s],
      [51, 0, 30, "KeyU", 51, "U", 85, "VK_U", s, s],
      [52, 0, 31, "KeyV", 52, "V", 86, "VK_V", s, s],
      [53, 0, 32, "KeyW", 53, "W", 87, "VK_W", s, s],
      [54, 0, 33, "KeyX", 54, "X", 88, "VK_X", s, s],
      [55, 0, 34, "KeyY", 55, "Y", 89, "VK_Y", s, s],
      [56, 0, 35, "KeyZ", 56, "Z", 90, "VK_Z", s, s],
      [22, 0, 36, "Digit1", 22, "1", 49, "VK_1", s, s],
      [23, 0, 37, "Digit2", 23, "2", 50, "VK_2", s, s],
      [24, 0, 38, "Digit3", 24, "3", 51, "VK_3", s, s],
      [25, 0, 39, "Digit4", 25, "4", 52, "VK_4", s, s],
      [26, 0, 40, "Digit5", 26, "5", 53, "VK_5", s, s],
      [27, 0, 41, "Digit6", 27, "6", 54, "VK_6", s, s],
      [28, 0, 42, "Digit7", 28, "7", 55, "VK_7", s, s],
      [29, 0, 43, "Digit8", 29, "8", 56, "VK_8", s, s],
      [30, 0, 44, "Digit9", 30, "9", 57, "VK_9", s, s],
      [21, 0, 45, "Digit0", 21, "0", 48, "VK_0", s, s],
      [3, 1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", s, s],
      [9, 1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", s, s],
      [1, 1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", s, s],
      [2, 1, 49, "Tab", 2, "Tab", 9, "VK_TAB", s, s],
      [10, 1, 50, "Space", 10, "Space", 32, "VK_SPACE", s, s],
      [83, 0, 51, "Minus", 83, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
      [81, 0, 52, "Equal", 81, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
      [87, 0, 53, "BracketLeft", 87, "[", 219, "VK_OEM_4", "[", "OEM_4"],
      [89, 0, 54, "BracketRight", 89, "]", 221, "VK_OEM_6", "]", "OEM_6"],
      [88, 0, 55, "Backslash", 88, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
      [0, 0, 56, "IntlHash", 0, s, 0, s, s, s],
      [80, 0, 57, "Semicolon", 80, ";", 186, "VK_OEM_1", ";", "OEM_1"],
      [90, 0, 58, "Quote", 90, "'", 222, "VK_OEM_7", "'", "OEM_7"],
      [86, 0, 59, "Backquote", 86, "`", 192, "VK_OEM_3", "`", "OEM_3"],
      [82, 0, 60, "Comma", 82, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
      [84, 0, 61, "Period", 84, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
      [85, 0, 62, "Slash", 85, "/", 191, "VK_OEM_2", "/", "OEM_2"],
      [8, 1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", s, s],
      [59, 1, 64, "F1", 59, "F1", 112, "VK_F1", s, s],
      [60, 1, 65, "F2", 60, "F2", 113, "VK_F2", s, s],
      [61, 1, 66, "F3", 61, "F3", 114, "VK_F3", s, s],
      [62, 1, 67, "F4", 62, "F4", 115, "VK_F4", s, s],
      [63, 1, 68, "F5", 63, "F5", 116, "VK_F5", s, s],
      [64, 1, 69, "F6", 64, "F6", 117, "VK_F6", s, s],
      [65, 1, 70, "F7", 65, "F7", 118, "VK_F7", s, s],
      [66, 1, 71, "F8", 66, "F8", 119, "VK_F8", s, s],
      [67, 1, 72, "F9", 67, "F9", 120, "VK_F9", s, s],
      [68, 1, 73, "F10", 68, "F10", 121, "VK_F10", s, s],
      [69, 1, 74, "F11", 69, "F11", 122, "VK_F11", s, s],
      [70, 1, 75, "F12", 70, "F12", 123, "VK_F12", s, s],
      [0, 1, 76, "PrintScreen", 0, s, 0, s, s, s],
      [79, 1, 77, "ScrollLock", 79, "ScrollLock", 145, "VK_SCROLL", s, s],
      [7, 1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", s, s],
      [19, 1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", s, s],
      [14, 1, 80, "Home", 14, "Home", 36, "VK_HOME", s, s],
      [11, 1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", s, s],
      [20, 1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", s, s],
      [13, 1, 83, "End", 13, "End", 35, "VK_END", s, s],
      [12, 1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", s, s],
      [17, 1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", s],
      [15, 1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", s],
      [18, 1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", s],
      [16, 1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", s],
      [78, 1, 89, "NumLock", 78, "NumLock", 144, "VK_NUMLOCK", s, s],
      [108, 1, 90, "NumpadDivide", 108, "NumPad_Divide", 111, "VK_DIVIDE", s, s],
      [103, 1, 91, "NumpadMultiply", 103, "NumPad_Multiply", 106, "VK_MULTIPLY", s, s],
      [106, 1, 92, "NumpadSubtract", 106, "NumPad_Subtract", 109, "VK_SUBTRACT", s, s],
      [104, 1, 93, "NumpadAdd", 104, "NumPad_Add", 107, "VK_ADD", s, s],
      [3, 1, 94, "NumpadEnter", 3, s, 0, s, s, s],
      [94, 1, 95, "Numpad1", 94, "NumPad1", 97, "VK_NUMPAD1", s, s],
      [95, 1, 96, "Numpad2", 95, "NumPad2", 98, "VK_NUMPAD2", s, s],
      [96, 1, 97, "Numpad3", 96, "NumPad3", 99, "VK_NUMPAD3", s, s],
      [97, 1, 98, "Numpad4", 97, "NumPad4", 100, "VK_NUMPAD4", s, s],
      [98, 1, 99, "Numpad5", 98, "NumPad5", 101, "VK_NUMPAD5", s, s],
      [99, 1, 100, "Numpad6", 99, "NumPad6", 102, "VK_NUMPAD6", s, s],
      [100, 1, 101, "Numpad7", 100, "NumPad7", 103, "VK_NUMPAD7", s, s],
      [101, 1, 102, "Numpad8", 101, "NumPad8", 104, "VK_NUMPAD8", s, s],
      [102, 1, 103, "Numpad9", 102, "NumPad9", 105, "VK_NUMPAD9", s, s],
      [93, 1, 104, "Numpad0", 93, "NumPad0", 96, "VK_NUMPAD0", s, s],
      [107, 1, 105, "NumpadDecimal", 107, "NumPad_Decimal", 110, "VK_DECIMAL", s, s],
      [92, 0, 106, "IntlBackslash", 92, "OEM_102", 226, "VK_OEM_102", s, s],
      [58, 1, 107, "ContextMenu", 58, "ContextMenu", 93, s, s, s],
      [0, 1, 108, "Power", 0, s, 0, s, s, s],
      [0, 1, 109, "NumpadEqual", 0, s, 0, s, s, s],
      [71, 1, 110, "F13", 71, "F13", 124, "VK_F13", s, s],
      [72, 1, 111, "F14", 72, "F14", 125, "VK_F14", s, s],
      [73, 1, 112, "F15", 73, "F15", 126, "VK_F15", s, s],
      [74, 1, 113, "F16", 74, "F16", 127, "VK_F16", s, s],
      [75, 1, 114, "F17", 75, "F17", 128, "VK_F17", s, s],
      [76, 1, 115, "F18", 76, "F18", 129, "VK_F18", s, s],
      [77, 1, 116, "F19", 77, "F19", 130, "VK_F19", s, s],
      [0, 1, 117, "F20", 0, s, 0, "VK_F20", s, s],
      [0, 1, 118, "F21", 0, s, 0, "VK_F21", s, s],
      [0, 1, 119, "F22", 0, s, 0, "VK_F22", s, s],
      [0, 1, 120, "F23", 0, s, 0, "VK_F23", s, s],
      [0, 1, 121, "F24", 0, s, 0, "VK_F24", s, s],
      [0, 1, 122, "Open", 0, s, 0, s, s, s],
      [0, 1, 123, "Help", 0, s, 0, s, s, s],
      [0, 1, 124, "Select", 0, s, 0, s, s, s],
      [0, 1, 125, "Again", 0, s, 0, s, s, s],
      [0, 1, 126, "Undo", 0, s, 0, s, s, s],
      [0, 1, 127, "Cut", 0, s, 0, s, s, s],
      [0, 1, 128, "Copy", 0, s, 0, s, s, s],
      [0, 1, 129, "Paste", 0, s, 0, s, s, s],
      [0, 1, 130, "Find", 0, s, 0, s, s, s],
      [0, 1, 131, "AudioVolumeMute", 112, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", s, s],
      [0, 1, 132, "AudioVolumeUp", 113, "AudioVolumeUp", 175, "VK_VOLUME_UP", s, s],
      [0, 1, 133, "AudioVolumeDown", 114, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", s, s],
      [105, 1, 134, "NumpadComma", 105, "NumPad_Separator", 108, "VK_SEPARATOR", s, s],
      [110, 0, 135, "IntlRo", 110, "ABNT_C1", 193, "VK_ABNT_C1", s, s],
      [0, 1, 136, "KanaMode", 0, s, 0, s, s, s],
      [0, 0, 137, "IntlYen", 0, s, 0, s, s, s],
      [0, 1, 138, "Convert", 0, s, 0, s, s, s],
      [0, 1, 139, "NonConvert", 0, s, 0, s, s, s],
      [0, 1, 140, "Lang1", 0, s, 0, s, s, s],
      [0, 1, 141, "Lang2", 0, s, 0, s, s, s],
      [0, 1, 142, "Lang3", 0, s, 0, s, s, s],
      [0, 1, 143, "Lang4", 0, s, 0, s, s, s],
      [0, 1, 144, "Lang5", 0, s, 0, s, s, s],
      [0, 1, 145, "Abort", 0, s, 0, s, s, s],
      [0, 1, 146, "Props", 0, s, 0, s, s, s],
      [0, 1, 147, "NumpadParenLeft", 0, s, 0, s, s, s],
      [0, 1, 148, "NumpadParenRight", 0, s, 0, s, s, s],
      [0, 1, 149, "NumpadBackspace", 0, s, 0, s, s, s],
      [0, 1, 150, "NumpadMemoryStore", 0, s, 0, s, s, s],
      [0, 1, 151, "NumpadMemoryRecall", 0, s, 0, s, s, s],
      [0, 1, 152, "NumpadMemoryClear", 0, s, 0, s, s, s],
      [0, 1, 153, "NumpadMemoryAdd", 0, s, 0, s, s, s],
      [0, 1, 154, "NumpadMemorySubtract", 0, s, 0, s, s, s],
      [0, 1, 155, "NumpadClear", 126, "Clear", 12, "VK_CLEAR", s, s],
      [0, 1, 156, "NumpadClearEntry", 0, s, 0, s, s, s],
      [5, 1, 0, s, 5, "Ctrl", 17, "VK_CONTROL", s, s],
      [4, 1, 0, s, 4, "Shift", 16, "VK_SHIFT", s, s],
      [6, 1, 0, s, 6, "Alt", 18, "VK_MENU", s, s],
      [57, 1, 0, s, 57, "Meta", 0, "VK_COMMAND", s, s],
      [5, 1, 157, "ControlLeft", 5, s, 0, "VK_LCONTROL", s, s],
      [4, 1, 158, "ShiftLeft", 4, s, 0, "VK_LSHIFT", s, s],
      [6, 1, 159, "AltLeft", 6, s, 0, "VK_LMENU", s, s],
      [57, 1, 160, "MetaLeft", 57, s, 0, "VK_LWIN", s, s],
      [5, 1, 161, "ControlRight", 5, s, 0, "VK_RCONTROL", s, s],
      [4, 1, 162, "ShiftRight", 4, s, 0, "VK_RSHIFT", s, s],
      [6, 1, 163, "AltRight", 6, s, 0, "VK_RMENU", s, s],
      [57, 1, 164, "MetaRight", 57, s, 0, "VK_RWIN", s, s],
      [0, 1, 165, "BrightnessUp", 0, s, 0, s, s, s],
      [0, 1, 166, "BrightnessDown", 0, s, 0, s, s, s],
      [0, 1, 167, "MediaPlay", 0, s, 0, s, s, s],
      [0, 1, 168, "MediaRecord", 0, s, 0, s, s, s],
      [0, 1, 169, "MediaFastForward", 0, s, 0, s, s, s],
      [0, 1, 170, "MediaRewind", 0, s, 0, s, s, s],
      [114, 1, 171, "MediaTrackNext", 119, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", s, s],
      [115, 1, 172, "MediaTrackPrevious", 120, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", s, s],
      [116, 1, 173, "MediaStop", 121, "MediaStop", 178, "VK_MEDIA_STOP", s, s],
      [0, 1, 174, "Eject", 0, s, 0, s, s, s],
      [117, 1, 175, "MediaPlayPause", 122, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", s, s],
      [0, 1, 176, "MediaSelect", 123, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", s, s],
      [0, 1, 177, "LaunchMail", 124, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", s, s],
      [0, 1, 178, "LaunchApp2", 125, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", s, s],
      [0, 1, 179, "LaunchApp1", 0, s, 0, "VK_MEDIA_LAUNCH_APP1", s, s],
      [0, 1, 180, "SelectTask", 0, s, 0, s, s, s],
      [0, 1, 181, "LaunchScreenSaver", 0, s, 0, s, s, s],
      [0, 1, 182, "BrowserSearch", 115, "BrowserSearch", 170, "VK_BROWSER_SEARCH", s, s],
      [0, 1, 183, "BrowserHome", 116, "BrowserHome", 172, "VK_BROWSER_HOME", s, s],
      [112, 1, 184, "BrowserBack", 117, "BrowserBack", 166, "VK_BROWSER_BACK", s, s],
      [113, 1, 185, "BrowserForward", 118, "BrowserForward", 167, "VK_BROWSER_FORWARD", s, s],
      [0, 1, 186, "BrowserStop", 0, s, 0, "VK_BROWSER_STOP", s, s],
      [0, 1, 187, "BrowserRefresh", 0, s, 0, "VK_BROWSER_REFRESH", s, s],
      [0, 1, 188, "BrowserFavorites", 0, s, 0, "VK_BROWSER_FAVORITES", s, s],
      [0, 1, 189, "ZoomToggle", 0, s, 0, s, s, s],
      [0, 1, 190, "MailReply", 0, s, 0, s, s, s],
      [0, 1, 191, "MailForward", 0, s, 0, s, s, s],
      [0, 1, 192, "MailSend", 0, s, 0, s, s, s],
      [109, 1, 0, s, 109, "KeyInComposition", 229, s, s, s],
      [111, 1, 0, s, 111, "ABNT_C2", 194, "VK_ABNT_C2", s, s],
      [91, 1, 0, s, 91, "OEM_8", 223, "VK_OEM_8", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_KANA", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_HANGUL", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_JUNJA", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_FINAL", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_HANJA", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_KANJI", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_CONVERT", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_NONCONVERT", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_ACCEPT", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_MODECHANGE", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_SELECT", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_PRINT", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_EXECUTE", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_SNAPSHOT", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_HELP", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_APPS", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_PROCESSKEY", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_PACKET", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_DBE_SBCSCHAR", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_DBE_DBCSCHAR", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_ATTN", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_CRSEL", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_EXSEL", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_EREOF", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_PLAY", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_ZOOM", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_NONAME", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_PA1", s, s],
      [0, 1, 0, s, 0, s, 0, "VK_OEM_CLEAR", s, s]
    ];
    let t = [], i = [];
    for (const n of e) {
      const [o, r, a, l, c, d, h, u, f, g] = n;
      if (i[a] || (i[a] = !0, HB[l] = a, zB[l.toLowerCase()] = a, r && (vI[a] = c)), !t[c]) {
        if (t[c] = !0, !d)
          throw new Error(`String representation missing for key code ${c} around scan code ${l}`);
        Jb.define(c, d), Hy.define(c, f || d), zy.define(c, g || f || d);
      }
      h && (J4[h] = c);
    }
  })();
  var bd;
  (function(s) {
    function e(a) {
      return Jb.keyCodeToStr(a);
    }
    s.toString = e;
    function t(a) {
      return Jb.strToKeyCode(a);
    }
    s.fromString = t;
    function i(a) {
      return Hy.keyCodeToStr(a);
    }
    s.toUserSettingsUS = i;
    function n(a) {
      return zy.keyCodeToStr(a);
    }
    s.toUserSettingsGeneral = n;
    function o(a) {
      return Hy.strToKeyCode(a) || zy.strToKeyCode(a);
    }
    s.fromUserSettings = o;
    function r(a) {
      if (a >= 93 && a <= 108)
        return null;
      switch (a) {
        case 16:
          return "Up";
        case 18:
          return "Down";
        case 15:
          return "Left";
        case 17:
          return "Right";
      }
      return Jb.keyCodeToStr(a);
    }
    s.toElectronAccelerator = r;
  })(bd || (bd = {}));
  function Qi(s, e) {
    const t = (e & 65535) << 16 >>> 0;
    return (s | t) >>> 0;
  }
  function Uy(s, e) {
    if (s === 0)
      return null;
    const t = (s & 65535) >>> 0, i = (s & 4294901760) >>> 16;
    return i !== 0 ? new W0([
      Dw(t, e),
      Dw(i, e)
    ]) : new W0([Dw(t, e)]);
  }
  function Dw(s, e) {
    const t = !!(s & 2048), i = !!(s & 256), n = e === 2 ? i : t, o = !!(s & 1024), r = !!(s & 512), a = e === 2 ? t : i, l = s & 255;
    return new Ud(n, o, r, a, l);
  }
  class Ud {
    constructor(e, t, i, n, o) {
      this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyCode = o;
    }
    equals(e) {
      return this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
    }
    isModifierKey() {
      return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
    }
    toChord() {
      return new W0([this]);
    }
    isDuplicateModifierCase() {
      return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
    }
  }
  class W0 {
    constructor(e) {
      if (e.length === 0)
        throw fr("parts");
      this.parts = e;
    }
  }
  class UB {
    constructor(e, t, i, n, o, r) {
      this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyLabel = o, this.keyAriaLabel = r;
    }
  }
  class $B {
  }
  function jB(s) {
    if (s.charCode) {
      let t = String.fromCharCode(s.charCode).toUpperCase();
      return bd.fromString(t);
    }
    const e = s.keyCode;
    if (e === 3)
      return 7;
    if (Xs) {
      if (e === 59)
        return 80;
      if (e === 107)
        return 81;
      if (e === 109)
        return 83;
      if (Ye && e === 224)
        return 57;
    } else if (Ql) {
      if (e === 91)
        return 57;
      if (Ye && e === 93)
        return 57;
      if (!Ye && e === 92)
        return 57;
    }
    return J4[e] || 0;
  }
  const KB = Ye ? 256 : 2048, qB = 512, GB = 1024, ZB = Ye ? 2048 : 256;
  class $t {
    constructor(e) {
      this._standardKeyboardEventBrand = !0;
      let t = e;
      this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.keyCode = jB(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asRuntimeKeybinding = this._computeRuntimeKeybinding();
    }
    preventDefault() {
      this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
    }
    stopPropagation() {
      this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
    }
    toKeybinding() {
      return this._asRuntimeKeybinding;
    }
    equals(e) {
      return this._asKeybinding === e;
    }
    _computeKeybinding() {
      let e = 0;
      this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
      let t = 0;
      return this.ctrlKey && (t |= KB), this.altKey && (t |= qB), this.shiftKey && (t |= GB), this.metaKey && (t |= ZB), t |= e, t;
    }
    _computeRuntimeKeybinding() {
      let e = 0;
      return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new Ud(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
    }
  }
  let $y = !1, Zh = null;
  function YB(s) {
    if (!s.parent || s.parent === s)
      return null;
    try {
      let e = s.location, t = s.parent.location;
      if (e.origin !== "null" && t.origin !== "null" && e.origin !== t.origin)
        return $y = !0, null;
    } catch {
      return $y = !0, null;
    }
    return s.parent;
  }
  class jy {
    static getSameOriginWindowChain() {
      if (!Zh) {
        Zh = [];
        let e = window, t;
        do
          t = YB(e), t ? Zh.push({
            window: e,
            iframeElement: e.frameElement || null
          }) : Zh.push({
            window: e,
            iframeElement: null
          }), e = t;
        while (e);
      }
      return Zh.slice(0);
    }
    static hasDifferentOriginAncestor() {
      return Zh || this.getSameOriginWindowChain(), $y;
    }
    static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
      if (!t || e === t)
        return {
          top: 0,
          left: 0
        };
      let i = 0, n = 0, o = this.getSameOriginWindowChain();
      for (const r of o) {
        if (i += r.window.scrollY, n += r.window.scrollX, r.window === t || !r.iframeElement)
          break;
        let a = r.iframeElement.getBoundingClientRect();
        i += a.top, n += a.left;
      }
      return {
        top: i,
        left: n
      };
    }
  }
  class ho {
    constructor(e) {
      this.timestamp = Date.now(), this.browserEvent = e, this.leftButton = e.button === 0, this.middleButton = e.button === 1, this.rightButton = e.button === 2, this.buttons = e.buttons, this.target = e.target, this.detail = e.detail || 1, e.type === "dblclick" && (this.detail = 2), this.ctrlKey = e.ctrlKey, this.shiftKey = e.shiftKey, this.altKey = e.altKey, this.metaKey = e.metaKey, typeof e.pageX == "number" ? (this.posx = e.pageX, this.posy = e.pageY) : (this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop);
      let t = jy.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
      this.posx -= t.left, this.posy -= t.top;
    }
    preventDefault() {
      this.browserEvent.preventDefault();
    }
    stopPropagation() {
      this.browserEvent.stopPropagation();
    }
  }
  class uf {
    constructor(e, t = 0, i = 0) {
      if (this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t, e) {
        let n = e, o = e;
        if (typeof n.wheelDeltaY < "u")
          this.deltaY = n.wheelDeltaY / 120;
        else if (typeof o.VERTICAL_AXIS < "u" && o.axis === o.VERTICAL_AXIS)
          this.deltaY = -o.detail / 3;
        else if (e.type === "wheel") {
          const r = e;
          r.deltaMode === r.DOM_DELTA_LINE ? Xs && !Ye ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
        }
        if (typeof n.wheelDeltaX < "u")
          Zo && rn ? this.deltaX = -(n.wheelDeltaX / 120) : this.deltaX = n.wheelDeltaX / 120;
        else if (typeof o.HORIZONTAL_AXIS < "u" && o.axis === o.HORIZONTAL_AXIS)
          this.deltaX = -e.detail / 3;
        else if (e.type === "wheel") {
          const r = e;
          r.deltaMode === r.DOM_DELTA_LINE ? Xs && !Ye ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
        }
        this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (this.deltaY = e.wheelDelta / 120);
      }
    }
    preventDefault() {
      this.browserEvent && this.browserEvent.preventDefault();
    }
    stopPropagation() {
      this.browserEvent && this.browserEvent.stopPropagation();
    }
  }
  const eP = Object.freeze(function(s, e) {
    const t = setTimeout(s.bind(e), 0);
    return { dispose() {
      clearTimeout(t);
    } };
  });
  var Je;
  (function(s) {
    function e(t) {
      return t === s.None || t === s.Cancelled || t instanceof e0 ? !0 : !t || typeof t != "object" ? !1 : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
    }
    s.isCancellationToken = e, s.None = Object.freeze({
      isCancellationRequested: !1,
      onCancellationRequested: be.None
    }), s.Cancelled = Object.freeze({
      isCancellationRequested: !0,
      onCancellationRequested: eP
    });
  })(Je || (Je = {}));
  class e0 {
    constructor() {
      this._isCancelled = !1, this._emitter = null;
    }
    cancel() {
      this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      return this._isCancelled ? eP : (this._emitter || (this._emitter = new B()), this._emitter.event);
    }
    dispose() {
      this._emitter && (this._emitter.dispose(), this._emitter = null);
    }
  }
  class bn {
    constructor(e) {
      this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
    }
    get token() {
      return this._token || (this._token = new e0()), this._token;
    }
    cancel() {
      this._token ? this._token instanceof e0 && this._token.cancel() : this._token = Je.Cancelled;
    }
    dispose(e = !1) {
      e && this.cancel(), this._parentListener && this._parentListener.dispose(), this._token ? this._token instanceof e0 && this._token.dispose() : this._token = Je.None;
    }
  }
  var no = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, Kg = globalThis && globalThis.__asyncValues || function(s) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = s[Symbol.asyncIterator], t;
    return e ? e.call(s) : (s = typeof __values == "function" ? __values(s) : s[Symbol.iterator](), t = {}, i("next"), i("throw"), i("return"), t[Symbol.asyncIterator] = function() {
      return this;
    }, t);
    function i(o) {
      t[o] = s[o] && function(r) {
        return new Promise(function(a, l) {
          r = s[o](r), n(a, l, r.done, r.value);
        });
      };
    }
    function n(o, r, a, l) {
      Promise.resolve(l).then(function(c) {
        o({ value: c, done: a });
      }, r);
    }
  };
  function XB(s) {
    return !!s && typeof s.then == "function";
  }
  function an(s) {
    const e = new bn(), t = s(e.token), i = new Promise((n, o) => {
      const r = e.token.onCancellationRequested(() => {
        r.dispose(), e.dispose(), o(new Dh());
      });
      Promise.resolve(t).then((a) => {
        r.dispose(), e.dispose(), n(a);
      }, (a) => {
        r.dispose(), e.dispose(), o(a);
      });
    });
    return new class {
      cancel() {
        e.cancel();
      }
      then(n, o) {
        return i.then(n, o);
      }
      catch(n) {
        return this.then(void 0, n);
      }
      finally(n) {
        return i.finally(n);
      }
    }();
  }
  function CI(s, e, t) {
    return new Promise((i, n) => {
      const o = e.onCancellationRequested(() => {
        o.dispose(), i(t);
      });
      s.then(i, n).finally(() => o.dispose());
    });
  }
  class QB {
    constructor() {
      this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
    }
    queue(e) {
      if (this.activePromise) {
        if (this.queuedPromiseFactory = e, !this.queuedPromise) {
          const t = () => {
            this.queuedPromise = null;
            const i = this.queue(this.queuedPromiseFactory);
            return this.queuedPromiseFactory = null, i;
          };
          this.queuedPromise = new Promise((i) => {
            this.activePromise.then(t, t).then(i);
          });
        }
        return new Promise((t, i) => {
          this.queuedPromise.then(t, i);
        });
      }
      return this.activePromise = e(), new Promise((t, i) => {
        this.activePromise.then((n) => {
          this.activePromise = null, t(n);
        }, (n) => {
          this.activePromise = null, i(n);
        });
      });
    }
  }
  const JB = (s, e) => {
    let t = !0;
    const i = setTimeout(() => {
      t = !1, e();
    }, s);
    return {
      isTriggered: () => t,
      dispose: () => {
        clearTimeout(i), t = !1;
      }
    };
  }, eW = (s) => {
    let e = !0;
    return queueMicrotask(() => {
      e && (e = !1, s());
    }), {
      isTriggered: () => e,
      dispose: () => {
        e = !1;
      }
    };
  }, tP = Symbol("MicrotaskDelay");
  class ca {
    constructor(e) {
      this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
    }
    trigger(e, t = this.defaultDelay) {
      this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((n, o) => {
        this.doResolve = n, this.doReject = o;
      }).then(() => {
        if (this.completionPromise = null, this.doResolve = null, this.task) {
          const n = this.task;
          return this.task = null, n();
        }
      }));
      const i = () => {
        var n;
        this.deferred = null, (n = this.doResolve) === null || n === void 0 || n.call(this, null);
      };
      return this.deferred = t === tP ? eW(i) : JB(t, i), this.completionPromise;
    }
    isTriggered() {
      var e;
      return !!(!((e = this.deferred) === null || e === void 0) && e.isTriggered());
    }
    cancel() {
      this.cancelTimeout(), this.completionPromise && (this.doReject && this.doReject(new Dh()), this.completionPromise = null);
    }
    cancelTimeout() {
      var e;
      (e = this.deferred) === null || e === void 0 || e.dispose(), this.deferred = null;
    }
    dispose() {
      this.cancel();
    }
  }
  class tW {
    constructor(e) {
      this.delayer = new ca(e), this.throttler = new QB();
    }
    trigger(e, t) {
      return this.delayer.trigger(() => this.throttler.queue(e), t);
    }
    dispose() {
      this.delayer.dispose();
    }
  }
  function gc(s, e) {
    return e ? new Promise((t, i) => {
      const n = setTimeout(() => {
        o.dispose(), t();
      }, s), o = e.onCancellationRequested(() => {
        clearTimeout(n), o.dispose(), i(new Dh());
      });
    }) : an((t) => gc(s, t));
  }
  function $d(s, e = 0) {
    const t = setTimeout(s, e);
    return qe(() => clearTimeout(t));
  }
  function iP(s, e = (i) => !!i, t = null) {
    let i = 0;
    const n = s.length, o = () => {
      if (i >= n)
        return Promise.resolve(t);
      const r = s[i++];
      return Promise.resolve(r()).then((l) => e(l) ? Promise.resolve(l) : o());
    };
    return o();
  }
  class Ns {
    constructor(e, t) {
      this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
    }
    dispose() {
      this.cancel();
    }
    cancel() {
      this._token !== -1 && (clearTimeout(this._token), this._token = -1);
    }
    cancelAndSet(e, t) {
      this.cancel(), this._token = setTimeout(() => {
        this._token = -1, e();
      }, t);
    }
    setIfNotSet(e, t) {
      this._token === -1 && (this._token = setTimeout(() => {
        this._token = -1, e();
      }, t));
    }
  }
  class o_ {
    constructor() {
      this._token = -1;
    }
    dispose() {
      this.cancel();
    }
    cancel() {
      this._token !== -1 && (clearInterval(this._token), this._token = -1);
    }
    cancelAndSet(e, t) {
      this.cancel(), this._token = setInterval(() => {
        e();
      }, t);
    }
  }
  class It {
    constructor(e, t) {
      this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
    }
    dispose() {
      this.cancel(), this.runner = null;
    }
    cancel() {
      this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
    }
    schedule(e = this.timeout) {
      this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
    }
    get delay() {
      return this.timeout;
    }
    set delay(e) {
      this.timeout = e;
    }
    isScheduled() {
      return this.timeoutToken !== -1;
    }
    onTimeout() {
      this.timeoutToken = -1, this.runner && this.doRun();
    }
    doRun() {
      this.runner && this.runner();
    }
  }
  let Bm;
  (function() {
    typeof requestIdleCallback != "function" || typeof cancelIdleCallback != "function" ? Bm = (s) => {
      K4(() => {
        if (e)
          return;
        const t = Date.now() + 15;
        s(Object.freeze({
          didTimeout: !0,
          timeRemaining() {
            return Math.max(0, t - Date.now());
          }
        }));
      });
      let e = !1;
      return {
        dispose() {
          e || (e = !0);
        }
      };
    } : Bm = (s, e) => {
      const t = requestIdleCallback(s, typeof e == "number" ? { timeout: e } : void 0);
      let i = !1;
      return {
        dispose() {
          i || (i = !0, cancelIdleCallback(t));
        }
      };
    };
  })();
  class Jl {
    constructor(e) {
      this._didRun = !1, this._executor = () => {
        try {
          this._value = e();
        } catch (t) {
          this._error = t;
        } finally {
          this._didRun = !0;
        }
      }, this._handle = Bm(() => this._executor());
    }
    dispose() {
      this._handle.dispose();
    }
    get value() {
      if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
        throw this._error;
      return this._value;
    }
    get isInitialized() {
      return this._didRun;
    }
  }
  class wI {
    constructor() {
      this.rejected = !1, this.resolved = !1, this.p = new Promise((e, t) => {
        this.completeCallback = e, this.errorCallback = t;
      });
    }
    get isRejected() {
      return this.rejected;
    }
    get isSettled() {
      return this.rejected || this.resolved;
    }
    complete(e) {
      return new Promise((t) => {
        this.completeCallback(e), this.resolved = !0, t();
      });
    }
    cancel() {
      new Promise((e) => {
        this.errorCallback(new Dh()), this.rejected = !0, e();
      });
    }
  }
  var Ky;
  (function(s) {
    function e(i) {
      return no(this, void 0, void 0, function* () {
        let n;
        const o = yield Promise.all(i.map((r) => r.then((a) => a, (a) => {
          n || (n = a);
        })));
        if (typeof n < "u")
          throw n;
        return o;
      });
    }
    s.settled = e;
    function t(i) {
      return new Promise((n, o) => no(this, void 0, void 0, function* () {
        try {
          yield i(n, o);
        } catch (r) {
          o(r);
        }
      }));
    }
    s.withAsyncBody = t;
  })(Ky || (Ky = {}));
  class vi {
    constructor(e) {
      this._state = 0, this._results = [], this._error = null, this._onStateChanged = new B(), queueMicrotask(() => no(this, void 0, void 0, function* () {
        const t = {
          emitOne: (i) => this.emitOne(i),
          emitMany: (i) => this.emitMany(i),
          reject: (i) => this.reject(i)
        };
        try {
          yield Promise.resolve(e(t)), this.resolve();
        } catch (i) {
          this.reject(i);
        } finally {
          t.emitOne = void 0, t.emitMany = void 0, t.reject = void 0;
        }
      }));
    }
    static fromArray(e) {
      return new vi((t) => {
        t.emitMany(e);
      });
    }
    static fromPromise(e) {
      return new vi((t) => no(this, void 0, void 0, function* () {
        t.emitMany(yield e);
      }));
    }
    static fromPromises(e) {
      return new vi((t) => no(this, void 0, void 0, function* () {
        yield Promise.all(e.map((i) => no(this, void 0, void 0, function* () {
          return t.emitOne(yield i);
        })));
      }));
    }
    static merge(e) {
      return new vi((t) => no(this, void 0, void 0, function* () {
        yield Promise.all(e.map((i) => {
          var n, o;
          return no(this, void 0, void 0, function* () {
            var r, a;
            try {
              for (n = Kg(i); o = yield n.next(), !o.done; ) {
                const l = o.value;
                t.emitOne(l);
              }
            } catch (l) {
              r = { error: l };
            } finally {
              try {
                o && !o.done && (a = n.return) && (yield a.call(n));
              } finally {
                if (r)
                  throw r.error;
              }
            }
          });
        }));
      }));
    }
    [Symbol.asyncIterator]() {
      let e = 0;
      return {
        next: () => no(this, void 0, void 0, function* () {
          do {
            if (this._state === 2)
              throw this._error;
            if (e < this._results.length)
              return { done: !1, value: this._results[e++] };
            if (this._state === 1)
              return { done: !0, value: void 0 };
            yield be.toPromise(this._onStateChanged.event);
          } while (!0);
        })
      };
    }
    static map(e, t) {
      return new vi((i) => no(this, void 0, void 0, function* () {
        var n, o;
        try {
          for (var r = Kg(e), a; a = yield r.next(), !a.done; ) {
            const l = a.value;
            i.emitOne(t(l));
          }
        } catch (l) {
          n = { error: l };
        } finally {
          try {
            a && !a.done && (o = r.return) && (yield o.call(r));
          } finally {
            if (n)
              throw n.error;
          }
        }
      }));
    }
    map(e) {
      return vi.map(this, e);
    }
    static filter(e, t) {
      return new vi((i) => no(this, void 0, void 0, function* () {
        var n, o;
        try {
          for (var r = Kg(e), a; a = yield r.next(), !a.done; ) {
            const l = a.value;
            t(l) && i.emitOne(l);
          }
        } catch (l) {
          n = { error: l };
        } finally {
          try {
            a && !a.done && (o = r.return) && (yield o.call(r));
          } finally {
            if (n)
              throw n.error;
          }
        }
      }));
    }
    filter(e) {
      return vi.filter(this, e);
    }
    static coalesce(e) {
      return vi.filter(e, (t) => !!t);
    }
    coalesce() {
      return vi.coalesce(this);
    }
    static toPromise(e) {
      var t, i, n, o;
      return no(this, void 0, void 0, function* () {
        const r = [];
        try {
          for (t = Kg(e); i = yield t.next(), !i.done; ) {
            const a = i.value;
            r.push(a);
          }
        } catch (a) {
          n = { error: a };
        } finally {
          try {
            i && !i.done && (o = t.return) && (yield o.call(t));
          } finally {
            if (n)
              throw n.error;
          }
        }
        return r;
      });
    }
    toPromise() {
      return vi.toPromise(this);
    }
    emitOne(e) {
      this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
    }
    emitMany(e) {
      this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
    }
    resolve() {
      this._state === 0 && (this._state = 1, this._onStateChanged.fire());
    }
    reject(e) {
      this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
    }
  }
  vi.EMPTY = vi.fromArray([]);
  class iW extends vi {
    constructor(e, t) {
      super(t), this._source = e;
    }
    cancel() {
      this._source.cancel();
    }
  }
  function nW(s) {
    const e = new bn(), t = s(e.token);
    return new iW(e, (i) => no(this, void 0, void 0, function* () {
      var n, o;
      const r = e.token.onCancellationRequested(() => {
        r.dispose(), e.dispose(), i.reject(new Dh());
      });
      try {
        try {
          for (var a = Kg(t), l; l = yield a.next(), !l.done; ) {
            const c = l.value;
            if (e.token.isCancellationRequested)
              return;
            i.emitOne(c);
          }
        } catch (c) {
          n = { error: c };
        } finally {
          try {
            l && !l.done && (o = a.return) && (yield o.call(a));
          } finally {
            if (n)
              throw n.error;
          }
        }
        r.dispose(), e.dispose();
      } catch (c) {
        r.dispose(), e.dispose(), i.reject(c);
      }
    }));
  }
  let zu;
  if (typeof gi.vscode < "u" && typeof gi.vscode.process < "u") {
    const s = gi.vscode.process;
    zu = {
      get platform() {
        return s.platform;
      },
      get arch() {
        return s.arch;
      },
      get env() {
        return s.env;
      },
      cwd() {
        return s.cwd();
      }
    };
  } else
    typeof process < "u" ? zu = {
      get platform() {
        return process.platform;
      },
      get arch() {
        return process.arch;
      },
      get env() {
        return process.env;
      },
      cwd() {
        return process.env.VSCODE_CWD || process.cwd();
      }
    } : zu = {
      get platform() {
        return rn ? "win32" : Ye ? "darwin" : "linux";
      },
      get arch() {
      },
      get env() {
        return {};
      },
      cwd() {
        return "/";
      }
    };
  const qy = zu.cwd, sW = zu.env, xh = zu.platform, oW = 65, rW = 97, aW = 90, lW = 122, ec = 46, An = 47, Ps = 92, Dl = 58, cW = 63;
  class nP extends Error {
    constructor(e, t, i) {
      let n;
      typeof t == "string" && t.indexOf("not ") === 0 ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      const o = e.indexOf(".") !== -1 ? "property" : "argument";
      let r = `The "${e}" ${o} ${n} of type ${t}`;
      r += `. Received type ${typeof i}`, super(r), this.code = "ERR_INVALID_ARG_TYPE";
    }
  }
  function Ki(s, e) {
    if (typeof s != "string")
      throw new nP(e, "string", s);
  }
  function _t(s) {
    return s === An || s === Ps;
  }
  function Gy(s) {
    return s === An;
  }
  function xl(s) {
    return s >= oW && s <= aW || s >= rW && s <= lW;
  }
  function V0(s, e, t, i) {
    let n = "", o = 0, r = -1, a = 0, l = 0;
    for (let c = 0; c <= s.length; ++c) {
      if (c < s.length)
        l = s.charCodeAt(c);
      else {
        if (i(l))
          break;
        l = An;
      }
      if (i(l)) {
        if (!(r === c - 1 || a === 1))
          if (a === 2) {
            if (n.length < 2 || o !== 2 || n.charCodeAt(n.length - 1) !== ec || n.charCodeAt(n.length - 2) !== ec) {
              if (n.length > 2) {
                const d = n.lastIndexOf(t);
                d === -1 ? (n = "", o = 0) : (n = n.slice(0, d), o = n.length - 1 - n.lastIndexOf(t)), r = c, a = 0;
                continue;
              } else if (n.length !== 0) {
                n = "", o = 0, r = c, a = 0;
                continue;
              }
            }
            e && (n += n.length > 0 ? `${t}..` : "..", o = 2);
          } else
            n.length > 0 ? n += `${t}${s.slice(r + 1, c)}` : n = s.slice(r + 1, c), o = c - r - 1;
        r = c, a = 0;
      } else
        l === ec && a !== -1 ? ++a : a = -1;
    }
    return n;
  }
  function sP(s, e) {
    if (e === null || typeof e != "object")
      throw new nP("pathObject", "Object", e);
    const t = e.dir || e.root, i = e.base || `${e.name || ""}${e.ext || ""}`;
    return t ? t === e.root ? `${t}${i}` : `${t}${s}${i}` : i;
  }
  const Ls = {
    resolve(...s) {
      let e = "", t = "", i = !1;
      for (let n = s.length - 1; n >= -1; n--) {
        let o;
        if (n >= 0) {
          if (o = s[n], Ki(o, "path"), o.length === 0)
            continue;
        } else
          e.length === 0 ? o = qy() : (o = sW[`=${e}`] || qy(), (o === void 0 || o.slice(0, 2).toLowerCase() !== e.toLowerCase() && o.charCodeAt(2) === Ps) && (o = `${e}\\`));
        const r = o.length;
        let a = 0, l = "", c = !1;
        const d = o.charCodeAt(0);
        if (r === 1)
          _t(d) && (a = 1, c = !0);
        else if (_t(d))
          if (c = !0, _t(o.charCodeAt(1))) {
            let h = 2, u = h;
            for (; h < r && !_t(o.charCodeAt(h)); )
              h++;
            if (h < r && h !== u) {
              const f = o.slice(u, h);
              for (u = h; h < r && _t(o.charCodeAt(h)); )
                h++;
              if (h < r && h !== u) {
                for (u = h; h < r && !_t(o.charCodeAt(h)); )
                  h++;
                (h === r || h !== u) && (l = `\\\\${f}\\${o.slice(u, h)}`, a = h);
              }
            }
          } else
            a = 1;
        else
          xl(d) && o.charCodeAt(1) === Dl && (l = o.slice(0, 2), a = 2, r > 2 && _t(o.charCodeAt(2)) && (c = !0, a = 3));
        if (l.length > 0)
          if (e.length > 0) {
            if (l.toLowerCase() !== e.toLowerCase())
              continue;
          } else
            e = l;
        if (i) {
          if (e.length > 0)
            break;
        } else if (t = `${o.slice(a)}\\${t}`, i = c, c && e.length > 0)
          break;
      }
      return t = V0(t, !i, "\\", _t), i ? `${e}\\${t}` : `${e}${t}` || ".";
    },
    normalize(s) {
      Ki(s, "path");
      const e = s.length;
      if (e === 0)
        return ".";
      let t = 0, i, n = !1;
      const o = s.charCodeAt(0);
      if (e === 1)
        return Gy(o) ? "\\" : s;
      if (_t(o))
        if (n = !0, _t(s.charCodeAt(1))) {
          let a = 2, l = a;
          for (; a < e && !_t(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            const c = s.slice(l, a);
            for (l = a; a < e && _t(s.charCodeAt(a)); )
              a++;
            if (a < e && a !== l) {
              for (l = a; a < e && !_t(s.charCodeAt(a)); )
                a++;
              if (a === e)
                return `\\\\${c}\\${s.slice(l)}\\`;
              a !== l && (i = `\\\\${c}\\${s.slice(l, a)}`, t = a);
            }
          }
        } else
          t = 1;
      else
        xl(o) && s.charCodeAt(1) === Dl && (i = s.slice(0, 2), t = 2, e > 2 && _t(s.charCodeAt(2)) && (n = !0, t = 3));
      let r = t < e ? V0(s.slice(t), !n, "\\", _t) : "";
      return r.length === 0 && !n && (r = "."), r.length > 0 && _t(s.charCodeAt(e - 1)) && (r += "\\"), i === void 0 ? n ? `\\${r}` : r : n ? `${i}\\${r}` : `${i}${r}`;
    },
    isAbsolute(s) {
      Ki(s, "path");
      const e = s.length;
      if (e === 0)
        return !1;
      const t = s.charCodeAt(0);
      return _t(t) || e > 2 && xl(t) && s.charCodeAt(1) === Dl && _t(s.charCodeAt(2));
    },
    join(...s) {
      if (s.length === 0)
        return ".";
      let e, t;
      for (let o = 0; o < s.length; ++o) {
        const r = s[o];
        Ki(r, "path"), r.length > 0 && (e === void 0 ? e = t = r : e += `\\${r}`);
      }
      if (e === void 0)
        return ".";
      let i = !0, n = 0;
      if (typeof t == "string" && _t(t.charCodeAt(0))) {
        ++n;
        const o = t.length;
        o > 1 && _t(t.charCodeAt(1)) && (++n, o > 2 && (_t(t.charCodeAt(2)) ? ++n : i = !1));
      }
      if (i) {
        for (; n < e.length && _t(e.charCodeAt(n)); )
          n++;
        n >= 2 && (e = `\\${e.slice(n)}`);
      }
      return Ls.normalize(e);
    },
    relative(s, e) {
      if (Ki(s, "from"), Ki(e, "to"), s === e)
        return "";
      const t = Ls.resolve(s), i = Ls.resolve(e);
      if (t === i || (s = t.toLowerCase(), e = i.toLowerCase(), s === e))
        return "";
      let n = 0;
      for (; n < s.length && s.charCodeAt(n) === Ps; )
        n++;
      let o = s.length;
      for (; o - 1 > n && s.charCodeAt(o - 1) === Ps; )
        o--;
      const r = o - n;
      let a = 0;
      for (; a < e.length && e.charCodeAt(a) === Ps; )
        a++;
      let l = e.length;
      for (; l - 1 > a && e.charCodeAt(l - 1) === Ps; )
        l--;
      const c = l - a, d = r < c ? r : c;
      let h = -1, u = 0;
      for (; u < d; u++) {
        const g = s.charCodeAt(n + u);
        if (g !== e.charCodeAt(a + u))
          break;
        g === Ps && (h = u);
      }
      if (u !== d) {
        if (h === -1)
          return i;
      } else {
        if (c > d) {
          if (e.charCodeAt(a + u) === Ps)
            return i.slice(a + u + 1);
          if (u === 2)
            return i.slice(a + u);
        }
        r > d && (s.charCodeAt(n + u) === Ps ? h = u : u === 2 && (h = 3)), h === -1 && (h = 0);
      }
      let f = "";
      for (u = n + h + 1; u <= o; ++u)
        (u === o || s.charCodeAt(u) === Ps) && (f += f.length === 0 ? ".." : "\\..");
      return a += h, f.length > 0 ? `${f}${i.slice(a, l)}` : (i.charCodeAt(a) === Ps && ++a, i.slice(a, l));
    },
    toNamespacedPath(s) {
      if (typeof s != "string")
        return s;
      if (s.length === 0)
        return "";
      const e = Ls.resolve(s);
      if (e.length <= 2)
        return s;
      if (e.charCodeAt(0) === Ps) {
        if (e.charCodeAt(1) === Ps) {
          const t = e.charCodeAt(2);
          if (t !== cW && t !== ec)
            return `\\\\?\\UNC\\${e.slice(2)}`;
        }
      } else if (xl(e.charCodeAt(0)) && e.charCodeAt(1) === Dl && e.charCodeAt(2) === Ps)
        return `\\\\?\\${e}`;
      return s;
    },
    dirname(s) {
      Ki(s, "path");
      const e = s.length;
      if (e === 0)
        return ".";
      let t = -1, i = 0;
      const n = s.charCodeAt(0);
      if (e === 1)
        return _t(n) ? s : ".";
      if (_t(n)) {
        if (t = i = 1, _t(s.charCodeAt(1))) {
          let a = 2, l = a;
          for (; a < e && !_t(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && _t(s.charCodeAt(a)); )
              a++;
            if (a < e && a !== l) {
              for (l = a; a < e && !_t(s.charCodeAt(a)); )
                a++;
              if (a === e)
                return s;
              a !== l && (t = i = a + 1);
            }
          }
        }
      } else
        xl(n) && s.charCodeAt(1) === Dl && (t = e > 2 && _t(s.charCodeAt(2)) ? 3 : 2, i = t);
      let o = -1, r = !0;
      for (let a = e - 1; a >= i; --a)
        if (_t(s.charCodeAt(a))) {
          if (!r) {
            o = a;
            break;
          }
        } else
          r = !1;
      if (o === -1) {
        if (t === -1)
          return ".";
        o = t;
      }
      return s.slice(0, o);
    },
    basename(s, e) {
      e !== void 0 && Ki(e, "ext"), Ki(s, "path");
      let t = 0, i = -1, n = !0, o;
      if (s.length >= 2 && xl(s.charCodeAt(0)) && s.charCodeAt(1) === Dl && (t = 2), e !== void 0 && e.length > 0 && e.length <= s.length) {
        if (e === s)
          return "";
        let r = e.length - 1, a = -1;
        for (o = s.length - 1; o >= t; --o) {
          const l = s.charCodeAt(o);
          if (_t(l)) {
            if (!n) {
              t = o + 1;
              break;
            }
          } else
            a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
        }
        return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
      }
      for (o = s.length - 1; o >= t; --o)
        if (_t(s.charCodeAt(o))) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          i === -1 && (n = !1, i = o + 1);
      return i === -1 ? "" : s.slice(t, i);
    },
    extname(s) {
      Ki(s, "path");
      let e = 0, t = -1, i = 0, n = -1, o = !0, r = 0;
      s.length >= 2 && s.charCodeAt(1) === Dl && xl(s.charCodeAt(0)) && (e = i = 2);
      for (let a = s.length - 1; a >= e; --a) {
        const l = s.charCodeAt(a);
        if (_t(l)) {
          if (!o) {
            i = a + 1;
            break;
          }
          continue;
        }
        n === -1 && (o = !1, n = a + 1), l === ec ? t === -1 ? t = a : r !== 1 && (r = 1) : t !== -1 && (r = -1);
      }
      return t === -1 || n === -1 || r === 0 || r === 1 && t === n - 1 && t === i + 1 ? "" : s.slice(t, n);
    },
    format: sP.bind(null, "\\"),
    parse(s) {
      Ki(s, "path");
      const e = { root: "", dir: "", base: "", ext: "", name: "" };
      if (s.length === 0)
        return e;
      const t = s.length;
      let i = 0, n = s.charCodeAt(0);
      if (t === 1)
        return _t(n) ? (e.root = e.dir = s, e) : (e.base = e.name = s, e);
      if (_t(n)) {
        if (i = 1, _t(s.charCodeAt(1))) {
          let h = 2, u = h;
          for (; h < t && !_t(s.charCodeAt(h)); )
            h++;
          if (h < t && h !== u) {
            for (u = h; h < t && _t(s.charCodeAt(h)); )
              h++;
            if (h < t && h !== u) {
              for (u = h; h < t && !_t(s.charCodeAt(h)); )
                h++;
              h === t ? i = h : h !== u && (i = h + 1);
            }
          }
        }
      } else if (xl(n) && s.charCodeAt(1) === Dl) {
        if (t <= 2)
          return e.root = e.dir = s, e;
        if (i = 2, _t(s.charCodeAt(2))) {
          if (t === 3)
            return e.root = e.dir = s, e;
          i = 3;
        }
      }
      i > 0 && (e.root = s.slice(0, i));
      let o = -1, r = i, a = -1, l = !0, c = s.length - 1, d = 0;
      for (; c >= i; --c) {
        if (n = s.charCodeAt(c), _t(n)) {
          if (!l) {
            r = c + 1;
            break;
          }
          continue;
        }
        a === -1 && (l = !1, a = c + 1), n === ec ? o === -1 ? o = c : d !== 1 && (d = 1) : o !== -1 && (d = -1);
      }
      return a !== -1 && (o === -1 || d === 0 || d === 1 && o === a - 1 && o === r + 1 ? e.base = e.name = s.slice(r, a) : (e.name = s.slice(r, o), e.base = s.slice(r, a), e.ext = s.slice(o, a))), r > 0 && r !== i ? e.dir = s.slice(0, r - 1) : e.dir = e.root, e;
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null
  }, Ci = {
    resolve(...s) {
      let e = "", t = !1;
      for (let i = s.length - 1; i >= -1 && !t; i--) {
        const n = i >= 0 ? s[i] : qy();
        Ki(n, "path"), n.length !== 0 && (e = `${n}/${e}`, t = n.charCodeAt(0) === An);
      }
      return e = V0(e, !t, "/", Gy), t ? `/${e}` : e.length > 0 ? e : ".";
    },
    normalize(s) {
      if (Ki(s, "path"), s.length === 0)
        return ".";
      const e = s.charCodeAt(0) === An, t = s.charCodeAt(s.length - 1) === An;
      return s = V0(s, !e, "/", Gy), s.length === 0 ? e ? "/" : t ? "./" : "." : (t && (s += "/"), e ? `/${s}` : s);
    },
    isAbsolute(s) {
      return Ki(s, "path"), s.length > 0 && s.charCodeAt(0) === An;
    },
    join(...s) {
      if (s.length === 0)
        return ".";
      let e;
      for (let t = 0; t < s.length; ++t) {
        const i = s[t];
        Ki(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
      }
      return e === void 0 ? "." : Ci.normalize(e);
    },
    relative(s, e) {
      if (Ki(s, "from"), Ki(e, "to"), s === e || (s = Ci.resolve(s), e = Ci.resolve(e), s === e))
        return "";
      const t = 1, i = s.length, n = i - t, o = 1, r = e.length - o, a = n < r ? n : r;
      let l = -1, c = 0;
      for (; c < a; c++) {
        const h = s.charCodeAt(t + c);
        if (h !== e.charCodeAt(o + c))
          break;
        h === An && (l = c);
      }
      if (c === a)
        if (r > a) {
          if (e.charCodeAt(o + c) === An)
            return e.slice(o + c + 1);
          if (c === 0)
            return e.slice(o + c);
        } else
          n > a && (s.charCodeAt(t + c) === An ? l = c : c === 0 && (l = 0));
      let d = "";
      for (c = t + l + 1; c <= i; ++c)
        (c === i || s.charCodeAt(c) === An) && (d += d.length === 0 ? ".." : "/..");
      return `${d}${e.slice(o + l)}`;
    },
    toNamespacedPath(s) {
      return s;
    },
    dirname(s) {
      if (Ki(s, "path"), s.length === 0)
        return ".";
      const e = s.charCodeAt(0) === An;
      let t = -1, i = !0;
      for (let n = s.length - 1; n >= 1; --n)
        if (s.charCodeAt(n) === An) {
          if (!i) {
            t = n;
            break;
          }
        } else
          i = !1;
      return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : s.slice(0, t);
    },
    basename(s, e) {
      e !== void 0 && Ki(e, "ext"), Ki(s, "path");
      let t = 0, i = -1, n = !0, o;
      if (e !== void 0 && e.length > 0 && e.length <= s.length) {
        if (e === s)
          return "";
        let r = e.length - 1, a = -1;
        for (o = s.length - 1; o >= 0; --o) {
          const l = s.charCodeAt(o);
          if (l === An) {
            if (!n) {
              t = o + 1;
              break;
            }
          } else
            a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
        }
        return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
      }
      for (o = s.length - 1; o >= 0; --o)
        if (s.charCodeAt(o) === An) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          i === -1 && (n = !1, i = o + 1);
      return i === -1 ? "" : s.slice(t, i);
    },
    extname(s) {
      Ki(s, "path");
      let e = -1, t = 0, i = -1, n = !0, o = 0;
      for (let r = s.length - 1; r >= 0; --r) {
        const a = s.charCodeAt(r);
        if (a === An) {
          if (!n) {
            t = r + 1;
            break;
          }
          continue;
        }
        i === -1 && (n = !1, i = r + 1), a === ec ? e === -1 ? e = r : o !== 1 && (o = 1) : e !== -1 && (o = -1);
      }
      return e === -1 || i === -1 || o === 0 || o === 1 && e === i - 1 && e === t + 1 ? "" : s.slice(e, i);
    },
    format: sP.bind(null, "/"),
    parse(s) {
      Ki(s, "path");
      const e = { root: "", dir: "", base: "", ext: "", name: "" };
      if (s.length === 0)
        return e;
      const t = s.charCodeAt(0) === An;
      let i;
      t ? (e.root = "/", i = 1) : i = 0;
      let n = -1, o = 0, r = -1, a = !0, l = s.length - 1, c = 0;
      for (; l >= i; --l) {
        const d = s.charCodeAt(l);
        if (d === An) {
          if (!a) {
            o = l + 1;
            break;
          }
          continue;
        }
        r === -1 && (a = !1, r = l + 1), d === ec ? n === -1 ? n = l : c !== 1 && (c = 1) : n !== -1 && (c = -1);
      }
      if (r !== -1) {
        const d = o === 0 && t ? 1 : o;
        n === -1 || c === 0 || c === 1 && n === r - 1 && n === o + 1 ? e.base = e.name = s.slice(d, r) : (e.name = s.slice(d, n), e.base = s.slice(d, r), e.ext = s.slice(n, r));
      }
      return o > 0 ? e.dir = s.slice(0, o - 1) : t && (e.dir = "/"), e;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  Ci.win32 = Ls.win32 = Ls;
  Ci.posix = Ls.posix = Ci;
  const SI = xh === "win32" ? Ls.normalize : Ci.normalize, dW = xh === "win32" ? Ls.resolve : Ci.resolve, hW = xh === "win32" ? Ls.relative : Ci.relative, oP = xh === "win32" ? Ls.dirname : Ci.dirname, kd = xh === "win32" ? Ls.basename : Ci.basename, uW = xh === "win32" ? Ls.extname : Ci.extname, ta = xh === "win32" ? Ls.sep : Ci.sep, fW = /^\w[\w\d+.-]*$/, gW = /^\//, mW = /^\/\//;
  function T2(s, e) {
    if (!s.scheme && e)
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${s.authority}", path: "${s.path}", query: "${s.query}", fragment: "${s.fragment}"}`);
    if (s.scheme && !fW.test(s.scheme))
      throw new Error("[UriError]: Scheme contains illegal characters.");
    if (s.path) {
      if (s.authority) {
        if (!gW.test(s.path))
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      } else if (mW.test(s.path))
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
    }
  }
  function pW(s, e) {
    return !s && !e ? "file" : s;
  }
  function _W(s, e) {
    switch (s) {
      case "https":
      case "http":
      case "file":
        e ? e[0] !== ar && (e = ar + e) : e = ar;
        break;
    }
    return e;
  }
  const hi = "", ar = "/", bW = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  class Ee {
    constructor(e, t, i, n, o, r = !1) {
      typeof e == "object" ? (this.scheme = e.scheme || hi, this.authority = e.authority || hi, this.path = e.path || hi, this.query = e.query || hi, this.fragment = e.fragment || hi) : (this.scheme = pW(e, r), this.authority = t || hi, this.path = _W(this.scheme, i || hi), this.query = n || hi, this.fragment = o || hi, T2(this, r));
    }
    static isUri(e) {
      return e instanceof Ee ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
    }
    get fsPath() {
      return H0(this, !1);
    }
    with(e) {
      if (!e)
        return this;
      let { scheme: t, authority: i, path: n, query: o, fragment: r } = e;
      return t === void 0 ? t = this.scheme : t === null && (t = hi), i === void 0 ? i = this.authority : i === null && (i = hi), n === void 0 ? n = this.path : n === null && (n = hi), o === void 0 ? o = this.query : o === null && (o = hi), r === void 0 ? r = this.fragment : r === null && (r = hi), t === this.scheme && i === this.authority && n === this.path && o === this.query && r === this.fragment ? this : new Yh(t, i, n, o, r);
    }
    static parse(e, t = !1) {
      const i = bW.exec(e);
      return i ? new Yh(i[2] || hi, z_(i[4] || hi), z_(i[5] || hi), z_(i[7] || hi), z_(i[9] || hi), t) : new Yh(hi, hi, hi, hi, hi);
    }
    static file(e) {
      let t = hi;
      if (rn && (e = e.replace(/\\/g, ar)), e[0] === ar && e[1] === ar) {
        const i = e.indexOf(ar, 2);
        i === -1 ? (t = e.substring(2), e = ar) : (t = e.substring(2, i), e = e.substring(i) || ar);
      }
      return new Yh("file", t, e, hi, hi);
    }
    static from(e) {
      const t = new Yh(e.scheme, e.authority, e.path, e.query, e.fragment);
      return T2(t, !0), t;
    }
    static joinPath(e, ...t) {
      if (!e.path)
        throw new Error("[UriError]: cannot call joinPath on URI without path");
      let i;
      return rn && e.scheme === "file" ? i = Ee.file(Ls.join(H0(e, !0), ...t)).path : i = Ci.join(e.path, ...t), e.with({ path: i });
    }
    toString(e = !1) {
      return Zy(this, e);
    }
    toJSON() {
      return this;
    }
    static revive(e) {
      if (e) {
        if (e instanceof Ee)
          return e;
        {
          const t = new Yh(e);
          return t._formatted = e.external, t._fsPath = e._sep === rP ? e.fsPath : null, t;
        }
      } else
        return e;
    }
  }
  const rP = rn ? 1 : void 0;
  class Yh extends Ee {
    constructor() {
      super(...arguments), this._formatted = null, this._fsPath = null;
    }
    get fsPath() {
      return this._fsPath || (this._fsPath = H0(this, !1)), this._fsPath;
    }
    toString(e = !1) {
      return e ? Zy(this, !0) : (this._formatted || (this._formatted = Zy(this, !1)), this._formatted);
    }
    toJSON() {
      const e = {
        $mid: 1
      };
      return this._fsPath && (e.fsPath = this._fsPath, e._sep = rP), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
    }
  }
  const aP = {
    [58]: "%3A",
    [47]: "%2F",
    [63]: "%3F",
    [35]: "%23",
    [91]: "%5B",
    [93]: "%5D",
    [64]: "%40",
    [33]: "%21",
    [36]: "%24",
    [38]: "%26",
    [39]: "%27",
    [40]: "%28",
    [41]: "%29",
    [42]: "%2A",
    [43]: "%2B",
    [44]: "%2C",
    [59]: "%3B",
    [61]: "%3D",
    [32]: "%20"
  };
  function M2(s, e) {
    let t, i = -1;
    for (let n = 0; n < s.length; n++) {
      const o = s.charCodeAt(n);
      if (o >= 97 && o <= 122 || o >= 65 && o <= 90 || o >= 48 && o <= 57 || o === 45 || o === 46 || o === 95 || o === 126 || e && o === 47)
        i !== -1 && (t += encodeURIComponent(s.substring(i, n)), i = -1), t !== void 0 && (t += s.charAt(n));
      else {
        t === void 0 && (t = s.substr(0, n));
        const r = aP[o];
        r !== void 0 ? (i !== -1 && (t += encodeURIComponent(s.substring(i, n)), i = -1), t += r) : i === -1 && (i = n);
      }
    }
    return i !== -1 && (t += encodeURIComponent(s.substring(i))), t !== void 0 ? t : s;
  }
  function vW(s) {
    let e;
    for (let t = 0; t < s.length; t++) {
      const i = s.charCodeAt(t);
      i === 35 || i === 63 ? (e === void 0 && (e = s.substr(0, t)), e += aP[i]) : e !== void 0 && (e += s[t]);
    }
    return e !== void 0 ? e : s;
  }
  function H0(s, e) {
    let t;
    return s.authority && s.path.length > 1 && s.scheme === "file" ? t = `//${s.authority}${s.path}` : s.path.charCodeAt(0) === 47 && (s.path.charCodeAt(1) >= 65 && s.path.charCodeAt(1) <= 90 || s.path.charCodeAt(1) >= 97 && s.path.charCodeAt(1) <= 122) && s.path.charCodeAt(2) === 58 ? e ? t = s.path.substr(1) : t = s.path[1].toLowerCase() + s.path.substr(2) : t = s.path, rn && (t = t.replace(/\//g, "\\")), t;
  }
  function Zy(s, e) {
    const t = e ? vW : M2;
    let i = "", { scheme: n, authority: o, path: r, query: a, fragment: l } = s;
    if (n && (i += n, i += ":"), (o || n === "file") && (i += ar, i += ar), o) {
      let c = o.indexOf("@");
      if (c !== -1) {
        const d = o.substr(0, c);
        o = o.substr(c + 1), c = d.indexOf(":"), c === -1 ? i += t(d, !1) : (i += t(d.substr(0, c), !1), i += ":", i += t(d.substr(c + 1), !1)), i += "@";
      }
      o = o.toLowerCase(), c = o.indexOf(":"), c === -1 ? i += t(o, !1) : (i += t(o.substr(0, c), !1), i += o.substr(c));
    }
    if (r) {
      if (r.length >= 3 && r.charCodeAt(0) === 47 && r.charCodeAt(2) === 58) {
        const c = r.charCodeAt(1);
        c >= 65 && c <= 90 && (r = `/${String.fromCharCode(c + 32)}:${r.substr(3)}`);
      } else if (r.length >= 2 && r.charCodeAt(1) === 58) {
        const c = r.charCodeAt(0);
        c >= 65 && c <= 90 && (r = `${String.fromCharCode(c + 32)}:${r.substr(2)}`);
      }
      i += t(r, !0);
    }
    return a && (i += "?", i += t(a, !1)), l && (i += "#", i += e ? l : M2(l, !1)), i;
  }
  function lP(s) {
    try {
      return decodeURIComponent(s);
    } catch {
      return s.length > 3 ? s.substr(0, 3) + lP(s.substr(3)) : s;
    }
  }
  const A2 = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function z_(s) {
    return s.match(A2) ? s.replace(A2, (e) => lP(e)) : s;
  }
  var ze;
  (function(s) {
    s.inMemory = "inmemory", s.vscode = "vscode", s.internal = "private", s.walkThrough = "walkThrough", s.walkThroughSnippet = "walkThroughSnippet", s.http = "http", s.https = "https", s.file = "file", s.mailto = "mailto", s.untitled = "untitled", s.data = "data", s.command = "command", s.vscodeRemote = "vscode-remote", s.vscodeRemoteResource = "vscode-remote-resource", s.userData = "vscode-userdata", s.vscodeCustomEditor = "vscode-custom-editor", s.vscodeNotebook = "vscode-notebook", s.vscodeNotebookCell = "vscode-notebook-cell", s.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", s.vscodeNotebookCellOutput = "vscode-notebook-cell-output", s.vscodeInteractive = "vscode-interactive", s.vscodeInteractiveInput = "vscode-interactive-input", s.vscodeSettings = "vscode-settings", s.vscodeWorkspaceTrust = "vscode-workspace-trust", s.vscodeTerminal = "vscode-terminal", s.webviewPanel = "webview-panel", s.vscodeWebview = "vscode-webview", s.extension = "extension", s.vscodeFileResource = "vscode-file", s.tmp = "tmp", s.vsls = "vsls";
  })(ze || (ze = {}));
  const CW = "tkn";
  class wW {
    constructor() {
      this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null;
    }
    setPreferredWebSchema(e) {
      this._preferredWebSchema = e;
    }
    rewrite(e) {
      if (this._delegate)
        return this._delegate(e);
      const t = e.authority;
      let i = this._hosts[t];
      i && i.indexOf(":") !== -1 && (i = `[${i}]`);
      const n = this._ports[t], o = this._connectionTokens[t];
      let r = `path=${encodeURIComponent(e.path)}`;
      return typeof o == "string" && (r += `&${CW}=${encodeURIComponent(o)}`), Ee.from({
        scheme: Pc ? this._preferredWebSchema : ze.vscodeRemoteResource,
        authority: `${i}:${n}`,
        path: "/vscode-remote-resource",
        query: r
      });
    }
  }
  const cP = new wW();
  class Wm {
    asBrowserUri(e, t) {
      const i = this.toUri(e, t);
      return i.scheme === ze.vscodeRemote ? cP.rewrite(i) : i.scheme === ze.file && (gr || yB && gi.origin === `${ze.vscodeFileResource}://${Wm.FALLBACK_AUTHORITY}`) ? i.with({
        scheme: ze.vscodeFileResource,
        authority: i.authority || Wm.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      }) : i;
    }
    toUri(e, t) {
      return Ee.isUri(e) ? e : Ee.parse(t.toUrl(e));
    }
  }
  Wm.FALLBACK_AUTHORITY = "vscode-app";
  const dP = new Wm();
  function Bi(s) {
    for (; s.firstChild; )
      s.firstChild.remove();
  }
  function yI(s) {
    var e;
    return (e = s?.isConnected) !== null && e !== void 0 ? e : !1;
  }
  class hP {
    constructor(e, t, i, n) {
      this._node = e, this._type = t, this._handler = i, this._options = n || !1, this._node.addEventListener(this._type, this._handler, this._options);
    }
    dispose() {
      !this._handler || (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
    }
  }
  function ee(s, e, t, i) {
    return new hP(s, e, t, i);
  }
  function uP(s) {
    return function(e) {
      return s(new ho(e));
    };
  }
  function SW(s) {
    return function(e) {
      return s(new $t(e));
    };
  }
  let on = function(e, t, i, n) {
    let o = i;
    return t === "click" || t === "mousedown" ? o = uP(i) : (t === "keydown" || t === "keypress" || t === "keyup") && (o = SW(i)), ee(e, t, o, n);
  }, yW = function(e, t, i) {
    let n = uP(t);
    return LI(e, n, i);
  };
  function LI(s, e, t) {
    return ee(s, aa && Ev.pointerEvents ? ye.POINTER_DOWN : ye.MOUSE_DOWN, e, t);
  }
  function fP(s, e, t) {
    return ee(s, aa && Ev.pointerEvents ? ye.POINTER_UP : ye.MOUSE_UP, e, t);
  }
  function kI(s, e) {
    return ee(s, "mouseout", (t) => {
      let i = t.relatedTarget;
      for (; i && i !== s; )
        i = i.parentNode;
      i !== s && e(t);
    });
  }
  function LW(s, e) {
    return ee(s, "pointerout", (t) => {
      let i = t.relatedTarget;
      for (; i && i !== s; )
        i = i.parentNode;
      i !== s && e(t);
    });
  }
  function tr(s, e, t) {
    let i = null;
    const n = (l) => a.fire(l), o = () => {
      i || (i = new hP(s, e, n, t));
    }, r = () => {
      i && (i.dispose(), i = null);
    }, a = new B({ onFirstListenerAdd: o, onLastListenerRemove: r });
    return a;
  }
  let xw = null;
  function kW(s) {
    if (!xw) {
      const e = (t) => setTimeout(() => t(new Date().getTime()), 0);
      xw = self.requestAnimationFrame || self.msRequestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || e;
    }
    return xw.call(self, s);
  }
  let gP, _r;
  class Iw {
    constructor(e, t = 0) {
      this._runner = e, this.priority = t, this._canceled = !1;
    }
    dispose() {
      this._canceled = !0;
    }
    execute() {
      if (!this._canceled)
        try {
          this._runner();
        } catch (e) {
          We(e);
        }
    }
    static sort(e, t) {
      return t.priority - e.priority;
    }
  }
  (function() {
    let s = [], e = null, t = !1, i = !1, n = () => {
      for (t = !1, e = s, s = [], i = !0; e.length > 0; )
        e.sort(Iw.sort), e.shift().execute();
      i = !1;
    };
    _r = (o, r = 0) => {
      let a = new Iw(o, r);
      return s.push(a), t || (t = !0, kW(n)), a;
    }, gP = (o, r) => {
      if (i) {
        let a = new Iw(o, r);
        return e.push(a), a;
      } else
        return _r(o, r);
    };
  })();
  const DW = 8, xW = function(s, e) {
    return e;
  };
  class IW extends z {
    constructor(e, t, i, n = xW, o = DW) {
      super();
      let r = null, a = 0, l = this._register(new Ns()), c = () => {
        a = new Date().getTime(), i(r), r = null;
      };
      this._register(ee(e, t, (d) => {
        r = n(r, d);
        let h = new Date().getTime() - a;
        h >= o ? (l.cancel(), c()) : l.setIfNotSet(c, o - h);
      }));
    }
  }
  function DI(s, e, t, i, n) {
    return new IW(s, e, t, i, n);
  }
  function xI(s) {
    return document.defaultView.getComputedStyle(s, null);
  }
  function Nv(s) {
    if (s !== document.body)
      return new Et(s.clientWidth, s.clientHeight);
    if (aa && window.visualViewport)
      return new Et(window.visualViewport.width, window.visualViewport.height);
    if (window.innerWidth && window.innerHeight)
      return new Et(window.innerWidth, window.innerHeight);
    if (document.body && document.body.clientWidth && document.body.clientHeight)
      return new Et(document.body.clientWidth, document.body.clientHeight);
    if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight)
      return new Et(document.documentElement.clientWidth, document.documentElement.clientHeight);
    throw new Error("Unable to figure out browser width and height");
  }
  class ri {
    static convertToPixels(e, t) {
      return parseFloat(t) || 0;
    }
    static getDimension(e, t, i) {
      let n = xI(e), o = "0";
      return n && (n.getPropertyValue ? o = n.getPropertyValue(t) : o = n.getAttribute(i)), ri.convertToPixels(e, o);
    }
    static getBorderLeftWidth(e) {
      return ri.getDimension(e, "border-left-width", "borderLeftWidth");
    }
    static getBorderRightWidth(e) {
      return ri.getDimension(e, "border-right-width", "borderRightWidth");
    }
    static getBorderTopWidth(e) {
      return ri.getDimension(e, "border-top-width", "borderTopWidth");
    }
    static getBorderBottomWidth(e) {
      return ri.getDimension(e, "border-bottom-width", "borderBottomWidth");
    }
    static getPaddingLeft(e) {
      return ri.getDimension(e, "padding-left", "paddingLeft");
    }
    static getPaddingRight(e) {
      return ri.getDimension(e, "padding-right", "paddingRight");
    }
    static getPaddingTop(e) {
      return ri.getDimension(e, "padding-top", "paddingTop");
    }
    static getPaddingBottom(e) {
      return ri.getDimension(e, "padding-bottom", "paddingBottom");
    }
    static getMarginLeft(e) {
      return ri.getDimension(e, "margin-left", "marginLeft");
    }
    static getMarginTop(e) {
      return ri.getDimension(e, "margin-top", "marginTop");
    }
    static getMarginRight(e) {
      return ri.getDimension(e, "margin-right", "marginRight");
    }
    static getMarginBottom(e) {
      return ri.getDimension(e, "margin-bottom", "marginBottom");
    }
  }
  class Et {
    constructor(e, t) {
      this.width = e, this.height = t;
    }
    with(e = this.width, t = this.height) {
      return e !== this.width || t !== this.height ? new Et(e, t) : this;
    }
    static is(e) {
      return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
    }
    static lift(e) {
      return e instanceof Et ? e : new Et(e.width, e.height);
    }
    static equals(e, t) {
      return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
    }
  }
  Et.None = new Et(0, 0);
  function mP(s) {
    let e = s.offsetParent, t = s.offsetTop, i = s.offsetLeft;
    for (; (s = s.parentNode) !== null && s !== document.body && s !== document.documentElement; ) {
      t -= s.scrollTop;
      const n = _P(s) ? null : xI(s);
      n && (i -= n.direction !== "rtl" ? s.scrollLeft : -s.scrollLeft), s === e && (i += ri.getBorderLeftWidth(s), t += ri.getBorderTopWidth(s), t += s.offsetTop, i += s.offsetLeft, e = s.offsetParent);
    }
    return {
      left: i,
      top: t
    };
  }
  function EW(s, e, t) {
    typeof e == "number" && (s.style.width = `${e}px`), typeof t == "number" && (s.style.height = `${t}px`);
  }
  function mn(s) {
    let e = s.getBoundingClientRect();
    return {
      left: e.left + rl.scrollX,
      top: e.top + rl.scrollY,
      width: e.width,
      height: e.height
    };
  }
  const rl = new class {
    get scrollX() {
      return typeof window.scrollX == "number" ? window.scrollX : document.body.scrollLeft + document.documentElement.scrollLeft;
    }
    get scrollY() {
      return typeof window.scrollY == "number" ? window.scrollY : document.body.scrollTop + document.documentElement.scrollTop;
    }
  }();
  function Bo(s) {
    let e = ri.getMarginLeft(s) + ri.getMarginRight(s);
    return s.offsetWidth + e;
  }
  function Ew(s) {
    let e = ri.getBorderLeftWidth(s) + ri.getBorderRightWidth(s), t = ri.getPaddingLeft(s) + ri.getPaddingRight(s);
    return s.offsetWidth - e - t;
  }
  function NW(s) {
    let e = ri.getBorderTopWidth(s) + ri.getBorderBottomWidth(s), t = ri.getPaddingTop(s) + ri.getPaddingBottom(s);
    return s.offsetHeight - e - t;
  }
  function Yy(s) {
    let e = ri.getMarginTop(s) + ri.getMarginBottom(s);
    return s.offsetHeight + e;
  }
  function al(s, e) {
    for (; s; ) {
      if (s === e)
        return !0;
      s = s.parentNode;
    }
    return !1;
  }
  function pP(s, e, t) {
    for (; s && s.nodeType === s.ELEMENT_NODE; ) {
      if (s.classList.contains(e))
        return s;
      if (t) {
        if (typeof t == "string") {
          if (s.classList.contains(t))
            return null;
        } else if (s === t)
          return null;
      }
      s = s.parentNode;
    }
    return null;
  }
  function R2(s, e, t) {
    return !!pP(s, e, t);
  }
  function _P(s) {
    return s && !!s.host && !!s.mode;
  }
  function Vm(s) {
    return !!mc(s);
  }
  function mc(s) {
    for (; s.parentNode; ) {
      if (s === document.body)
        return null;
      s = s.parentNode;
    }
    return _P(s) ? s : null;
  }
  function Uu() {
    let s = document.activeElement;
    for (; s?.shadowRoot; )
      s = s.shadowRoot.activeElement;
    return s;
  }
  function Co(s = document.getElementsByTagName("head")[0]) {
    let e = document.createElement("style");
    return e.type = "text/css", e.media = "screen", s.appendChild(e), e;
  }
  let Nw = null;
  function bP() {
    return Nw || (Nw = Co()), Nw;
  }
  function TW(s) {
    var e, t;
    return !((e = s?.sheet) === null || e === void 0) && e.rules ? s.sheet.rules : !((t = s?.sheet) === null || t === void 0) && t.cssRules ? s.sheet.cssRules : [];
  }
  function Xy(s, e, t = bP()) {
    !t || !e || t.sheet.insertRule(s + "{" + e + "}", 0);
  }
  function O2(s, e = bP()) {
    if (!e)
      return;
    let t = TW(e), i = [];
    for (let n = 0; n < t.length; n++)
      t[n].selectorText.indexOf(s) !== -1 && i.push(n);
    for (let n = i.length - 1; n >= 0; n--)
      e.sheet.deleteRule(i[n]);
  }
  function vP(s) {
    return typeof HTMLElement == "object" ? s instanceof HTMLElement : s && typeof s == "object" && s.nodeType === 1 && typeof s.nodeName == "string";
  }
  const ye = {
    CLICK: "click",
    AUXCLICK: "auxclick",
    DBLCLICK: "dblclick",
    MOUSE_UP: "mouseup",
    MOUSE_DOWN: "mousedown",
    MOUSE_OVER: "mouseover",
    MOUSE_MOVE: "mousemove",
    MOUSE_OUT: "mouseout",
    MOUSE_ENTER: "mouseenter",
    MOUSE_LEAVE: "mouseleave",
    MOUSE_WHEEL: "wheel",
    POINTER_UP: "pointerup",
    POINTER_DOWN: "pointerdown",
    POINTER_MOVE: "pointermove",
    CONTEXT_MENU: "contextmenu",
    WHEEL: "wheel",
    KEY_DOWN: "keydown",
    KEY_PRESS: "keypress",
    KEY_UP: "keyup",
    LOAD: "load",
    BEFORE_UNLOAD: "beforeunload",
    UNLOAD: "unload",
    PAGE_SHOW: "pageshow",
    PAGE_HIDE: "pagehide",
    ABORT: "abort",
    ERROR: "error",
    RESIZE: "resize",
    SCROLL: "scroll",
    FULLSCREEN_CHANGE: "fullscreenchange",
    WK_FULLSCREEN_CHANGE: "webkitfullscreenchange",
    SELECT: "select",
    CHANGE: "change",
    SUBMIT: "submit",
    RESET: "reset",
    FOCUS: "focus",
    FOCUS_IN: "focusin",
    FOCUS_OUT: "focusout",
    BLUR: "blur",
    INPUT: "input",
    STORAGE: "storage",
    DRAG_START: "dragstart",
    DRAG: "drag",
    DRAG_ENTER: "dragenter",
    DRAG_LEAVE: "dragleave",
    DRAG_OVER: "dragover",
    DROP: "drop",
    DRAG_END: "dragend",
    ANIMATION_START: Ql ? "webkitAnimationStart" : "animationstart",
    ANIMATION_END: Ql ? "webkitAnimationEnd" : "animationend",
    ANIMATION_ITERATION: Ql ? "webkitAnimationIteration" : "animationiteration"
  }, wt = {
    stop: function(s, e) {
      s.preventDefault ? s.preventDefault() : s.returnValue = !1, e && (s.stopPropagation ? s.stopPropagation() : s.cancelBubble = !0);
    }
  };
  function MW(s) {
    let e = [];
    for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
      e[t] = s.scrollTop, s = s.parentNode;
    return e;
  }
  function AW(s, e) {
    for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
      s.scrollTop !== e[t] && (s.scrollTop = e[t]), s = s.parentNode;
  }
  class z0 extends z {
    constructor(e) {
      super(), this._onDidFocus = this._register(new B()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new B()), this.onDidBlur = this._onDidBlur.event;
      let t = z0.hasFocusWithin(e), i = !1;
      const n = () => {
        i = !1, t || (t = !0, this._onDidFocus.fire());
      }, o = () => {
        t && (i = !0, window.setTimeout(() => {
          i && (i = !1, t = !1, this._onDidBlur.fire());
        }, 0));
      };
      this._refreshStateHandler = () => {
        z0.hasFocusWithin(e) !== t && (t ? o() : n());
      }, this._register(ee(e, ye.FOCUS, n, !0)), this._register(ee(e, ye.BLUR, o, !0)), this._register(ee(e, ye.FOCUS_IN, () => this._refreshStateHandler())), this._register(ee(e, ye.FOCUS_OUT, () => this._refreshStateHandler()));
    }
    static hasFocusWithin(e) {
      const t = mc(e), i = t ? t.activeElement : document.activeElement;
      return al(i, e);
    }
  }
  function ff(s) {
    return new z0(s);
  }
  function q(s, ...e) {
    if (s.append(...e), e.length === 1 && typeof e[0] != "string")
      return e[0];
  }
  function RW(s, e) {
    return s.insertBefore(e, s.firstChild), e;
  }
  function pc(s, ...e) {
    s.innerText = "", q(s, ...e);
  }
  const OW = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
  var Hm;
  (function(s) {
    s.HTML = "http://www.w3.org/1999/xhtml", s.SVG = "http://www.w3.org/2000/svg";
  })(Hm || (Hm = {}));
  function CP(s, e, t, ...i) {
    let n = OW.exec(e);
    if (!n)
      throw new Error("Bad use of emmet");
    t = Object.assign({}, t || {});
    let o = n[1] || "div", r;
    return s !== Hm.HTML ? r = document.createElementNS(s, o) : r = document.createElement(o), n[3] && (r.id = n[3]), n[4] && (r.className = n[4].replace(/\./g, " ").trim()), Object.keys(t).forEach((a) => {
      const l = t[a];
      typeof l > "u" || (/^on\w+$/.test(a) ? r[a] = l : a === "selected" ? l && r.setAttribute(a, "true") : r.setAttribute(a, l));
    }), r.append(...i), r;
  }
  function J(s, e, ...t) {
    return CP(Hm.HTML, s, e, ...t);
  }
  J.SVG = function(s, e, ...t) {
    return CP(Hm.SVG, s, e, ...t);
  };
  function Vs(...s) {
    for (let e of s)
      e.style.display = "", e.removeAttribute("aria-hidden");
  }
  function os(...s) {
    for (let e of s)
      e.style.display = "none", e.setAttribute("aria-hidden", "true");
  }
  function PW(s) {
    return Array.prototype.slice.call(document.getElementsByTagName(s), 0);
  }
  function P2(s) {
    const e = window.devicePixelRatio * s;
    return Math.max(1, Math.floor(e)) / window.devicePixelRatio;
  }
  function wP(s) {
    window.open(s, "_blank", "noopener");
  }
  function FW(s) {
    const e = () => {
      s(), t = _r(e);
    };
    let t = _r(e);
    return qe(() => t.dispose());
  }
  cP.setPreferredWebSchema(/^https:/.test(window.location.href) ? "https" : "http");
  function jd(s) {
    return s ? `url('${dP.asBrowserUri(s).toString(!0).replace(/'/g, "%27")}')` : "url('')";
  }
  function F2(s) {
    return `'${s.replace(/'/g, "%27")}'`;
  }
  class vd extends B {
    constructor() {
      super(), this._subscriptions = new te(), this._keyStatus = {
        altKey: !1,
        shiftKey: !1,
        ctrlKey: !1,
        metaKey: !1
      }, this._subscriptions.add(ee(window, "keydown", (e) => {
        if (e.defaultPrevented)
          return;
        const t = new $t(e);
        if (!(t.keyCode === 6 && e.repeat)) {
          if (e.altKey && !this._keyStatus.altKey)
            this._keyStatus.lastKeyPressed = "alt";
          else if (e.ctrlKey && !this._keyStatus.ctrlKey)
            this._keyStatus.lastKeyPressed = "ctrl";
          else if (e.metaKey && !this._keyStatus.metaKey)
            this._keyStatus.lastKeyPressed = "meta";
          else if (e.shiftKey && !this._keyStatus.shiftKey)
            this._keyStatus.lastKeyPressed = "shift";
          else if (t.keyCode !== 6)
            this._keyStatus.lastKeyPressed = void 0;
          else
            return;
          this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = e, this.fire(this._keyStatus));
        }
      }, !0)), this._subscriptions.add(ee(window, "keyup", (e) => {
        e.defaultPrevented || (!e.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !e.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !e.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !e.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = e, this.fire(this._keyStatus)));
      }, !0)), this._subscriptions.add(ee(document.body, "mousedown", () => {
        this._keyStatus.lastKeyPressed = void 0;
      }, !0)), this._subscriptions.add(ee(document.body, "mouseup", () => {
        this._keyStatus.lastKeyPressed = void 0;
      }, !0)), this._subscriptions.add(ee(document.body, "mousemove", (e) => {
        e.buttons && (this._keyStatus.lastKeyPressed = void 0);
      }, !0)), this._subscriptions.add(ee(window, "blur", () => {
        this.resetKeyStatus();
      }));
    }
    get keyStatus() {
      return this._keyStatus;
    }
    resetKeyStatus() {
      this.doResetKeyStatus(), this.fire(this._keyStatus);
    }
    doResetKeyStatus() {
      this._keyStatus = {
        altKey: !1,
        shiftKey: !1,
        ctrlKey: !1,
        metaKey: !1
      };
    }
    static getInstance() {
      return vd.instance || (vd.instance = new vd()), vd.instance;
    }
    dispose() {
      super.dispose(), this._subscriptions.dispose();
    }
  }
  function BW(s, e) {
    window.matchMedia(s).addEventListener("change", e);
  }
  const B2 = 2e4;
  let rd, t0, Qy, i0, Jy;
  function WW(s) {
    rd = document.createElement("div"), rd.className = "monaco-aria-container";
    const e = () => {
      const i = document.createElement("div");
      return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), rd.appendChild(i), i;
    };
    t0 = e(), Qy = e();
    const t = () => {
      const i = document.createElement("div");
      return i.className = "monaco-status", i.setAttribute("role", "complementary"), i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), rd.appendChild(i), i;
    };
    i0 = t(), Jy = t(), s.appendChild(rd);
  }
  function pn(s) {
    !rd || (t0.textContent !== s ? (Bi(Qy), $0(t0, s)) : (Bi(t0), $0(Qy, s)));
  }
  function U0(s) {
    !rd || (Ye ? pn(s) : i0.textContent !== s ? (Bi(Jy), $0(i0, s)) : (Bi(i0), $0(Jy, s)));
  }
  function $0(s, e) {
    Bi(s), e.length > B2 && (e = e.substr(0, B2)), s.textContent = e, s.style.visibility = "hidden", s.style.visibility = "visible";
  }
  var dr;
  (function(s) {
    s.serviceIds = /* @__PURE__ */ new Map(), s.DI_TARGET = "$di$target", s.DI_DEPENDENCIES = "$di$dependencies";
    function e(t) {
      return t[s.DI_DEPENDENCIES] || [];
    }
    s.getServiceDependencies = e;
  })(dr || (dr = {}));
  const et = st("instantiationService");
  function VW(s, e, t) {
    e[dr.DI_TARGET] === e ? e[dr.DI_DEPENDENCIES].push({ id: s, index: t }) : (e[dr.DI_DEPENDENCIES] = [{ id: s, index: t }], e[dr.DI_TARGET] = e);
  }
  function st(s) {
    if (dr.serviceIds.has(s))
      return dr.serviceIds.get(s);
    const e = function(t, i, n) {
      if (arguments.length !== 3)
        throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
      VW(e, t, n);
    };
    return e.toString = () => s, dr.serviceIds.set(s, e), e;
  }
  const St = st("codeEditorService");
  class V {
    constructor(e, t) {
      this.lineNumber = e, this.column = t;
    }
    with(e = this.lineNumber, t = this.column) {
      return e === this.lineNumber && t === this.column ? this : new V(e, t);
    }
    delta(e = 0, t = 0) {
      return this.with(this.lineNumber + e, this.column + t);
    }
    equals(e) {
      return V.equals(this, e);
    }
    static equals(e, t) {
      return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
    }
    isBefore(e) {
      return V.isBefore(this, e);
    }
    static isBefore(e, t) {
      return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column;
    }
    isBeforeOrEqual(e) {
      return V.isBeforeOrEqual(this, e);
    }
    static isBeforeOrEqual(e, t) {
      return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column;
    }
    static compare(e, t) {
      const i = e.lineNumber | 0, n = t.lineNumber | 0;
      if (i === n) {
        const o = e.column | 0, r = t.column | 0;
        return o - r;
      }
      return i - n;
    }
    clone() {
      return new V(this.lineNumber, this.column);
    }
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")";
    }
    static lift(e) {
      return new V(e.lineNumber, e.column);
    }
    static isIPosition(e) {
      return e && typeof e.lineNumber == "number" && typeof e.column == "number";
    }
  }
  const Qt = st("modelService"), fs = st("textModelService");
  var j0 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class ks extends z {
    constructor(e, t = "", i = "", n = !0, o) {
      super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._id = e, this._label = t, this._cssClass = i, this._enabled = n, this._actionCallback = o;
    }
    get id() {
      return this._id;
    }
    get label() {
      return this._label;
    }
    set label(e) {
      this._setLabel(e);
    }
    _setLabel(e) {
      this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
    }
    get tooltip() {
      return this._tooltip || "";
    }
    set tooltip(e) {
      this._setTooltip(e);
    }
    _setTooltip(e) {
      this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
    }
    get class() {
      return this._cssClass;
    }
    set class(e) {
      this._setClass(e);
    }
    _setClass(e) {
      this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e) {
      this._setEnabled(e);
    }
    _setEnabled(e) {
      this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
    }
    get checked() {
      return this._checked;
    }
    set checked(e) {
      this._setChecked(e);
    }
    _setChecked(e) {
      this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
    }
    run(e, t) {
      return j0(this, void 0, void 0, function* () {
        this._actionCallback && (yield this._actionCallback(e));
      });
    }
  }
  class gf extends z {
    constructor() {
      super(...arguments), this._onBeforeRun = this._register(new B()), this.onBeforeRun = this._onBeforeRun.event, this._onDidRun = this._register(new B()), this.onDidRun = this._onDidRun.event;
    }
    run(e, t) {
      return j0(this, void 0, void 0, function* () {
        if (!e.enabled)
          return;
        this._onBeforeRun.fire({ action: e });
        let i;
        try {
          yield this.runAction(e, t);
        } catch (n) {
          i = n;
        }
        this._onDidRun.fire({ action: e, error: i });
      });
    }
    runAction(e, t) {
      return j0(this, void 0, void 0, function* () {
        yield e.run(t);
      });
    }
  }
  class mo extends ks {
    constructor(e) {
      super(mo.ID, e, e ? "separator text" : "separator"), this.checked = !1, this.enabled = !1;
    }
  }
  mo.ID = "vs.actions.separator";
  class Tv {
    constructor(e, t, i, n) {
      this.tooltip = "", this.enabled = !0, this.checked = void 0, this.id = e, this.label = t, this.class = n, this._actions = i;
    }
    get actions() {
      return this._actions;
    }
    dispose() {
    }
    run() {
      return j0(this, void 0, void 0, function* () {
      });
    }
  }
  class Mv extends ks {
    constructor() {
      super(Mv.ID, m("submenu.empty", "(empty)"), void 0, !1);
    }
  }
  Mv.ID = "vs.actions.empty";
  function HW(s) {
    return s ? s.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
  }
  class p {
    constructor(e, t, i) {
      this.id = e, this.definition = t, this.description = i, p._allCodicons.push(this);
    }
    get classNames() {
      return "codicon codicon-" + this.id;
    }
    get classNamesArray() {
      return ["codicon", "codicon-" + this.id];
    }
    get cssSelector() {
      return ".codicon.codicon-" + this.id;
    }
    static getAll() {
      return p._allCodicons;
    }
  }
  p._allCodicons = [];
  p.add = new p("add", { fontCharacter: "\\ea60" });
  p.plus = new p("plus", p.add.definition);
  p.gistNew = new p("gist-new", p.add.definition);
  p.repoCreate = new p("repo-create", p.add.definition);
  p.lightbulb = new p("lightbulb", { fontCharacter: "\\ea61" });
  p.lightBulb = new p("light-bulb", { fontCharacter: "\\ea61" });
  p.repo = new p("repo", { fontCharacter: "\\ea62" });
  p.repoDelete = new p("repo-delete", { fontCharacter: "\\ea62" });
  p.gistFork = new p("gist-fork", { fontCharacter: "\\ea63" });
  p.repoForked = new p("repo-forked", { fontCharacter: "\\ea63" });
  p.gitPullRequest = new p("git-pull-request", { fontCharacter: "\\ea64" });
  p.gitPullRequestAbandoned = new p("git-pull-request-abandoned", { fontCharacter: "\\ea64" });
  p.recordKeys = new p("record-keys", { fontCharacter: "\\ea65" });
  p.keyboard = new p("keyboard", { fontCharacter: "\\ea65" });
  p.tag = new p("tag", { fontCharacter: "\\ea66" });
  p.tagAdd = new p("tag-add", { fontCharacter: "\\ea66" });
  p.tagRemove = new p("tag-remove", { fontCharacter: "\\ea66" });
  p.person = new p("person", { fontCharacter: "\\ea67" });
  p.personFollow = new p("person-follow", { fontCharacter: "\\ea67" });
  p.personOutline = new p("person-outline", { fontCharacter: "\\ea67" });
  p.personFilled = new p("person-filled", { fontCharacter: "\\ea67" });
  p.gitBranch = new p("git-branch", { fontCharacter: "\\ea68" });
  p.gitBranchCreate = new p("git-branch-create", { fontCharacter: "\\ea68" });
  p.gitBranchDelete = new p("git-branch-delete", { fontCharacter: "\\ea68" });
  p.sourceControl = new p("source-control", { fontCharacter: "\\ea68" });
  p.mirror = new p("mirror", { fontCharacter: "\\ea69" });
  p.mirrorPublic = new p("mirror-public", { fontCharacter: "\\ea69" });
  p.star = new p("star", { fontCharacter: "\\ea6a" });
  p.starAdd = new p("star-add", { fontCharacter: "\\ea6a" });
  p.starDelete = new p("star-delete", { fontCharacter: "\\ea6a" });
  p.starEmpty = new p("star-empty", { fontCharacter: "\\ea6a" });
  p.comment = new p("comment", { fontCharacter: "\\ea6b" });
  p.commentAdd = new p("comment-add", { fontCharacter: "\\ea6b" });
  p.alert = new p("alert", { fontCharacter: "\\ea6c" });
  p.warning = new p("warning", { fontCharacter: "\\ea6c" });
  p.search = new p("search", { fontCharacter: "\\ea6d" });
  p.searchSave = new p("search-save", { fontCharacter: "\\ea6d" });
  p.logOut = new p("log-out", { fontCharacter: "\\ea6e" });
  p.signOut = new p("sign-out", { fontCharacter: "\\ea6e" });
  p.logIn = new p("log-in", { fontCharacter: "\\ea6f" });
  p.signIn = new p("sign-in", { fontCharacter: "\\ea6f" });
  p.eye = new p("eye", { fontCharacter: "\\ea70" });
  p.eyeUnwatch = new p("eye-unwatch", { fontCharacter: "\\ea70" });
  p.eyeWatch = new p("eye-watch", { fontCharacter: "\\ea70" });
  p.circleFilled = new p("circle-filled", { fontCharacter: "\\ea71" });
  p.primitiveDot = new p("primitive-dot", { fontCharacter: "\\ea71" });
  p.closeDirty = new p("close-dirty", { fontCharacter: "\\ea71" });
  p.debugBreakpoint = new p("debug-breakpoint", { fontCharacter: "\\ea71" });
  p.debugBreakpointDisabled = new p("debug-breakpoint-disabled", { fontCharacter: "\\ea71" });
  p.debugHint = new p("debug-hint", { fontCharacter: "\\ea71" });
  p.primitiveSquare = new p("primitive-square", { fontCharacter: "\\ea72" });
  p.edit = new p("edit", { fontCharacter: "\\ea73" });
  p.pencil = new p("pencil", { fontCharacter: "\\ea73" });
  p.info = new p("info", { fontCharacter: "\\ea74" });
  p.issueOpened = new p("issue-opened", { fontCharacter: "\\ea74" });
  p.gistPrivate = new p("gist-private", { fontCharacter: "\\ea75" });
  p.gitForkPrivate = new p("git-fork-private", { fontCharacter: "\\ea75" });
  p.lock = new p("lock", { fontCharacter: "\\ea75" });
  p.mirrorPrivate = new p("mirror-private", { fontCharacter: "\\ea75" });
  p.close = new p("close", { fontCharacter: "\\ea76" });
  p.removeClose = new p("remove-close", { fontCharacter: "\\ea76" });
  p.x = new p("x", { fontCharacter: "\\ea76" });
  p.repoSync = new p("repo-sync", { fontCharacter: "\\ea77" });
  p.sync = new p("sync", { fontCharacter: "\\ea77" });
  p.clone = new p("clone", { fontCharacter: "\\ea78" });
  p.desktopDownload = new p("desktop-download", { fontCharacter: "\\ea78" });
  p.beaker = new p("beaker", { fontCharacter: "\\ea79" });
  p.microscope = new p("microscope", { fontCharacter: "\\ea79" });
  p.vm = new p("vm", { fontCharacter: "\\ea7a" });
  p.deviceDesktop = new p("device-desktop", { fontCharacter: "\\ea7a" });
  p.file = new p("file", { fontCharacter: "\\ea7b" });
  p.fileText = new p("file-text", { fontCharacter: "\\ea7b" });
  p.more = new p("more", { fontCharacter: "\\ea7c" });
  p.ellipsis = new p("ellipsis", { fontCharacter: "\\ea7c" });
  p.kebabHorizontal = new p("kebab-horizontal", { fontCharacter: "\\ea7c" });
  p.mailReply = new p("mail-reply", { fontCharacter: "\\ea7d" });
  p.reply = new p("reply", { fontCharacter: "\\ea7d" });
  p.organization = new p("organization", { fontCharacter: "\\ea7e" });
  p.organizationFilled = new p("organization-filled", { fontCharacter: "\\ea7e" });
  p.organizationOutline = new p("organization-outline", { fontCharacter: "\\ea7e" });
  p.newFile = new p("new-file", { fontCharacter: "\\ea7f" });
  p.fileAdd = new p("file-add", { fontCharacter: "\\ea7f" });
  p.newFolder = new p("new-folder", { fontCharacter: "\\ea80" });
  p.fileDirectoryCreate = new p("file-directory-create", { fontCharacter: "\\ea80" });
  p.trash = new p("trash", { fontCharacter: "\\ea81" });
  p.trashcan = new p("trashcan", { fontCharacter: "\\ea81" });
  p.history = new p("history", { fontCharacter: "\\ea82" });
  p.clock = new p("clock", { fontCharacter: "\\ea82" });
  p.folder = new p("folder", { fontCharacter: "\\ea83" });
  p.fileDirectory = new p("file-directory", { fontCharacter: "\\ea83" });
  p.symbolFolder = new p("symbol-folder", { fontCharacter: "\\ea83" });
  p.logoGithub = new p("logo-github", { fontCharacter: "\\ea84" });
  p.markGithub = new p("mark-github", { fontCharacter: "\\ea84" });
  p.github = new p("github", { fontCharacter: "\\ea84" });
  p.terminal = new p("terminal", { fontCharacter: "\\ea85" });
  p.console = new p("console", { fontCharacter: "\\ea85" });
  p.repl = new p("repl", { fontCharacter: "\\ea85" });
  p.zap = new p("zap", { fontCharacter: "\\ea86" });
  p.symbolEvent = new p("symbol-event", { fontCharacter: "\\ea86" });
  p.error = new p("error", { fontCharacter: "\\ea87" });
  p.stop = new p("stop", { fontCharacter: "\\ea87" });
  p.variable = new p("variable", { fontCharacter: "\\ea88" });
  p.symbolVariable = new p("symbol-variable", { fontCharacter: "\\ea88" });
  p.array = new p("array", { fontCharacter: "\\ea8a" });
  p.symbolArray = new p("symbol-array", { fontCharacter: "\\ea8a" });
  p.symbolModule = new p("symbol-module", { fontCharacter: "\\ea8b" });
  p.symbolPackage = new p("symbol-package", { fontCharacter: "\\ea8b" });
  p.symbolNamespace = new p("symbol-namespace", { fontCharacter: "\\ea8b" });
  p.symbolObject = new p("symbol-object", { fontCharacter: "\\ea8b" });
  p.symbolMethod = new p("symbol-method", { fontCharacter: "\\ea8c" });
  p.symbolFunction = new p("symbol-function", { fontCharacter: "\\ea8c" });
  p.symbolConstructor = new p("symbol-constructor", { fontCharacter: "\\ea8c" });
  p.symbolBoolean = new p("symbol-boolean", { fontCharacter: "\\ea8f" });
  p.symbolNull = new p("symbol-null", { fontCharacter: "\\ea8f" });
  p.symbolNumeric = new p("symbol-numeric", { fontCharacter: "\\ea90" });
  p.symbolNumber = new p("symbol-number", { fontCharacter: "\\ea90" });
  p.symbolStructure = new p("symbol-structure", { fontCharacter: "\\ea91" });
  p.symbolStruct = new p("symbol-struct", { fontCharacter: "\\ea91" });
  p.symbolParameter = new p("symbol-parameter", { fontCharacter: "\\ea92" });
  p.symbolTypeParameter = new p("symbol-type-parameter", { fontCharacter: "\\ea92" });
  p.symbolKey = new p("symbol-key", { fontCharacter: "\\ea93" });
  p.symbolText = new p("symbol-text", { fontCharacter: "\\ea93" });
  p.symbolReference = new p("symbol-reference", { fontCharacter: "\\ea94" });
  p.goToFile = new p("go-to-file", { fontCharacter: "\\ea94" });
  p.symbolEnum = new p("symbol-enum", { fontCharacter: "\\ea95" });
  p.symbolValue = new p("symbol-value", { fontCharacter: "\\ea95" });
  p.symbolRuler = new p("symbol-ruler", { fontCharacter: "\\ea96" });
  p.symbolUnit = new p("symbol-unit", { fontCharacter: "\\ea96" });
  p.activateBreakpoints = new p("activate-breakpoints", { fontCharacter: "\\ea97" });
  p.archive = new p("archive", { fontCharacter: "\\ea98" });
  p.arrowBoth = new p("arrow-both", { fontCharacter: "\\ea99" });
  p.arrowDown = new p("arrow-down", { fontCharacter: "\\ea9a" });
  p.arrowLeft = new p("arrow-left", { fontCharacter: "\\ea9b" });
  p.arrowRight = new p("arrow-right", { fontCharacter: "\\ea9c" });
  p.arrowSmallDown = new p("arrow-small-down", { fontCharacter: "\\ea9d" });
  p.arrowSmallLeft = new p("arrow-small-left", { fontCharacter: "\\ea9e" });
  p.arrowSmallRight = new p("arrow-small-right", { fontCharacter: "\\ea9f" });
  p.arrowSmallUp = new p("arrow-small-up", { fontCharacter: "\\eaa0" });
  p.arrowUp = new p("arrow-up", { fontCharacter: "\\eaa1" });
  p.bell = new p("bell", { fontCharacter: "\\eaa2" });
  p.bold = new p("bold", { fontCharacter: "\\eaa3" });
  p.book = new p("book", { fontCharacter: "\\eaa4" });
  p.bookmark = new p("bookmark", { fontCharacter: "\\eaa5" });
  p.debugBreakpointConditionalUnverified = new p("debug-breakpoint-conditional-unverified", { fontCharacter: "\\eaa6" });
  p.debugBreakpointConditional = new p("debug-breakpoint-conditional", { fontCharacter: "\\eaa7" });
  p.debugBreakpointConditionalDisabled = new p("debug-breakpoint-conditional-disabled", { fontCharacter: "\\eaa7" });
  p.debugBreakpointDataUnverified = new p("debug-breakpoint-data-unverified", { fontCharacter: "\\eaa8" });
  p.debugBreakpointData = new p("debug-breakpoint-data", { fontCharacter: "\\eaa9" });
  p.debugBreakpointDataDisabled = new p("debug-breakpoint-data-disabled", { fontCharacter: "\\eaa9" });
  p.debugBreakpointLogUnverified = new p("debug-breakpoint-log-unverified", { fontCharacter: "\\eaaa" });
  p.debugBreakpointLog = new p("debug-breakpoint-log", { fontCharacter: "\\eaab" });
  p.debugBreakpointLogDisabled = new p("debug-breakpoint-log-disabled", { fontCharacter: "\\eaab" });
  p.briefcase = new p("briefcase", { fontCharacter: "\\eaac" });
  p.broadcast = new p("broadcast", { fontCharacter: "\\eaad" });
  p.browser = new p("browser", { fontCharacter: "\\eaae" });
  p.bug = new p("bug", { fontCharacter: "\\eaaf" });
  p.calendar = new p("calendar", { fontCharacter: "\\eab0" });
  p.caseSensitive = new p("case-sensitive", { fontCharacter: "\\eab1" });
  p.check = new p("check", { fontCharacter: "\\eab2" });
  p.checklist = new p("checklist", { fontCharacter: "\\eab3" });
  p.chevronDown = new p("chevron-down", { fontCharacter: "\\eab4" });
  p.dropDownButton = new p("drop-down-button", p.chevronDown.definition);
  p.chevronLeft = new p("chevron-left", { fontCharacter: "\\eab5" });
  p.chevronRight = new p("chevron-right", { fontCharacter: "\\eab6" });
  p.chevronUp = new p("chevron-up", { fontCharacter: "\\eab7" });
  p.chromeClose = new p("chrome-close", { fontCharacter: "\\eab8" });
  p.chromeMaximize = new p("chrome-maximize", { fontCharacter: "\\eab9" });
  p.chromeMinimize = new p("chrome-minimize", { fontCharacter: "\\eaba" });
  p.chromeRestore = new p("chrome-restore", { fontCharacter: "\\eabb" });
  p.circleOutline = new p("circle-outline", { fontCharacter: "\\eabc" });
  p.debugBreakpointUnverified = new p("debug-breakpoint-unverified", { fontCharacter: "\\eabc" });
  p.circleSlash = new p("circle-slash", { fontCharacter: "\\eabd" });
  p.circuitBoard = new p("circuit-board", { fontCharacter: "\\eabe" });
  p.clearAll = new p("clear-all", { fontCharacter: "\\eabf" });
  p.clippy = new p("clippy", { fontCharacter: "\\eac0" });
  p.closeAll = new p("close-all", { fontCharacter: "\\eac1" });
  p.cloudDownload = new p("cloud-download", { fontCharacter: "\\eac2" });
  p.cloudUpload = new p("cloud-upload", { fontCharacter: "\\eac3" });
  p.code = new p("code", { fontCharacter: "\\eac4" });
  p.collapseAll = new p("collapse-all", { fontCharacter: "\\eac5" });
  p.colorMode = new p("color-mode", { fontCharacter: "\\eac6" });
  p.commentDiscussion = new p("comment-discussion", { fontCharacter: "\\eac7" });
  p.compareChanges = new p("compare-changes", { fontCharacter: "\\eafd" });
  p.creditCard = new p("credit-card", { fontCharacter: "\\eac9" });
  p.dash = new p("dash", { fontCharacter: "\\eacc" });
  p.dashboard = new p("dashboard", { fontCharacter: "\\eacd" });
  p.database = new p("database", { fontCharacter: "\\eace" });
  p.debugContinue = new p("debug-continue", { fontCharacter: "\\eacf" });
  p.debugDisconnect = new p("debug-disconnect", { fontCharacter: "\\ead0" });
  p.debugPause = new p("debug-pause", { fontCharacter: "\\ead1" });
  p.debugRestart = new p("debug-restart", { fontCharacter: "\\ead2" });
  p.debugStart = new p("debug-start", { fontCharacter: "\\ead3" });
  p.debugStepInto = new p("debug-step-into", { fontCharacter: "\\ead4" });
  p.debugStepOut = new p("debug-step-out", { fontCharacter: "\\ead5" });
  p.debugStepOver = new p("debug-step-over", { fontCharacter: "\\ead6" });
  p.debugStop = new p("debug-stop", { fontCharacter: "\\ead7" });
  p.debug = new p("debug", { fontCharacter: "\\ead8" });
  p.deviceCameraVideo = new p("device-camera-video", { fontCharacter: "\\ead9" });
  p.deviceCamera = new p("device-camera", { fontCharacter: "\\eada" });
  p.deviceMobile = new p("device-mobile", { fontCharacter: "\\eadb" });
  p.diffAdded = new p("diff-added", { fontCharacter: "\\eadc" });
  p.diffIgnored = new p("diff-ignored", { fontCharacter: "\\eadd" });
  p.diffModified = new p("diff-modified", { fontCharacter: "\\eade" });
  p.diffRemoved = new p("diff-removed", { fontCharacter: "\\eadf" });
  p.diffRenamed = new p("diff-renamed", { fontCharacter: "\\eae0" });
  p.diff = new p("diff", { fontCharacter: "\\eae1" });
  p.discard = new p("discard", { fontCharacter: "\\eae2" });
  p.editorLayout = new p("editor-layout", { fontCharacter: "\\eae3" });
  p.emptyWindow = new p("empty-window", { fontCharacter: "\\eae4" });
  p.exclude = new p("exclude", { fontCharacter: "\\eae5" });
  p.extensions = new p("extensions", { fontCharacter: "\\eae6" });
  p.eyeClosed = new p("eye-closed", { fontCharacter: "\\eae7" });
  p.fileBinary = new p("file-binary", { fontCharacter: "\\eae8" });
  p.fileCode = new p("file-code", { fontCharacter: "\\eae9" });
  p.fileMedia = new p("file-media", { fontCharacter: "\\eaea" });
  p.filePdf = new p("file-pdf", { fontCharacter: "\\eaeb" });
  p.fileSubmodule = new p("file-submodule", { fontCharacter: "\\eaec" });
  p.fileSymlinkDirectory = new p("file-symlink-directory", { fontCharacter: "\\eaed" });
  p.fileSymlinkFile = new p("file-symlink-file", { fontCharacter: "\\eaee" });
  p.fileZip = new p("file-zip", { fontCharacter: "\\eaef" });
  p.files = new p("files", { fontCharacter: "\\eaf0" });
  p.filter = new p("filter", { fontCharacter: "\\eaf1" });
  p.flame = new p("flame", { fontCharacter: "\\eaf2" });
  p.foldDown = new p("fold-down", { fontCharacter: "\\eaf3" });
  p.foldUp = new p("fold-up", { fontCharacter: "\\eaf4" });
  p.fold = new p("fold", { fontCharacter: "\\eaf5" });
  p.folderActive = new p("folder-active", { fontCharacter: "\\eaf6" });
  p.folderOpened = new p("folder-opened", { fontCharacter: "\\eaf7" });
  p.gear = new p("gear", { fontCharacter: "\\eaf8" });
  p.gift = new p("gift", { fontCharacter: "\\eaf9" });
  p.gistSecret = new p("gist-secret", { fontCharacter: "\\eafa" });
  p.gist = new p("gist", { fontCharacter: "\\eafb" });
  p.gitCommit = new p("git-commit", { fontCharacter: "\\eafc" });
  p.gitCompare = new p("git-compare", { fontCharacter: "\\eafd" });
  p.gitMerge = new p("git-merge", { fontCharacter: "\\eafe" });
  p.githubAction = new p("github-action", { fontCharacter: "\\eaff" });
  p.githubAlt = new p("github-alt", { fontCharacter: "\\eb00" });
  p.globe = new p("globe", { fontCharacter: "\\eb01" });
  p.grabber = new p("grabber", { fontCharacter: "\\eb02" });
  p.graph = new p("graph", { fontCharacter: "\\eb03" });
  p.gripper = new p("gripper", { fontCharacter: "\\eb04" });
  p.heart = new p("heart", { fontCharacter: "\\eb05" });
  p.home = new p("home", { fontCharacter: "\\eb06" });
  p.horizontalRule = new p("horizontal-rule", { fontCharacter: "\\eb07" });
  p.hubot = new p("hubot", { fontCharacter: "\\eb08" });
  p.inbox = new p("inbox", { fontCharacter: "\\eb09" });
  p.issueClosed = new p("issue-closed", { fontCharacter: "\\eba4" });
  p.issueReopened = new p("issue-reopened", { fontCharacter: "\\eb0b" });
  p.issues = new p("issues", { fontCharacter: "\\eb0c" });
  p.italic = new p("italic", { fontCharacter: "\\eb0d" });
  p.jersey = new p("jersey", { fontCharacter: "\\eb0e" });
  p.json = new p("json", { fontCharacter: "\\eb0f" });
  p.kebabVertical = new p("kebab-vertical", { fontCharacter: "\\eb10" });
  p.key = new p("key", { fontCharacter: "\\eb11" });
  p.law = new p("law", { fontCharacter: "\\eb12" });
  p.lightbulbAutofix = new p("lightbulb-autofix", { fontCharacter: "\\eb13" });
  p.linkExternal = new p("link-external", { fontCharacter: "\\eb14" });
  p.link = new p("link", { fontCharacter: "\\eb15" });
  p.listOrdered = new p("list-ordered", { fontCharacter: "\\eb16" });
  p.listUnordered = new p("list-unordered", { fontCharacter: "\\eb17" });
  p.liveShare = new p("live-share", { fontCharacter: "\\eb18" });
  p.loading = new p("loading", { fontCharacter: "\\eb19" });
  p.location = new p("location", { fontCharacter: "\\eb1a" });
  p.mailRead = new p("mail-read", { fontCharacter: "\\eb1b" });
  p.mail = new p("mail", { fontCharacter: "\\eb1c" });
  p.markdown = new p("markdown", { fontCharacter: "\\eb1d" });
  p.megaphone = new p("megaphone", { fontCharacter: "\\eb1e" });
  p.mention = new p("mention", { fontCharacter: "\\eb1f" });
  p.milestone = new p("milestone", { fontCharacter: "\\eb20" });
  p.mortarBoard = new p("mortar-board", { fontCharacter: "\\eb21" });
  p.move = new p("move", { fontCharacter: "\\eb22" });
  p.multipleWindows = new p("multiple-windows", { fontCharacter: "\\eb23" });
  p.mute = new p("mute", { fontCharacter: "\\eb24" });
  p.noNewline = new p("no-newline", { fontCharacter: "\\eb25" });
  p.note = new p("note", { fontCharacter: "\\eb26" });
  p.octoface = new p("octoface", { fontCharacter: "\\eb27" });
  p.openPreview = new p("open-preview", { fontCharacter: "\\eb28" });
  p.package_ = new p("package", { fontCharacter: "\\eb29" });
  p.paintcan = new p("paintcan", { fontCharacter: "\\eb2a" });
  p.pin = new p("pin", { fontCharacter: "\\eb2b" });
  p.play = new p("play", { fontCharacter: "\\eb2c" });
  p.run = new p("run", { fontCharacter: "\\eb2c" });
  p.plug = new p("plug", { fontCharacter: "\\eb2d" });
  p.preserveCase = new p("preserve-case", { fontCharacter: "\\eb2e" });
  p.preview = new p("preview", { fontCharacter: "\\eb2f" });
  p.project = new p("project", { fontCharacter: "\\eb30" });
  p.pulse = new p("pulse", { fontCharacter: "\\eb31" });
  p.question = new p("question", { fontCharacter: "\\eb32" });
  p.quote = new p("quote", { fontCharacter: "\\eb33" });
  p.radioTower = new p("radio-tower", { fontCharacter: "\\eb34" });
  p.reactions = new p("reactions", { fontCharacter: "\\eb35" });
  p.references = new p("references", { fontCharacter: "\\eb36" });
  p.refresh = new p("refresh", { fontCharacter: "\\eb37" });
  p.regex = new p("regex", { fontCharacter: "\\eb38" });
  p.remoteExplorer = new p("remote-explorer", { fontCharacter: "\\eb39" });
  p.remote = new p("remote", { fontCharacter: "\\eb3a" });
  p.remove = new p("remove", { fontCharacter: "\\eb3b" });
  p.replaceAll = new p("replace-all", { fontCharacter: "\\eb3c" });
  p.replace = new p("replace", { fontCharacter: "\\eb3d" });
  p.repoClone = new p("repo-clone", { fontCharacter: "\\eb3e" });
  p.repoForcePush = new p("repo-force-push", { fontCharacter: "\\eb3f" });
  p.repoPull = new p("repo-pull", { fontCharacter: "\\eb40" });
  p.repoPush = new p("repo-push", { fontCharacter: "\\eb41" });
  p.report = new p("report", { fontCharacter: "\\eb42" });
  p.requestChanges = new p("request-changes", { fontCharacter: "\\eb43" });
  p.rocket = new p("rocket", { fontCharacter: "\\eb44" });
  p.rootFolderOpened = new p("root-folder-opened", { fontCharacter: "\\eb45" });
  p.rootFolder = new p("root-folder", { fontCharacter: "\\eb46" });
  p.rss = new p("rss", { fontCharacter: "\\eb47" });
  p.ruby = new p("ruby", { fontCharacter: "\\eb48" });
  p.saveAll = new p("save-all", { fontCharacter: "\\eb49" });
  p.saveAs = new p("save-as", { fontCharacter: "\\eb4a" });
  p.save = new p("save", { fontCharacter: "\\eb4b" });
  p.screenFull = new p("screen-full", { fontCharacter: "\\eb4c" });
  p.screenNormal = new p("screen-normal", { fontCharacter: "\\eb4d" });
  p.searchStop = new p("search-stop", { fontCharacter: "\\eb4e" });
  p.server = new p("server", { fontCharacter: "\\eb50" });
  p.settingsGear = new p("settings-gear", { fontCharacter: "\\eb51" });
  p.settings = new p("settings", { fontCharacter: "\\eb52" });
  p.shield = new p("shield", { fontCharacter: "\\eb53" });
  p.smiley = new p("smiley", { fontCharacter: "\\eb54" });
  p.sortPrecedence = new p("sort-precedence", { fontCharacter: "\\eb55" });
  p.splitHorizontal = new p("split-horizontal", { fontCharacter: "\\eb56" });
  p.splitVertical = new p("split-vertical", { fontCharacter: "\\eb57" });
  p.squirrel = new p("squirrel", { fontCharacter: "\\eb58" });
  p.starFull = new p("star-full", { fontCharacter: "\\eb59" });
  p.starHalf = new p("star-half", { fontCharacter: "\\eb5a" });
  p.symbolClass = new p("symbol-class", { fontCharacter: "\\eb5b" });
  p.symbolColor = new p("symbol-color", { fontCharacter: "\\eb5c" });
  p.symbolCustomColor = new p("symbol-customcolor", { fontCharacter: "\\eb5c" });
  p.symbolConstant = new p("symbol-constant", { fontCharacter: "\\eb5d" });
  p.symbolEnumMember = new p("symbol-enum-member", { fontCharacter: "\\eb5e" });
  p.symbolField = new p("symbol-field", { fontCharacter: "\\eb5f" });
  p.symbolFile = new p("symbol-file", { fontCharacter: "\\eb60" });
  p.symbolInterface = new p("symbol-interface", { fontCharacter: "\\eb61" });
  p.symbolKeyword = new p("symbol-keyword", { fontCharacter: "\\eb62" });
  p.symbolMisc = new p("symbol-misc", { fontCharacter: "\\eb63" });
  p.symbolOperator = new p("symbol-operator", { fontCharacter: "\\eb64" });
  p.symbolProperty = new p("symbol-property", { fontCharacter: "\\eb65" });
  p.wrench = new p("wrench", { fontCharacter: "\\eb65" });
  p.wrenchSubaction = new p("wrench-subaction", { fontCharacter: "\\eb65" });
  p.symbolSnippet = new p("symbol-snippet", { fontCharacter: "\\eb66" });
  p.tasklist = new p("tasklist", { fontCharacter: "\\eb67" });
  p.telescope = new p("telescope", { fontCharacter: "\\eb68" });
  p.textSize = new p("text-size", { fontCharacter: "\\eb69" });
  p.threeBars = new p("three-bars", { fontCharacter: "\\eb6a" });
  p.thumbsdown = new p("thumbsdown", { fontCharacter: "\\eb6b" });
  p.thumbsup = new p("thumbsup", { fontCharacter: "\\eb6c" });
  p.tools = new p("tools", { fontCharacter: "\\eb6d" });
  p.triangleDown = new p("triangle-down", { fontCharacter: "\\eb6e" });
  p.triangleLeft = new p("triangle-left", { fontCharacter: "\\eb6f" });
  p.triangleRight = new p("triangle-right", { fontCharacter: "\\eb70" });
  p.triangleUp = new p("triangle-up", { fontCharacter: "\\eb71" });
  p.twitter = new p("twitter", { fontCharacter: "\\eb72" });
  p.unfold = new p("unfold", { fontCharacter: "\\eb73" });
  p.unlock = new p("unlock", { fontCharacter: "\\eb74" });
  p.unmute = new p("unmute", { fontCharacter: "\\eb75" });
  p.unverified = new p("unverified", { fontCharacter: "\\eb76" });
  p.verified = new p("verified", { fontCharacter: "\\eb77" });
  p.versions = new p("versions", { fontCharacter: "\\eb78" });
  p.vmActive = new p("vm-active", { fontCharacter: "\\eb79" });
  p.vmOutline = new p("vm-outline", { fontCharacter: "\\eb7a" });
  p.vmRunning = new p("vm-running", { fontCharacter: "\\eb7b" });
  p.watch = new p("watch", { fontCharacter: "\\eb7c" });
  p.whitespace = new p("whitespace", { fontCharacter: "\\eb7d" });
  p.wholeWord = new p("whole-word", { fontCharacter: "\\eb7e" });
  p.window = new p("window", { fontCharacter: "\\eb7f" });
  p.wordWrap = new p("word-wrap", { fontCharacter: "\\eb80" });
  p.zoomIn = new p("zoom-in", { fontCharacter: "\\eb81" });
  p.zoomOut = new p("zoom-out", { fontCharacter: "\\eb82" });
  p.listFilter = new p("list-filter", { fontCharacter: "\\eb83" });
  p.listFlat = new p("list-flat", { fontCharacter: "\\eb84" });
  p.listSelection = new p("list-selection", { fontCharacter: "\\eb85" });
  p.selection = new p("selection", { fontCharacter: "\\eb85" });
  p.listTree = new p("list-tree", { fontCharacter: "\\eb86" });
  p.debugBreakpointFunctionUnverified = new p("debug-breakpoint-function-unverified", { fontCharacter: "\\eb87" });
  p.debugBreakpointFunction = new p("debug-breakpoint-function", { fontCharacter: "\\eb88" });
  p.debugBreakpointFunctionDisabled = new p("debug-breakpoint-function-disabled", { fontCharacter: "\\eb88" });
  p.debugStackframeActive = new p("debug-stackframe-active", { fontCharacter: "\\eb89" });
  p.debugStackframeDot = new p("debug-stackframe-dot", { fontCharacter: "\\eb8a" });
  p.debugStackframe = new p("debug-stackframe", { fontCharacter: "\\eb8b" });
  p.debugStackframeFocused = new p("debug-stackframe-focused", { fontCharacter: "\\eb8b" });
  p.debugBreakpointUnsupported = new p("debug-breakpoint-unsupported", { fontCharacter: "\\eb8c" });
  p.symbolString = new p("symbol-string", { fontCharacter: "\\eb8d" });
  p.debugReverseContinue = new p("debug-reverse-continue", { fontCharacter: "\\eb8e" });
  p.debugStepBack = new p("debug-step-back", { fontCharacter: "\\eb8f" });
  p.debugRestartFrame = new p("debug-restart-frame", { fontCharacter: "\\eb90" });
  p.callIncoming = new p("call-incoming", { fontCharacter: "\\eb92" });
  p.callOutgoing = new p("call-outgoing", { fontCharacter: "\\eb93" });
  p.menu = new p("menu", { fontCharacter: "\\eb94" });
  p.expandAll = new p("expand-all", { fontCharacter: "\\eb95" });
  p.feedback = new p("feedback", { fontCharacter: "\\eb96" });
  p.groupByRefType = new p("group-by-ref-type", { fontCharacter: "\\eb97" });
  p.ungroupByRefType = new p("ungroup-by-ref-type", { fontCharacter: "\\eb98" });
  p.account = new p("account", { fontCharacter: "\\eb99" });
  p.bellDot = new p("bell-dot", { fontCharacter: "\\eb9a" });
  p.debugConsole = new p("debug-console", { fontCharacter: "\\eb9b" });
  p.library = new p("library", { fontCharacter: "\\eb9c" });
  p.output = new p("output", { fontCharacter: "\\eb9d" });
  p.runAll = new p("run-all", { fontCharacter: "\\eb9e" });
  p.syncIgnored = new p("sync-ignored", { fontCharacter: "\\eb9f" });
  p.pinned = new p("pinned", { fontCharacter: "\\eba0" });
  p.githubInverted = new p("github-inverted", { fontCharacter: "\\eba1" });
  p.debugAlt = new p("debug-alt", { fontCharacter: "\\eb91" });
  p.serverProcess = new p("server-process", { fontCharacter: "\\eba2" });
  p.serverEnvironment = new p("server-environment", { fontCharacter: "\\eba3" });
  p.pass = new p("pass", { fontCharacter: "\\eba4" });
  p.stopCircle = new p("stop-circle", { fontCharacter: "\\eba5" });
  p.playCircle = new p("play-circle", { fontCharacter: "\\eba6" });
  p.record = new p("record", { fontCharacter: "\\eba7" });
  p.debugAltSmall = new p("debug-alt-small", { fontCharacter: "\\eba8" });
  p.vmConnect = new p("vm-connect", { fontCharacter: "\\eba9" });
  p.cloud = new p("cloud", { fontCharacter: "\\ebaa" });
  p.merge = new p("merge", { fontCharacter: "\\ebab" });
  p.exportIcon = new p("export", { fontCharacter: "\\ebac" });
  p.graphLeft = new p("graph-left", { fontCharacter: "\\ebad" });
  p.magnet = new p("magnet", { fontCharacter: "\\ebae" });
  p.notebook = new p("notebook", { fontCharacter: "\\ebaf" });
  p.redo = new p("redo", { fontCharacter: "\\ebb0" });
  p.checkAll = new p("check-all", { fontCharacter: "\\ebb1" });
  p.pinnedDirty = new p("pinned-dirty", { fontCharacter: "\\ebb2" });
  p.passFilled = new p("pass-filled", { fontCharacter: "\\ebb3" });
  p.circleLargeFilled = new p("circle-large-filled", { fontCharacter: "\\ebb4" });
  p.circleLargeOutline = new p("circle-large-outline", { fontCharacter: "\\ebb5" });
  p.combine = new p("combine", { fontCharacter: "\\ebb6" });
  p.gather = new p("gather", { fontCharacter: "\\ebb6" });
  p.table = new p("table", { fontCharacter: "\\ebb7" });
  p.variableGroup = new p("variable-group", { fontCharacter: "\\ebb8" });
  p.typeHierarchy = new p("type-hierarchy", { fontCharacter: "\\ebb9" });
  p.typeHierarchySub = new p("type-hierarchy-sub", { fontCharacter: "\\ebba" });
  p.typeHierarchySuper = new p("type-hierarchy-super", { fontCharacter: "\\ebbb" });
  p.gitPullRequestCreate = new p("git-pull-request-create", { fontCharacter: "\\ebbc" });
  p.runAbove = new p("run-above", { fontCharacter: "\\ebbd" });
  p.runBelow = new p("run-below", { fontCharacter: "\\ebbe" });
  p.notebookTemplate = new p("notebook-template", { fontCharacter: "\\ebbf" });
  p.debugRerun = new p("debug-rerun", { fontCharacter: "\\ebc0" });
  p.workspaceTrusted = new p("workspace-trusted", { fontCharacter: "\\ebc1" });
  p.workspaceUntrusted = new p("workspace-untrusted", { fontCharacter: "\\ebc2" });
  p.workspaceUnspecified = new p("workspace-unspecified", { fontCharacter: "\\ebc3" });
  p.terminalCmd = new p("terminal-cmd", { fontCharacter: "\\ebc4" });
  p.terminalDebian = new p("terminal-debian", { fontCharacter: "\\ebc5" });
  p.terminalLinux = new p("terminal-linux", { fontCharacter: "\\ebc6" });
  p.terminalPowershell = new p("terminal-powershell", { fontCharacter: "\\ebc7" });
  p.terminalTmux = new p("terminal-tmux", { fontCharacter: "\\ebc8" });
  p.terminalUbuntu = new p("terminal-ubuntu", { fontCharacter: "\\ebc9" });
  p.terminalBash = new p("terminal-bash", { fontCharacter: "\\ebca" });
  p.arrowSwap = new p("arrow-swap", { fontCharacter: "\\ebcb" });
  p.copy = new p("copy", { fontCharacter: "\\ebcc" });
  p.personAdd = new p("person-add", { fontCharacter: "\\ebcd" });
  p.filterFilled = new p("filter-filled", { fontCharacter: "\\ebce" });
  p.wand = new p("wand", { fontCharacter: "\\ebcf" });
  p.debugLineByLine = new p("debug-line-by-line", { fontCharacter: "\\ebd0" });
  p.inspect = new p("inspect", { fontCharacter: "\\ebd1" });
  p.layers = new p("layers", { fontCharacter: "\\ebd2" });
  p.layersDot = new p("layers-dot", { fontCharacter: "\\ebd3" });
  p.layersActive = new p("layers-active", { fontCharacter: "\\ebd4" });
  p.compass = new p("compass", { fontCharacter: "\\ebd5" });
  p.compassDot = new p("compass-dot", { fontCharacter: "\\ebd6" });
  p.compassActive = new p("compass-active", { fontCharacter: "\\ebd7" });
  p.azure = new p("azure", { fontCharacter: "\\ebd8" });
  p.issueDraft = new p("issue-draft", { fontCharacter: "\\ebd9" });
  p.gitPullRequestClosed = new p("git-pull-request-closed", { fontCharacter: "\\ebda" });
  p.gitPullRequestDraft = new p("git-pull-request-draft", { fontCharacter: "\\ebdb" });
  p.debugAll = new p("debug-all", { fontCharacter: "\\ebdc" });
  p.debugCoverage = new p("debug-coverage", { fontCharacter: "\\ebdd" });
  p.runErrors = new p("run-errors", { fontCharacter: "\\ebde" });
  p.folderLibrary = new p("folder-library", { fontCharacter: "\\ebdf" });
  p.debugContinueSmall = new p("debug-continue-small", { fontCharacter: "\\ebe0" });
  p.beakerStop = new p("beaker-stop", { fontCharacter: "\\ebe1" });
  p.graphLine = new p("graph-line", { fontCharacter: "\\ebe2" });
  p.graphScatter = new p("graph-scatter", { fontCharacter: "\\ebe3" });
  p.pieChart = new p("pie-chart", { fontCharacter: "\\ebe4" });
  p.bracket = new p("bracket", p.json.definition);
  p.bracketDot = new p("bracket-dot", { fontCharacter: "\\ebe5" });
  p.bracketError = new p("bracket-error", { fontCharacter: "\\ebe6" });
  p.lockSmall = new p("lock-small", { fontCharacter: "\\ebe7" });
  p.azureDevops = new p("azure-devops", { fontCharacter: "\\ebe8" });
  p.verifiedFilled = new p("verified-filled", { fontCharacter: "\\ebe9" });
  p.newLine = new p("newline", { fontCharacter: "\\ebea" });
  p.layout = new p("layout", { fontCharacter: "\\ebeb" });
  p.layoutActivitybarLeft = new p("layout-activitybar-left", { fontCharacter: "\\ebec" });
  p.layoutActivitybarRight = new p("layout-activitybar-right", { fontCharacter: "\\ebed" });
  p.layoutPanelLeft = new p("layout-panel-left", { fontCharacter: "\\ebee" });
  p.layoutPanelCenter = new p("layout-panel-center", { fontCharacter: "\\ebef" });
  p.layoutPanelJustify = new p("layout-panel-justify", { fontCharacter: "\\ebf0" });
  p.layoutPanelRight = new p("layout-panel-right", { fontCharacter: "\\ebf1" });
  p.layoutPanel = new p("layout-panel", { fontCharacter: "\\ebf2" });
  p.layoutSidebarLeft = new p("layout-sidebar-left", { fontCharacter: "\\ebf3" });
  p.layoutSidebarRight = new p("layout-sidebar-right", { fontCharacter: "\\ebf4" });
  p.layoutStatusbar = new p("layout-statusbar", { fontCharacter: "\\ebf5" });
  p.layoutMenubar = new p("layout-menubar", { fontCharacter: "\\ebf6" });
  p.layoutCentered = new p("layout-centered", { fontCharacter: "\\ebf7" });
  p.target = new p("target", { fontCharacter: "\\ebf8" });
  p.indent = new p("indent", { fontCharacter: "\\ebf9" });
  p.recordSmall = new p("record-small", { fontCharacter: "\\ebfa" });
  p.errorSmall = new p("error-small", { fontCharacter: "\\ebfb" });
  p.arrowCircleDown = new p("arrow-circle-down", { fontCharacter: "\\ebfc" });
  p.arrowCircleLeft = new p("arrow-circle-left", { fontCharacter: "\\ebfd" });
  p.arrowCircleRight = new p("arrow-circle-right", { fontCharacter: "\\ebfe" });
  p.arrowCircleUp = new p("arrow-circle-up", { fontCharacter: "\\ebff" });
  p.dialogError = new p("dialog-error", p.error.definition);
  p.dialogWarning = new p("dialog-warning", p.warning.definition);
  p.dialogInfo = new p("dialog-info", p.info.definition);
  p.dialogClose = new p("dialog-close", p.close.definition);
  p.treeItemExpanded = new p("tree-item-expanded", p.chevronDown.definition);
  p.treeFilterOnTypeOn = new p("tree-filter-on-type-on", p.listFilter.definition);
  p.treeFilterOnTypeOff = new p("tree-filter-on-type-off", p.listSelection.definition);
  p.treeFilterClear = new p("tree-filter-clear", p.close.definition);
  p.treeItemLoading = new p("tree-item-loading", p.loading.definition);
  p.menuSelection = new p("menu-selection", p.check.definition);
  p.menuSubmenu = new p("menu-submenu", p.chevronRight.definition);
  p.menuBarMore = new p("menubar-more", p.more.definition);
  p.scrollbarButtonLeft = new p("scrollbar-button-left", p.triangleLeft.definition);
  p.scrollbarButtonRight = new p("scrollbar-button-right", p.triangleRight.definition);
  p.scrollbarButtonUp = new p("scrollbar-button-up", p.triangleUp.definition);
  p.scrollbarButtonDown = new p("scrollbar-button-down", p.triangleDown.definition);
  p.toolBarMore = new p("toolbar-more", p.more.definition);
  p.quickInputBack = new p("quick-input-back", p.arrowLeft.definition);
  var Un;
  (function(s) {
    s.iconNameSegment = "[A-Za-z0-9]+", s.iconNameExpression = "[A-Za-z0-9-]+", s.iconModifierExpression = "~[A-Za-z]+", s.iconNameCharacter = "[A-Za-z0-9~-]";
    const e = new RegExp(`^(${s.iconNameExpression})(${s.iconModifierExpression})?$`);
    function t(o) {
      if (o instanceof p)
        return ["codicon", "codicon-" + o.id];
      const r = e.exec(o.id);
      if (!r)
        return t(p.error);
      let [, a, l] = r;
      const c = ["codicon", "codicon-" + a];
      return l && c.push("codicon-modifier-" + l.substr(1)), c;
    }
    s.asClassNameArray = t;
    function i(o) {
      return t(o).join(" ");
    }
    s.asClassName = i;
    function n(o) {
      return "." + t(o).join(".");
    }
    s.asCSSSelector = n;
  })(Un || (Un = {}));
  const wi = st("commandService"), lt = new class {
    constructor() {
      this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new B(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
    }
    registerCommand(s, e) {
      if (!s)
        throw new Error("invalid command");
      if (typeof s == "string") {
        if (!e)
          throw new Error("invalid command");
        return this.registerCommand({ id: s, handler: e });
      }
      if (s.description) {
        const r = [];
        for (let l of s.description.args)
          r.push(l.constraint);
        const a = s.handler;
        s.handler = function(l, ...c) {
          return FB(c, r), a(l, ...c);
        };
      }
      const { id: t } = s;
      let i = this._commands.get(t);
      i || (i = new $s(), this._commands.set(t, i));
      let n = i.unshift(s), o = qe(() => {
        n();
        const r = this._commands.get(t);
        r?.isEmpty() && this._commands.delete(t);
      });
      return this._onDidRegisterCommand.fire(t), o;
    }
    registerCommandAlias(s, e) {
      return lt.registerCommand(s, (t, ...i) => t.get(wi).executeCommand(e, ...i));
    }
    getCommand(s) {
      const e = this._commands.get(s);
      if (!(!e || e.isEmpty()))
        return rt.first(e);
    }
    getCommands() {
      const s = /* @__PURE__ */ new Map();
      for (const e of this._commands.keys()) {
        const t = this.getCommand(e);
        t && s.set(e, t);
      }
      return s;
    }
  }();
  lt.registerCommand("noop", () => {
  });
  class zW {
    constructor(e) {
      this.computeFn = e, this.lastCache = void 0, this.lastArgKey = void 0;
    }
    get(e) {
      const t = JSON.stringify(e);
      return this.lastArgKey !== t && (this.lastArgKey = t, this.lastCache = this.computeFn(e)), this.lastCache;
    }
  }
  class mf {
    constructor(e) {
      this.executor = e, this._didRun = !1;
    }
    getValue() {
      if (!this._didRun)
        try {
          this._value = this.executor();
        } catch (e) {
          this._error = e;
        } finally {
          this._didRun = !0;
        }
      if (this._error)
        throw this._error;
      return this._value;
    }
    get rawValue() {
      return this._value;
    }
  }
  var SP;
  function yP(s) {
    return !s || typeof s != "string" ? !0 : s.trim().length === 0;
  }
  const UW = /{(\d+)}/g;
  function uo(s, ...e) {
    return e.length === 0 ? s : s.replace(UW, function(t, i) {
      const n = parseInt(i, 10);
      return isNaN(n) || n < 0 || n >= e.length ? t : e[n];
    });
  }
  function II(s) {
    return s.replace(/[<>&]/g, function(e) {
      switch (e) {
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "&":
          return "&amp;";
        default:
          return e;
      }
    });
  }
  function wo(s) {
    return s.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function $W(s, e = " ") {
    const t = EI(s, e);
    return LP(t, e);
  }
  function EI(s, e) {
    if (!s || !e)
      return s;
    const t = e.length;
    if (t === 0 || s.length === 0)
      return s;
    let i = 0;
    for (; s.indexOf(e, i) === i; )
      i = i + t;
    return s.substring(i);
  }
  function LP(s, e) {
    if (!s || !e)
      return s;
    const t = e.length, i = s.length;
    if (t === 0 || i === 0)
      return s;
    let n = i, o = -1;
    for (; o = s.lastIndexOf(e, n - 1), !(o === -1 || o + t !== n); ) {
      if (o === 0)
        return "";
      n = o;
    }
    return s.substring(0, n);
  }
  function jW(s) {
    return s.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
  }
  function KW(s) {
    return s.replace(/\*/g, "");
  }
  function kP(s, e, t = {}) {
    if (!s)
      throw new Error("Cannot create regex from empty string");
    e || (s = wo(s)), t.wholeWord && (/\B/.test(s.charAt(0)) || (s = "\\b" + s), /\B/.test(s.charAt(s.length - 1)) || (s = s + "\\b"));
    let i = "";
    return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(s, i);
  }
  function qW(s) {
    return s.source === "^" || s.source === "^$" || s.source === "$" || s.source === "^\\s*$" ? !1 : !!(s.exec("") && s.lastIndex === 0);
  }
  function Tw(s) {
    return (s.global ? "g" : "") + (s.ignoreCase ? "i" : "") + (s.multiline ? "m" : "") + (s.unicode ? "u" : "");
  }
  function da(s) {
    return s.split(/\r\n|\r|\n/);
  }
  function jn(s) {
    for (let e = 0, t = s.length; e < t; e++) {
      const i = s.charCodeAt(e);
      if (i !== 32 && i !== 9)
        return e;
    }
    return -1;
  }
  function Dt(s, e = 0, t = s.length) {
    for (let i = e; i < t; i++) {
      const n = s.charCodeAt(i);
      if (n !== 32 && n !== 9)
        return s.substring(e, i);
    }
    return s.substring(e, t);
  }
  function ia(s, e = s.length - 1) {
    for (let t = e; t >= 0; t--) {
      const i = s.charCodeAt(t);
      if (i !== 32 && i !== 9)
        return t;
    }
    return -1;
  }
  function zm(s, e) {
    return s < e ? -1 : s > e ? 1 : 0;
  }
  function NI(s, e, t = 0, i = s.length, n = 0, o = e.length) {
    for (; t < i && n < o; t++, n++) {
      let l = s.charCodeAt(t), c = e.charCodeAt(n);
      if (l < c)
        return -1;
      if (l > c)
        return 1;
    }
    const r = i - t, a = o - n;
    return r < a ? -1 : r > a ? 1 : 0;
  }
  function eL(s, e) {
    return r_(s, e, 0, s.length, 0, e.length);
  }
  function r_(s, e, t = 0, i = s.length, n = 0, o = e.length) {
    for (; t < i && n < o; t++, n++) {
      let l = s.charCodeAt(t), c = e.charCodeAt(n);
      if (l === c)
        continue;
      if (l >= 128 || c >= 128)
        return NI(s.toLowerCase(), e.toLowerCase(), t, i, n, o);
      jl(l) && (l -= 32), jl(c) && (c -= 32);
      const d = l - c;
      if (d !== 0)
        return d;
    }
    const r = i - t, a = o - n;
    return r < a ? -1 : r > a ? 1 : 0;
  }
  function jl(s) {
    return s >= 97 && s <= 122;
  }
  function Wr(s) {
    return s >= 65 && s <= 90;
  }
  function Su(s, e) {
    return s.length === e.length && r_(s, e) === 0;
  }
  function TI(s, e) {
    const t = e.length;
    return e.length > s.length ? !1 : r_(s, e, 0, t) === 0;
  }
  function pf(s, e) {
    let t, i = Math.min(s.length, e.length);
    for (t = 0; t < i; t++)
      if (s.charCodeAt(t) !== e.charCodeAt(t))
        return t;
    return i;
  }
  function K0(s, e) {
    let t, i = Math.min(s.length, e.length);
    const n = s.length - 1, o = e.length - 1;
    for (t = 0; t < i; t++)
      if (s.charCodeAt(n - t) !== e.charCodeAt(o - t))
        return t;
    return i;
  }
  function Pi(s) {
    return 55296 <= s && s <= 56319;
  }
  function Kd(s) {
    return 56320 <= s && s <= 57343;
  }
  function MI(s, e) {
    return (s - 55296 << 10) + (e - 56320) + 65536;
  }
  function q0(s, e, t) {
    const i = s.charCodeAt(t);
    if (Pi(i) && t + 1 < e) {
      const n = s.charCodeAt(t + 1);
      if (Kd(n))
        return MI(i, n);
    }
    return i;
  }
  function GW(s, e) {
    const t = s.charCodeAt(e - 1);
    if (Kd(t) && e > 1) {
      const i = s.charCodeAt(e - 2);
      if (Pi(i))
        return MI(i, t);
    }
    return t;
  }
  class AI {
    constructor(e, t = 0) {
      this._str = e, this._len = e.length, this._offset = t;
    }
    get offset() {
      return this._offset;
    }
    setOffset(e) {
      this._offset = e;
    }
    prevCodePoint() {
      const e = GW(this._str, this._offset);
      return this._offset -= e >= 65536 ? 2 : 1, e;
    }
    nextCodePoint() {
      const e = q0(this._str, this._len, this._offset);
      return this._offset += e >= 65536 ? 2 : 1, e;
    }
    eol() {
      return this._offset >= this._len;
    }
  }
  class G0 {
    constructor(e, t = 0) {
      this._iterator = new AI(e, t);
    }
    get offset() {
      return this._iterator.offset;
    }
    nextGraphemeLength() {
      const e = Kl.getInstance(), t = this._iterator, i = t.offset;
      let n = e.getGraphemeBreakType(t.nextCodePoint());
      for (; !t.eol(); ) {
        const o = t.offset, r = e.getGraphemeBreakType(t.nextCodePoint());
        if (W2(n, r)) {
          t.setOffset(o);
          break;
        }
        n = r;
      }
      return t.offset - i;
    }
    prevGraphemeLength() {
      const e = Kl.getInstance(), t = this._iterator, i = t.offset;
      let n = e.getGraphemeBreakType(t.prevCodePoint());
      for (; t.offset > 0; ) {
        const o = t.offset, r = e.getGraphemeBreakType(t.prevCodePoint());
        if (W2(r, n)) {
          t.setOffset(o);
          break;
        }
        n = r;
      }
      return i - t.offset;
    }
    eol() {
      return this._iterator.eol();
    }
  }
  function RI(s, e) {
    return new G0(s, e).nextGraphemeLength();
  }
  function DP(s, e) {
    return new G0(s, e).prevGraphemeLength();
  }
  function ZW(s, e) {
    e > 0 && Kd(s.charCodeAt(e)) && e--;
    const t = e + RI(s, e);
    return [t - DP(s, t), t];
  }
  const YW = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
  function Av(s) {
    return YW.test(s);
  }
  const XW = /^[\t\n\r\x20-\x7E]*$/;
  function Rv(s) {
    return XW.test(s);
  }
  const xP = /[\u2028\u2029]/;
  function IP(s) {
    return xP.test(s);
  }
  function _c(s) {
    return s >= 11904 && s <= 55215 || s >= 63744 && s <= 64255 || s >= 65281 && s <= 65374;
  }
  function OI(s) {
    return s >= 127462 && s <= 127487 || s === 8986 || s === 8987 || s === 9200 || s === 9203 || s >= 9728 && s <= 10175 || s === 11088 || s === 11093 || s >= 127744 && s <= 128591 || s >= 128640 && s <= 128764 || s >= 128992 && s <= 129008 || s >= 129280 && s <= 129535 || s >= 129648 && s <= 129782;
  }
  const QW = String.fromCharCode(65279);
  function PI(s) {
    return !!(s && s.length > 0 && s.charCodeAt(0) === 65279);
  }
  function JW(s, e = !1) {
    return s ? (e && (s = s.replace(/\\./g, "")), s.toLowerCase() !== s) : !1;
  }
  function EP(s) {
    return s = s % (2 * 26), s < 26 ? String.fromCharCode(97 + s) : String.fromCharCode(65 + s - 26);
  }
  function W2(s, e) {
    return s === 0 ? e !== 5 && e !== 7 : s === 2 && e === 3 ? !1 : s === 4 || s === 2 || s === 3 || e === 4 || e === 2 || e === 3 ? !0 : !(s === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (s === 11 || s === 9) && (e === 9 || e === 10) || (s === 12 || s === 10) && e === 10 || e === 5 || e === 13 || e === 7 || s === 1 || s === 13 && e === 14 || s === 6 && e === 6);
  }
  class Kl {
    constructor() {
      this._data = eV();
    }
    static getInstance() {
      return Kl._INSTANCE || (Kl._INSTANCE = new Kl()), Kl._INSTANCE;
    }
    getGraphemeBreakType(e) {
      if (e < 32)
        return e === 10 ? 3 : e === 13 ? 2 : 4;
      if (e < 127)
        return 0;
      const t = this._data, i = t.length / 3;
      let n = 1;
      for (; n <= i; )
        if (e < t[3 * n])
          n = 2 * n;
        else if (e > t[3 * n + 1])
          n = 2 * n + 1;
        else
          return t[3 * n + 2];
      return 0;
    }
  }
  Kl._INSTANCE = null;
  function eV() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  function tV(s, e) {
    if (s === 0)
      return 0;
    const t = iV(s, e);
    if (t !== void 0)
      return t;
    const i = new AI(e, s);
    return i.prevCodePoint(), i.offset;
  }
  function iV(s, e) {
    const t = new AI(e, s);
    let i = t.prevCodePoint();
    for (; nV(i) || i === 65039 || i === 8419; ) {
      if (t.offset === 0)
        return;
      i = t.prevCodePoint();
    }
    if (!OI(i))
      return;
    let n = t.offset;
    return n > 0 && t.prevCodePoint() === 8205 && (n = t.offset), n;
  }
  function nV(s) {
    return 127995 <= s && s <= 127999;
  }
  const sV = "\xA0";
  class Yo {
    constructor(e) {
      this.confusableDictionary = e;
    }
    static getInstance(e) {
      return Yo.cache.get(Array.from(e));
    }
    static getLocales() {
      return Yo._locales.getValue();
    }
    isAmbiguous(e) {
      return this.confusableDictionary.has(e);
    }
    getPrimaryConfusable(e) {
      return this.confusableDictionary.get(e);
    }
    getConfusableCodePoints() {
      return new Set(this.confusableDictionary.keys());
    }
  }
  SP = Yo;
  Yo.ambiguousCharacterData = new mf(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}'));
  Yo.cache = new zW((s) => {
    function e(c) {
      const d = /* @__PURE__ */ new Map();
      for (let h = 0; h < c.length; h += 2)
        d.set(c[h], c[h + 1]);
      return d;
    }
    function t(c, d) {
      const h = new Map(c);
      for (const [u, f] of d)
        h.set(u, f);
      return h;
    }
    function i(c, d) {
      if (!c)
        return d;
      const h = /* @__PURE__ */ new Map();
      for (const [u, f] of c)
        d.has(u) && h.set(u, f);
      return h;
    }
    const n = SP.ambiguousCharacterData.getValue();
    let o = s.filter((c) => !c.startsWith("_") && c in n);
    o.length === 0 && (o = ["_default"]);
    let r;
    for (const c of o) {
      const d = e(n[c]);
      r = i(r, d);
    }
    const a = e(n._common), l = t(a, r);
    return new Yo(l);
  });
  Yo._locales = new mf(() => Object.keys(Yo.ambiguousCharacterData.getValue()).filter((s) => !s.startsWith("_")));
  class na {
    static getRawData() {
      return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
    }
    static getData() {
      return this._data || (this._data = new Set(na.getRawData())), this._data;
    }
    static isInvisibleCharacter(e) {
      return na.getData().has(e);
    }
    static get codePoints() {
      return na.getData();
    }
  }
  na._data = void 0;
  const Tn = /* @__PURE__ */ new Map();
  Tn.set("false", !1);
  Tn.set("true", !0);
  Tn.set("isMac", Ye);
  Tn.set("isLinux", Nn);
  Tn.set("isWindows", rn);
  Tn.set("isWeb", Pc);
  Tn.set("isMacNative", Ye && !Pc);
  Tn.set("isEdge", xB);
  Tn.set("isFirefox", kB);
  Tn.set("isChrome", G4);
  Tn.set("isSafari", DB);
  const oV = Object.prototype.hasOwnProperty;
  class ce {
    static has(e) {
      return bc.create(e);
    }
    static equals(e, t) {
      return _f.create(e, t);
    }
    static regex(e, t) {
      return Z0.create(e, t);
    }
    static not(e) {
      return qd.create(e);
    }
    static and(...e) {
      return ql.create(e, null);
    }
    static or(...e) {
      return tl.create(e, null, !0);
    }
    static deserialize(e, t = !1) {
      if (!!e)
        return this._deserializeOrExpression(e, t);
    }
    static _deserializeOrExpression(e, t) {
      let i = e.split("||");
      return tl.create(i.map((n) => this._deserializeAndExpression(n, t)), null, !0);
    }
    static _deserializeAndExpression(e, t) {
      let i = e.split("&&");
      return ql.create(i.map((n) => this._deserializeOne(n, t)), null);
    }
    static _deserializeOne(e, t) {
      if (e = e.trim(), e.indexOf("!=") >= 0) {
        let i = e.split("!=");
        return Ov.create(i[0].trim(), this._deserializeValue(i[1], t));
      }
      if (e.indexOf("==") >= 0) {
        let i = e.split("==");
        return _f.create(i[0].trim(), this._deserializeValue(i[1], t));
      }
      if (e.indexOf("=~") >= 0) {
        let i = e.split("=~");
        return Z0.create(i[0].trim(), this._deserializeRegexValue(i[1], t));
      }
      if (e.indexOf(" in ") >= 0) {
        let i = e.split(" in ");
        return FI.create(i[0].trim(), i[1].trim());
      }
      if (/^[^<=>]+>=[^<=>]+$/.test(e)) {
        const i = e.split(">=");
        return Bv.create(i[0].trim(), i[1].trim());
      }
      if (/^[^<=>]+>[^<=>]+$/.test(e)) {
        const i = e.split(">");
        return Fv.create(i[0].trim(), i[1].trim());
      }
      if (/^[^<=>]+<=[^<=>]+$/.test(e)) {
        const i = e.split("<=");
        return Vv.create(i[0].trim(), i[1].trim());
      }
      if (/^[^<=>]+<[^<=>]+$/.test(e)) {
        const i = e.split("<");
        return Wv.create(i[0].trim(), i[1].trim());
      }
      return /^\!\s*/.test(e) ? qd.create(e.substr(1).trim()) : bc.create(e);
    }
    static _deserializeValue(e, t) {
      if (e = e.trim(), e === "true")
        return !0;
      if (e === "false")
        return !1;
      let i = /^'([^']*)'$/.exec(e);
      return i ? i[1].trim() : e;
    }
    static _deserializeRegexValue(e, t) {
      if (yP(e)) {
        if (t)
          throw new Error("missing regexp-value for =~-expression");
        return console.warn("missing regexp-value for =~-expression"), null;
      }
      let i = e.indexOf("/"), n = e.lastIndexOf("/");
      if (i === n || i < 0) {
        if (t)
          throw new Error(`bad regexp-value '${e}', missing /-enclosure`);
        return console.warn(`bad regexp-value '${e}', missing /-enclosure`), null;
      }
      let o = e.slice(i + 1, n), r = e[n + 1] === "i" ? "i" : "";
      try {
        return new RegExp(o, r);
      } catch (a) {
        if (t)
          throw new Error(`bad regexp-value '${e}', parse error: ${a}`);
        return console.warn(`bad regexp-value '${e}', parse error: ${a}`), null;
      }
    }
  }
  function rV(s, e) {
    const t = s ? s.substituteConstants() : void 0, i = e ? e.substituteConstants() : void 0;
    return !t && !i ? !0 : !t || !i ? !1 : t.equals(i);
  }
  function $u(s, e) {
    return s.cmp(e);
  }
  class Qs {
    constructor() {
      this.type = 0;
    }
    cmp(e) {
      return this.type - e.type;
    }
    equals(e) {
      return e.type === this.type;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !1;
    }
    serialize() {
      return "false";
    }
    keys() {
      return [];
    }
    negate() {
      return So.INSTANCE;
    }
  }
  Qs.INSTANCE = new Qs();
  class So {
    constructor() {
      this.type = 1;
    }
    cmp(e) {
      return this.type - e.type;
    }
    equals(e) {
      return e.type === this.type;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !0;
    }
    serialize() {
      return "true";
    }
    keys() {
      return [];
    }
    negate() {
      return Qs.INSTANCE;
    }
  }
  So.INSTANCE = new So();
  class bc {
    constructor(e, t) {
      this.key = e, this.negated = t, this.type = 2;
    }
    static create(e, t = null) {
      const i = Tn.get(e);
      return typeof i == "boolean" ? i ? So.INSTANCE : Qs.INSTANCE : new bc(e, t);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : TP(this.key, e.key);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key : !1;
    }
    substituteConstants() {
      const e = Tn.get(this.key);
      return typeof e == "boolean" ? e ? So.INSTANCE : Qs.INSTANCE : this;
    }
    evaluate(e) {
      return !!e.getValue(this.key);
    }
    serialize() {
      return this.key;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = qd.create(this.key, this)), this.negated;
    }
  }
  class _f {
    constructor(e, t, i) {
      this.key = e, this.value = t, this.negated = i, this.type = 4;
    }
    static create(e, t, i = null) {
      if (typeof t == "boolean")
        return t ? bc.create(e, i) : qd.create(e, i);
      const n = Tn.get(e);
      return typeof n == "boolean" ? t === (n ? "true" : "false") ? So.INSTANCE : Qs.INSTANCE : new _f(e, t, i);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ih(this.key, this.value, e.key, e.value);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
    }
    substituteConstants() {
      const e = Tn.get(this.key);
      if (typeof e == "boolean") {
        const t = e ? "true" : "false";
        return this.value === t ? So.INSTANCE : Qs.INSTANCE;
      }
      return this;
    }
    evaluate(e) {
      return e.getValue(this.key) == this.value;
    }
    serialize() {
      return `${this.key} == '${this.value}'`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = Ov.create(this.key, this.value, this)), this.negated;
    }
  }
  class FI {
    constructor(e, t) {
      this.key = e, this.valueKey = t, this.type = 10, this.negated = null;
    }
    static create(e, t) {
      return new FI(e, t);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ih(this.key, this.valueKey, e.key, e.valueKey);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      const t = e.getValue(this.valueKey), i = e.getValue(this.key);
      return Array.isArray(t) ? t.indexOf(i) >= 0 : typeof i == "string" && typeof t == "object" && t !== null ? oV.call(t, i) : !1;
    }
    serialize() {
      return `${this.key} in '${this.valueKey}'`;
    }
    keys() {
      return [this.key, this.valueKey];
    }
    negate() {
      return this.negated || (this.negated = BI.create(this)), this.negated;
    }
  }
  class BI {
    constructor(e) {
      this._actual = e, this.type = 11;
    }
    static create(e) {
      return new BI(e);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
    }
    equals(e) {
      return e.type === this.type ? this._actual.equals(e._actual) : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !this._actual.evaluate(e);
    }
    serialize() {
      throw new Error("Method not implemented.");
    }
    keys() {
      return this._actual.keys();
    }
    negate() {
      return this._actual;
    }
  }
  class Ov {
    constructor(e, t, i) {
      this.key = e, this.value = t, this.negated = i, this.type = 5;
    }
    static create(e, t, i = null) {
      if (typeof t == "boolean")
        return t ? qd.create(e, i) : bc.create(e, i);
      const n = Tn.get(e);
      return typeof n == "boolean" ? t === (n ? "true" : "false") ? Qs.INSTANCE : So.INSTANCE : new Ov(e, t, i);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ih(this.key, this.value, e.key, e.value);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
    }
    substituteConstants() {
      const e = Tn.get(this.key);
      if (typeof e == "boolean") {
        const t = e ? "true" : "false";
        return this.value === t ? Qs.INSTANCE : So.INSTANCE;
      }
      return this;
    }
    evaluate(e) {
      return e.getValue(this.key) != this.value;
    }
    serialize() {
      return `${this.key} != '${this.value}'`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = _f.create(this.key, this.value, this)), this.negated;
    }
  }
  class qd {
    constructor(e, t) {
      this.key = e, this.negated = t, this.type = 3;
    }
    static create(e, t = null) {
      const i = Tn.get(e);
      return typeof i == "boolean" ? i ? Qs.INSTANCE : So.INSTANCE : new qd(e, t);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : TP(this.key, e.key);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key : !1;
    }
    substituteConstants() {
      const e = Tn.get(this.key);
      return typeof e == "boolean" ? e ? Qs.INSTANCE : So.INSTANCE : this;
    }
    evaluate(e) {
      return !e.getValue(this.key);
    }
    serialize() {
      return `!${this.key}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = bc.create(this.key, this)), this.negated;
    }
  }
  function Pv(s, e) {
    if (typeof s == "string") {
      const t = parseFloat(s);
      isNaN(t) || (s = t);
    }
    return typeof s == "string" || typeof s == "number" ? e(s) : Qs.INSTANCE;
  }
  class Fv {
    constructor(e, t, i) {
      this.key = e, this.value = t, this.negated = i, this.type = 12;
    }
    static create(e, t, i = null) {
      return Pv(t, (n) => new Fv(e, n, i));
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ih(this.key, this.value, e.key, e.value);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value;
    }
    serialize() {
      return `${this.key} > ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = Vv.create(this.key, this.value, this)), this.negated;
    }
  }
  class Bv {
    constructor(e, t, i) {
      this.key = e, this.value = t, this.negated = i, this.type = 13;
    }
    static create(e, t, i = null) {
      return Pv(t, (n) => new Bv(e, n, i));
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ih(this.key, this.value, e.key, e.value);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value;
    }
    serialize() {
      return `${this.key} >= ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = Wv.create(this.key, this.value, this)), this.negated;
    }
  }
  class Wv {
    constructor(e, t, i) {
      this.key = e, this.value = t, this.negated = i, this.type = 14;
    }
    static create(e, t, i = null) {
      return Pv(t, (n) => new Wv(e, n, i));
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ih(this.key, this.value, e.key, e.value);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value;
    }
    serialize() {
      return `${this.key} < ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = Bv.create(this.key, this.value, this)), this.negated;
    }
  }
  class Vv {
    constructor(e, t, i) {
      this.key = e, this.value = t, this.negated = i, this.type = 15;
    }
    static create(e, t, i = null) {
      return Pv(t, (n) => new Vv(e, n, i));
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ih(this.key, this.value, e.key, e.value);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value;
    }
    serialize() {
      return `${this.key} <= ${this.value}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = Fv.create(this.key, this.value, this)), this.negated;
    }
  }
  class Z0 {
    constructor(e, t) {
      this.key = e, this.regexp = t, this.type = 7, this.negated = null;
    }
    static create(e, t) {
      return new Z0(e, t);
    }
    cmp(e) {
      if (e.type !== this.type)
        return this.type - e.type;
      if (this.key < e.key)
        return -1;
      if (this.key > e.key)
        return 1;
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return t < i ? -1 : t > i ? 1 : 0;
    }
    equals(e) {
      if (e.type === this.type) {
        const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
        return this.key === e.key && t === i;
      }
      return !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      let t = e.getValue(this.key);
      return this.regexp ? this.regexp.test(t) : !1;
    }
    serialize() {
      const e = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? "i" : ""}` : "/invalid/";
      return `${this.key} =~ ${e}`;
    }
    keys() {
      return [this.key];
    }
    negate() {
      return this.negated || (this.negated = WI.create(this)), this.negated;
    }
  }
  class WI {
    constructor(e) {
      this._actual = e, this.type = 8;
    }
    static create(e) {
      return new WI(e);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
    }
    equals(e) {
      return e.type === this.type ? this._actual.equals(e._actual) : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !this._actual.evaluate(e);
    }
    serialize() {
      throw new Error("Method not implemented.");
    }
    keys() {
      return this._actual.keys();
    }
    negate() {
      return this._actual;
    }
  }
  function NP(s) {
    let e = null;
    for (let t = 0, i = s.length; t < i; t++) {
      const n = s[t].substituteConstants();
      if (s[t] !== n && e === null) {
        e = [];
        for (let o = 0; o < t; o++)
          e[o] = s[o];
      }
      e !== null && (e[t] = n);
    }
    return e === null ? s : e;
  }
  class ql {
    constructor(e, t) {
      this.expr = e, this.negated = t, this.type = 6;
    }
    static create(e, t) {
      return ql._normalizeArr(e, t);
    }
    cmp(e) {
      if (e.type !== this.type)
        return this.type - e.type;
      if (this.expr.length < e.expr.length)
        return -1;
      if (this.expr.length > e.expr.length)
        return 1;
      for (let t = 0, i = this.expr.length; t < i; t++) {
        const n = $u(this.expr[t], e.expr[t]);
        if (n !== 0)
          return n;
      }
      return 0;
    }
    equals(e) {
      if (e.type === this.type) {
        if (this.expr.length !== e.expr.length)
          return !1;
        for (let t = 0, i = this.expr.length; t < i; t++)
          if (!this.expr[t].equals(e.expr[t]))
            return !1;
        return !0;
      }
      return !1;
    }
    substituteConstants() {
      const e = NP(this.expr);
      return e === this.expr ? this : ql.create(e, this.negated);
    }
    evaluate(e) {
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].evaluate(e))
          return !1;
      return !0;
    }
    static _normalizeArr(e, t) {
      const i = [];
      let n = !1;
      for (const o of e)
        if (!!o) {
          if (o.type === 1) {
            n = !0;
            continue;
          }
          if (o.type === 0)
            return Qs.INSTANCE;
          if (o.type === 6) {
            i.push(...o.expr);
            continue;
          }
          i.push(o);
        }
      if (i.length === 0 && n)
        return So.INSTANCE;
      if (i.length !== 0) {
        if (i.length === 1)
          return i[0];
        i.sort($u);
        for (let o = 1; o < i.length; o++)
          i[o - 1].equals(i[o]) && (i.splice(o, 1), o--);
        if (i.length === 1)
          return i[0];
        for (; i.length > 1; ) {
          const o = i[i.length - 1];
          if (o.type !== 9)
            break;
          i.pop();
          const r = i.pop(), a = i.length === 0, l = tl.create(o.expr.map((c) => ql.create([c, r], null)), null, a);
          l && (i.push(l), i.sort($u));
        }
        return i.length === 1 ? i[0] : new ql(i, t);
      }
    }
    serialize() {
      return this.expr.map((e) => e.serialize()).join(" && ");
    }
    keys() {
      const e = [];
      for (let t of this.expr)
        e.push(...t.keys());
      return e;
    }
    negate() {
      if (!this.negated) {
        const e = [];
        for (let t of this.expr)
          e.push(t.negate());
        this.negated = tl.create(e, this, !0);
      }
      return this.negated;
    }
  }
  class tl {
    constructor(e, t) {
      this.expr = e, this.negated = t, this.type = 9;
    }
    static create(e, t, i) {
      return tl._normalizeArr(e, t, i);
    }
    cmp(e) {
      if (e.type !== this.type)
        return this.type - e.type;
      if (this.expr.length < e.expr.length)
        return -1;
      if (this.expr.length > e.expr.length)
        return 1;
      for (let t = 0, i = this.expr.length; t < i; t++) {
        const n = $u(this.expr[t], e.expr[t]);
        if (n !== 0)
          return n;
      }
      return 0;
    }
    equals(e) {
      if (e.type === this.type) {
        if (this.expr.length !== e.expr.length)
          return !1;
        for (let t = 0, i = this.expr.length; t < i; t++)
          if (!this.expr[t].equals(e.expr[t]))
            return !1;
        return !0;
      }
      return !1;
    }
    substituteConstants() {
      const e = NP(this.expr);
      return e === this.expr ? this : tl.create(e, this.negated, !1);
    }
    evaluate(e) {
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (this.expr[t].evaluate(e))
          return !0;
      return !1;
    }
    static _normalizeArr(e, t, i) {
      let n = [], o = !1;
      if (e) {
        for (let r = 0, a = e.length; r < a; r++) {
          const l = e[r];
          if (!!l) {
            if (l.type === 0) {
              o = !0;
              continue;
            }
            if (l.type === 1)
              return So.INSTANCE;
            if (l.type === 9) {
              n = n.concat(l.expr);
              continue;
            }
            n.push(l);
          }
        }
        if (n.length === 0 && o)
          return Qs.INSTANCE;
        n.sort($u);
      }
      if (n.length !== 0) {
        if (n.length === 1)
          return n[0];
        for (let r = 1; r < n.length; r++)
          n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
        if (n.length === 1)
          return n[0];
        if (i) {
          for (let r = 0; r < n.length; r++)
            for (let a = r + 1; a < n.length; a++)
              MP(n[r], n[a]) && (n.splice(a, 1), a--);
          if (n.length === 1)
            return n[0];
        }
        return new tl(n, t);
      }
    }
    serialize() {
      return this.expr.map((e) => e.serialize()).join(" || ");
    }
    keys() {
      const e = [];
      for (let t of this.expr)
        e.push(...t.keys());
      return e;
    }
    negate() {
      if (!this.negated) {
        let e = [];
        for (let t of this.expr)
          e.push(t.negate());
        for (; e.length > 1; ) {
          const t = e.shift(), i = e.shift(), n = [];
          for (const r of Y0(t))
            for (const a of Y0(i))
              n.push(ql.create([r, a], null));
          const o = e.length === 0;
          e.unshift(tl.create(n, null, o));
        }
        this.negated = e[0];
      }
      return this.negated;
    }
  }
  class ue extends bc {
    constructor(e, t, i) {
      super(e, null), this._defaultValue = t, typeof i == "object" ? ue._info.push(Object.assign(Object.assign({}, i), { key: e })) : i !== !0 && ue._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
    }
    static all() {
      return ue._info.values();
    }
    bindTo(e) {
      return e.createKey(this.key, this._defaultValue);
    }
    getValue(e) {
      return e.getContextKeyValue(this.key);
    }
    toNegated() {
      return this.negate();
    }
    isEqualTo(e) {
      return _f.create(this.key, e);
    }
  }
  ue._info = [];
  const Fe = st("contextKeyService"), aV = "setContext";
  function TP(s, e) {
    return s < e ? -1 : s > e ? 1 : 0;
  }
  function Ih(s, e, t, i) {
    return s < t ? -1 : s > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
  }
  function MP(s, e) {
    if (e.type === 6 && s.type !== 9 && s.type !== 6) {
      for (const n of e.expr)
        if (s.equals(n))
          return !0;
    }
    const t = s.negate(), i = Y0(t).concat(Y0(e));
    i.sort($u);
    for (let n = 0; n < i.length; n++) {
      const r = i[n].negate();
      for (let a = n + 1; a < i.length; a++) {
        const l = i[a];
        if (r.equals(l))
          return !0;
      }
    }
    return !1;
  }
  function Y0(s) {
    return s.type === 9 ? s.expr : [s];
  }
  function n0(s, e) {
    if (!s)
      throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
  }
  class lV {
    constructor() {
      this.data = /* @__PURE__ */ new Map();
    }
    add(e, t) {
      n0(vo(e)), n0(ls(t)), n0(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
    }
    as(e) {
      return this.data.get(e) || null;
    }
  }
  const Si = new lV();
  var jo;
  (function(s) {
    s.DARK = "dark", s.LIGHT = "light", s.HIGH_CONTRAST = "hc";
  })(jo || (jo = {}));
  const jt = st("themeService");
  var tL;
  (function(s) {
    function e(t) {
      return t && typeof t == "object" && typeof t.id == "string";
    }
    s.isThemeColor = e;
  })(tL || (tL = {}));
  function ai(s) {
    return { id: s };
  }
  var Tt;
  (function(s) {
    function e(c) {
      return c && typeof c == "object" && typeof c.id == "string" && (typeof c.color > "u" || tL.isThemeColor(c.color));
    }
    s.isThemeIcon = e;
    const t = new RegExp(`^\\$\\((${Un.iconNameExpression}(?:${Un.iconModifierExpression})?)\\)$`);
    function i(c) {
      const d = t.exec(c);
      if (!d)
        return;
      let [, h] = d;
      return { id: h };
    }
    s.fromString = i;
    function n(c) {
      return { id: c };
    }
    s.fromId = n;
    function o(c, d) {
      let h = c.id;
      const u = h.lastIndexOf("~");
      return u !== -1 && (h = h.substring(0, u)), d && (h = `${h}~${d}`), { id: h };
    }
    s.modify = o;
    function r(c) {
      const d = c.id.lastIndexOf("~");
      if (d !== -1)
        return c.id.substring(d + 1);
    }
    s.getModifier = r;
    function a(c, d) {
      var h, u;
      return c.id === d.id && ((h = c.color) === null || h === void 0 ? void 0 : h.id) === ((u = d.color) === null || u === void 0 ? void 0 : u.id);
    }
    s.isEqual = a;
    function l(c, d) {
      return { id: c.id, color: d ? ai(d) : void 0 };
    }
    s.asThemeIcon = l, s.asClassNameArray = Un.asClassNameArray, s.asClassName = Un.asClassName, s.asCSSSelector = Un.asCSSSelector;
  })(Tt || (Tt = {}));
  function X0(s) {
    switch (s) {
      case jo.DARK:
        return "vs-dark";
      case jo.HIGH_CONTRAST:
        return "hc-black";
      default:
        return "vs";
    }
  }
  const AP = {
    ThemingContribution: "base.contributions.theming"
  };
  class cV {
    constructor() {
      this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new B();
    }
    onColorThemeChange(e) {
      return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), qe(() => {
        const t = this.themingParticipants.indexOf(e);
        this.themingParticipants.splice(t, 1);
      });
    }
    getThemingParticipants() {
      return this.themingParticipants;
    }
  }
  let RP = new cV();
  Si.add(AP.ThemingContribution, RP);
  function Vt(s) {
    return RP.onColorThemeChange(s);
  }
  class dV extends z {
    constructor(e) {
      super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
    }
    onThemeChange(e) {
      this.theme = e, this.updateStyles();
    }
    updateStyles() {
    }
  }
  var hV = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, V2 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  function yu(s) {
    return s.command !== void 0;
  }
  class A {
    constructor(e) {
      this.id = A._idPool++, this._debugName = e;
    }
  }
  A._idPool = 0;
  A.CommandPalette = new A("CommandPalette");
  A.DebugBreakpointsContext = new A("DebugBreakpointsContext");
  A.DebugCallStackContext = new A("DebugCallStackContext");
  A.DebugConsoleContext = new A("DebugConsoleContext");
  A.DebugVariablesContext = new A("DebugVariablesContext");
  A.DebugWatchContext = new A("DebugWatchContext");
  A.DebugToolBar = new A("DebugToolBar");
  A.EditorContext = new A("EditorContext");
  A.SimpleEditorContext = new A("SimpleEditorContext");
  A.EditorContextCopy = new A("EditorContextCopy");
  A.EditorContextPeek = new A("EditorContextPeek");
  A.EditorTitle = new A("EditorTitle");
  A.EditorTitleRun = new A("EditorTitleRun");
  A.EditorTitleContext = new A("EditorTitleContext");
  A.EmptyEditorGroup = new A("EmptyEditorGroup");
  A.EmptyEditorGroupContext = new A("EmptyEditorGroupContext");
  A.ExplorerContext = new A("ExplorerContext");
  A.ExtensionContext = new A("ExtensionContext");
  A.GlobalActivity = new A("GlobalActivity");
  A.LayoutControlMenuSubmenu = new A("LayoutControlMenuSubmenu");
  A.LayoutControlMenu = new A("LayoutControlMenu");
  A.MenubarMainMenu = new A("MenubarMainMenu");
  A.MenubarAppearanceMenu = new A("MenubarAppearanceMenu");
  A.MenubarDebugMenu = new A("MenubarDebugMenu");
  A.MenubarEditMenu = new A("MenubarEditMenu");
  A.MenubarCopy = new A("MenubarCopy");
  A.MenubarFileMenu = new A("MenubarFileMenu");
  A.MenubarGoMenu = new A("MenubarGoMenu");
  A.MenubarHelpMenu = new A("MenubarHelpMenu");
  A.MenubarLayoutMenu = new A("MenubarLayoutMenu");
  A.MenubarNewBreakpointMenu = new A("MenubarNewBreakpointMenu");
  A.MenubarPanelAlignmentMenu = new A("MenubarPanelAlignmentMenu");
  A.MenubarPanelPositionMenu = new A("MenubarPanelPositionMenu");
  A.MenubarPreferencesMenu = new A("MenubarPreferencesMenu");
  A.MenubarRecentMenu = new A("MenubarRecentMenu");
  A.MenubarSelectionMenu = new A("MenubarSelectionMenu");
  A.MenubarSwitchEditorMenu = new A("MenubarSwitchEditorMenu");
  A.MenubarSwitchGroupMenu = new A("MenubarSwitchGroupMenu");
  A.MenubarTerminalMenu = new A("MenubarTerminalMenu");
  A.MenubarViewMenu = new A("MenubarViewMenu");
  A.MenubarHomeMenu = new A("MenubarHomeMenu");
  A.OpenEditorsContext = new A("OpenEditorsContext");
  A.ProblemsPanelContext = new A("ProblemsPanelContext");
  A.SCMChangeContext = new A("SCMChangeContext");
  A.SCMResourceContext = new A("SCMResourceContext");
  A.SCMResourceFolderContext = new A("SCMResourceFolderContext");
  A.SCMResourceGroupContext = new A("SCMResourceGroupContext");
  A.SCMSourceControl = new A("SCMSourceControl");
  A.SCMTitle = new A("SCMTitle");
  A.SearchContext = new A("SearchContext");
  A.StatusBarWindowIndicatorMenu = new A("StatusBarWindowIndicatorMenu");
  A.StatusBarRemoteIndicatorMenu = new A("StatusBarRemoteIndicatorMenu");
  A.TestItem = new A("TestItem");
  A.TestItemGutter = new A("TestItemGutter");
  A.TestPeekElement = new A("TestPeekElement");
  A.TestPeekTitle = new A("TestPeekTitle");
  A.TouchBarContext = new A("TouchBarContext");
  A.TitleBarContext = new A("TitleBarContext");
  A.TunnelContext = new A("TunnelContext");
  A.TunnelPrivacy = new A("TunnelPrivacy");
  A.TunnelProtocol = new A("TunnelProtocol");
  A.TunnelPortInline = new A("TunnelInline");
  A.TunnelTitle = new A("TunnelTitle");
  A.TunnelLocalAddressInline = new A("TunnelLocalAddressInline");
  A.TunnelOriginInline = new A("TunnelOriginInline");
  A.ViewItemContext = new A("ViewItemContext");
  A.ViewContainerTitle = new A("ViewContainerTitle");
  A.ViewContainerTitleContext = new A("ViewContainerTitleContext");
  A.ViewTitle = new A("ViewTitle");
  A.ViewTitleContext = new A("ViewTitleContext");
  A.CommentThreadTitle = new A("CommentThreadTitle");
  A.CommentThreadActions = new A("CommentThreadActions");
  A.CommentTitle = new A("CommentTitle");
  A.CommentActions = new A("CommentActions");
  A.InteractiveToolbar = new A("InteractiveToolbar");
  A.InteractiveCellTitle = new A("InteractiveCellTitle");
  A.InteractiveCellExecute = new A("InteractiveCellExecute");
  A.InteractiveInputExecute = new A("InteractiveInputExecute");
  A.NotebookToolbar = new A("NotebookToolbar");
  A.NotebookCellTitle = new A("NotebookCellTitle");
  A.NotebookCellInsert = new A("NotebookCellInsert");
  A.NotebookCellBetween = new A("NotebookCellBetween");
  A.NotebookCellListTop = new A("NotebookCellTop");
  A.NotebookCellExecute = new A("NotebookCellExecute");
  A.NotebookCellExecutePrimary = new A("NotebookCellExecutePrimary");
  A.NotebookDiffCellInputTitle = new A("NotebookDiffCellInputTitle");
  A.NotebookDiffCellMetadataTitle = new A("NotebookDiffCellMetadataTitle");
  A.NotebookDiffCellOutputsTitle = new A("NotebookDiffCellOutputsTitle");
  A.NotebookOutputToolbar = new A("NotebookOutputToolbar");
  A.NotebookEditorLayoutConfigure = new A("NotebookEditorLayoutConfigure");
  A.BulkEditTitle = new A("BulkEditTitle");
  A.BulkEditContext = new A("BulkEditContext");
  A.TimelineItemContext = new A("TimelineItemContext");
  A.TimelineTitle = new A("TimelineTitle");
  A.TimelineTitleContext = new A("TimelineTitleContext");
  A.AccountsContext = new A("AccountsContext");
  A.PanelTitle = new A("PanelTitle");
  A.AuxiliaryBarTitle = new A("AuxiliaryBarTitle");
  A.TerminalInstanceContext = new A("TerminalInstanceContext");
  A.TerminalEditorInstanceContext = new A("TerminalEditorInstanceContext");
  A.TerminalNewDropdownContext = new A("TerminalNewDropdownContext");
  A.TerminalTabContext = new A("TerminalTabContext");
  A.TerminalTabEmptyAreaContext = new A("TerminalTabEmptyAreaContext");
  A.TerminalInlineTabContext = new A("TerminalInlineTabContext");
  A.WebviewContext = new A("WebviewContext");
  A.InlineCompletionsActions = new A("InlineCompletionsActions");
  A.NewFile = new A("NewFile");
  const Eh = st("menuService"), qs = new class {
    constructor() {
      this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new B(), this.onDidChangeMenu = this._onDidChangeMenu.event, this._commandPaletteChangeEvent = {
        has: (s) => s === A.CommandPalette
      };
    }
    addCommand(s) {
      return this.addCommands(rt.single(s));
    }
    addCommands(s) {
      for (const e of s)
        this._commands.set(e.id, e);
      return this._onDidChangeMenu.fire(this._commandPaletteChangeEvent), qe(() => {
        let e = !1;
        for (const t of s)
          e = this._commands.delete(t.id) || e;
        e && this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
      });
    }
    getCommand(s) {
      return this._commands.get(s);
    }
    getCommands() {
      const s = /* @__PURE__ */ new Map();
      return this._commands.forEach((e, t) => s.set(t, e)), s;
    }
    appendMenuItem(s, e) {
      return this.appendMenuItems(rt.single({ id: s, item: e }));
    }
    appendMenuItems(s) {
      const e = /* @__PURE__ */ new Set(), t = new $s();
      for (const { id: i, item: n } of s) {
        let o = this._menuItems.get(i);
        o || (o = new $s(), this._menuItems.set(i, o)), t.push(o.push(n)), e.add(i);
      }
      return this._onDidChangeMenu.fire(e), qe(() => {
        if (t.size > 0) {
          for (let i of t)
            i();
          this._onDidChangeMenu.fire(e), t.clear();
        }
      });
    }
    getMenuItems(s) {
      let e;
      return this._menuItems.has(s) ? e = [...this._menuItems.get(s)] : e = [], s === A.CommandPalette && this._appendImplicitItems(e), e;
    }
    _appendImplicitItems(s) {
      const e = /* @__PURE__ */ new Set();
      for (const t of s)
        yu(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
      this._commands.forEach((t, i) => {
        e.has(i) || s.push({ command: t });
      });
    }
  }();
  class VI extends Tv {
    constructor(e, t, i, n) {
      super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, [], "submenu"), this.item = e, this._menuService = t, this._contextKeyService = i, this._options = n;
    }
    get actions() {
      const e = [], t = this._menuService.createMenu(this.item.submenu, this._contextKeyService), i = t.getActions(this._options);
      t.dispose();
      for (const [, n] of i)
        n.length > 0 && (e.push(...n), e.push(new mo()));
      return e.length && e.pop(), e;
    }
  }
  let vc = class OP {
    constructor(e, t, i, n, o) {
      var r, a;
      if (this._commandService = o, this.id = e.id, this.label = i?.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value, this.tooltip = (a = typeof e.tooltip == "string" ? e.tooltip : (r = e.tooltip) === null || r === void 0 ? void 0 : r.value) !== null && a !== void 0 ? a : "", this.enabled = !e.precondition || n.contextMatchesRules(e.precondition), this.checked = void 0, e.toggled) {
        const l = e.toggled.condition ? e.toggled : { condition: e.toggled };
        this.checked = n.contextMatchesRules(l.condition), this.checked && l.tooltip && (this.tooltip = typeof l.tooltip == "string" ? l.tooltip : l.tooltip.value), l.title && (this.label = typeof l.title == "string" ? l.title : l.title.value);
      }
      this.item = e, this.alt = t ? new OP(t, void 0, i, n, o) : void 0, this._options = i, Tt.isThemeIcon(e.icon) && (this.class = Un.asClassName(e.icon));
    }
    dispose() {
    }
    run(...e) {
      var t, i;
      let n = [];
      return !((t = this._options) === null || t === void 0) && t.arg && (n = [...n, this._options.arg]), !((i = this._options) === null || i === void 0) && i.shouldForwardArgs && (n = [...n, ...e]), this._commandService.executeCommand(this.id, ...n);
    }
  };
  vc = hV([
    V2(3, Fe),
    V2(4, wi)
  ], vc);
  class Q0 {
    constructor() {
      this._coreKeybindings = [], this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
    }
    static bindToCurrentPlatform(e) {
      if (oo === 1) {
        if (e && e.win)
          return e.win;
      } else if (oo === 2) {
        if (e && e.mac)
          return e.mac;
      } else if (e && e.linux)
        return e.linux;
      return e;
    }
    registerKeybindingRule(e) {
      const t = Q0.bindToCurrentPlatform(e);
      if (t && t.primary) {
        const i = Uy(t.primary, oo);
        i && this._registerDefaultKeybinding(i, e.id, e.args, e.weight, 0, e.when);
      }
      if (t && Array.isArray(t.secondary))
        for (let i = 0, n = t.secondary.length; i < n; i++) {
          const o = t.secondary[i], r = Uy(o, oo);
          r && this._registerDefaultKeybinding(r, e.id, e.args, e.weight, -i - 1, e.when);
        }
    }
    registerCommandAndKeybindingRule(e) {
      this.registerKeybindingRule(e), lt.registerCommand(e);
    }
    static _mightProduceChar(e) {
      return e >= 21 && e <= 30 || e >= 31 && e <= 56 ? !0 : e === 80 || e === 81 || e === 82 || e === 83 || e === 84 || e === 85 || e === 86 || e === 110 || e === 111 || e === 87 || e === 88 || e === 89 || e === 90 || e === 91 || e === 92;
    }
    _assertNoCtrlAlt(e, t) {
      e.ctrlKey && e.altKey && !e.metaKey && Q0._mightProduceChar(e.keyCode) && console.warn("Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ", e, " for ", t);
    }
    _registerDefaultKeybinding(e, t, i, n, o, r) {
      oo === 1 && this._assertNoCtrlAlt(e.parts[0], t), this._coreKeybindings.push({
        keybinding: e.parts,
        command: t,
        commandArgs: i,
        when: r,
        weight1: n,
        weight2: o,
        extensionId: null,
        isBuiltinExtension: !1
      }), this._cachedMergedKeybindings = null;
    }
    getDefaultKeybindings() {
      return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(fV)), this._cachedMergedKeybindings.slice(0);
    }
  }
  const Zn = new Q0(), uV = {
    EditorModes: "platform.keybindingsRegistry"
  };
  Si.add(uV.EditorModes, Zn);
  function fV(s, e) {
    return s.weight1 !== e.weight1 ? s.weight1 - e.weight1 : s.command < e.command ? -1 : s.command > e.command ? 1 : s.weight2 - e.weight2;
  }
  const Ca = st("telemetryService"), Xo = st("logService");
  var hr;
  (function(s) {
    s[s.Trace = 0] = "Trace", s[s.Debug = 1] = "Debug", s[s.Info = 2] = "Info", s[s.Warning = 3] = "Warning", s[s.Error = 4] = "Error", s[s.Critical = 5] = "Critical", s[s.Off = 6] = "Off";
  })(hr || (hr = {}));
  const PP = hr.Info;
  class gV extends z {
    constructor() {
      super(...arguments), this.level = PP, this._onDidChangeLogLevel = this._register(new B());
    }
    setLevel(e) {
      this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
    }
    getLevel() {
      return this.level;
    }
  }
  class mV extends gV {
    constructor(e = PP) {
      super(), this.setLevel(e);
    }
    trace(e, ...t) {
      this.getLevel() <= hr.Trace && console.log("%cTRACE", "color: #888", e, ...t);
    }
    debug(e, ...t) {
      this.getLevel() <= hr.Debug && console.log("%cDEBUG", "background: #eee; color: #888", e, ...t);
    }
    info(e, ...t) {
      this.getLevel() <= hr.Info && console.log("%c INFO", "color: #33f", e, ...t);
    }
    error(e, ...t) {
      this.getLevel() <= hr.Error && console.log("%c  ERR", "color: #f33", e, ...t);
    }
    dispose() {
    }
  }
  class pV extends z {
    constructor(e) {
      super(), this.logger = e, this._register(e);
    }
    getLevel() {
      return this.logger.getLevel();
    }
    trace(e, ...t) {
      this.logger.trace(e, ...t);
    }
    debug(e, ...t) {
      this.logger.debug(e, ...t);
    }
    info(e, ...t) {
      this.logger.info(e, ...t);
    }
    error(e, ...t) {
      this.logger.error(e, ...t);
    }
  }
  class Hv {
    constructor(e) {
      this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this._description = e.description;
    }
    register() {
      if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
        const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
        for (const t of e) {
          let i = t.kbExpr;
          this.precondition && (i ? i = ce.and(i, this.precondition) : i = this.precondition);
          const n = {
            id: this.id,
            weight: t.weight,
            args: t.args,
            when: i,
            primary: t.primary,
            secondary: t.secondary,
            win: t.win,
            linux: t.linux,
            mac: t.mac
          };
          Zn.registerKeybindingRule(n);
        }
      }
      lt.registerCommand({
        id: this.id,
        handler: (e, t) => this.runCommand(e, t),
        description: this._description
      });
    }
    _registerMenuItem(e) {
      qs.appendMenuItem(e.menuId, {
        group: e.group,
        command: {
          id: this.id,
          title: e.title,
          icon: e.icon,
          precondition: this.precondition
        },
        when: e.when,
        order: e.order
      });
    }
  }
  class Jf extends Hv {
    constructor() {
      super(...arguments), this._implementations = [];
    }
    addImplementation(e, t, i) {
      return this._implementations.push({ priority: e, name: t, implementation: i }), this._implementations.sort((n, o) => o.priority - n.priority), {
        dispose: () => {
          for (let n = 0; n < this._implementations.length; n++)
            if (this._implementations[n].implementation === i) {
              this._implementations.splice(n, 1);
              return;
            }
        }
      };
    }
    runCommand(e, t) {
      const i = e.get(Xo);
      i.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
      for (const n of this._implementations) {
        const o = n.implementation(e, t);
        if (o)
          return i.trace(`Command '${this.id}' was handled by '${n.name}'.`), typeof o == "boolean" ? void 0 : o;
      }
      i.trace(`The Command '${this.id}' was not handled by any implementation.`);
    }
  }
  class FP extends Hv {
    constructor(e, t) {
      super(t), this.command = e;
    }
    runCommand(e, t) {
      return this.command.runCommand(e, t);
    }
  }
  class wn extends Hv {
    static bindToContribution(e) {
      return class extends wn {
        constructor(i) {
          super(i), this._callback = i.handler;
        }
        runEditorCommand(i, n, o) {
          const r = e(n);
          r && this._callback(r, o);
        }
      };
    }
    runCommand(e, t) {
      const i = e.get(St), n = i.getFocusedCodeEditor() || i.getActiveCodeEditor();
      if (!!n)
        return n.invokeWithinContext((o) => {
          if (!!o.get(Fe).contextMatchesRules(ys(this.precondition)))
            return this.runEditorCommand(o, n, t);
        });
    }
  }
  class ge extends wn {
    constructor(e) {
      super(ge.convertOptions(e)), this.label = e.label, this.alias = e.alias;
    }
    static convertOptions(e) {
      let t;
      Array.isArray(e.menuOpts) ? t = e.menuOpts : e.menuOpts ? t = [e.menuOpts] : t = [];
      function i(n) {
        return n.menuId || (n.menuId = A.EditorContext), n.title || (n.title = e.label), n.when = ce.and(e.precondition, n.when), n;
      }
      return Array.isArray(e.contextMenuOpts) ? t.push(...e.contextMenuOpts.map(i)) : e.contextMenuOpts && t.push(i(e.contextMenuOpts)), e.menuOpts = t, e;
    }
    runEditorCommand(e, t, i) {
      return this.reportTelemetry(e, t), this.run(e, t, i || {});
    }
    reportTelemetry(e, t) {
      e.get(Ca).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
    }
  }
  class BP extends ge {
    constructor() {
      super(...arguments), this._implementations = [];
    }
    addImplementation(e, t) {
      return this._implementations.push([e, t]), this._implementations.sort((i, n) => n[0] - i[0]), {
        dispose: () => {
          for (let i = 0; i < this._implementations.length; i++)
            if (this._implementations[i][1] === t) {
              this._implementations.splice(i, 1);
              return;
            }
        }
      };
    }
    run(e, t, i) {
      for (const n of this._implementations) {
        const o = n[1](e, t, i);
        if (o)
          return typeof o == "boolean" ? void 0 : o;
      }
    }
  }
  function wa(s, e) {
    lt.registerCommand(s, function(t, ...i) {
      const n = t.get(et), [o, r] = i;
      Nt(Ee.isUri(o)), Nt(V.isIPosition(r));
      const a = t.get(Qt).getModel(o);
      if (a) {
        const l = V.lift(r);
        return n.invokeFunction(e, a, l, ...i.slice(2));
      }
      return t.get(fs).createModelReference(o).then((l) => new Promise((c, d) => {
        try {
          const h = n.invokeFunction(e, l.object.textEditorModel, V.lift(r), i.slice(2));
          c(h);
        } catch (h) {
          d(h);
        }
      }).finally(() => {
        l.dispose();
      }));
    });
  }
  function se(s) {
    return ro.INSTANCE.registerEditorCommand(s), s;
  }
  function oe(s) {
    const e = new s();
    return ro.INSTANCE.registerEditorAction(e), e;
  }
  function WP(s) {
    return ro.INSTANCE.registerEditorAction(s), s;
  }
  function VP(s) {
    ro.INSTANCE.registerEditorAction(s);
  }
  function vt(s, e) {
    ro.INSTANCE.registerEditorContribution(s, e);
  }
  var Dd;
  (function(s) {
    function e(r) {
      return ro.INSTANCE.getEditorCommand(r);
    }
    s.getEditorCommand = e;
    function t() {
      return ro.INSTANCE.getEditorActions();
    }
    s.getEditorActions = t;
    function i() {
      return ro.INSTANCE.getEditorContributions();
    }
    s.getEditorContributions = i;
    function n(r) {
      return ro.INSTANCE.getEditorContributions().filter((a) => r.indexOf(a.id) >= 0);
    }
    s.getSomeEditorContributions = n;
    function o() {
      return ro.INSTANCE.getDiffEditorContributions();
    }
    s.getDiffEditorContributions = o;
  })(Dd || (Dd = {}));
  const _V = {
    EditorCommonContributions: "editor.contributions"
  };
  class ro {
    constructor() {
      this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
    }
    registerEditorContribution(e, t) {
      this.editorContributions.push({ id: e, ctor: t });
    }
    getEditorContributions() {
      return this.editorContributions.slice(0);
    }
    getDiffEditorContributions() {
      return this.diffEditorContributions.slice(0);
    }
    registerEditorAction(e) {
      e.register(), this.editorActions.push(e);
    }
    getEditorActions() {
      return this.editorActions.slice(0);
    }
    registerEditorCommand(e) {
      e.register(), this.editorCommands[e.id] = e;
    }
    getEditorCommand(e) {
      return this.editorCommands[e] || null;
    }
  }
  ro.INSTANCE = new ro();
  Si.add(_V.EditorCommonContributions, ro.INSTANCE);
  function a_(s) {
    return s.register(), s;
  }
  const HP = a_(new Jf({
    id: "undo",
    precondition: void 0,
    kbOpts: {
      weight: 0,
      primary: 2104
    },
    menuOpts: [{
      menuId: A.MenubarEditMenu,
      group: "1_do",
      title: m({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
      order: 1
    }, {
      menuId: A.CommandPalette,
      group: "",
      title: m("undo", "Undo"),
      order: 1
    }]
  }));
  a_(new FP(HP, { id: "default:undo", precondition: void 0 }));
  const zP = a_(new Jf({
    id: "redo",
    precondition: void 0,
    kbOpts: {
      weight: 0,
      primary: 2103,
      secondary: [3128],
      mac: { primary: 3128 }
    },
    menuOpts: [{
      menuId: A.MenubarEditMenu,
      group: "1_do",
      title: m({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
      order: 2
    }, {
      menuId: A.CommandPalette,
      group: "",
      title: m("redo", "Redo"),
      order: 1
    }]
  }));
  a_(new FP(zP, { id: "default:redo", precondition: void 0 }));
  const bV = a_(new Jf({
    id: "editor.action.selectAll",
    precondition: void 0,
    kbOpts: {
      weight: 0,
      kbExpr: null,
      primary: 2079
    },
    menuOpts: [{
      menuId: A.MenubarSelectionMenu,
      group: "1_basic",
      title: m({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
      order: 1
    }, {
      menuId: A.CommandPalette,
      group: "",
      title: m("selectAll", "Select All"),
      order: 1
    }]
  }));
  class D {
    constructor(e, t, i, n) {
      e > i || e === i && t > n ? (this.startLineNumber = i, this.startColumn = n, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = n);
    }
    isEmpty() {
      return D.isEmpty(this);
    }
    static isEmpty(e) {
      return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
    }
    containsPosition(e) {
      return D.containsPosition(this, e);
    }
    static containsPosition(e, t) {
      return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
    }
    static strictContainsPosition(e, t) {
      return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column <= e.startColumn || t.lineNumber === e.endLineNumber && t.column >= e.endColumn);
    }
    containsRange(e) {
      return D.containsRange(this, e);
    }
    static containsRange(e, t) {
      return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
    }
    strictContainsRange(e) {
      return D.strictContainsRange(this, e);
    }
    static strictContainsRange(e, t) {
      return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
    }
    plusRange(e) {
      return D.plusRange(this, e);
    }
    static plusRange(e, t) {
      let i, n, o, r;
      return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, n = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, n = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, n = e.startColumn), t.endLineNumber > e.endLineNumber ? (o = t.endLineNumber, r = t.endColumn) : t.endLineNumber === e.endLineNumber ? (o = t.endLineNumber, r = Math.max(t.endColumn, e.endColumn)) : (o = e.endLineNumber, r = e.endColumn), new D(i, n, o, r);
    }
    intersectRanges(e) {
      return D.intersectRanges(this, e);
    }
    static intersectRanges(e, t) {
      let i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn, a = t.startLineNumber, l = t.startColumn, c = t.endLineNumber, d = t.endColumn;
      return i < a ? (i = a, n = l) : i === a && (n = Math.max(n, l)), o > c ? (o = c, r = d) : o === c && (r = Math.min(r, d)), i > o || i === o && n > r ? null : new D(i, n, o, r);
    }
    equalsRange(e) {
      return D.equalsRange(this, e);
    }
    static equalsRange(e, t) {
      return !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
    }
    getEndPosition() {
      return D.getEndPosition(this);
    }
    static getEndPosition(e) {
      return new V(e.endLineNumber, e.endColumn);
    }
    getStartPosition() {
      return D.getStartPosition(this);
    }
    static getStartPosition(e) {
      return new V(e.startLineNumber, e.startColumn);
    }
    toString() {
      return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
    }
    setEndPosition(e, t) {
      return new D(this.startLineNumber, this.startColumn, e, t);
    }
    setStartPosition(e, t) {
      return new D(e, t, this.endLineNumber, this.endColumn);
    }
    collapseToStart() {
      return D.collapseToStart(this);
    }
    static collapseToStart(e) {
      return new D(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
    }
    static fromPositions(e, t = e) {
      return new D(e.lineNumber, e.column, t.lineNumber, t.column);
    }
    static lift(e) {
      return e ? new D(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
    }
    static isIRange(e) {
      return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
    }
    static areIntersectingOrTouching(e, t) {
      return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
    }
    static areIntersecting(e, t) {
      return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
    }
    static compareRangesUsingStarts(e, t) {
      if (e && t) {
        const o = e.startLineNumber | 0, r = t.startLineNumber | 0;
        if (o === r) {
          const a = e.startColumn | 0, l = t.startColumn | 0;
          if (a === l) {
            const c = e.endLineNumber | 0, d = t.endLineNumber | 0;
            if (c === d) {
              const h = e.endColumn | 0, u = t.endColumn | 0;
              return h - u;
            }
            return c - d;
          }
          return a - l;
        }
        return o - r;
      }
      return (e ? 1 : 0) - (t ? 1 : 0);
    }
    static compareRangesUsingEnds(e, t) {
      return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
    }
    static spansMultipleLines(e) {
      return e.endLineNumber > e.startLineNumber;
    }
    toJSON() {
      return this;
    }
  }
  class ae extends D {
    constructor(e, t, i, n) {
      super(e, t, i, n), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = n;
    }
    toString() {
      return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
    }
    equalsSelection(e) {
      return ae.selectionsEqual(this, e);
    }
    static selectionsEqual(e, t) {
      return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
    }
    getDirection() {
      return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
    }
    setEndPosition(e, t) {
      return this.getDirection() === 0 ? new ae(this.startLineNumber, this.startColumn, e, t) : new ae(e, t, this.startLineNumber, this.startColumn);
    }
    getPosition() {
      return new V(this.positionLineNumber, this.positionColumn);
    }
    getSelectionStart() {
      return new V(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    setStartPosition(e, t) {
      return this.getDirection() === 0 ? new ae(e, t, this.endLineNumber, this.endColumn) : new ae(this.endLineNumber, this.endColumn, e, t);
    }
    static fromPositions(e, t = e) {
      return new ae(e.lineNumber, e.column, t.lineNumber, t.column);
    }
    static fromRange(e, t) {
      return t === 0 ? new ae(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new ae(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
    }
    static liftSelection(e) {
      return new ae(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    }
    static selectionsArrEqual(e, t) {
      if (e && !t || !e && t)
        return !1;
      if (!e && !t)
        return !0;
      if (e.length !== t.length)
        return !1;
      for (let i = 0, n = e.length; i < n; i++)
        if (!this.selectionsEqual(e[i], t[i]))
          return !1;
      return !0;
    }
    static isISelection(e) {
      return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
    }
    static createWithDirection(e, t, i, n, o) {
      return o === 0 ? new ae(e, t, i, n) : new ae(i, n, e, t);
    }
  }
  function J0(s, e) {
    const t = s.getCount(), i = s.findTokenIndexAtOffset(e), n = s.getLanguageId(i);
    let o = i;
    for (; o + 1 < t && s.getLanguageId(o + 1) === n; )
      o++;
    let r = i;
    for (; r > 0 && s.getLanguageId(r - 1) === n; )
      r--;
    return new vV(s, n, r, o + 1, s.getStartOffset(r), s.getEndOffset(o));
  }
  class vV {
    constructor(e, t, i, n, o, r) {
      this._scopedLineTokensBrand = void 0, this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = n, this.firstCharOffset = o, this._lastCharOffset = r;
    }
    getLineContent() {
      return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
    }
    getActualLineContentBefore(e) {
      return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
    }
    getTokenCount() {
      return this._lastTokenIndex - this._firstTokenIndex;
    }
    findTokenIndexAtOffset(e) {
      return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
    }
    getStandardTokenType(e) {
      return this._actual.getStandardTokenType(e + this._firstTokenIndex);
    }
  }
  function Mr(s) {
    return (s & 3) !== 0;
  }
  class Oi {
    static _nextVisibleColumn(e, t, i) {
      return e === 9 ? Oi.nextRenderTabStop(t, i) : _c(e) || OI(e) ? t + 2 : t + 1;
    }
    static visibleColumnFromColumn(e, t, i) {
      const n = Math.min(t - 1, e.length), o = e.substring(0, n), r = new G0(o);
      let a = 0;
      for (; !r.eol(); ) {
        const l = q0(o, n, r.offset);
        r.nextGraphemeLength(), a = this._nextVisibleColumn(l, a, i);
      }
      return a;
    }
    static columnFromVisibleColumn(e, t, i) {
      if (t <= 0)
        return 1;
      const n = e.length, o = new G0(e);
      let r = 0, a = 1;
      for (; !o.eol(); ) {
        const l = q0(e, n, o.offset);
        o.nextGraphemeLength();
        const c = this._nextVisibleColumn(l, r, i), d = o.offset + 1;
        if (c >= t) {
          const h = t - r;
          return c - t < h ? d : a;
        }
        r = c, a = d;
      }
      return n + 1;
    }
    static nextRenderTabStop(e, t) {
      return e + t - e % t;
    }
    static nextIndentTabStop(e, t) {
      return e + t - e % t;
    }
    static prevRenderTabStop(e, t) {
      return Math.max(0, e - 1 - (e - 1) % t);
    }
    static prevIndentTabStop(e, t) {
      return Math.max(0, e - 1 - (e - 1) % t);
    }
  }
  function CV(s, e, t) {
    let i = 0;
    for (let o = 0; o < s.length; o++)
      s.charAt(o) === "	" ? i += e : i++;
    let n = "";
    if (!t) {
      const o = Math.floor(i / e);
      i = i % e;
      for (let r = 0; r < o; r++)
        n += "	";
    }
    for (let o = 0; o < i; o++)
      n += " ";
    return n;
  }
  function e1(s, e, t) {
    let i = jn(s);
    return i === -1 && (i = s.length), CV(s.substring(0, i), e, t) + s.substring(i);
  }
  const wV = () => !0, SV = () => !1, yV = (s) => s === " " || s === "	";
  class Xh {
    constructor(e, t, i, n) {
      this.languageConfigurationService = n, this._cursorMoveConfigurationBrand = void 0, this._languageId = e;
      const o = i.options, r = o.get(131);
      this.readOnly = o.get(81), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = o.get(104), this.lineHeight = o.get(59), this.pageSize = Math.max(1, Math.floor(r.height / this.lineHeight) - 2), this.useTabStops = o.get(116), this.wordSeparators = o.get(117), this.emptySelectionClipboard = o.get(32), this.copyWithSyntaxHighlighting = o.get(21), this.multiCursorMergeOverlapping = o.get(69), this.multiCursorPaste = o.get(71), this.autoClosingBrackets = o.get(5), this.autoClosingQuotes = o.get(8), this.autoClosingDelete = o.get(6), this.autoClosingOvertype = o.get(7), this.autoSurround = o.get(11), this.autoIndent = o.get(9), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
        quote: this._getShouldAutoClose(e, this.autoClosingQuotes),
        bracket: this._getShouldAutoClose(e, this.autoClosingBrackets)
      }, this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(e).getAutoClosingPairs();
      const a = this.languageConfigurationService.getLanguageConfiguration(e).getSurroundingPairs();
      if (a)
        for (const l of a)
          this.surroundingPairs[l.open] = l.close;
    }
    static shouldRecreate(e) {
      return e.hasChanged(131) || e.hasChanged(117) || e.hasChanged(32) || e.hasChanged(69) || e.hasChanged(71) || e.hasChanged(5) || e.hasChanged(8) || e.hasChanged(6) || e.hasChanged(7) || e.hasChanged(11) || e.hasChanged(116) || e.hasChanged(59) || e.hasChanged(81);
    }
    get electricChars() {
      var e;
      if (!this._electricChars) {
        this._electricChars = {};
        const t = (e = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || e === void 0 ? void 0 : e.getElectricCharacters();
        if (t)
          for (const i of t)
            this._electricChars[i] = !0;
      }
      return this._electricChars;
    }
    onElectricCharacter(e, t, i) {
      const n = J0(t, i - 1), o = this.languageConfigurationService.getLanguageConfiguration(n.languageId).electricCharacter;
      return o ? o.onElectricCharacter(e, n, i - n.firstCharOffset) : null;
    }
    normalizeIndentation(e) {
      return e1(e, this.indentSize, this.insertSpaces);
    }
    _getShouldAutoClose(e, t) {
      switch (t) {
        case "beforeWhitespace":
          return yV;
        case "languageDefined":
          return this._getLanguageDefinedShouldAutoClose(e);
        case "always":
          return wV;
        case "never":
          return SV;
      }
    }
    _getLanguageDefinedShouldAutoClose(e) {
      const t = this.languageConfigurationService.getLanguageConfiguration(e).getAutoCloseBeforeSet();
      return (i) => t.indexOf(i) !== -1;
    }
    visibleColumnFromColumn(e, t) {
      return Oi.visibleColumnFromColumn(e.getLineContent(t.lineNumber), t.column, this.tabSize);
    }
    columnFromVisibleColumn(e, t, i) {
      const n = Oi.columnFromVisibleColumn(e.getLineContent(t), i, this.tabSize), o = e.getLineMinColumn(t);
      if (n < o)
        return o;
      const r = e.getLineMaxColumn(t);
      return n > r ? r : n;
    }
  }
  class Ze {
    constructor(e, t) {
      this._cursorStateBrand = void 0, this.modelState = e, this.viewState = t;
    }
    static fromModelState(e) {
      return new LV(e);
    }
    static fromViewState(e) {
      return new kV(e);
    }
    static fromModelSelection(e) {
      const t = ae.liftSelection(e), i = new nn(D.fromPositions(t.getSelectionStart()), 0, t.getPosition(), 0);
      return Ze.fromModelState(i);
    }
    static fromModelSelections(e) {
      const t = [];
      for (let i = 0, n = e.length; i < n; i++)
        t[i] = this.fromModelSelection(e[i]);
      return t;
    }
    equals(e) {
      return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
    }
  }
  class LV {
    constructor(e) {
      this.modelState = e, this.viewState = null;
    }
  }
  class kV {
    constructor(e) {
      this.modelState = null, this.viewState = e;
    }
  }
  class nn {
    constructor(e, t, i, n) {
      this._singleCursorStateBrand = void 0, this.selectionStart = e, this.selectionStartLeftoverVisibleColumns = t, this.position = i, this.leftoverVisibleColumns = n, this.selection = nn._computeSelection(this.selectionStart, this.position);
    }
    equals(e) {
      return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
    }
    hasSelection() {
      return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
    }
    move(e, t, i, n) {
      return e ? new nn(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new V(t, i), n) : new nn(new D(t, i, t, i), n, new V(t, i), n);
    }
    static _computeSelection(e, t) {
      return e.isEmpty() || !t.isBeforeOrEqual(e.getStartPosition()) ? ae.fromPositions(e.getStartPosition(), t) : ae.fromPositions(e.getEndPosition(), t);
    }
  }
  class _s {
    constructor(e, t, i) {
      this._editOperationResultBrand = void 0, this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
    }
  }
  function pu(s) {
    return s === "'" || s === '"' || s === "`";
  }
  class ad {
    static columnSelect(e, t, i, n, o, r) {
      const a = Math.abs(o - i) + 1, l = i > o, c = n > r, d = n < r, h = [];
      for (let u = 0; u < a; u++) {
        const f = i + (l ? -u : u), g = e.columnFromVisibleColumn(t, f, n), _ = e.columnFromVisibleColumn(t, f, r), b = e.visibleColumnFromColumn(t, new V(f, g)), C = e.visibleColumnFromColumn(t, new V(f, _));
        d && (b > r || C < n) || c && (C > n || b < r) || h.push(new nn(new D(f, g, f, g), 0, new V(f, _), 0));
      }
      if (h.length === 0)
        for (let u = 0; u < a; u++) {
          const f = i + (l ? -u : u), g = t.getLineMaxColumn(f);
          h.push(new nn(new D(f, g, f, g), 0, new V(f, g), 0));
        }
      return {
        viewStates: h,
        reversed: l,
        fromLineNumber: i,
        fromVisualColumn: n,
        toLineNumber: o,
        toVisualColumn: r
      };
    }
    static columnSelectLeft(e, t, i) {
      let n = i.toViewVisualColumn;
      return n > 0 && n--, ad.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, n);
    }
    static columnSelectRight(e, t, i) {
      let n = 0;
      const o = Math.min(i.fromViewLineNumber, i.toViewLineNumber), r = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
      for (let l = o; l <= r; l++) {
        const c = t.getLineMaxColumn(l), d = e.visibleColumnFromColumn(t, new V(l, c));
        n = Math.max(n, d);
      }
      let a = i.toViewVisualColumn;
      return a < n && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
    }
    static columnSelectUp(e, t, i, n) {
      const o = n ? e.pageSize : 1, r = Math.max(1, i.toViewLineNumber - o);
      return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
    }
    static columnSelectDown(e, t, i, n) {
      const o = n ? e.pageSize : 1, r = Math.min(t.getLineCount(), i.toViewLineNumber + o);
      return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
    }
  }
  class fn {
    constructor(e, t, i = !1) {
      this._range = e, this._text = t, this.insertsAutoWhitespace = i;
    }
    getEditOperations(e, t) {
      t.addTrackedEditOperation(this._range, this._text);
    }
    computeCursorState(e, t) {
      const n = t.getInverseEditOperations()[0].range;
      return ae.fromPositions(n.getEndPosition());
    }
  }
  class DV {
    constructor(e, t) {
      this._range = e, this._text = t;
    }
    getEditOperations(e, t) {
      t.addTrackedEditOperation(this._range, this._text);
    }
    computeCursorState(e, t) {
      const n = t.getInverseEditOperations()[0].range;
      return ae.fromRange(n, 0);
    }
  }
  class U_ {
    constructor(e, t, i = !1) {
      this._range = e, this._text = t, this.insertsAutoWhitespace = i;
    }
    getEditOperations(e, t) {
      t.addTrackedEditOperation(this._range, this._text);
    }
    computeCursorState(e, t) {
      const n = t.getInverseEditOperations()[0].range;
      return ae.fromPositions(n.getStartPosition());
    }
  }
  class s0 {
    constructor(e, t, i, n, o = !1) {
      this._range = e, this._text = t, this._columnDeltaOffset = n, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = o;
    }
    getEditOperations(e, t) {
      t.addTrackedEditOperation(this._range, this._text);
    }
    computeCursorState(e, t) {
      const n = t.getInverseEditOperations()[0].range;
      return ae.fromPositions(n.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
    }
  }
  class HI {
    constructor(e, t, i, n = !1) {
      this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = n, this._selectionId = null;
    }
    getEditOperations(e, t) {
      t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
    }
    computeCursorState(e, t) {
      return t.getTrackedSelection(this._selectionId);
    }
  }
  class Um {
    static whitespaceVisibleColumn(e, t, i) {
      const n = e.length;
      let o = 0, r = -1, a = -1;
      for (let l = 0; l < n; l++) {
        if (l === t)
          return [r, a, o];
        switch (o % i === 0 && (r = l, a = o), e.charCodeAt(l)) {
          case 32:
            o += 1;
            break;
          case 9:
            o = Oi.nextRenderTabStop(o, i);
            break;
          default:
            return [-1, -1, -1];
        }
      }
      return t === n ? [r, a, o] : [-1, -1, -1];
    }
    static atomicPosition(e, t, i, n) {
      const o = e.length, [r, a, l] = Um.whitespaceVisibleColumn(e, t, i);
      if (l === -1)
        return -1;
      let c;
      switch (n) {
        case 0:
          c = !0;
          break;
        case 1:
          c = !1;
          break;
        case 2:
          if (l % i === 0)
            return t;
          c = l % i <= i / 2;
          break;
      }
      if (c) {
        if (r === -1)
          return -1;
        let u = a;
        for (let f = r; f < o; ++f) {
          if (u === a + i)
            return r;
          switch (e.charCodeAt(f)) {
            case 32:
              u += 1;
              break;
            case 9:
              u = Oi.nextRenderTabStop(u, i);
              break;
            default:
              return -1;
          }
        }
        return u === a + i ? r : -1;
      }
      const d = Oi.nextRenderTabStop(l, i);
      let h = l;
      for (let u = t; u < o; u++) {
        if (h === d)
          return u;
        switch (e.charCodeAt(u)) {
          case 32:
            h += 1;
            break;
          case 9:
            h = Oi.nextRenderTabStop(h, i);
            break;
          default:
            return -1;
        }
      }
      return h === d ? o : -1;
    }
  }
  class Mw {
    constructor(e, t, i) {
      this._cursorPositionBrand = void 0, this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
    }
  }
  class ut {
    static leftPosition(e, t) {
      if (t.column > e.getLineMinColumn(t.lineNumber))
        return t.delta(void 0, -DP(e.getLineContent(t.lineNumber), t.column - 1));
      if (t.lineNumber > 1) {
        const i = t.lineNumber - 1;
        return new V(i, e.getLineMaxColumn(i));
      } else
        return t;
    }
    static leftPositionAtomicSoftTabs(e, t, i) {
      if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
        const n = e.getLineMinColumn(t.lineNumber), o = e.getLineContent(t.lineNumber), r = Um.atomicPosition(o, t.column - 1, i, 0);
        if (r !== -1 && r + 1 >= n)
          return new V(t.lineNumber, r + 1);
      }
      return this.leftPosition(e, t);
    }
    static left(e, t, i) {
      const n = e.stickyTabStops ? ut.leftPositionAtomicSoftTabs(t, i, e.tabSize) : ut.leftPosition(t, i);
      return new Mw(n.lineNumber, n.column, 0);
    }
    static moveLeft(e, t, i, n, o) {
      let r, a;
      if (i.hasSelection() && !n)
        r = i.selection.startLineNumber, a = i.selection.startColumn;
      else {
        const l = i.position.delta(void 0, -(o - 1)), c = t.normalizePosition(ut.clipPositionColumn(l, t), 0), d = ut.left(e, t, c);
        r = d.lineNumber, a = d.column;
      }
      return i.move(n, r, a, 0);
    }
    static clipPositionColumn(e, t) {
      return new V(e.lineNumber, ut.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
    }
    static clipRange(e, t, i) {
      return e < t ? t : e > i ? i : e;
    }
    static rightPosition(e, t, i) {
      return i < e.getLineMaxColumn(t) ? i = i + RI(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new V(t, i);
    }
    static rightPositionAtomicSoftTabs(e, t, i, n, o) {
      if (i < e.getLineIndentColumn(t)) {
        const r = e.getLineContent(t), a = Um.atomicPosition(r, i - 1, n, 1);
        if (a !== -1)
          return new V(t, a + 1);
      }
      return this.rightPosition(e, t, i);
    }
    static right(e, t, i) {
      const n = e.stickyTabStops ? ut.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : ut.rightPosition(t, i.lineNumber, i.column);
      return new Mw(n.lineNumber, n.column, 0);
    }
    static moveRight(e, t, i, n, o) {
      let r, a;
      if (i.hasSelection() && !n)
        r = i.selection.endLineNumber, a = i.selection.endColumn;
      else {
        const l = i.position.delta(void 0, o - 1), c = t.normalizePosition(ut.clipPositionColumn(l, t), 1), d = ut.right(e, t, c);
        r = d.lineNumber, a = d.column;
      }
      return i.move(n, r, a, 0);
    }
    static vertical(e, t, i, n, o, r, a, l) {
      const c = Oi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize) + o, d = t.getLineCount(), h = i === 1 && n === 1, u = i === d && n === t.getLineMaxColumn(i), f = r < i ? h : u;
      if (i = r, i < 1 ? (i = 1, a ? n = t.getLineMinColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : i > d ? (i = d, a ? n = t.getLineMaxColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : n = e.columnFromVisibleColumn(t, i, c), f ? o = 0 : o = c - Oi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize), l !== void 0) {
        const g = new V(i, n), _ = t.normalizePosition(g, l);
        o = o + (n - _.column), i = _.lineNumber, n = _.column;
      }
      return new Mw(i, n, o);
    }
    static down(e, t, i, n, o, r, a) {
      return this.vertical(e, t, i, n, o, i + r, a, 1);
    }
    static moveDown(e, t, i, n, o) {
      let r, a;
      i.hasSelection() && !n ? (r = i.selection.endLineNumber, a = i.selection.endColumn) : (r = i.position.lineNumber, a = i.position.column);
      const l = ut.down(e, t, r, a, i.leftoverVisibleColumns, o, !0);
      return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
    }
    static translateDown(e, t, i) {
      const n = i.selection, o = ut.down(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = ut.down(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
      return new nn(new D(o.lineNumber, o.column, o.lineNumber, o.column), o.leftoverVisibleColumns, new V(r.lineNumber, r.column), r.leftoverVisibleColumns);
    }
    static up(e, t, i, n, o, r, a) {
      return this.vertical(e, t, i, n, o, i - r, a, 0);
    }
    static moveUp(e, t, i, n, o) {
      let r, a;
      i.hasSelection() && !n ? (r = i.selection.startLineNumber, a = i.selection.startColumn) : (r = i.position.lineNumber, a = i.position.column);
      const l = ut.up(e, t, r, a, i.leftoverVisibleColumns, o, !0);
      return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
    }
    static translateUp(e, t, i) {
      const n = i.selection, o = ut.up(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = ut.up(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
      return new nn(new D(o.lineNumber, o.column, o.lineNumber, o.column), o.leftoverVisibleColumns, new V(r.lineNumber, r.column), r.leftoverVisibleColumns);
    }
    static _isBlankLine(e, t) {
      return e.getLineFirstNonWhitespaceColumn(t) === 0;
    }
    static moveToPrevBlankLine(e, t, i, n) {
      let o = i.position.lineNumber;
      for (; o > 1 && this._isBlankLine(t, o); )
        o--;
      for (; o > 1 && !this._isBlankLine(t, o); )
        o--;
      return i.move(n, o, t.getLineMinColumn(o), 0);
    }
    static moveToNextBlankLine(e, t, i, n) {
      const o = t.getLineCount();
      let r = i.position.lineNumber;
      for (; r < o && this._isBlankLine(t, r); )
        r++;
      for (; r < o && !this._isBlankLine(t, r); )
        r++;
      return i.move(n, r, t.getLineMinColumn(r), 0);
    }
    static moveToBeginningOfLine(e, t, i, n) {
      const o = i.position.lineNumber, r = t.getLineMinColumn(o), a = t.getLineFirstNonWhitespaceColumn(o) || r;
      let l;
      return i.position.column === a ? l = r : l = a, i.move(n, o, l, 0);
    }
    static moveToEndOfLine(e, t, i, n, o) {
      const r = i.position.lineNumber, a = t.getLineMaxColumn(r);
      return i.move(n, r, a, o ? 1073741824 - a : 0);
    }
    static moveToBeginningOfBuffer(e, t, i, n) {
      return i.move(n, 1, 1, 0);
    }
    static moveToEndOfBuffer(e, t, i, n) {
      const o = t.getLineCount(), r = t.getLineMaxColumn(o);
      return i.move(n, o, r, 0);
    }
  }
  class Gd {
    static deleteRight(e, t, i, n) {
      const o = [];
      let r = e !== 3;
      for (let a = 0, l = n.length; a < l; a++) {
        const c = n[a];
        let d = c;
        if (d.isEmpty()) {
          const h = c.getPosition(), u = ut.right(t, i, h);
          d = new D(u.lineNumber, u.column, h.lineNumber, h.column);
        }
        if (d.isEmpty()) {
          o[a] = null;
          continue;
        }
        d.startLineNumber !== d.endLineNumber && (r = !0), o[a] = new fn(d, "");
      }
      return [r, o];
    }
    static isAutoClosingPairDelete(e, t, i, n, o, r, a) {
      if (t === "never" && i === "never" || e === "never")
        return !1;
      for (let l = 0, c = r.length; l < c; l++) {
        const d = r[l], h = d.getPosition();
        if (!d.isEmpty())
          return !1;
        const u = o.getLineContent(h.lineNumber);
        if (h.column < 2 || h.column >= u.length + 1)
          return !1;
        const f = u.charAt(h.column - 2), g = n.get(f);
        if (!g)
          return !1;
        if (pu(f)) {
          if (i === "never")
            return !1;
        } else if (t === "never")
          return !1;
        const _ = u.charAt(h.column - 1);
        let b = !1;
        for (const C of g)
          C.open === f && C.close === _ && (b = !0);
        if (!b)
          return !1;
        if (e === "auto") {
          let C = !1;
          for (let v = 0, w = a.length; v < w; v++) {
            const S = a[v];
            if (h.lineNumber === S.startLineNumber && h.column === S.startColumn) {
              C = !0;
              break;
            }
          }
          if (!C)
            return !1;
        }
      }
      return !0;
    }
    static _runAutoClosingPairDelete(e, t, i) {
      const n = [];
      for (let o = 0, r = i.length; o < r; o++) {
        const a = i[o].getPosition(), l = new D(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
        n[o] = new fn(l, "");
      }
      return [!0, n];
    }
    static deleteLeft(e, t, i, n, o) {
      if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, n, o))
        return this._runAutoClosingPairDelete(t, i, n);
      const r = [];
      let a = e !== 2;
      for (let l = 0, c = n.length; l < c; l++) {
        const d = Gd.getDeleteRange(n[l], i, t);
        if (d.isEmpty()) {
          r[l] = null;
          continue;
        }
        d.startLineNumber !== d.endLineNumber && (a = !0), r[l] = new fn(d, "");
      }
      return [a, r];
    }
    static getDeleteRange(e, t, i) {
      if (!e.isEmpty())
        return e;
      const n = e.getPosition();
      if (i.useTabStops && n.column > 1) {
        const o = t.getLineContent(n.lineNumber), r = jn(o), a = r === -1 ? o.length + 1 : r + 1;
        if (n.column <= a) {
          const l = i.visibleColumnFromColumn(t, n), c = Oi.prevIndentTabStop(l, i.indentSize), d = i.columnFromVisibleColumn(t, n.lineNumber, c);
          return new D(n.lineNumber, d, n.lineNumber, n.column);
        }
      }
      return D.fromPositions(Gd.getPositionAfterDeleteLeft(n, t), n);
    }
    static getPositionAfterDeleteLeft(e, t) {
      if (e.column > 1) {
        const i = tV(e.column - 1, t.getLineContent(e.lineNumber));
        return e.with(void 0, i + 1);
      } else if (e.lineNumber > 1) {
        const i = e.lineNumber - 1;
        return new V(i, t.getLineMaxColumn(i));
      } else
        return e;
    }
    static cut(e, t, i) {
      const n = [];
      let o = null;
      i.sort((r, a) => V.compare(r.getStartPosition(), a.getEndPosition()));
      for (let r = 0, a = i.length; r < a; r++) {
        const l = i[r];
        if (l.isEmpty())
          if (e.emptySelectionClipboard) {
            const c = l.getPosition();
            let d, h, u, f;
            c.lineNumber < t.getLineCount() ? (d = c.lineNumber, h = 1, u = c.lineNumber + 1, f = 1) : c.lineNumber > 1 && o?.endLineNumber !== c.lineNumber ? (d = c.lineNumber - 1, h = t.getLineMaxColumn(c.lineNumber - 1), u = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber)) : (d = c.lineNumber, h = 1, u = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber));
            const g = new D(d, h, u, f);
            o = g, g.isEmpty() ? n[r] = null : n[r] = new fn(g, "");
          } else
            n[r] = null;
        else
          n[r] = new fn(l, "");
      }
      return new _s(0, n, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !0
      });
    }
  }
  function t1(s) {
    return s < 0 ? 0 : s > 255 ? 255 : s | 0;
  }
  function Qh(s) {
    return s < 0 ? 0 : s > 4294967295 ? 4294967295 : s | 0;
  }
  class eg {
    constructor(e) {
      const t = t1(e);
      this._defaultValue = t, this._asciiMap = eg._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
    }
    static _createAsciiMap(e) {
      const t = new Uint8Array(256);
      for (let i = 0; i < 256; i++)
        t[i] = e;
      return t;
    }
    set(e, t) {
      const i = t1(t);
      e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
    }
    get(e) {
      return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
    }
  }
  class Lu {
    constructor() {
      this._actual = new eg(0);
    }
    add(e) {
      this._actual.set(e, 1);
    }
    has(e) {
      return this._actual.get(e) === 1;
    }
  }
  class xV extends eg {
    constructor(e) {
      super(0);
      for (let t = 0, i = e.length; t < i; t++)
        this.set(e.charCodeAt(t), 2);
      this.set(32, 1), this.set(9, 1);
    }
  }
  function IV(s) {
    const e = {};
    return (t) => (e.hasOwnProperty(t) || (e[t] = s(t)), e[t]);
  }
  const yo = IV((s) => new xV(s));
  class ct {
    static _createWord(e, t, i, n, o) {
      return { start: n, end: o, wordType: t, nextCharClass: i };
    }
    static _findPreviousWordOnLine(e, t, i) {
      const n = t.getLineContent(i.lineNumber);
      return this._doFindPreviousWordOnLine(n, e, i);
    }
    static _doFindPreviousWordOnLine(e, t, i) {
      let n = 0;
      for (let o = i.column - 2; o >= 0; o--) {
        const r = e.charCodeAt(o), a = t.get(r);
        if (a === 0) {
          if (n === 2)
            return this._createWord(e, n, a, o + 1, this._findEndOfWord(e, t, n, o + 1));
          n = 1;
        } else if (a === 2) {
          if (n === 1)
            return this._createWord(e, n, a, o + 1, this._findEndOfWord(e, t, n, o + 1));
          n = 2;
        } else if (a === 1 && n !== 0)
          return this._createWord(e, n, a, o + 1, this._findEndOfWord(e, t, n, o + 1));
      }
      return n !== 0 ? this._createWord(e, n, 1, 0, this._findEndOfWord(e, t, n, 0)) : null;
    }
    static _findEndOfWord(e, t, i, n) {
      const o = e.length;
      for (let r = n; r < o; r++) {
        const a = e.charCodeAt(r), l = t.get(a);
        if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
          return r;
      }
      return o;
    }
    static _findNextWordOnLine(e, t, i) {
      const n = t.getLineContent(i.lineNumber);
      return this._doFindNextWordOnLine(n, e, i);
    }
    static _doFindNextWordOnLine(e, t, i) {
      let n = 0;
      const o = e.length;
      for (let r = i.column - 1; r < o; r++) {
        const a = e.charCodeAt(r), l = t.get(a);
        if (l === 0) {
          if (n === 2)
            return this._createWord(e, n, l, this._findStartOfWord(e, t, n, r - 1), r);
          n = 1;
        } else if (l === 2) {
          if (n === 1)
            return this._createWord(e, n, l, this._findStartOfWord(e, t, n, r - 1), r);
          n = 2;
        } else if (l === 1 && n !== 0)
          return this._createWord(e, n, l, this._findStartOfWord(e, t, n, r - 1), r);
      }
      return n !== 0 ? this._createWord(e, n, 1, this._findStartOfWord(e, t, n, o - 1), o) : null;
    }
    static _findStartOfWord(e, t, i, n) {
      for (let o = n; o >= 0; o--) {
        const r = e.charCodeAt(o), a = t.get(r);
        if (a === 1 || i === 1 && a === 2 || i === 2 && a === 0)
          return o + 1;
      }
      return 0;
    }
    static moveWordLeft(e, t, i, n) {
      let o = i.lineNumber, r = i.column;
      r === 1 && o > 1 && (o = o - 1, r = t.getLineMaxColumn(o));
      let a = ct._findPreviousWordOnLine(e, t, new V(o, r));
      if (n === 0)
        return new V(o, a ? a.start + 1 : 1);
      if (n === 1)
        return a && a.wordType === 2 && a.end - a.start === 1 && a.nextCharClass === 0 && (a = ct._findPreviousWordOnLine(e, t, new V(o, a.start + 1))), new V(o, a ? a.start + 1 : 1);
      if (n === 3) {
        for (; a && a.wordType === 2; )
          a = ct._findPreviousWordOnLine(e, t, new V(o, a.start + 1));
        return new V(o, a ? a.start + 1 : 1);
      }
      return a && r <= a.end + 1 && (a = ct._findPreviousWordOnLine(e, t, new V(o, a.start + 1))), new V(o, a ? a.end + 1 : 1);
    }
    static _moveWordPartLeft(e, t) {
      const i = t.lineNumber, n = e.getLineMaxColumn(i);
      if (t.column === 1)
        return i > 1 ? new V(i - 1, e.getLineMaxColumn(i - 1)) : t;
      const o = e.getLineContent(i);
      for (let r = t.column - 1; r > 1; r--) {
        const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
        if (a === 95 && l !== 95)
          return new V(i, r);
        if (jl(a) && Wr(l))
          return new V(i, r);
        if (Wr(a) && Wr(l) && r + 1 < n) {
          const c = o.charCodeAt(r);
          if (jl(c))
            return new V(i, r);
        }
      }
      return new V(i, 1);
    }
    static moveWordRight(e, t, i, n) {
      let o = i.lineNumber, r = i.column, a = !1;
      r === t.getLineMaxColumn(o) && o < t.getLineCount() && (a = !0, o = o + 1, r = 1);
      let l = ct._findNextWordOnLine(e, t, new V(o, r));
      if (n === 2)
        l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = ct._findNextWordOnLine(e, t, new V(o, l.end + 1))), l ? r = l.end + 1 : r = t.getLineMaxColumn(o);
      else if (n === 3) {
        for (a && (r = 0); l && (l.wordType === 2 || l.start + 1 <= r); )
          l = ct._findNextWordOnLine(e, t, new V(o, l.end + 1));
        l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
      } else
        l && !a && r >= l.start + 1 && (l = ct._findNextWordOnLine(e, t, new V(o, l.end + 1))), l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
      return new V(o, r);
    }
    static _moveWordPartRight(e, t) {
      const i = t.lineNumber, n = e.getLineMaxColumn(i);
      if (t.column === n)
        return i < e.getLineCount() ? new V(i + 1, 1) : t;
      const o = e.getLineContent(i);
      for (let r = t.column + 1; r < n; r++) {
        const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
        if (a !== 95 && l === 95)
          return new V(i, r);
        if (jl(a) && Wr(l))
          return new V(i, r);
        if (Wr(a) && Wr(l) && r + 1 < n) {
          const c = o.charCodeAt(r);
          if (jl(c))
            return new V(i, r);
        }
      }
      return new V(i, n);
    }
    static _deleteWordLeftWhitespace(e, t) {
      const i = e.getLineContent(t.lineNumber), n = t.column - 2, o = ia(i, n);
      return o + 1 < n ? new D(t.lineNumber, o + 2, t.lineNumber, t.column) : null;
    }
    static deleteWordLeft(e, t) {
      const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
      if (!o.isEmpty())
        return o;
      if (Gd.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
        const h = e.selection.getPosition();
        return new D(h.lineNumber, h.column - 1, h.lineNumber, h.column + 1);
      }
      const a = new V(o.positionLineNumber, o.positionColumn);
      let l = a.lineNumber, c = a.column;
      if (l === 1 && c === 1)
        return null;
      if (r) {
        const h = this._deleteWordLeftWhitespace(n, a);
        if (h)
          return h;
      }
      let d = ct._findPreviousWordOnLine(i, n, a);
      return t === 0 ? d ? c = d.start + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l)) : (d && c <= d.end + 1 && (d = ct._findPreviousWordOnLine(i, n, new V(l, d.start + 1))), d ? c = d.end + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l))), new D(l, c, a.lineNumber, a.column);
    }
    static deleteInsideWord(e, t, i) {
      if (!i.isEmpty())
        return i;
      const n = new V(i.positionLineNumber, i.positionColumn), o = this._deleteInsideWordWhitespace(t, n);
      return o || this._deleteInsideWordDetermineDeleteRange(e, t, n);
    }
    static _charAtIsWhitespace(e, t) {
      const i = e.charCodeAt(t);
      return i === 32 || i === 9;
    }
    static _deleteInsideWordWhitespace(e, t) {
      const i = e.getLineContent(t.lineNumber), n = i.length;
      if (n === 0)
        return null;
      let o = Math.max(t.column - 2, 0);
      if (!this._charAtIsWhitespace(i, o))
        return null;
      let r = Math.min(t.column - 1, n - 1);
      if (!this._charAtIsWhitespace(i, r))
        return null;
      for (; o > 0 && this._charAtIsWhitespace(i, o - 1); )
        o--;
      for (; r + 1 < n && this._charAtIsWhitespace(i, r + 1); )
        r++;
      return new D(t.lineNumber, o + 1, t.lineNumber, r + 2);
    }
    static _deleteInsideWordDetermineDeleteRange(e, t, i) {
      const n = t.getLineContent(i.lineNumber), o = n.length;
      if (o === 0)
        return i.lineNumber > 1 ? new D(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new D(i.lineNumber, 1, i.lineNumber + 1, 1) : new D(i.lineNumber, 1, i.lineNumber, 1);
      const r = (h) => h.start + 1 <= i.column && i.column <= h.end + 1, a = (h, u) => (h = Math.min(h, i.column), u = Math.max(u, i.column), new D(i.lineNumber, h, i.lineNumber, u)), l = (h) => {
        let u = h.start + 1, f = h.end + 1, g = !1;
        for (; f - 1 < o && this._charAtIsWhitespace(n, f - 1); )
          g = !0, f++;
        if (!g)
          for (; u > 1 && this._charAtIsWhitespace(n, u - 2); )
            u--;
        return a(u, f);
      }, c = ct._findPreviousWordOnLine(e, t, i);
      if (c && r(c))
        return l(c);
      const d = ct._findNextWordOnLine(e, t, i);
      return d && r(d) ? l(d) : c && d ? a(c.end + 1, d.start + 1) : c ? a(c.start + 1, c.end + 1) : d ? a(d.start + 1, d.end + 1) : a(1, o + 1);
    }
    static _deleteWordPartLeft(e, t) {
      if (!t.isEmpty())
        return t;
      const i = t.getPosition(), n = ct._moveWordPartLeft(e, i);
      return new D(i.lineNumber, i.column, n.lineNumber, n.column);
    }
    static _findFirstNonWhitespaceChar(e, t) {
      const i = e.length;
      for (let n = t; n < i; n++) {
        const o = e.charAt(n);
        if (o !== " " && o !== "	")
          return n;
      }
      return i;
    }
    static _deleteWordRightWhitespace(e, t) {
      const i = e.getLineContent(t.lineNumber), n = t.column - 1, o = this._findFirstNonWhitespaceChar(i, n);
      return n + 1 < o ? new D(t.lineNumber, t.column, t.lineNumber, o + 1) : null;
    }
    static deleteWordRight(e, t) {
      const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
      if (!o.isEmpty())
        return o;
      const a = new V(o.positionLineNumber, o.positionColumn);
      let l = a.lineNumber, c = a.column;
      const d = n.getLineCount(), h = n.getLineMaxColumn(l);
      if (l === d && c === h)
        return null;
      if (r) {
        const f = this._deleteWordRightWhitespace(n, a);
        if (f)
          return f;
      }
      let u = ct._findNextWordOnLine(i, n, a);
      return t === 2 ? u ? c = u.end + 1 : c < h || l === d ? c = h : (l++, u = ct._findNextWordOnLine(i, n, new V(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l)) : (u && c >= u.start + 1 && (u = ct._findNextWordOnLine(i, n, new V(l, u.end + 1))), u ? c = u.start + 1 : c < h || l === d ? c = h : (l++, u = ct._findNextWordOnLine(i, n, new V(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l))), new D(l, c, a.lineNumber, a.column);
    }
    static _deleteWordPartRight(e, t) {
      if (!t.isEmpty())
        return t;
      const i = t.getPosition(), n = ct._moveWordPartRight(e, i);
      return new D(i.lineNumber, i.column, n.lineNumber, n.column);
    }
    static _createWordAtPosition(e, t, i) {
      const n = new D(t, i.start + 1, t, i.end + 1);
      return {
        word: e.getValueInRange(n),
        startColumn: n.startColumn,
        endColumn: n.endColumn
      };
    }
    static getWordAtPosition(e, t, i) {
      const n = yo(t), o = ct._findPreviousWordOnLine(n, e, i);
      if (o && o.wordType === 1 && o.start <= i.column - 1 && i.column - 1 <= o.end)
        return ct._createWordAtPosition(e, i.lineNumber, o);
      const r = ct._findNextWordOnLine(n, e, i);
      return r && r.wordType === 1 && r.start <= i.column - 1 && i.column - 1 <= r.end ? ct._createWordAtPosition(e, i.lineNumber, r) : null;
    }
    static word(e, t, i, n, o) {
      const r = yo(e.wordSeparators), a = ct._findPreviousWordOnLine(r, t, o), l = ct._findNextWordOnLine(r, t, o);
      if (!n) {
        let f, g;
        return a && a.wordType === 1 && a.start <= o.column - 1 && o.column - 1 <= a.end ? (f = a.start + 1, g = a.end + 1) : l && l.wordType === 1 && l.start <= o.column - 1 && o.column - 1 <= l.end ? (f = l.start + 1, g = l.end + 1) : (a ? f = a.end + 1 : f = 1, l ? g = l.start + 1 : g = t.getLineMaxColumn(o.lineNumber)), new nn(new D(o.lineNumber, f, o.lineNumber, g), 0, new V(o.lineNumber, g), 0);
      }
      let c, d;
      a && a.wordType === 1 && a.start < o.column - 1 && o.column - 1 < a.end ? (c = a.start + 1, d = a.end + 1) : l && l.wordType === 1 && l.start < o.column - 1 && o.column - 1 < l.end ? (c = l.start + 1, d = l.end + 1) : (c = o.column, d = o.column);
      const h = o.lineNumber;
      let u;
      if (i.selectionStart.containsPosition(o))
        u = i.selectionStart.endColumn;
      else if (o.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
        u = c;
        const f = new V(h, u);
        i.selectionStart.containsPosition(f) && (u = i.selectionStart.endColumn);
      } else {
        u = d;
        const f = new V(h, u);
        i.selectionStart.containsPosition(f) && (u = i.selectionStart.startColumn);
      }
      return i.move(!0, h, u, 0);
    }
  }
  class zv extends ct {
    static deleteWordPartLeft(e) {
      const t = $_([
        ct.deleteWordLeft(e, 0),
        ct.deleteWordLeft(e, 2),
        ct._deleteWordPartLeft(e.model, e.selection)
      ]);
      return t.sort(D.compareRangesUsingEnds), t[2];
    }
    static deleteWordPartRight(e) {
      const t = $_([
        ct.deleteWordRight(e, 0),
        ct.deleteWordRight(e, 2),
        ct._deleteWordPartRight(e.model, e.selection)
      ]);
      return t.sort(D.compareRangesUsingStarts), t[0];
    }
    static moveWordPartLeft(e, t, i) {
      const n = $_([
        ct.moveWordLeft(e, t, i, 0),
        ct.moveWordLeft(e, t, i, 2),
        ct._moveWordPartLeft(t, i)
      ]);
      return n.sort(V.compare), n[2];
    }
    static moveWordPartRight(e, t, i) {
      const n = $_([
        ct.moveWordRight(e, t, i, 0),
        ct.moveWordRight(e, t, i, 2),
        ct._moveWordPartRight(t, i)
      ]);
      return n.sort(V.compare), n[0];
    }
  }
  function $_(s) {
    return s.filter((e) => Boolean(e));
  }
  class tn {
    static addCursorDown(e, t, i) {
      const n = [];
      let o = 0;
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        n[o++] = new Ze(l.modelState, l.viewState), i ? n[o++] = Ze.fromModelState(ut.translateDown(e.cursorConfig, e.model, l.modelState)) : n[o++] = Ze.fromViewState(ut.translateDown(e.cursorConfig, e, l.viewState));
      }
      return n;
    }
    static addCursorUp(e, t, i) {
      const n = [];
      let o = 0;
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        n[o++] = new Ze(l.modelState, l.viewState), i ? n[o++] = Ze.fromModelState(ut.translateUp(e.cursorConfig, e.model, l.modelState)) : n[o++] = Ze.fromViewState(ut.translateUp(e.cursorConfig, e, l.viewState));
      }
      return n;
    }
    static moveToBeginningOfLine(e, t, i) {
      let n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o];
        n[o] = this._moveToLineStart(e, a, i);
      }
      return n;
    }
    static _moveToLineStart(e, t, i) {
      const n = t.viewState.position.column, o = t.modelState.position.column, r = n === o, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
      return !r && !(n === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
    }
    static _moveToLineStartByView(e, t, i) {
      return Ze.fromViewState(ut.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
    }
    static _moveToLineStartByModel(e, t, i) {
      return Ze.fromModelState(ut.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
    }
    static moveToEndOfLine(e, t, i, n) {
      const o = [];
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        o[r] = this._moveToLineEnd(e, l, i, n);
      }
      return o;
    }
    static _moveToLineEnd(e, t, i, n) {
      const o = t.viewState.position, r = e.getLineMaxColumn(o.lineNumber), a = o.column === r, l = t.modelState.position, c = e.model.getLineMaxColumn(l.lineNumber), d = r - o.column === c - l.column;
      return a || d ? this._moveToLineEndByModel(e, t, i, n) : this._moveToLineEndByView(e, t, i, n);
    }
    static _moveToLineEndByView(e, t, i, n) {
      return Ze.fromViewState(ut.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, n));
    }
    static _moveToLineEndByModel(e, t, i, n) {
      return Ze.fromModelState(ut.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, n));
    }
    static expandLineSelection(e, t) {
      const i = [];
      for (let n = 0, o = t.length; n < o; n++) {
        const r = t[n], a = r.modelState.selection.startLineNumber, l = e.model.getLineCount();
        let c = r.modelState.selection.endLineNumber, d;
        c === l ? d = e.model.getLineMaxColumn(l) : (c++, d = 1), i[n] = Ze.fromModelState(new nn(new D(a, 1, a, 1), 0, new V(c, d), 0));
      }
      return i;
    }
    static moveToBeginningOfBuffer(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o];
        n[o] = Ze.fromModelState(ut.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
      }
      return n;
    }
    static moveToEndOfBuffer(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o];
        n[o] = Ze.fromModelState(ut.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
      }
      return n;
    }
    static selectAll(e, t) {
      const i = e.model.getLineCount(), n = e.model.getLineMaxColumn(i);
      return Ze.fromModelState(new nn(new D(1, 1, 1, 1), 0, new V(i, n), 0));
    }
    static line(e, t, i, n, o) {
      const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new V(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
      if (!i || !t.modelState.hasSelection()) {
        const c = e.model.getLineCount();
        let d = r.lineNumber + 1, h = 1;
        return d > c && (d = c, h = e.model.getLineMaxColumn(d)), Ze.fromModelState(new nn(new D(r.lineNumber, 1, d, h), 0, new V(d, h), 0));
      }
      const l = t.modelState.selectionStart.getStartPosition().lineNumber;
      if (r.lineNumber < l)
        return Ze.fromViewState(t.viewState.move(t.modelState.hasSelection(), a.lineNumber, 1, 0));
      if (r.lineNumber > l) {
        const c = e.getLineCount();
        let d = a.lineNumber + 1, h = 1;
        return d > c && (d = c, h = e.getLineMaxColumn(d)), Ze.fromViewState(t.viewState.move(t.modelState.hasSelection(), d, h, 0));
      } else {
        const c = t.modelState.selectionStart.getEndPosition();
        return Ze.fromModelState(t.modelState.move(t.modelState.hasSelection(), c.lineNumber, c.column, 0));
      }
    }
    static word(e, t, i, n) {
      const o = e.model.validatePosition(n);
      return Ze.fromModelState(ct.word(e.cursorConfig, e.model, t.modelState, i, o));
    }
    static cancelSelection(e, t) {
      if (!t.modelState.hasSelection())
        return new Ze(t.modelState, t.viewState);
      const i = t.viewState.position.lineNumber, n = t.viewState.position.column;
      return Ze.fromViewState(new nn(new D(i, n, i, n), 0, new V(i, n), 0));
    }
    static moveTo(e, t, i, n, o) {
      const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new V(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
      return Ze.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
    }
    static simpleMove(e, t, i, n, o, r) {
      switch (i) {
        case 0:
          return r === 4 ? this._moveHalfLineLeft(e, t, n) : this._moveLeft(e, t, n, o);
        case 1:
          return r === 4 ? this._moveHalfLineRight(e, t, n) : this._moveRight(e, t, n, o);
        case 2:
          return r === 2 ? this._moveUpByViewLines(e, t, n, o) : this._moveUpByModelLines(e, t, n, o);
        case 3:
          return r === 2 ? this._moveDownByViewLines(e, t, n, o) : this._moveDownByModelLines(e, t, n, o);
        case 4:
          return r === 2 ? t.map((a) => Ze.fromViewState(ut.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Ze.fromModelState(ut.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, n)));
        case 5:
          return r === 2 ? t.map((a) => Ze.fromViewState(ut.moveToNextBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Ze.fromModelState(ut.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, n)));
        case 6:
          return this._moveToViewMinColumn(e, t, n);
        case 7:
          return this._moveToViewFirstNonWhitespaceColumn(e, t, n);
        case 8:
          return this._moveToViewCenterColumn(e, t, n);
        case 9:
          return this._moveToViewMaxColumn(e, t, n);
        case 10:
          return this._moveToViewLastNonWhitespaceColumn(e, t, n);
        default:
          return null;
      }
    }
    static viewportMove(e, t, i, n, o) {
      const r = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(r);
      switch (i) {
        case 11: {
          const l = this._firstLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
          return [this._moveToModelPosition(e, t[0], n, l, c)];
        }
        case 13: {
          const l = this._lastLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
          return [this._moveToModelPosition(e, t[0], n, l, c)];
        }
        case 12: {
          const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), c = e.model.getLineFirstNonWhitespaceColumn(l);
          return [this._moveToModelPosition(e, t[0], n, l, c)];
        }
        case 14: {
          const l = [];
          for (let c = 0, d = t.length; c < d; c++) {
            const h = t[c];
            l[c] = this.findPositionInViewportIfOutside(e, h, r, n);
          }
          return l;
        }
        default:
          return null;
      }
    }
    static findPositionInViewportIfOutside(e, t, i, n) {
      const o = t.viewState.position.lineNumber;
      if (i.startLineNumber <= o && o <= i.endLineNumber - 1)
        return new Ze(t.modelState, t.viewState);
      {
        let r;
        o > i.endLineNumber - 1 ? r = i.endLineNumber - 1 : o < i.startLineNumber ? r = i.startLineNumber : r = o;
        const a = ut.vertical(e.cursorConfig, e, o, t.viewState.position.column, t.viewState.leftoverVisibleColumns, r, !1);
        return Ze.fromViewState(t.viewState.move(n, a.lineNumber, a.column, a.leftoverVisibleColumns));
      }
    }
    static _firstLineNumberInRange(e, t, i) {
      let n = t.startLineNumber;
      return t.startColumn !== e.getLineMinColumn(n) && n++, Math.min(t.endLineNumber, n + i - 1);
    }
    static _lastLineNumberInRange(e, t, i) {
      let n = t.startLineNumber;
      return t.startColumn !== e.getLineMinColumn(n) && n++, Math.max(n, t.endLineNumber - i + 1);
    }
    static _moveLeft(e, t, i, n) {
      return t.map((o) => Ze.fromViewState(ut.moveLeft(e.cursorConfig, e, o.viewState, i, n)));
    }
    static _moveHalfLineLeft(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineContent(l).length / 2);
        n[o] = Ze.fromViewState(ut.moveLeft(e.cursorConfig, e, a.viewState, i, c));
      }
      return n;
    }
    static _moveRight(e, t, i, n) {
      return t.map((o) => Ze.fromViewState(ut.moveRight(e.cursorConfig, e, o.viewState, i, n)));
    }
    static _moveHalfLineRight(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineContent(l).length / 2);
        n[o] = Ze.fromViewState(ut.moveRight(e.cursorConfig, e, a.viewState, i, c));
      }
      return n;
    }
    static _moveDownByViewLines(e, t, i, n) {
      const o = [];
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        o[r] = Ze.fromViewState(ut.moveDown(e.cursorConfig, e, l.viewState, i, n));
      }
      return o;
    }
    static _moveDownByModelLines(e, t, i, n) {
      const o = [];
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        o[r] = Ze.fromModelState(ut.moveDown(e.cursorConfig, e.model, l.modelState, i, n));
      }
      return o;
    }
    static _moveUpByViewLines(e, t, i, n) {
      const o = [];
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        o[r] = Ze.fromViewState(ut.moveUp(e.cursorConfig, e, l.viewState, i, n));
      }
      return o;
    }
    static _moveUpByModelLines(e, t, i, n) {
      const o = [];
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        o[r] = Ze.fromModelState(ut.moveUp(e.cursorConfig, e.model, l.modelState, i, n));
      }
      return o;
    }
    static _moveToViewPosition(e, t, i, n, o) {
      return Ze.fromViewState(t.viewState.move(i, n, o, 0));
    }
    static _moveToModelPosition(e, t, i, n, o) {
      return Ze.fromModelState(t.modelState.move(i, n, o, 0));
    }
    static _moveToViewMinColumn(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMinColumn(l);
        n[o] = this._moveToViewPosition(e, a, i, l, c);
      }
      return n;
    }
    static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineFirstNonWhitespaceColumn(l);
        n[o] = this._moveToViewPosition(e, a, i, l, c);
      }
      return n;
    }
    static _moveToViewCenterColumn(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.viewState.position.lineNumber, c = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
        n[o] = this._moveToViewPosition(e, a, i, l, c);
      }
      return n;
    }
    static _moveToViewMaxColumn(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMaxColumn(l);
        n[o] = this._moveToViewPosition(e, a, i, l, c);
      }
      return n;
    }
    static _moveToViewLastNonWhitespaceColumn(e, t, i) {
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineLastNonWhitespaceColumn(l);
        n[o] = this._moveToViewPosition(e, a, i, l, c);
      }
      return n;
    }
  }
  var i1;
  (function(s) {
    const e = function(i) {
      if (!ls(i))
        return !1;
      const n = i;
      return !(!vo(n.to) || !Ss(n.select) && !Q4(n.select) || !Ss(n.by) && !vo(n.by) || !Ss(n.value) && !zd(n.value));
    };
    s.description = {
      description: "Move cursor to a logical position in the view",
      args: [
        {
          name: "Cursor move argument object",
          description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
          constraint: e,
          schema: {
            type: "object",
            required: ["to"],
            properties: {
              to: {
                type: "string",
                enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
              },
              by: {
                type: "string",
                enum: ["line", "wrappedLine", "character", "halfLine"]
              },
              value: {
                type: "number",
                default: 1
              },
              select: {
                type: "boolean",
                default: !1
              }
            }
          }
        }
      ]
    }, s.RawDirection = {
      Left: "left",
      Right: "right",
      Up: "up",
      Down: "down",
      PrevBlankLine: "prevBlankLine",
      NextBlankLine: "nextBlankLine",
      WrappedLineStart: "wrappedLineStart",
      WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
      WrappedLineColumnCenter: "wrappedLineColumnCenter",
      WrappedLineEnd: "wrappedLineEnd",
      WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
      ViewPortTop: "viewPortTop",
      ViewPortCenter: "viewPortCenter",
      ViewPortBottom: "viewPortBottom",
      ViewPortIfOutside: "viewPortIfOutside"
    }, s.RawUnit = {
      Line: "line",
      WrappedLine: "wrappedLine",
      Character: "character",
      HalfLine: "halfLine"
    };
    function t(i) {
      if (!i.to)
        return null;
      let n;
      switch (i.to) {
        case s.RawDirection.Left:
          n = 0;
          break;
        case s.RawDirection.Right:
          n = 1;
          break;
        case s.RawDirection.Up:
          n = 2;
          break;
        case s.RawDirection.Down:
          n = 3;
          break;
        case s.RawDirection.PrevBlankLine:
          n = 4;
          break;
        case s.RawDirection.NextBlankLine:
          n = 5;
          break;
        case s.RawDirection.WrappedLineStart:
          n = 6;
          break;
        case s.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
          n = 7;
          break;
        case s.RawDirection.WrappedLineColumnCenter:
          n = 8;
          break;
        case s.RawDirection.WrappedLineEnd:
          n = 9;
          break;
        case s.RawDirection.WrappedLineLastNonWhitespaceCharacter:
          n = 10;
          break;
        case s.RawDirection.ViewPortTop:
          n = 11;
          break;
        case s.RawDirection.ViewPortBottom:
          n = 13;
          break;
        case s.RawDirection.ViewPortCenter:
          n = 12;
          break;
        case s.RawDirection.ViewPortIfOutside:
          n = 14;
          break;
        default:
          return null;
      }
      let o = 0;
      switch (i.by) {
        case s.RawUnit.Line:
          o = 1;
          break;
        case s.RawUnit.WrappedLine:
          o = 2;
          break;
        case s.RawUnit.Character:
          o = 3;
          break;
        case s.RawUnit.HalfLine:
          o = 4;
          break;
      }
      return {
        direction: n,
        unit: o,
        select: !!i.select,
        value: i.value || 1
      };
    }
    s.parse = t;
  })(i1 || (i1 = {}));
  const UP = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
  function EV(s = "") {
    let e = "(-?\\d*\\.\\d\\w*)|([^";
    for (const t of UP)
      s.indexOf(t) >= 0 || (e += "\\" + t);
    return e += "\\s]+)", new RegExp(e, "g");
  }
  const zI = EV();
  function $P(s) {
    let e = zI;
    if (s && s instanceof RegExp)
      if (s.global)
        e = s;
      else {
        let t = "g";
        s.ignoreCase && (t += "i"), s.multiline && (t += "m"), s.unicode && (t += "u"), e = new RegExp(s.source, t);
      }
    return e.lastIndex = 0, e;
  }
  const NV = {
    maxLen: 1e3,
    windowSize: 15,
    timeBudget: 150
  };
  function $m(s, e, t, i, n = NV) {
    if (t.length > n.maxLen) {
      let c = s - n.maxLen / 2;
      return c < 0 ? c = 0 : i += c, t = t.substring(c, s + n.maxLen / 2), $m(s, e, t, i, n);
    }
    const o = Date.now(), r = s - 1 - i;
    let a = -1, l = null;
    for (let c = 1; !(Date.now() - o >= n.timeBudget); c++) {
      const d = r - n.windowSize * c;
      e.lastIndex = Math.max(0, d);
      const h = TV(e, t, r, a);
      if (!h && l || (l = h, d <= 0))
        break;
      a = d;
    }
    if (l) {
      const c = {
        word: l[0],
        startColumn: i + 1 + l.index,
        endColumn: i + 1 + l.index + l[0].length
      };
      return e.lastIndex = 0, c;
    }
    return null;
  }
  function TV(s, e, t, i) {
    let n;
    for (; n = s.exec(e); ) {
      const o = n.index || 0;
      if (o <= t && s.lastIndex >= t)
        return n;
      if (i > 0 && o > i)
        return null;
    }
    return null;
  }
  var _i;
  (function(s) {
    s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
  })(_i || (_i = {}));
  class Aw {
    constructor(e) {
      if (this._neutralCharacter = null, this._neutralCharacterSearched = !1, this.open = e.open, this.close = e.close, this._inString = !0, this._inComment = !0, this._inRegEx = !0, Array.isArray(e.notIn))
        for (let t = 0, i = e.notIn.length; t < i; t++)
          switch (e.notIn[t]) {
            case "string":
              this._inString = !1;
              break;
            case "comment":
              this._inComment = !1;
              break;
            case "regex":
              this._inRegEx = !1;
              break;
          }
    }
    isOK(e) {
      switch (e) {
        case 0:
          return !0;
        case 1:
          return this._inComment;
        case 2:
          return this._inString;
        case 3:
          return this._inRegEx;
      }
    }
    shouldAutoClose(e, t) {
      if (e.getTokenCount() === 0)
        return !0;
      const i = e.findTokenIndexAtOffset(t - 2), n = e.getStandardTokenType(i);
      return this.isOK(n);
    }
    _findNeutralCharacterInRange(e, t) {
      for (let i = e; i <= t; i++) {
        const n = String.fromCharCode(i);
        if (!this.open.includes(n) && !this.close.includes(n))
          return n;
      }
      return null;
    }
    findNeutralCharacter() {
      return this._neutralCharacterSearched || (this._neutralCharacterSearched = !0, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(48, 57)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(97, 122)), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(65, 90))), this._neutralCharacter;
    }
  }
  class MV {
    constructor(e) {
      this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
      for (const t of e)
        bg(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), bg(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), bg(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), bg(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && bg(this.autoClosingPairsCloseSingleChar, t.close, t);
    }
  }
  function bg(s, e, t) {
    s.has(e) ? s.get(e).push(t) : s.set(e, [t]);
  }
  class Uv {
    constructor(e) {
      if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new Aw(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new Aw({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.colorizedBracketPairs ? this._colorizedBracketPairs = H2(e.colorizedBracketPairs.map((t) => [t[0], t[1]])) : e.brackets ? this._colorizedBracketPairs = H2(e.brackets.map((t) => [t[0], t[1]]).filter((t) => !(t[0] === "<" && t[1] === ">"))) : this._colorizedBracketPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
        const t = e.__electricCharacterSupport.docComment;
        this._autoClosingPairs.push(new Aw({ open: t.open, close: t.close || "" }));
      }
      this._autoCloseBefore = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Uv.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
    }
    getAutoClosingPairs() {
      return this._autoClosingPairs;
    }
    getAutoCloseBeforeSet() {
      return this._autoCloseBefore;
    }
    getSurroundingPairs() {
      return this._surroundingPairs;
    }
    getColorizedBrackets() {
      return this._colorizedBracketPairs;
    }
  }
  Uv.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = `;:.,=}])> 
	`;
  function H2(s) {
    return s.filter(([e, t]) => e !== "" && t !== "");
  }
  function io(s, e = 0) {
    return s[s.length - (1 + e)];
  }
  function AV(s) {
    if (s.length === 0)
      throw new Error("Invalid tail call");
    return [s.slice(0, s.length - 1), s[s.length - 1]];
  }
  function Gs(s, e, t = (i, n) => i === n) {
    if (s === e)
      return !0;
    if (!s || !e || s.length !== e.length)
      return !1;
    for (let i = 0, n = s.length; i < n; i++)
      if (!t(s[i], e[i]))
        return !1;
    return !0;
  }
  function UI(s, e, t) {
    let i = 0, n = s.length - 1;
    for (; i <= n; ) {
      const o = (i + n) / 2 | 0, r = t(s[o], e);
      if (r < 0)
        i = o + 1;
      else if (r > 0)
        n = o - 1;
      else
        return o;
    }
    return -(i + 1);
  }
  function jP(s, e) {
    let t = 0, i = s.length;
    if (i === 0)
      return 0;
    for (; t < i; ) {
      const n = Math.floor((t + i) / 2);
      e(s[n]) ? i = n : t = n + 1;
    }
    return t;
  }
  function iL(s, e, t) {
    if (s = s | 0, s >= e.length)
      throw new TypeError("invalid index");
    let i = e[Math.floor(e.length * Math.random())], n = [], o = [], r = [];
    for (let a of e) {
      const l = t(a, i);
      l < 0 ? n.push(a) : l > 0 ? o.push(a) : r.push(a);
    }
    return s < n.length ? iL(s, n, t) : s < n.length + r.length ? r[0] : iL(s - (n.length + r.length), o, t);
  }
  function z2(s, e) {
    const t = [];
    let i;
    for (const n of s.slice(0).sort(e))
      !i || e(i[0], n) !== 0 ? (i = [n], t.push(i)) : i.push(n);
    return t;
  }
  function Nh(s) {
    return s.filter((e) => !!e);
  }
  function KP(s) {
    return !Array.isArray(s) || s.length === 0;
  }
  function Ds(s) {
    return Array.isArray(s) && s.length > 0;
  }
  function Cc(s, e = (t) => t) {
    const t = /* @__PURE__ */ new Set();
    return s.filter((i) => {
      const n = e(i);
      return t.has(n) ? !1 : (t.add(n), !0);
    });
  }
  function RV(s, e) {
    const t = OV(s, e);
    if (t !== -1)
      return s[t];
  }
  function OV(s, e) {
    for (let t = s.length - 1; t >= 0; t--) {
      const i = s[t];
      if (e(i))
        return t;
    }
    return -1;
  }
  function qP(s, e) {
    return s.length > 0 ? s[0] : e;
  }
  function $I(s) {
    return [].concat(...s);
  }
  function Vn(s, e) {
    let t = typeof e == "number" ? s : 0;
    typeof e == "number" ? t = s : (t = 0, e = s);
    const i = [];
    if (t <= e)
      for (let n = t; n < e; n++)
        i.push(n);
    else
      for (let n = t; n > e; n--)
        i.push(n);
    return i;
  }
  function $v(s, e, t) {
    const i = s.slice(0, e), n = s.slice(e);
    return i.concat(t, n);
  }
  function Rw(s, e) {
    const t = s.indexOf(e);
    t > -1 && (s.splice(t, 1), s.unshift(e));
  }
  function j_(s, e) {
    const t = s.indexOf(e);
    t > -1 && (s.splice(t, 1), s.push(e));
  }
  function jI(s) {
    return Array.isArray(s) ? s : [s];
  }
  function PV(s, e, t) {
    const i = GP(s, e), n = s.length, o = t.length;
    s.length = n + o;
    for (let r = n - 1; r >= i; r--)
      s[r + o] = s[r];
    for (let r = 0; r < o; r++)
      s[r + i] = t[r];
  }
  function U2(s, e, t, i) {
    const n = GP(s, e), o = s.splice(n, t);
    return PV(s, n, i), o;
  }
  function GP(s, e) {
    return e < 0 ? Math.max(e + s.length, 0) : Math.min(e, s.length);
  }
  function o0(s, e) {
    return (t, i) => e(s(t), s(i));
  }
  const FV = (s, e) => s - e;
  function ZP(s, e) {
    if (s.length === 0)
      return;
    let t = s[0];
    for (let i = 1; i < s.length; i++) {
      const n = s[i];
      e(n, t) > 0 && (t = n);
    }
    return t;
  }
  function BV(s, e) {
    if (s.length === 0)
      return;
    let t = s[0];
    for (let i = 1; i < s.length; i++) {
      const n = s[i];
      e(n, t) >= 0 && (t = n);
    }
    return t;
  }
  function WV(s, e) {
    return ZP(s, (t, i) => -e(t, i));
  }
  class bf {
    constructor(e) {
      this.items = e, this.firstIdx = 0, this.lastIdx = this.items.length - 1;
    }
    takeWhile(e) {
      let t = this.firstIdx;
      for (; t < this.items.length && e(this.items[t]); )
        t++;
      const i = t === this.firstIdx ? null : this.items.slice(this.firstIdx, t);
      return this.firstIdx = t, i;
    }
    takeFromEndWhile(e) {
      let t = this.lastIdx;
      for (; t >= 0 && e(this.items[t]); )
        t--;
      const i = t === this.lastIdx ? null : this.items.slice(t + 1, this.lastIdx + 1);
      return this.lastIdx = t, i;
    }
    peek() {
      return this.items[this.firstIdx];
    }
    dequeue() {
      const e = this.items[this.firstIdx];
      return this.firstIdx++, e;
    }
    takeCount(e) {
      const t = this.items.slice(this.firstIdx, this.firstIdx + e);
      return this.firstIdx += e, t;
    }
  }
  const $2 = typeof Buffer < "u";
  let Ow;
  class jv {
    constructor(e) {
      this.buffer = e, this.byteLength = this.buffer.byteLength;
    }
    static wrap(e) {
      return $2 && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new jv(e);
    }
    toString() {
      return $2 ? this.buffer.toString() : (Ow || (Ow = new TextDecoder()), Ow.decode(this.buffer));
    }
  }
  function VV(s, e) {
    return s[e + 0] << 0 >>> 0 | s[e + 1] << 8 >>> 0;
  }
  function HV(s, e, t) {
    s[t + 0] = e & 255, e = e >>> 8, s[t + 1] = e & 255;
  }
  function ir(s, e) {
    return s[e] * Math.pow(2, 24) + s[e + 1] * Math.pow(2, 16) + s[e + 2] * Math.pow(2, 8) + s[e + 3];
  }
  function nr(s, e, t) {
    s[t + 3] = e, e = e >>> 8, s[t + 2] = e, e = e >>> 8, s[t + 1] = e, e = e >>> 8, s[t] = e;
  }
  function j2(s, e) {
    return s[e];
  }
  function K2(s, e, t) {
    s[t] = e;
  }
  let Pw;
  function YP() {
    return Pw || (Pw = new TextDecoder("UTF-16LE")), Pw;
  }
  let Fw;
  function zV() {
    return Fw || (Fw = new TextDecoder("UTF-16BE")), Fw;
  }
  let Bw;
  function XP() {
    return Bw || (Bw = q4() ? YP() : zV()), Bw;
  }
  const QP = typeof TextDecoder < "u";
  let Zd, nL;
  QP ? (Zd = (s) => new $V(s), nL = UV) : (Zd = (s) => new jV(), nL = JP);
  function UV(s, e, t) {
    const i = new Uint16Array(s.buffer, e, t);
    return t > 0 && (i[0] === 65279 || i[0] === 65534) ? JP(s, e, t) : YP().decode(i);
  }
  function JP(s, e, t) {
    const i = [];
    let n = 0;
    for (let o = 0; o < t; o++) {
      const r = VV(s, e);
      e += 2, i[n++] = String.fromCharCode(r);
    }
    return i.join("");
  }
  class $V {
    constructor(e) {
      this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
    }
    reset() {
      this._completedStrings = null, this._bufferLength = 0;
    }
    build() {
      return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
    }
    _buildBuffer() {
      if (this._bufferLength === 0)
        return "";
      const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
      return XP().decode(e);
    }
    _flushBuffer() {
      const e = this._buildBuffer();
      this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
    }
    write1(e) {
      const t = this._capacity - this._bufferLength;
      t <= 1 && (t === 0 || Pi(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
    }
    appendASCII(e) {
      this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
    }
    appendASCIIString(e) {
      const t = e.length;
      if (this._bufferLength + t >= this._capacity) {
        this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
        return;
      }
      for (let i = 0; i < t; i++)
        this._buffer[this._bufferLength++] = e.charCodeAt(i);
    }
  }
  class jV {
    constructor() {
      this._pieces = [], this._piecesLen = 0;
    }
    reset() {
      this._pieces = [], this._piecesLen = 0;
    }
    build() {
      return this._pieces.join("");
    }
    write1(e) {
      this._pieces[this._piecesLen++] = String.fromCharCode(e);
    }
    appendASCII(e) {
      this._pieces[this._piecesLen++] = String.fromCharCode(e);
    }
    appendASCIIString(e) {
      this._pieces[this._piecesLen++] = e;
    }
  }
  class n1 {
    constructor(e, t, i, n, o, r) {
      this._richEditBracketBrand = void 0, this.languageId = e, this.index = t, this.open = i, this.close = n, this.forwardRegex = o, this.reversedRegex = r, this._openSet = n1._toSet(this.open), this._closeSet = n1._toSet(this.close);
    }
    isOpen(e) {
      return this._openSet.has(e);
    }
    isClose(e) {
      return this._closeSet.has(e);
    }
    static _toSet(e) {
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      return t;
    }
  }
  function KV(s) {
    const e = s.length;
    s = s.map((r) => [r[0].toLowerCase(), r[1].toLowerCase()]);
    const t = [];
    for (let r = 0; r < e; r++)
      t[r] = r;
    const i = (r, a) => {
      const [l, c] = r, [d, h] = a;
      return l === d || l === h || c === d || c === h;
    }, n = (r, a) => {
      const l = Math.min(r, a), c = Math.max(r, a);
      for (let d = 0; d < e; d++)
        t[d] === c && (t[d] = l);
    };
    for (let r = 0; r < e; r++) {
      const a = s[r];
      for (let l = r + 1; l < e; l++) {
        const c = s[l];
        i(a, c) && n(t[r], t[l]);
      }
    }
    const o = [];
    for (let r = 0; r < e; r++) {
      const a = [], l = [];
      for (let c = 0; c < e; c++)
        if (t[c] === r) {
          const [d, h] = s[c];
          a.push(d), l.push(h);
        }
      a.length > 0 && o.push({
        open: a,
        close: l
      });
    }
    return o;
  }
  class qV {
    constructor(e, t) {
      this._richEditBracketsBrand = void 0;
      const i = KV(t);
      this.brackets = i.map((n, o) => new n1(e, o, n.open, n.close, GV(n.open, n.close, i, o), ZV(n.open, n.close, i, o))), this.forwardRegex = YV(this.brackets), this.reversedRegex = XV(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
      for (const n of this.brackets) {
        for (const o of n.open)
          this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
        for (const o of n.close)
          this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
      }
    }
  }
  function e5(s, e, t, i) {
    for (let n = 0, o = e.length; n < o; n++) {
      if (n === t)
        continue;
      const r = e[n];
      for (const a of r.open)
        a.indexOf(s) >= 0 && i.push(a);
      for (const a of r.close)
        a.indexOf(s) >= 0 && i.push(a);
    }
  }
  function t5(s, e) {
    return s.length - e.length;
  }
  function Kv(s) {
    if (s.length <= 1)
      return s;
    const e = [], t = /* @__PURE__ */ new Set();
    for (const i of s)
      t.has(i) || (e.push(i), t.add(i));
    return e;
  }
  function GV(s, e, t, i) {
    let n = [];
    n = n.concat(s), n = n.concat(e);
    for (let o = 0, r = n.length; o < r; o++)
      e5(n[o], t, i, n);
    return n = Kv(n), n.sort(t5), n.reverse(), qv(n);
  }
  function ZV(s, e, t, i) {
    let n = [];
    n = n.concat(s), n = n.concat(e);
    for (let o = 0, r = n.length; o < r; o++)
      e5(n[o], t, i, n);
    return n = Kv(n), n.sort(t5), n.reverse(), qv(n.map(KI));
  }
  function YV(s) {
    let e = [];
    for (const t of s) {
      for (const i of t.open)
        e.push(i);
      for (const i of t.close)
        e.push(i);
    }
    return e = Kv(e), qv(e);
  }
  function XV(s) {
    let e = [];
    for (const t of s) {
      for (const i of t.open)
        e.push(i);
      for (const i of t.close)
        e.push(i);
    }
    return e = Kv(e), qv(e.map(KI));
  }
  function QV(s) {
    const e = /^[\w ]+$/.test(s);
    return s = wo(s), e ? `\\b${s}\\b` : s;
  }
  function qv(s) {
    const e = `(${s.map(QV).join(")|(")})`;
    return kP(e, !0);
  }
  const KI = function() {
    function s(i) {
      if (QP) {
        const n = new Uint16Array(i.length);
        let o = 0;
        for (let r = i.length - 1; r >= 0; r--)
          n[o++] = i.charCodeAt(r);
        return XP().decode(n);
      } else {
        const n = [];
        let o = 0;
        for (let r = i.length - 1; r >= 0; r--)
          n[o++] = i.charAt(r);
        return n.join("");
      }
    }
    let e = null, t = null;
    return function(n) {
      return e !== n && (e = n, t = s(e)), t;
    };
  }();
  class Fo {
    static _findPrevBracketInText(e, t, i, n) {
      const o = i.match(e);
      if (!o)
        return null;
      const r = i.length - (o.index || 0), a = o[0].length, l = n + r;
      return new D(t, l - a + 1, t, l + 1);
    }
    static findPrevBracketInRange(e, t, i, n, o) {
      const a = KI(i).substring(i.length - o, i.length - n);
      return this._findPrevBracketInText(e, t, a, n);
    }
    static findNextBracketInText(e, t, i, n) {
      const o = i.match(e);
      if (!o)
        return null;
      const r = o.index || 0, a = o[0].length;
      if (a === 0)
        return null;
      const l = n + r;
      return new D(t, l + 1, t, l + 1 + a);
    }
    static findNextBracketInRange(e, t, i, n, o) {
      const r = i.substring(n, o);
      return this.findNextBracketInText(e, t, r, n);
    }
  }
  class JV {
    constructor(e) {
      this._richEditBrackets = e;
    }
    getElectricCharacters() {
      const e = [];
      if (this._richEditBrackets)
        for (const t of this._richEditBrackets.brackets)
          for (const i of t.close) {
            const n = i.charAt(i.length - 1);
            e.push(n);
          }
      return Cc(e);
    }
    onElectricCharacter(e, t, i) {
      if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
        return null;
      const n = t.findTokenIndexAtOffset(i - 1);
      if (Mr(t.getStandardTokenType(n)))
        return null;
      const o = this._richEditBrackets.reversedRegex, r = t.getLineContent().substring(0, i - 1) + e, a = Fo.findPrevBracketInRange(o, 1, r, 0, r.length);
      if (!a)
        return null;
      const l = r.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
      if (this._richEditBrackets.textIsOpenBracket[l])
        return null;
      const d = t.getActualLineContentBefore(a.startColumn - 1);
      return /^\s*$/.test(d) ? {
        matchOpenBracket: l
      } : null;
    }
  }
  function K_(s) {
    return s.global && (s.lastIndex = 0), !0;
  }
  class eH {
    constructor(e) {
      this._indentationRules = e;
    }
    shouldIncrease(e) {
      return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && K_(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
    }
    shouldDecrease(e) {
      return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && K_(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
    }
    shouldIndentNextLine(e) {
      return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && K_(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
    }
    shouldIgnore(e) {
      return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && K_(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
    }
    getIndentMetadata(e) {
      let t = 0;
      return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
    }
  }
  class ku {
    constructor(e) {
      e = e || {}, e.brackets = e.brackets || [
        ["(", ")"],
        ["{", "}"],
        ["[", "]"]
      ], this._brackets = [], e.brackets.forEach((t) => {
        const i = ku._createOpenBracketRegExp(t[0]), n = ku._createCloseBracketRegExp(t[1]);
        i && n && this._brackets.push({
          open: t[0],
          openRegExp: i,
          close: t[1],
          closeRegExp: n
        });
      }), this._regExpRules = e.onEnterRules || [];
    }
    onEnter(e, t, i, n) {
      if (e >= 3)
        for (let o = 0, r = this._regExpRules.length; o < r; o++) {
          const a = this._regExpRules[o];
          if ([{
            reg: a.beforeText,
            text: i
          }, {
            reg: a.afterText,
            text: n
          }, {
            reg: a.previousLineText,
            text: t
          }].every((c) => c.reg ? (c.reg.lastIndex = 0, c.reg.test(c.text)) : !0))
            return a.action;
        }
      if (e >= 2 && i.length > 0 && n.length > 0)
        for (let o = 0, r = this._brackets.length; o < r; o++) {
          const a = this._brackets[o];
          if (a.openRegExp.test(i) && a.closeRegExp.test(n))
            return { indentAction: _i.IndentOutdent };
        }
      if (e >= 2 && i.length > 0) {
        for (let o = 0, r = this._brackets.length; o < r; o++)
          if (this._brackets[o].openRegExp.test(i))
            return { indentAction: _i.Indent };
      }
      return null;
    }
    static _createOpenBracketRegExp(e) {
      let t = wo(e);
      return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", ku._safeRegExp(t);
    }
    static _createCloseBracketRegExp(e) {
      let t = wo(e);
      return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, ku._safeRegExp(t);
    }
    static _safeRegExp(e) {
      try {
        return new RegExp(e);
      } catch (t) {
        return We(t), null;
      }
    }
  }
  const At = st("configurationService");
  function i5(s, e) {
    const t = /* @__PURE__ */ Object.create(null);
    for (let i in s)
      qI(t, i, s[i], e);
    return t;
  }
  function qI(s, e, t, i) {
    const n = e.split("."), o = n.pop();
    let r = s;
    for (let a = 0; a < n.length; a++) {
      let l = n[a], c = r[l];
      switch (typeof c) {
        case "undefined":
          c = r[l] = /* @__PURE__ */ Object.create(null);
          break;
        case "object":
          break;
        default:
          i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(c)}`);
          return;
      }
      r = c;
    }
    if (typeof r == "object" && r !== null)
      try {
        r[o] = t;
      } catch {
        i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
      }
    else
      i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
  }
  function tH(s, e) {
    const t = e.split(".");
    n5(s, t);
  }
  function n5(s, e) {
    const t = e.shift();
    if (e.length === 0) {
      delete s[t];
      return;
    }
    if (Object.keys(s).indexOf(t) !== -1) {
      const i = s[t];
      typeof i == "object" && !Array.isArray(i) && (n5(i, e), Object.keys(i).length === 0 && delete s[t]);
    }
  }
  function q2(s, e, t) {
    function i(r, a) {
      let l = r;
      for (const c of a) {
        if (typeof l != "object" || l === null)
          return;
        l = l[c];
      }
      return l;
    }
    const n = e.split("."), o = i(s, n);
    return typeof o > "u" ? t : o;
  }
  const Jt = st("languageService");
  class Vr {
    constructor(e, t = [], i = !1) {
      this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
    }
  }
  const s5 = [];
  function ht(s, e, t) {
    e instanceof Vr || (e = new Vr(e, [], t)), s5.push([s, e]);
  }
  function G2() {
    return s5;
  }
  var iH = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Z2 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class Ww {
    constructor(e) {
      this.languageId = e;
    }
    affects(e) {
      return this.languageId ? this.languageId === e : !0;
    }
  }
  const Mn = st("languageConfigurationService");
  let sL = class extends z {
    constructor(e, t) {
      super(), this.configurationService = e, this.languageService = t, this.onDidChangeEmitter = this._register(new B()), this.onDidChange = this.onDidChangeEmitter.event, this.configurations = /* @__PURE__ */ new Map();
      const i = new Set(Object.values(oL));
      this._register(this.configurationService.onDidChangeConfiguration((n) => {
        const o = n.change.keys.some((a) => i.has(a)), r = n.change.overrides.filter(([a, l]) => l.some((c) => i.has(c))).map(([a]) => a);
        if (o)
          this.configurations.clear(), this.onDidChangeEmitter.fire(new Ww(void 0));
        else
          for (const a of r)
            this.languageService.isRegisteredLanguageId(a) && (this.configurations.delete(a), this.onDidChangeEmitter.fire(new Ww(a)));
      })), this._register(Di.onDidChange((n) => {
        this.configurations.delete(n.languageId), this.onDidChangeEmitter.fire(new Ww(n.languageId));
      }));
    }
    getLanguageConfiguration(e) {
      let t = this.configurations.get(e);
      return t || (t = nH(e, this.configurationService, this.languageService), this.configurations.set(e, t)), t;
    }
  };
  sL = iH([
    Z2(0, At),
    Z2(1, Jt)
  ], sL);
  function nH(s, e, t) {
    let i = Di.getLanguageConfiguration(s);
    if (!i) {
      if (!t.isRegisteredLanguageId(s))
        throw new Error(`Language id "${s}" is not configured nor known`);
      i = new jm(s, {});
    }
    const n = sH(i.languageId, e), o = o5([i.underlyingConfig, n]);
    return new jm(i.languageId, o);
  }
  const oL = {
    brackets: "editor.language.brackets",
    colorizedBracketPairs: "editor.language.colorizedBracketPairs"
  };
  function sH(s, e) {
    const t = e.getValue(oL.brackets, {
      overrideIdentifier: s
    }), i = e.getValue(oL.colorizedBracketPairs, {
      overrideIdentifier: s
    });
    return {
      brackets: Y2(t),
      colorizedBracketPairs: Y2(i)
    };
  }
  function Y2(s) {
    if (!!Array.isArray(s))
      return s.map((e) => {
        if (!(!Array.isArray(e) || e.length !== 2))
          return [e[0], e[1]];
      }).filter((e) => !!e);
  }
  class X2 {
    constructor(e) {
      this.languageId = e;
    }
  }
  class oH {
    constructor() {
      this._entries = /* @__PURE__ */ new Map(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event;
    }
    register(e, t, i = 0) {
      let n = this._entries.get(e);
      n || (n = new rH(e), this._entries.set(e, n));
      const o = n.register(t, i);
      return this._onDidChange.fire(new X2(e)), qe(() => {
        o.dispose(), this._onDidChange.fire(new X2(e));
      });
    }
    getLanguageConfiguration(e) {
      const t = this._entries.get(e);
      return t?.getResolvedConfiguration() || null;
    }
    getComments(e) {
      const t = this.getLanguageConfiguration(e);
      return t && t.comments || null;
    }
    getIndentRulesSupport(e) {
      const t = this.getLanguageConfiguration(e);
      return t && t.indentRulesSupport || null;
    }
    getPrecedingValidLine(e, t, i) {
      const n = e.getLanguageIdAtPosition(t, 0);
      if (t > 1) {
        let o, r = -1;
        for (o = t - 1; o >= 1; o--) {
          if (e.getLanguageIdAtPosition(o, 0) !== n)
            return r;
          const a = e.getLineContent(o);
          if (i.shouldIgnore(a) || /^\s+$/.test(a) || a === "") {
            r = o;
            continue;
          }
          return o;
        }
      }
      return -1;
    }
    getInheritIndentForLine(e, t, i, n = !0) {
      if (e < 4)
        return null;
      const o = this.getIndentRulesSupport(t.getLanguageId());
      if (!o)
        return null;
      if (i <= 1)
        return {
          indentation: "",
          action: null
        };
      const r = this.getPrecedingValidLine(t, i, o);
      if (r < 0)
        return null;
      if (r < 1)
        return {
          indentation: "",
          action: null
        };
      const a = t.getLineContent(r);
      if (o.shouldIncrease(a) || o.shouldIndentNextLine(a))
        return {
          indentation: Dt(a),
          action: _i.Indent,
          line: r
        };
      if (o.shouldDecrease(a))
        return {
          indentation: Dt(a),
          action: null,
          line: r
        };
      {
        if (r === 1)
          return {
            indentation: Dt(t.getLineContent(r)),
            action: null,
            line: r
          };
        const l = r - 1, c = o.getIndentMetadata(t.getLineContent(l));
        if (!(c & 3) && c & 4) {
          let d = 0;
          for (let h = l - 1; h > 0; h--)
            if (!o.shouldIndentNextLine(t.getLineContent(h))) {
              d = h;
              break;
            }
          return {
            indentation: Dt(t.getLineContent(d + 1)),
            action: null,
            line: d + 1
          };
        }
        if (n)
          return {
            indentation: Dt(t.getLineContent(r)),
            action: null,
            line: r
          };
        for (let d = r; d > 0; d--) {
          const h = t.getLineContent(d);
          if (o.shouldIncrease(h))
            return {
              indentation: Dt(h),
              action: _i.Indent,
              line: d
            };
          if (o.shouldIndentNextLine(h)) {
            let u = 0;
            for (let f = d - 1; f > 0; f--)
              if (!o.shouldIndentNextLine(t.getLineContent(d))) {
                u = f;
                break;
              }
            return {
              indentation: Dt(t.getLineContent(u + 1)),
              action: null,
              line: u + 1
            };
          } else if (o.shouldDecrease(h))
            return {
              indentation: Dt(h),
              action: null,
              line: d
            };
        }
        return {
          indentation: Dt(t.getLineContent(1)),
          action: null,
          line: 1
        };
      }
    }
    getGoodIndentForLine(e, t, i, n, o) {
      if (e < 4)
        return null;
      const r = this.getLanguageConfiguration(i);
      if (!r)
        return null;
      const a = this.getIndentRulesSupport(i);
      if (!a)
        return null;
      const l = this.getInheritIndentForLine(e, t, n), c = t.getLineContent(n);
      if (l) {
        const d = l.line;
        if (d !== void 0) {
          const h = r.onEnter(e, "", t.getLineContent(d), "");
          if (h) {
            let u = Dt(t.getLineContent(d));
            return h.removeText && (u = u.substring(0, u.length - h.removeText)), h.indentAction === _i.Indent || h.indentAction === _i.IndentOutdent ? u = o.shiftIndent(u) : h.indentAction === _i.Outdent && (u = o.unshiftIndent(u)), a.shouldDecrease(c) && (u = o.unshiftIndent(u)), h.appendText && (u += h.appendText), Dt(u);
          }
        }
        return a.shouldDecrease(c) ? l.action === _i.Indent ? l.indentation : o.unshiftIndent(l.indentation) : l.action === _i.Indent ? o.shiftIndent(l.indentation) : l.indentation;
      }
      return null;
    }
    getIndentForEnter(e, t, i, n) {
      if (e < 4)
        return null;
      t.forceTokenization(i.startLineNumber);
      const o = t.getLineTokens(i.startLineNumber), r = J0(o, i.startColumn - 1), a = r.getLineContent();
      let l = !1, c;
      r.firstCharOffset > 0 && o.getLanguageId(0) !== r.languageId ? (l = !0, c = a.substr(0, i.startColumn - 1 - r.firstCharOffset)) : c = o.getLineContent().substring(0, i.startColumn - 1);
      let d;
      i.isEmpty() ? d = a.substr(i.startColumn - 1 - r.firstCharOffset) : d = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - r.firstCharOffset);
      const h = this.getIndentRulesSupport(r.languageId);
      if (!h)
        return null;
      const u = c, f = Dt(c), g = {
        getLineTokens: (v) => t.getLineTokens(v),
        getLanguageId: () => t.getLanguageId(),
        getLanguageIdAtPosition: (v, w) => t.getLanguageIdAtPosition(v, w),
        getLineContent: (v) => v === i.startLineNumber ? u : t.getLineContent(v)
      }, _ = Dt(o.getLineContent()), b = this.getInheritIndentForLine(e, g, i.startLineNumber + 1);
      if (!b) {
        const v = l ? _ : f;
        return {
          beforeEnter: v,
          afterEnter: v
        };
      }
      let C = l ? _ : b.indentation;
      return b.action === _i.Indent && (C = n.shiftIndent(C)), h.shouldDecrease(d) && (C = n.unshiftIndent(C)), {
        beforeEnter: l ? _ : f,
        afterEnter: C
      };
    }
    getIndentActionForType(e, t, i, n, o) {
      if (e < 4)
        return null;
      const r = this.getScopedLineTokens(t, i.startLineNumber, i.startColumn);
      if (r.firstCharOffset)
        return null;
      const a = this.getIndentRulesSupport(r.languageId);
      if (!a)
        return null;
      const l = r.getLineContent(), c = l.substr(0, i.startColumn - 1 - r.firstCharOffset);
      let d;
      if (i.isEmpty() ? d = l.substr(i.startColumn - 1 - r.firstCharOffset) : d = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - r.firstCharOffset), !a.shouldDecrease(c + d) && a.shouldDecrease(c + n + d)) {
        const h = this.getInheritIndentForLine(e, t, i.startLineNumber, !1);
        if (!h)
          return null;
        let u = h.indentation;
        return h.action !== _i.Indent && (u = o.unshiftIndent(u)), u;
      }
      return null;
    }
    getIndentMetadata(e, t) {
      const i = this.getIndentRulesSupport(e.getLanguageId());
      return !i || t < 1 || t > e.getLineCount() ? null : i.getIndentMetadata(e.getLineContent(t));
    }
    getEnterAction(e, t, i) {
      const n = this.getScopedLineTokens(t, i.startLineNumber, i.startColumn), o = this.getLanguageConfiguration(n.languageId);
      if (!o)
        return null;
      const r = n.getLineContent(), a = r.substr(0, i.startColumn - 1 - n.firstCharOffset);
      let l;
      i.isEmpty() ? l = r.substr(i.startColumn - 1 - n.firstCharOffset) : l = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - n.firstCharOffset);
      let c = "";
      if (i.startLineNumber > 1 && n.firstCharOffset === 0) {
        const _ = this.getScopedLineTokens(t, i.startLineNumber - 1);
        _.languageId === n.languageId && (c = _.getLineContent());
      }
      const d = o.onEnter(e, c, a, l);
      if (!d)
        return null;
      const h = d.indentAction;
      let u = d.appendText;
      const f = d.removeText || 0;
      u ? h === _i.Indent && (u = "	" + u) : h === _i.Indent || h === _i.IndentOutdent ? u = "	" : u = "";
      let g = this.getIndentationAtPosition(t, i.startLineNumber, i.startColumn);
      return f && (g = g.substring(0, g.length - f)), {
        indentAction: h,
        appendText: u,
        removeText: f,
        indentation: g
      };
    }
    getIndentationAtPosition(e, t, i) {
      const n = e.getLineContent(t);
      let o = Dt(n);
      return o.length > i - 1 && (o = o.substring(0, i - 1)), o;
    }
    getScopedLineTokens(e, t, i) {
      e.forceTokenization(t);
      const n = e.getLineTokens(t), o = typeof i > "u" ? e.getLineMaxColumn(t) - 1 : i - 1;
      return J0(n, o);
    }
  }
  const Di = new oH();
  class rH {
    constructor(e) {
      this.languageId = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
    }
    register(e, t) {
      const i = new Q2(e, t, ++this._order);
      return this._entries.push(i), this._resolved = null, qe(() => {
        for (let n = 0; n < this._entries.length; n++)
          if (this._entries[n] === i) {
            this._entries.splice(n, 1), this._resolved = null;
            break;
          }
      });
    }
    getResolvedConfiguration() {
      if (!this._resolved) {
        const e = this._resolve();
        e && (this._resolved = new jm(this.languageId, e));
      }
      return this._resolved;
    }
    _resolve() {
      return this._entries.length === 0 ? null : (this._entries.sort(Q2.cmp), o5(this._entries.map((e) => e.configuration)));
    }
  }
  function o5(s) {
    let e = {
      comments: void 0,
      brackets: void 0,
      wordPattern: void 0,
      indentationRules: void 0,
      onEnterRules: void 0,
      autoClosingPairs: void 0,
      surroundingPairs: void 0,
      autoCloseBefore: void 0,
      folding: void 0,
      colorizedBracketPairs: void 0,
      __electricCharacterSupport: void 0
    };
    for (const t of s)
      e = {
        comments: t.comments || e.comments,
        brackets: t.brackets || e.brackets,
        wordPattern: t.wordPattern || e.wordPattern,
        indentationRules: t.indentationRules || e.indentationRules,
        onEnterRules: t.onEnterRules || e.onEnterRules,
        autoClosingPairs: t.autoClosingPairs || e.autoClosingPairs,
        surroundingPairs: t.surroundingPairs || e.surroundingPairs,
        autoCloseBefore: t.autoCloseBefore || e.autoCloseBefore,
        folding: t.folding || e.folding,
        colorizedBracketPairs: t.colorizedBracketPairs || e.colorizedBracketPairs,
        __electricCharacterSupport: t.__electricCharacterSupport || e.__electricCharacterSupport
      };
    return e;
  }
  class Q2 {
    constructor(e, t, i) {
      this.configuration = e, this.priority = t, this.order = i;
    }
    static cmp(e, t) {
      return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
    }
  }
  class jm {
    constructor(e, t) {
      this.languageId = e, this.underlyingConfig = t, this._brackets = null, this._electricCharacter = null, this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new ku(this.underlyingConfig) : null, this.comments = jm._handleComments(this.underlyingConfig), this.characterPair = new Uv(this.underlyingConfig), this.wordDefinition = this.underlyingConfig.wordPattern || zI, this.indentationRules = this.underlyingConfig.indentationRules, this.underlyingConfig.indentationRules ? this.indentRulesSupport = new eH(this.underlyingConfig.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this.underlyingConfig.folding || {};
    }
    getWordDefinition() {
      return $P(this.wordDefinition);
    }
    get brackets() {
      return !this._brackets && this.underlyingConfig.brackets && (this._brackets = new qV(this.languageId, this.underlyingConfig.brackets)), this._brackets;
    }
    get electricCharacter() {
      return this._electricCharacter || (this._electricCharacter = new JV(this.brackets)), this._electricCharacter;
    }
    onEnter(e, t, i, n) {
      return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, n) : null;
    }
    getAutoClosingPairs() {
      return new MV(this.characterPair.getAutoClosingPairs());
    }
    getAutoCloseBeforeSet() {
      return this.characterPair.getAutoCloseBeforeSet();
    }
    getSurroundingPairs() {
      return this.characterPair.getSurroundingPairs();
    }
    static _handleComments(e) {
      const t = e.comments;
      if (!t)
        return null;
      const i = {};
      if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
        const [n, o] = t.blockComment;
        i.blockCommentStartToken = n, i.blockCommentEndToken = o;
      }
      return i;
    }
  }
  ht(Mn, sL);
  const Vw = /* @__PURE__ */ Object.create(null);
  function Gc(s, e) {
    if (e <= 0)
      return "";
    Vw[s] || (Vw[s] = ["", s]);
    const t = Vw[s];
    for (let i = t.length; i <= e; i++)
      t[i] = t[i - 1] + s;
    return t[e];
  }
  class Hs {
    constructor(e, t) {
      this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
    }
    static unshiftIndent(e, t, i, n, o) {
      const r = Oi.visibleColumnFromColumn(e, t, i);
      if (o) {
        const a = Gc(" ", n), c = Oi.prevIndentTabStop(r, n) / n;
        return Gc(a, c);
      } else {
        const a = "	", c = Oi.prevRenderTabStop(r, i) / i;
        return Gc(a, c);
      }
    }
    static shiftIndent(e, t, i, n, o) {
      const r = Oi.visibleColumnFromColumn(e, t, i);
      if (o) {
        const a = Gc(" ", n), c = Oi.nextIndentTabStop(r, n) / n;
        return Gc(a, c);
      } else {
        const a = "	", c = Oi.nextRenderTabStop(r, i) / i;
        return Gc(a, c);
      }
    }
    _addEditOperation(e, t, i) {
      this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
    }
    getEditOperations(e, t) {
      const i = this._selection.startLineNumber;
      let n = this._selection.endLineNumber;
      this._selection.endColumn === 1 && i !== n && (n = n - 1);
      const { tabSize: o, indentSize: r, insertSpaces: a } = this._opts, l = i === n;
      if (this._opts.useTabStops) {
        this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
        let c = 0, d = 0;
        for (let h = i; h <= n; h++, c = d) {
          d = 0;
          const u = e.getLineContent(h);
          let f = jn(u);
          if (this._opts.isUnshift && (u.length === 0 || f === 0) || !l && !this._opts.isUnshift && u.length === 0)
            continue;
          if (f === -1 && (f = u.length), h > 1 && Oi.visibleColumnFromColumn(u, f + 1, o) % r !== 0 && e.isCheapToTokenize(h - 1)) {
            const b = Di.getEnterAction(this._opts.autoIndent, e, new D(h - 1, e.getLineMaxColumn(h - 1), h - 1, e.getLineMaxColumn(h - 1)));
            if (b) {
              if (d = c, b.appendText)
                for (let C = 0, v = b.appendText.length; C < v && d < r && b.appendText.charCodeAt(C) === 32; C++)
                  d++;
              b.removeText && (d = Math.max(0, d - b.removeText));
              for (let C = 0; C < d && !(f === 0 || u.charCodeAt(f - 1) !== 32); C++)
                f--;
            }
          }
          if (this._opts.isUnshift && f === 0)
            continue;
          let g;
          this._opts.isUnshift ? g = Hs.unshiftIndent(u, f + 1, o, r, a) : g = Hs.shiftIndent(u, f + 1, o, r, a), this._addEditOperation(t, new D(h, 1, h, f + 1), g), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= f + 1);
        }
      } else {
        !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
        const c = a ? Gc(" ", r) : "	";
        for (let d = i; d <= n; d++) {
          const h = e.getLineContent(d);
          let u = jn(h);
          if (!(this._opts.isUnshift && (h.length === 0 || u === 0)) && !(!l && !this._opts.isUnshift && h.length === 0) && (u === -1 && (u = h.length), !(this._opts.isUnshift && u === 0)))
            if (this._opts.isUnshift) {
              u = Math.min(u, r);
              for (let f = 0; f < u; f++)
                if (h.charCodeAt(f) === 9) {
                  u = f + 1;
                  break;
                }
              this._addEditOperation(t, new D(d, 1, d, u + 1), "");
            } else
              this._addEditOperation(t, new D(d, 1, d, 1), c), d === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
        }
      }
      this._selectionId = t.trackSelection(this._selection);
    }
    computeCursorState(e, t) {
      if (this._useLastEditRangeForCursorEndPosition) {
        const n = t.getInverseEditOperations()[0];
        return new ae(n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn);
      }
      const i = t.getTrackedSelection(this._selectionId);
      if (this._selectionStartColumnStaysPut) {
        const n = this._selection.startColumn;
        return i.startColumn <= n ? i : i.getDirection() === 0 ? new ae(i.startLineNumber, n, i.endLineNumber, i.endColumn) : new ae(i.endLineNumber, i.endColumn, i.startLineNumber, n);
      }
      return i;
    }
  }
  class aH {
    constructor(e, t, i) {
      this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
    }
    getEditOperations(e, t) {
      t.addTrackedEditOperation(new D(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new D(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
    }
    computeCursorState(e, t) {
      const i = t.getInverseEditOperations(), n = i[0].range, o = i[1].range;
      return new ae(n.endLineNumber, n.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length);
    }
  }
  class Gt {
    static indent(e, t, i) {
      if (t === null || i === null)
        return [];
      const n = [];
      for (let o = 0, r = i.length; o < r; o++)
        n[o] = new Hs(i[o], {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        });
      return n;
    }
    static outdent(e, t, i) {
      const n = [];
      for (let o = 0, r = i.length; o < r; o++)
        n[o] = new Hs(i[o], {
          isUnshift: !0,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        });
      return n;
    }
    static shiftIndent(e, t, i) {
      return i = i || 1, Hs.shiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
    }
    static unshiftIndent(e, t, i) {
      return i = i || 1, Hs.unshiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
    }
    static _distributedPaste(e, t, i, n) {
      const o = [];
      for (let r = 0, a = i.length; r < a; r++)
        o[r] = new fn(i[r], n[r]);
      return new _s(0, o, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !0
      });
    }
    static _simplePaste(e, t, i, n, o) {
      const r = [];
      for (let a = 0, l = i.length; a < l; a++) {
        const c = i[a], d = c.getPosition();
        if (o && !c.isEmpty() && (o = !1), o && n.indexOf(`
`) !== n.length - 1 && (o = !1), o) {
          const h = new D(d.lineNumber, 1, d.lineNumber, 1);
          r[a] = new HI(h, n, c, !0);
        } else
          r[a] = new fn(c, n);
      }
      return new _s(0, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !0
      });
    }
    static _distributePasteToCursors(e, t, i, n, o) {
      if (n || t.length === 1)
        return null;
      if (o && o.length === t.length)
        return o;
      if (e.multiCursorPaste === "spread") {
        i.charCodeAt(i.length - 1) === 10 && (i = i.substr(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substr(0, i.length - 1));
        const r = da(i);
        if (r.length === t.length)
          return r;
      }
      return null;
    }
    static paste(e, t, i, n, o, r) {
      const a = this._distributePasteToCursors(e, i, n, o, r);
      return a ? (i = i.sort(D.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, n, o);
    }
    static _goodIndentForLine(e, t, i) {
      let n = null, o = "";
      const r = Di.getInheritIndentForLine(e.autoIndent, t, i, !1);
      if (r)
        n = r.action, o = r.indentation;
      else if (i > 1) {
        let a;
        for (a = i - 1; a >= 1; a--) {
          const d = t.getLineContent(a);
          if (ia(d) >= 0)
            break;
        }
        if (a < 1)
          return null;
        const l = t.getLineMaxColumn(a), c = Di.getEnterAction(e.autoIndent, t, new D(a, l, a, l));
        c && (o = c.indentation + c.appendText);
      }
      return n && (n === _i.Indent && (o = Gt.shiftIndent(e, o)), n === _i.Outdent && (o = Gt.unshiftIndent(e, o)), o = e.normalizeIndentation(o)), o || null;
    }
    static _replaceJumpToNextIndent(e, t, i, n) {
      let o = "";
      const r = i.getStartPosition();
      if (e.insertSpaces) {
        const a = e.visibleColumnFromColumn(t, r), l = e.indentSize, c = l - a % l;
        for (let d = 0; d < c; d++)
          o += " ";
      } else
        o = "	";
      return new fn(i, o, n);
    }
    static tab(e, t, i) {
      const n = [];
      for (let o = 0, r = i.length; o < r; o++) {
        const a = i[o];
        if (a.isEmpty()) {
          const l = t.getLineContent(a.startLineNumber);
          if (/^\s*$/.test(l) && t.isCheapToTokenize(a.startLineNumber)) {
            let c = this._goodIndentForLine(e, t, a.startLineNumber);
            c = c || "	";
            const d = e.normalizeIndentation(c);
            if (!l.startsWith(d)) {
              n[o] = new fn(new D(a.startLineNumber, 1, a.startLineNumber, l.length + 1), d, !0);
              continue;
            }
          }
          n[o] = this._replaceJumpToNextIndent(e, t, a, !0);
        } else {
          if (a.startLineNumber === a.endLineNumber) {
            const l = t.getLineMaxColumn(a.startLineNumber);
            if (a.startColumn !== 1 || a.endColumn !== l) {
              n[o] = this._replaceJumpToNextIndent(e, t, a, !1);
              continue;
            }
          }
          n[o] = new Hs(a, {
            isUnshift: !1,
            tabSize: e.tabSize,
            indentSize: e.indentSize,
            insertSpaces: e.insertSpaces,
            useTabStops: e.useTabStops,
            autoIndent: e.autoIndent
          });
        }
      }
      return n;
    }
    static compositionType(e, t, i, n, o, r, a, l) {
      const c = n.map((d) => this._compositionType(i, d, o, r, a, l));
      return new _s(4, c, {
        shouldPushStackElementBefore: q_(e, 4),
        shouldPushStackElementAfter: !1
      });
    }
    static _compositionType(e, t, i, n, o, r) {
      if (!t.isEmpty())
        return null;
      const a = t.getPosition(), l = Math.max(1, a.column - n), c = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + o), d = new D(a.lineNumber, l, a.lineNumber, c);
      return e.getValueInRange(d) === i && r === 0 ? null : new s0(d, i, 0, r);
    }
    static _typeCommand(e, t, i) {
      return i ? new U_(e, t, !0) : new fn(e, t, !0);
    }
    static _enter(e, t, i, n) {
      if (e.autoIndent === 0)
        return Gt._typeCommand(n, `
`, i);
      if (!t.isCheapToTokenize(n.getStartPosition().lineNumber) || e.autoIndent === 1) {
        const l = t.getLineContent(n.startLineNumber), c = Dt(l).substring(0, n.startColumn - 1);
        return Gt._typeCommand(n, `
` + e.normalizeIndentation(c), i);
      }
      const o = Di.getEnterAction(e.autoIndent, t, n);
      if (o) {
        if (o.indentAction === _i.None)
          return Gt._typeCommand(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
        if (o.indentAction === _i.Indent)
          return Gt._typeCommand(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
        if (o.indentAction === _i.IndentOutdent) {
          const l = e.normalizeIndentation(o.indentation), c = e.normalizeIndentation(o.indentation + o.appendText), d = `
` + c + `
` + l;
          return i ? new U_(n, d, !0) : new s0(n, d, -1, c.length - l.length, !0);
        } else if (o.indentAction === _i.Outdent) {
          const l = Gt.unshiftIndent(e, o.indentation);
          return Gt._typeCommand(n, `
` + e.normalizeIndentation(l + o.appendText), i);
        }
      }
      const r = t.getLineContent(n.startLineNumber), a = Dt(r).substring(0, n.startColumn - 1);
      if (e.autoIndent >= 4) {
        const l = Di.getIndentForEnter(e.autoIndent, t, n, {
          unshiftIndent: (c) => Gt.unshiftIndent(e, c),
          shiftIndent: (c) => Gt.shiftIndent(e, c),
          normalizeIndentation: (c) => e.normalizeIndentation(c)
        });
        if (l) {
          let c = e.visibleColumnFromColumn(t, n.getEndPosition());
          const d = n.endColumn, h = t.getLineContent(n.endLineNumber), u = jn(h);
          if (u >= 0 ? n = n.setEndPosition(n.endLineNumber, Math.max(n.endColumn, u + 1)) : n = n.setEndPosition(n.endLineNumber, t.getLineMaxColumn(n.endLineNumber)), i)
            return new U_(n, `
` + e.normalizeIndentation(l.afterEnter), !0);
          {
            let f = 0;
            return d <= u + 1 && (e.insertSpaces || (c = Math.ceil(c / e.indentSize)), f = Math.min(c + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new s0(n, `
` + e.normalizeIndentation(l.afterEnter), 0, f, !0);
          }
        }
      }
      return Gt._typeCommand(n, `
` + e.normalizeIndentation(a), i);
    }
    static _isAutoIndentType(e, t, i) {
      if (e.autoIndent < 4)
        return !1;
      for (let n = 0, o = i.length; n < o; n++)
        if (!t.isCheapToTokenize(i[n].getEndPosition().lineNumber))
          return !1;
      return !0;
    }
    static _runAutoIndentType(e, t, i, n) {
      const o = Di.getIndentationAtPosition(t, i.startLineNumber, i.startColumn), r = Di.getIndentActionForType(e.autoIndent, t, i, n, {
        shiftIndent: (a) => Gt.shiftIndent(e, a),
        unshiftIndent: (a) => Gt.unshiftIndent(e, a)
      });
      if (r === null)
        return null;
      if (r !== e.normalizeIndentation(o)) {
        const a = t.getLineFirstNonWhitespaceColumn(i.startLineNumber);
        return a === 0 ? Gt._typeCommand(new D(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(r) + n, !1) : Gt._typeCommand(new D(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(r) + t.getLineContent(i.startLineNumber).substring(a - 1, i.startColumn - 1) + n, !1);
      }
      return null;
    }
    static _isAutoClosingOvertype(e, t, i, n, o) {
      if (e.autoClosingOvertype === "never" || !e.autoClosingPairs.autoClosingPairsCloseSingleChar.has(o))
        return !1;
      for (let r = 0, a = i.length; r < a; r++) {
        const l = i[r];
        if (!l.isEmpty())
          return !1;
        const c = l.getPosition(), d = t.getLineContent(c.lineNumber);
        if (d.charAt(c.column - 1) !== o)
          return !1;
        const u = pu(o);
        if ((c.column > 2 ? d.charCodeAt(c.column - 2) : 0) === 92 && u)
          return !1;
        if (e.autoClosingOvertype === "auto") {
          let g = !1;
          for (let _ = 0, b = n.length; _ < b; _++) {
            const C = n[_];
            if (c.lineNumber === C.startLineNumber && c.column === C.startColumn) {
              g = !0;
              break;
            }
          }
          if (!g)
            return !1;
        }
      }
      return !0;
    }
    static _runAutoClosingOvertype(e, t, i, n, o) {
      const r = [];
      for (let a = 0, l = n.length; a < l; a++) {
        const d = n[a].getPosition(), h = new D(d.lineNumber, d.column, d.lineNumber, d.column + 1);
        r[a] = new fn(h, o);
      }
      return new _s(4, r, {
        shouldPushStackElementBefore: q_(e, 4),
        shouldPushStackElementAfter: !1
      });
    }
    static _isBeforeClosingBrace(e, t) {
      const i = t.charAt(0), n = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], o = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], r = n.some((l) => t.startsWith(l.open)), a = o.some((l) => t.startsWith(l.close));
      return !r && a;
    }
    static _findAutoClosingPairOpen(e, t, i, n) {
      const o = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(n);
      if (!o)
        return null;
      let r = null;
      for (const a of o)
        if (r === null || a.open.length > r.open.length) {
          let l = !0;
          for (const c of i)
            if (t.getValueInRange(new D(c.lineNumber, c.column - a.open.length + 1, c.lineNumber, c.column)) + n !== a.open) {
              l = !1;
              break;
            }
          l && (r = a);
        }
      return r;
    }
    static _findContainedAutoClosingPair(e, t) {
      if (t.open.length <= 1)
        return null;
      const i = t.close.charAt(t.close.length - 1), n = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
      let o = null;
      for (const r of n)
        r.open !== t.open && t.open.includes(r.open) && t.close.endsWith(r.close) && (!o || r.open.length > o.open.length) && (o = r);
      return o;
    }
    static _getAutoClosingPairClose(e, t, i, n, o) {
      const r = pu(n), a = r ? e.autoClosingQuotes : e.autoClosingBrackets, l = r ? e.shouldAutoCloseBefore.quote : e.shouldAutoCloseBefore.bracket;
      if (a === "never")
        return null;
      for (const g of i)
        if (!g.isEmpty())
          return null;
      const c = i.map((g) => {
        const _ = g.getPosition();
        return o ? { lineNumber: _.lineNumber, beforeColumn: _.column - n.length, afterColumn: _.column } : { lineNumber: _.lineNumber, beforeColumn: _.column, afterColumn: _.column };
      }), d = this._findAutoClosingPairOpen(e, t, c.map((g) => new V(g.lineNumber, g.beforeColumn)), n);
      if (!d)
        return null;
      const h = this._findContainedAutoClosingPair(e, d), u = h ? h.close : "";
      let f = !0;
      for (const g of c) {
        const { lineNumber: _, beforeColumn: b, afterColumn: C } = g, v = t.getLineContent(_), w = v.substring(0, b - 1), S = v.substring(C - 1);
        if (S.startsWith(u) || (f = !1), S.length > 0) {
          const k = S.charAt(0);
          if (!Gt._isBeforeClosingBrace(e, S) && !l(k))
            return null;
        }
        if (d.open.length === 1 && (n === "'" || n === '"') && a !== "always") {
          const k = yo(e.wordSeparators);
          if (w.length > 0) {
            const I = w.charCodeAt(w.length - 1);
            if (k.get(I) === 0)
              return null;
          }
        }
        if (!t.isCheapToTokenize(_))
          return null;
        t.forceTokenization(_);
        const L = t.getLineTokens(_), x = J0(L, b - 1);
        if (!d.shouldAutoClose(x, b - x.firstCharOffset))
          return null;
        const y = d.findNeutralCharacter();
        if (y) {
          const k = t.getTokenTypeIfInsertingCharacter(_, b, y);
          if (!d.isOK(k))
            return null;
        }
      }
      return f ? d.close.substring(0, d.close.length - u.length) : d.close;
    }
    static _runAutoClosingOpenCharType(e, t, i, n, o, r, a) {
      const l = [];
      for (let c = 0, d = n.length; c < d; c++) {
        const h = n[c];
        l[c] = new r5(h, o, !r, a);
      }
      return new _s(4, l, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    static _shouldSurroundChar(e, t) {
      return pu(t) ? e.autoSurround === "quotes" || e.autoSurround === "languageDefined" : e.autoSurround === "brackets" || e.autoSurround === "languageDefined";
    }
    static _isSurroundSelectionType(e, t, i, n) {
      if (!Gt._shouldSurroundChar(e, n) || !e.surroundingPairs.hasOwnProperty(n))
        return !1;
      const o = pu(n);
      for (let r = 0, a = i.length; r < a; r++) {
        const l = i[r];
        if (l.isEmpty())
          return !1;
        let c = !0;
        for (let d = l.startLineNumber; d <= l.endLineNumber; d++) {
          const h = t.getLineContent(d), u = d === l.startLineNumber ? l.startColumn - 1 : 0, f = d === l.endLineNumber ? l.endColumn - 1 : h.length, g = h.substring(u, f);
          if (/[^ \t]/.test(g)) {
            c = !1;
            break;
          }
        }
        if (c)
          return !1;
        if (o && l.startLineNumber === l.endLineNumber && l.startColumn + 1 === l.endColumn) {
          const d = t.getValueInRange(l);
          if (pu(d))
            return !1;
        }
      }
      return !0;
    }
    static _runSurroundSelectionType(e, t, i, n, o) {
      const r = [];
      for (let a = 0, l = n.length; a < l; a++) {
        const c = n[a], d = t.surroundingPairs[o];
        r[a] = new aH(c, o, d);
      }
      return new _s(0, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !0
      });
    }
    static _isTypeInterceptorElectricChar(e, t, i) {
      return !!(i.length === 1 && t.isCheapToTokenize(i[0].getEndPosition().lineNumber));
    }
    static _typeInterceptorElectricChar(e, t, i, n, o) {
      if (!t.electricChars.hasOwnProperty(o) || !n.isEmpty())
        return null;
      const r = n.getPosition();
      i.forceTokenization(r.lineNumber);
      const a = i.getLineTokens(r.lineNumber);
      let l;
      try {
        l = t.onElectricCharacter(o, a, r.column);
      } catch (c) {
        return We(c), null;
      }
      if (!l)
        return null;
      if (l.matchOpenBracket) {
        const c = (a.getLineContent() + o).lastIndexOf(l.matchOpenBracket) + 1, d = i.bracketPairs.findMatchingBracketUp(l.matchOpenBracket, {
          lineNumber: r.lineNumber,
          column: c
        }, 500);
        if (d) {
          if (d.startLineNumber === r.lineNumber)
            return null;
          const h = i.getLineContent(d.startLineNumber), u = Dt(h), f = t.normalizeIndentation(u), g = i.getLineContent(r.lineNumber), _ = i.getLineFirstNonWhitespaceColumn(r.lineNumber) || r.column, b = g.substring(_ - 1, r.column - 1), C = f + b + o, v = new D(r.lineNumber, 1, r.lineNumber, r.column), w = new fn(v, C);
          return new _s(Hw(C, e), [w], {
            shouldPushStackElementBefore: !1,
            shouldPushStackElementAfter: !0
          });
        }
      }
      return null;
    }
    static compositionEndWithInterceptors(e, t, i, n, o, r) {
      if (!n || ae.selectionsArrEqual(n, o))
        return null;
      let a = null;
      for (const c of o) {
        if (!c.isEmpty())
          return null;
        const d = c.getPosition(), h = i.getValueInRange(new D(d.lineNumber, d.column - 1, d.lineNumber, d.column));
        if (a === null)
          a = h;
        else if (a !== h)
          return null;
      }
      if (!a)
        return null;
      if (this._isAutoClosingOvertype(t, i, o, r, a)) {
        const c = o.map((d) => new fn(new D(d.positionLineNumber, d.positionColumn, d.positionLineNumber, d.positionColumn + 1), "", !1));
        return new _s(4, c, {
          shouldPushStackElementBefore: !0,
          shouldPushStackElementAfter: !1
        });
      }
      const l = this._getAutoClosingPairClose(t, i, o, a, !0);
      return l !== null ? this._runAutoClosingOpenCharType(e, t, i, o, a, !0, l) : null;
    }
    static typeWithInterceptors(e, t, i, n, o, r, a) {
      if (!e && a === `
`) {
        const d = [];
        for (let h = 0, u = o.length; h < u; h++)
          d[h] = Gt._enter(i, n, !1, o[h]);
        return new _s(4, d, {
          shouldPushStackElementBefore: !0,
          shouldPushStackElementAfter: !1
        });
      }
      if (!e && this._isAutoIndentType(i, n, o)) {
        const d = [];
        let h = !1;
        for (let u = 0, f = o.length; u < f; u++)
          if (d[u] = this._runAutoIndentType(i, n, o[u], a), !d[u]) {
            h = !0;
            break;
          }
        if (!h)
          return new _s(4, d, {
            shouldPushStackElementBefore: !0,
            shouldPushStackElementAfter: !1
          });
      }
      if (!e && this._isAutoClosingOvertype(i, n, o, r, a))
        return this._runAutoClosingOvertype(t, i, n, o, a);
      if (!e) {
        const d = this._getAutoClosingPairClose(i, n, o, a, !1);
        if (d)
          return this._runAutoClosingOpenCharType(t, i, n, o, a, !1, d);
      }
      if (this._isSurroundSelectionType(i, n, o, a))
        return this._runSurroundSelectionType(t, i, n, o, a);
      if (!e && this._isTypeInterceptorElectricChar(i, n, o)) {
        const d = this._typeInterceptorElectricChar(t, i, n, o[0], a);
        if (d)
          return d;
      }
      const l = [];
      for (let d = 0, h = o.length; d < h; d++)
        l[d] = new fn(o[d], a);
      const c = Hw(a, t);
      return new _s(c, l, {
        shouldPushStackElementBefore: q_(t, c),
        shouldPushStackElementAfter: !1
      });
    }
    static typeWithoutInterceptors(e, t, i, n, o) {
      const r = [];
      for (let l = 0, c = n.length; l < c; l++)
        r[l] = new fn(n[l], o);
      const a = Hw(o, e);
      return new _s(a, r, {
        shouldPushStackElementBefore: q_(e, a),
        shouldPushStackElementAfter: !1
      });
    }
    static lineInsertBefore(e, t, i) {
      if (t === null || i === null)
        return [];
      const n = [];
      for (let o = 0, r = i.length; o < r; o++) {
        let a = i[o].positionLineNumber;
        if (a === 1)
          n[o] = new U_(new D(1, 1, 1, 1), `
`);
        else {
          a--;
          const l = t.getLineMaxColumn(a);
          n[o] = this._enter(e, t, !1, new D(a, l, a, l));
        }
      }
      return n;
    }
    static lineInsertAfter(e, t, i) {
      if (t === null || i === null)
        return [];
      const n = [];
      for (let o = 0, r = i.length; o < r; o++) {
        const a = i[o].positionLineNumber, l = t.getLineMaxColumn(a);
        n[o] = this._enter(e, t, !1, new D(a, l, a, l));
      }
      return n;
    }
    static lineBreakInsert(e, t, i) {
      const n = [];
      for (let o = 0, r = i.length; o < r; o++)
        n[o] = this._enter(e, t, !0, i[o]);
      return n;
    }
  }
  class r5 extends s0 {
    constructor(e, t, i, n) {
      super(e, (i ? t : "") + n, 0, -n.length), this._openCharacter = t, this._closeCharacter = n, this.closeCharacterRange = null, this.enclosingRange = null;
    }
    computeCursorState(e, t) {
      const n = t.getInverseEditOperations()[0].range;
      return this.closeCharacterRange = new D(n.startLineNumber, n.endColumn - this._closeCharacter.length, n.endLineNumber, n.endColumn), this.enclosingRange = new D(n.startLineNumber, n.endColumn - this._openCharacter.length - this._closeCharacter.length, n.endLineNumber, n.endColumn), super.computeCursorState(e, t);
    }
  }
  function Hw(s, e) {
    return s === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
  }
  function q_(s, e) {
    return eT(s) && !eT(e) ? !0 : s === 5 ? !1 : J2(s) !== J2(e);
  }
  function J2(s) {
    return s === 6 || s === 5 ? "space" : s;
  }
  function eT(s) {
    return s === 4 || s === 5 || s === 6;
  }
  var T;
  (function(s) {
    s.editorSimpleInput = new ue("editorSimpleInput", !1, !0), s.editorTextFocus = new ue("editorTextFocus", !1, m("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), s.focus = new ue("editorFocus", !1, m("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), s.textInputFocus = new ue("textInputFocus", !1, m("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), s.readOnly = new ue("editorReadonly", !1, m("editorReadonly", "Whether the editor is read only")), s.inDiffEditor = new ue("inDiffEditor", !1, m("inDiffEditor", "Whether the context is a diff editor")), s.columnSelection = new ue("editorColumnSelection", !1, m("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), s.writable = s.readOnly.toNegated(), s.hasNonEmptySelection = new ue("editorHasSelection", !1, m("editorHasSelection", "Whether the editor has text selected")), s.hasOnlyEmptySelection = s.hasNonEmptySelection.toNegated(), s.hasMultipleSelections = new ue("editorHasMultipleSelections", !1, m("editorHasMultipleSelections", "Whether the editor has multiple selections")), s.hasSingleSelection = s.hasMultipleSelections.toNegated(), s.tabMovesFocus = new ue("editorTabMovesFocus", !1, m("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), s.tabDoesNotMoveFocus = s.tabMovesFocus.toNegated(), s.isInWalkThroughSnippet = new ue("isInEmbeddedEditor", !1, !0), s.canUndo = new ue("canUndo", !1, !0), s.canRedo = new ue("canRedo", !1, !0), s.hoverVisible = new ue("editorHoverVisible", !1, m("editorHoverVisible", "Whether the editor hover is visible")), s.inCompositeEditor = new ue("inCompositeEditor", void 0, m("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), s.notInCompositeEditor = s.inCompositeEditor.toNegated(), s.languageId = new ue("editorLangId", "", m("editorLangId", "The language identifier of the editor")), s.hasCompletionItemProvider = new ue("editorHasCompletionItemProvider", !1, m("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), s.hasCodeActionsProvider = new ue("editorHasCodeActionsProvider", !1, m("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), s.hasCodeLensProvider = new ue("editorHasCodeLensProvider", !1, m("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), s.hasDefinitionProvider = new ue("editorHasDefinitionProvider", !1, m("editorHasDefinitionProvider", "Whether the editor has a definition provider")), s.hasDeclarationProvider = new ue("editorHasDeclarationProvider", !1, m("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), s.hasImplementationProvider = new ue("editorHasImplementationProvider", !1, m("editorHasImplementationProvider", "Whether the editor has an implementation provider")), s.hasTypeDefinitionProvider = new ue("editorHasTypeDefinitionProvider", !1, m("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), s.hasHoverProvider = new ue("editorHasHoverProvider", !1, m("editorHasHoverProvider", "Whether the editor has a hover provider")), s.hasDocumentHighlightProvider = new ue("editorHasDocumentHighlightProvider", !1, m("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), s.hasDocumentSymbolProvider = new ue("editorHasDocumentSymbolProvider", !1, m("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), s.hasReferenceProvider = new ue("editorHasReferenceProvider", !1, m("editorHasReferenceProvider", "Whether the editor has a reference provider")), s.hasRenameProvider = new ue("editorHasRenameProvider", !1, m("editorHasRenameProvider", "Whether the editor has a rename provider")), s.hasSignatureHelpProvider = new ue("editorHasSignatureHelpProvider", !1, m("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), s.hasInlayHintsProvider = new ue("editorHasInlayHintsProvider", !1, m("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), s.hasDocumentFormattingProvider = new ue("editorHasDocumentFormattingProvider", !1, m("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), s.hasDocumentSelectionFormattingProvider = new ue("editorHasDocumentSelectionFormattingProvider", !1, m("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), s.hasMultipleDocumentFormattingProvider = new ue("editorHasMultipleDocumentFormattingProvider", !1, m("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), s.hasMultipleDocumentSelectionFormattingProvider = new ue("editorHasMultipleDocumentSelectionFormattingProvider", !1, m("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
  })(T || (T = {}));
  const gt = 0;
  class Li extends wn {
    runEditorCommand(e, t, i) {
      const n = t._getViewModel();
      !n || this.runCoreEditorCommand(n, i || {});
    }
  }
  var s1;
  (function(s) {
    const e = function(i) {
      if (!ls(i))
        return !1;
      const n = i;
      return !(!vo(n.to) || !Ss(n.by) && !vo(n.by) || !Ss(n.value) && !zd(n.value) || !Ss(n.revealCursor) && !Q4(n.revealCursor));
    };
    s.description = {
      description: "Scroll editor in the given direction",
      args: [
        {
          name: "Editor scroll argument object",
          description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
          constraint: e,
          schema: {
            type: "object",
            required: ["to"],
            properties: {
              to: {
                type: "string",
                enum: ["up", "down"]
              },
              by: {
                type: "string",
                enum: ["line", "wrappedLine", "page", "halfPage"]
              },
              value: {
                type: "number",
                default: 1
              },
              revealCursor: {
                type: "boolean"
              }
            }
          }
        }
      ]
    }, s.RawDirection = {
      Up: "up",
      Down: "down"
    }, s.RawUnit = {
      Line: "line",
      WrappedLine: "wrappedLine",
      Page: "page",
      HalfPage: "halfPage"
    };
    function t(i) {
      let n;
      switch (i.to) {
        case s.RawDirection.Up:
          n = 1;
          break;
        case s.RawDirection.Down:
          n = 2;
          break;
        default:
          return null;
      }
      let o;
      switch (i.by) {
        case s.RawUnit.Line:
          o = 1;
          break;
        case s.RawUnit.WrappedLine:
          o = 2;
          break;
        case s.RawUnit.Page:
          o = 3;
          break;
        case s.RawUnit.HalfPage:
          o = 4;
          break;
        default:
          o = 2;
      }
      const r = Math.floor(i.value || 1), a = !!i.revealCursor;
      return {
        direction: n,
        unit: o,
        value: r,
        revealCursor: a,
        select: !!i.select
      };
    }
    s.parse = t;
  })(s1 || (s1 = {}));
  var Du;
  (function(s) {
    const e = function(t) {
      if (!ls(t))
        return !1;
      const i = t;
      return !(!zd(i.lineNumber) && !vo(i.lineNumber) || !Ss(i.at) && !vo(i.at));
    };
    s.description = {
      description: "Reveal the given line at the given logical position",
      args: [
        {
          name: "Reveal line argument object",
          description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
          constraint: e,
          schema: {
            type: "object",
            required: ["lineNumber"],
            properties: {
              lineNumber: {
                type: ["number", "string"]
              },
              at: {
                type: "string",
                enum: ["top", "center", "bottom"]
              }
            }
          }
        }
      ]
    }, s.RawAtArgument = {
      Top: "top",
      Center: "center",
      Bottom: "bottom"
    };
  })(Du || (Du = {}));
  class rL {
    constructor(e) {
      e.addImplementation(1e4, "code-editor", (t, i) => {
        const n = t.get(St).getFocusedCodeEditor();
        return n && n.hasTextFocus() ? this._runEditorCommand(t, n, i) : !1;
      }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
        const n = document.activeElement;
        return n && ["input", "textarea"].indexOf(n.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(), !0) : !1;
      }), e.addImplementation(0, "generic-dom", (t, i) => {
        const n = t.get(St).getActiveCodeEditor();
        return n ? (n.focus(), this._runEditorCommand(t, n, i)) : !1;
      });
    }
    _runEditorCommand(e, t, i) {
      const n = this.runEditorCommand(e, t, i);
      return n || !0;
    }
  }
  var Ui;
  (function(s) {
    class e extends Li {
      constructor(v) {
        super(v), this._minimalReveal = v.minimalReveal, this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, [
          tn.moveTo(v, v.getPrimaryCursorState(), this._inSelectionMode, w.position, w.viewPosition)
        ]) && v.revealPrimaryCursor(w.source, !0, this._minimalReveal);
      }
    }
    s.MoveTo = se(new e({
      id: "_moveTo",
      minimalReveal: !0,
      inSelectionMode: !1,
      precondition: void 0
    })), s.MoveToSelect = se(new e({
      id: "_moveToSelect",
      minimalReveal: !1,
      inSelectionMode: !0,
      precondition: void 0
    }));
    class t extends Li {
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement();
        const S = this._getColumnSelectResult(v, v.getPrimaryCursorState(), v.getCursorColumnSelectData(), w);
        v.setCursorStates(w.source, 3, S.viewStates.map((L) => Ze.fromViewState(L))), v.setCursorColumnSelectData({
          isReal: !0,
          fromViewLineNumber: S.fromLineNumber,
          fromViewVisualColumn: S.fromVisualColumn,
          toViewLineNumber: S.toLineNumber,
          toViewVisualColumn: S.toVisualColumn
        }), S.reversed ? v.revealTopMostCursor(w.source) : v.revealBottomMostCursor(w.source);
      }
    }
    s.ColumnSelect = se(new class extends t {
      constructor() {
        super({
          id: "columnSelect",
          precondition: void 0
        });
      }
      _getColumnSelectResult(C, v, w, S) {
        const L = C.model.validatePosition(S.position), x = C.coordinatesConverter.validateViewPosition(new V(S.viewPosition.lineNumber, S.viewPosition.column), L), y = S.doColumnSelect ? w.fromViewLineNumber : x.lineNumber, k = S.doColumnSelect ? w.fromViewVisualColumn : S.mouseColumn - 1;
        return ad.columnSelect(C.cursorConfig, C, y, k, x.lineNumber, S.mouseColumn - 1);
      }
    }()), s.CursorColumnSelectLeft = se(new class extends t {
      constructor() {
        super({
          id: "cursorColumnSelectLeft",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 3599,
            linux: { primary: 0 }
          }
        });
      }
      _getColumnSelectResult(C, v, w, S) {
        return ad.columnSelectLeft(C.cursorConfig, C, w);
      }
    }()), s.CursorColumnSelectRight = se(new class extends t {
      constructor() {
        super({
          id: "cursorColumnSelectRight",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 3601,
            linux: { primary: 0 }
          }
        });
      }
      _getColumnSelectResult(C, v, w, S) {
        return ad.columnSelectRight(C.cursorConfig, C, w);
      }
    }());
    class i extends t {
      constructor(v) {
        super(v), this._isPaged = v.isPaged;
      }
      _getColumnSelectResult(v, w, S, L) {
        return ad.columnSelectUp(v.cursorConfig, v, S, this._isPaged);
      }
    }
    s.CursorColumnSelectUp = se(new i({
      isPaged: !1,
      id: "cursorColumnSelectUp",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 3600,
        linux: { primary: 0 }
      }
    })), s.CursorColumnSelectPageUp = se(new i({
      isPaged: !0,
      id: "cursorColumnSelectPageUp",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 3595,
        linux: { primary: 0 }
      }
    }));
    class n extends t {
      constructor(v) {
        super(v), this._isPaged = v.isPaged;
      }
      _getColumnSelectResult(v, w, S, L) {
        return ad.columnSelectDown(v.cursorConfig, v, S, this._isPaged);
      }
    }
    s.CursorColumnSelectDown = se(new n({
      isPaged: !1,
      id: "cursorColumnSelectDown",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 3602,
        linux: { primary: 0 }
      }
    })), s.CursorColumnSelectPageDown = se(new n({
      isPaged: !0,
      id: "cursorColumnSelectPageDown",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 3596,
        linux: { primary: 0 }
      }
    }));
    class o extends Li {
      constructor() {
        super({
          id: "cursorMove",
          precondition: void 0,
          description: i1.description
        });
      }
      runCoreEditorCommand(v, w) {
        const S = i1.parse(w);
        !S || this._runCursorMove(v, w.source, S);
      }
      _runCursorMove(v, w, S) {
        v.model.pushStackElement(), v.setCursorStates(w, 3, o._move(v, v.getCursorStates(), S)), v.revealPrimaryCursor(w, !0);
      }
      static _move(v, w, S) {
        const L = S.select, x = S.value;
        switch (S.direction) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
            return tn.simpleMove(v, w, S.direction, L, x, S.unit);
          case 11:
          case 13:
          case 12:
          case 14:
            return tn.viewportMove(v, w, S.direction, L, x);
          default:
            return null;
        }
      }
    }
    s.CursorMoveImpl = o, s.CursorMove = se(new o());
    class r extends Li {
      constructor(v) {
        super(v), this._staticArgs = v.args;
      }
      runCoreEditorCommand(v, w) {
        let S = this._staticArgs;
        this._staticArgs.value === -1 && (S = {
          direction: this._staticArgs.direction,
          unit: this._staticArgs.unit,
          select: this._staticArgs.select,
          value: w.pageSize || v.cursorConfig.pageSize
        }), v.model.pushStackElement(), v.setCursorStates(w.source, 3, tn.simpleMove(v, v.getCursorStates(), S.direction, S.select, S.value, S.unit)), v.revealPrimaryCursor(w.source, !0);
      }
    }
    s.CursorLeft = se(new r({
      args: {
        direction: 0,
        unit: 0,
        select: !1,
        value: 1
      },
      id: "cursorLeft",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 15,
        mac: { primary: 15, secondary: [288] }
      }
    })), s.CursorLeftSelect = se(new r({
      args: {
        direction: 0,
        unit: 0,
        select: !0,
        value: 1
      },
      id: "cursorLeftSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1039
      }
    })), s.CursorRight = se(new r({
      args: {
        direction: 1,
        unit: 0,
        select: !1,
        value: 1
      },
      id: "cursorRight",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 17,
        mac: { primary: 17, secondary: [292] }
      }
    })), s.CursorRightSelect = se(new r({
      args: {
        direction: 1,
        unit: 0,
        select: !0,
        value: 1
      },
      id: "cursorRightSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1041
      }
    })), s.CursorUp = se(new r({
      args: {
        direction: 2,
        unit: 2,
        select: !1,
        value: 1
      },
      id: "cursorUp",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 16,
        mac: { primary: 16, secondary: [302] }
      }
    })), s.CursorUpSelect = se(new r({
      args: {
        direction: 2,
        unit: 2,
        select: !0,
        value: 1
      },
      id: "cursorUpSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1040,
        secondary: [3088],
        mac: { primary: 1040 },
        linux: { primary: 1040 }
      }
    })), s.CursorPageUp = se(new r({
      args: {
        direction: 2,
        unit: 2,
        select: !1,
        value: -1
      },
      id: "cursorPageUp",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 11
      }
    })), s.CursorPageUpSelect = se(new r({
      args: {
        direction: 2,
        unit: 2,
        select: !0,
        value: -1
      },
      id: "cursorPageUpSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1035
      }
    })), s.CursorDown = se(new r({
      args: {
        direction: 3,
        unit: 2,
        select: !1,
        value: 1
      },
      id: "cursorDown",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 18,
        mac: { primary: 18, secondary: [300] }
      }
    })), s.CursorDownSelect = se(new r({
      args: {
        direction: 3,
        unit: 2,
        select: !0,
        value: 1
      },
      id: "cursorDownSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1042,
        secondary: [3090],
        mac: { primary: 1042 },
        linux: { primary: 1042 }
      }
    })), s.CursorPageDown = se(new r({
      args: {
        direction: 3,
        unit: 2,
        select: !1,
        value: -1
      },
      id: "cursorPageDown",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 12
      }
    })), s.CursorPageDownSelect = se(new r({
      args: {
        direction: 3,
        unit: 2,
        select: !0,
        value: -1
      },
      id: "cursorPageDownSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1036
      }
    })), s.CreateCursor = se(new class extends Li {
      constructor() {
        super({
          id: "createCursor",
          precondition: void 0
        });
      }
      runCoreEditorCommand(C, v) {
        let w;
        v.wholeLine ? w = tn.line(C, C.getPrimaryCursorState(), !1, v.position, v.viewPosition) : w = tn.moveTo(C, C.getPrimaryCursorState(), !1, v.position, v.viewPosition);
        const S = C.getCursorStates();
        if (S.length > 1) {
          const L = w.modelState ? w.modelState.position : null, x = w.viewState ? w.viewState.position : null;
          for (let y = 0, k = S.length; y < k; y++) {
            const I = S[y];
            if (!(L && !I.modelState.selection.containsPosition(L)) && !(x && !I.viewState.selection.containsPosition(x))) {
              S.splice(y, 1), C.model.pushStackElement(), C.setCursorStates(v.source, 3, S);
              return;
            }
          }
        }
        S.push(w), C.model.pushStackElement(), C.setCursorStates(v.source, 3, S);
      }
    }()), s.LastCursorMoveToSelect = se(new class extends Li {
      constructor() {
        super({
          id: "_lastCursorMoveToSelect",
          precondition: void 0
        });
      }
      runCoreEditorCommand(C, v) {
        const w = C.getLastAddedCursorIndex(), S = C.getCursorStates(), L = S.slice(0);
        L[w] = tn.moveTo(C, S[w], !0, v.position, v.viewPosition), C.model.pushStackElement(), C.setCursorStates(v.source, 3, L);
      }
    }());
    class a extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, tn.moveToBeginningOfLine(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(w.source, !0);
      }
    }
    s.CursorHome = se(new a({
      inSelectionMode: !1,
      id: "cursorHome",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 14,
        mac: { primary: 14, secondary: [2063] }
      }
    })), s.CursorHomeSelect = se(new a({
      inSelectionMode: !0,
      id: "cursorHomeSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1038,
        mac: { primary: 1038, secondary: [3087] }
      }
    }));
    class l extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, this._exec(v.getCursorStates())), v.revealPrimaryCursor(w.source, !0);
      }
      _exec(v) {
        const w = [];
        for (let S = 0, L = v.length; S < L; S++) {
          const x = v[S], y = x.modelState.position.lineNumber;
          w[S] = Ze.fromModelState(x.modelState.move(this._inSelectionMode, y, 1, 0));
        }
        return w;
      }
    }
    s.CursorLineStart = se(new l({
      inSelectionMode: !1,
      id: "cursorLineStart",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 0,
        mac: { primary: 287 }
      }
    })), s.CursorLineStartSelect = se(new l({
      inSelectionMode: !0,
      id: "cursorLineStartSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 0,
        mac: { primary: 1311 }
      }
    }));
    class c extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, tn.moveToEndOfLine(v, v.getCursorStates(), this._inSelectionMode, w.sticky || !1)), v.revealPrimaryCursor(w.source, !0);
      }
    }
    s.CursorEnd = se(new c({
      inSelectionMode: !1,
      id: "cursorEnd",
      precondition: void 0,
      kbOpts: {
        args: { sticky: !1 },
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 13,
        mac: { primary: 13, secondary: [2065] }
      },
      description: {
        description: "Go to End",
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              sticky: {
                description: m("stickydesc", "Stick to the end even when going to longer lines"),
                type: "boolean",
                default: !1
              }
            }
          }
        }]
      }
    })), s.CursorEndSelect = se(new c({
      inSelectionMode: !0,
      id: "cursorEndSelect",
      precondition: void 0,
      kbOpts: {
        args: { sticky: !1 },
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 1037,
        mac: { primary: 1037, secondary: [3089] }
      },
      description: {
        description: "Select to End",
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              sticky: {
                description: m("stickydesc", "Stick to the end even when going to longer lines"),
                type: "boolean",
                default: !1
              }
            }
          }
        }]
      }
    }));
    class d extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, this._exec(v, v.getCursorStates())), v.revealPrimaryCursor(w.source, !0);
      }
      _exec(v, w) {
        const S = [];
        for (let L = 0, x = w.length; L < x; L++) {
          const y = w[L], k = y.modelState.position.lineNumber, I = v.model.getLineMaxColumn(k);
          S[L] = Ze.fromModelState(y.modelState.move(this._inSelectionMode, k, I, 0));
        }
        return S;
      }
    }
    s.CursorLineEnd = se(new d({
      inSelectionMode: !1,
      id: "cursorLineEnd",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 0,
        mac: { primary: 291 }
      }
    })), s.CursorLineEndSelect = se(new d({
      inSelectionMode: !0,
      id: "cursorLineEndSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 0,
        mac: { primary: 1315 }
      }
    }));
    class h extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, tn.moveToBeginningOfBuffer(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(w.source, !0);
      }
    }
    s.CursorTop = se(new h({
      inSelectionMode: !1,
      id: "cursorTop",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 2062,
        mac: { primary: 2064 }
      }
    })), s.CursorTopSelect = se(new h({
      inSelectionMode: !0,
      id: "cursorTopSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 3086,
        mac: { primary: 3088 }
      }
    }));
    class u extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, tn.moveToEndOfBuffer(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(w.source, !0);
      }
    }
    s.CursorBottom = se(new u({
      inSelectionMode: !1,
      id: "cursorBottom",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 2061,
        mac: { primary: 2066 }
      }
    })), s.CursorBottomSelect = se(new u({
      inSelectionMode: !0,
      id: "cursorBottomSelect",
      precondition: void 0,
      kbOpts: {
        weight: gt,
        kbExpr: T.textInputFocus,
        primary: 3085,
        mac: { primary: 3090 }
      }
    }));
    class f extends Li {
      constructor() {
        super({
          id: "editorScroll",
          precondition: void 0,
          description: s1.description
        });
      }
      runCoreEditorCommand(v, w) {
        const S = s1.parse(w);
        !S || this._runEditorScroll(v, w.source, S);
      }
      _runEditorScroll(v, w, S) {
        const L = this._computeDesiredScrollTop(v, S);
        if (S.revealCursor) {
          const x = v.getCompletelyVisibleViewRangeAtScrollTop(L);
          v.setCursorStates(w, 3, [
            tn.findPositionInViewportIfOutside(v, v.getPrimaryCursorState(), x, S.select)
          ]);
        }
        v.viewLayout.setScrollPosition({ scrollTop: L }, 0);
      }
      _computeDesiredScrollTop(v, w) {
        if (w.unit === 1) {
          const x = v.getCompletelyVisibleViewRange(), y = v.coordinatesConverter.convertViewRangeToModelRange(x);
          let k;
          w.direction === 1 ? k = Math.max(1, y.startLineNumber - w.value) : k = Math.min(v.model.getLineCount(), y.startLineNumber + w.value);
          const I = v.coordinatesConverter.convertModelPositionToViewPosition(new V(k, 1));
          return v.viewLayout.getVerticalOffsetForLineNumber(I.lineNumber);
        }
        let S;
        w.unit === 3 ? S = v.cursorConfig.pageSize * w.value : w.unit === 4 ? S = Math.round(v.cursorConfig.pageSize / 2) * w.value : S = w.value;
        const L = (w.direction === 1 ? -1 : 1) * S;
        return v.viewLayout.getCurrentScrollTop() + L * v.cursorConfig.lineHeight;
      }
    }
    s.EditorScrollImpl = f, s.EditorScroll = se(new f()), s.ScrollLineUp = se(new class extends Li {
      constructor() {
        super({
          id: "scrollLineUp",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 2064,
            mac: { primary: 267 }
          }
        });
      }
      runCoreEditorCommand(C, v) {
        s.EditorScroll._runEditorScroll(C, v.source, {
          direction: 1,
          unit: 2,
          value: 1,
          revealCursor: !1,
          select: !1
        });
      }
    }()), s.ScrollPageUp = se(new class extends Li {
      constructor() {
        super({
          id: "scrollPageUp",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 2059,
            win: { primary: 523 },
            linux: { primary: 523 }
          }
        });
      }
      runCoreEditorCommand(C, v) {
        s.EditorScroll._runEditorScroll(C, v.source, {
          direction: 1,
          unit: 3,
          value: 1,
          revealCursor: !1,
          select: !1
        });
      }
    }()), s.ScrollLineDown = se(new class extends Li {
      constructor() {
        super({
          id: "scrollLineDown",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 2066,
            mac: { primary: 268 }
          }
        });
      }
      runCoreEditorCommand(C, v) {
        s.EditorScroll._runEditorScroll(C, v.source, {
          direction: 2,
          unit: 2,
          value: 1,
          revealCursor: !1,
          select: !1
        });
      }
    }()), s.ScrollPageDown = se(new class extends Li {
      constructor() {
        super({
          id: "scrollPageDown",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 2060,
            win: { primary: 524 },
            linux: { primary: 524 }
          }
        });
      }
      runCoreEditorCommand(C, v) {
        s.EditorScroll._runEditorScroll(C, v.source, {
          direction: 2,
          unit: 3,
          value: 1,
          revealCursor: !1,
          select: !1
        });
      }
    }());
    class g extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, [
          tn.word(v, v.getPrimaryCursorState(), this._inSelectionMode, w.position)
        ]), v.revealPrimaryCursor(w.source, !0);
      }
    }
    s.WordSelect = se(new g({
      inSelectionMode: !1,
      id: "_wordSelect",
      precondition: void 0
    })), s.WordSelectDrag = se(new g({
      inSelectionMode: !0,
      id: "_wordSelectDrag",
      precondition: void 0
    })), s.LastCursorWordSelect = se(new class extends Li {
      constructor() {
        super({
          id: "lastCursorWordSelect",
          precondition: void 0
        });
      }
      runCoreEditorCommand(C, v) {
        const w = C.getLastAddedCursorIndex(), S = C.getCursorStates(), L = S.slice(0), x = S[w];
        L[w] = tn.word(C, x, x.modelState.hasSelection(), v.position), C.model.pushStackElement(), C.setCursorStates(v.source, 3, L);
      }
    }());
    class _ extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        v.model.pushStackElement(), v.setCursorStates(w.source, 3, [
          tn.line(v, v.getPrimaryCursorState(), this._inSelectionMode, w.position, w.viewPosition)
        ]), v.revealPrimaryCursor(w.source, !1);
      }
    }
    s.LineSelect = se(new _({
      inSelectionMode: !1,
      id: "_lineSelect",
      precondition: void 0
    })), s.LineSelectDrag = se(new _({
      inSelectionMode: !0,
      id: "_lineSelectDrag",
      precondition: void 0
    }));
    class b extends Li {
      constructor(v) {
        super(v), this._inSelectionMode = v.inSelectionMode;
      }
      runCoreEditorCommand(v, w) {
        const S = v.getLastAddedCursorIndex(), L = v.getCursorStates(), x = L.slice(0);
        x[S] = tn.line(v, L[S], this._inSelectionMode, w.position, w.viewPosition), v.model.pushStackElement(), v.setCursorStates(w.source, 3, x);
      }
    }
    s.LastCursorLineSelect = se(new b({
      inSelectionMode: !1,
      id: "lastCursorLineSelect",
      precondition: void 0
    })), s.LastCursorLineSelectDrag = se(new b({
      inSelectionMode: !0,
      id: "lastCursorLineSelectDrag",
      precondition: void 0
    })), s.CancelSelection = se(new class extends Li {
      constructor() {
        super({
          id: "cancelSelection",
          precondition: T.hasNonEmptySelection,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 9,
            secondary: [1033]
          }
        });
      }
      runCoreEditorCommand(C, v) {
        C.model.pushStackElement(), C.setCursorStates(v.source, 3, [
          tn.cancelSelection(C, C.getPrimaryCursorState())
        ]), C.revealPrimaryCursor(v.source, !0);
      }
    }()), s.RemoveSecondaryCursors = se(new class extends Li {
      constructor() {
        super({
          id: "removeSecondaryCursors",
          precondition: T.hasMultipleSelections,
          kbOpts: {
            weight: gt + 1,
            kbExpr: T.textInputFocus,
            primary: 9,
            secondary: [1033]
          }
        });
      }
      runCoreEditorCommand(C, v) {
        C.model.pushStackElement(), C.setCursorStates(v.source, 3, [
          C.getPrimaryCursorState()
        ]), C.revealPrimaryCursor(v.source, !0), U0(m("removedCursor", "Removed secondary cursors"));
      }
    }()), s.RevealLine = se(new class extends Li {
      constructor() {
        super({
          id: "revealLine",
          precondition: void 0,
          description: Du.description
        });
      }
      runCoreEditorCommand(C, v) {
        const w = v, S = w.lineNumber || 0;
        let L = typeof S == "number" ? S + 1 : parseInt(S) + 1;
        L < 1 && (L = 1);
        const x = C.model.getLineCount();
        L > x && (L = x);
        const y = new D(L, 1, L, C.model.getLineMaxColumn(L));
        let k = 0;
        if (w.at)
          switch (w.at) {
            case Du.RawAtArgument.Top:
              k = 3;
              break;
            case Du.RawAtArgument.Center:
              k = 1;
              break;
            case Du.RawAtArgument.Bottom:
              k = 4;
              break;
          }
        const I = C.coordinatesConverter.convertModelRangeToViewRange(y);
        C.revealRange(v.source, !1, I, k, 0);
      }
    }()), s.SelectAll = new class extends rL {
      constructor() {
        super(bV);
      }
      runDOMCommand() {
        Xs && (document.activeElement.focus(), document.activeElement.select()), document.execCommand("selectAll");
      }
      runEditorCommand(C, v, w) {
        const S = v._getViewModel();
        !S || this.runCoreEditorCommand(S, w);
      }
      runCoreEditorCommand(C, v) {
        C.model.pushStackElement(), C.setCursorStates("keyboard", 3, [
          tn.selectAll(C, C.getPrimaryCursorState())
        ]);
      }
    }(), s.SetSelection = se(new class extends Li {
      constructor() {
        super({
          id: "setSelection",
          precondition: void 0
        });
      }
      runCoreEditorCommand(C, v) {
        C.model.pushStackElement(), C.setCursorStates(v.source, 3, [
          Ze.fromModelSelection(v.selection)
        ]);
      }
    }());
  })(Ui || (Ui = {}));
  const lH = ce.and(T.textInputFocus, T.columnSelection);
  function tg(s, e) {
    Zn.registerKeybindingRule({
      id: s,
      primary: e,
      when: lH,
      weight: gt + 1
    });
  }
  tg(Ui.CursorColumnSelectLeft.id, 1039);
  tg(Ui.CursorColumnSelectRight.id, 1041);
  tg(Ui.CursorColumnSelectUp.id, 1040);
  tg(Ui.CursorColumnSelectPageUp.id, 1035);
  tg(Ui.CursorColumnSelectDown.id, 1042);
  tg(Ui.CursorColumnSelectPageDown.id, 1036);
  function tT(s) {
    return s.register(), s;
  }
  var ju;
  (function(s) {
    class e extends wn {
      runEditorCommand(i, n, o) {
        const r = n._getViewModel();
        !r || this.runCoreEditingCommand(n, r, o || {});
      }
    }
    s.CoreEditingCommand = e, s.LineBreakInsert = se(new class extends e {
      constructor() {
        super({
          id: "lineBreakInsert",
          precondition: T.writable,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 0,
            mac: { primary: 301 }
          }
        });
      }
      runCoreEditingCommand(t, i, n) {
        t.pushUndoStop(), t.executeCommands(this.id, Gt.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection)));
      }
    }()), s.Outdent = se(new class extends e {
      constructor() {
        super({
          id: "outdent",
          precondition: T.writable,
          kbOpts: {
            weight: gt,
            kbExpr: ce.and(T.editorTextFocus, T.tabDoesNotMoveFocus),
            primary: 1026
          }
        });
      }
      runCoreEditingCommand(t, i, n) {
        t.pushUndoStop(), t.executeCommands(this.id, Gt.outdent(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
      }
    }()), s.Tab = se(new class extends e {
      constructor() {
        super({
          id: "tab",
          precondition: T.writable,
          kbOpts: {
            weight: gt,
            kbExpr: ce.and(T.editorTextFocus, T.tabDoesNotMoveFocus),
            primary: 2
          }
        });
      }
      runCoreEditingCommand(t, i, n) {
        t.pushUndoStop(), t.executeCommands(this.id, Gt.tab(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
      }
    }()), s.DeleteLeft = se(new class extends e {
      constructor() {
        super({
          id: "deleteLeft",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 1,
            secondary: [1025],
            mac: { primary: 1, secondary: [1025, 294, 257] }
          }
        });
      }
      runCoreEditingCommand(t, i, n) {
        const [o, r] = Gd.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
        o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(2);
      }
    }()), s.DeleteRight = se(new class extends e {
      constructor() {
        super({
          id: "deleteRight",
          precondition: void 0,
          kbOpts: {
            weight: gt,
            kbExpr: T.textInputFocus,
            primary: 20,
            mac: { primary: 20, secondary: [290, 276] }
          }
        });
      }
      runCoreEditingCommand(t, i, n) {
        const [o, r] = Gd.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
        o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(3);
      }
    }()), s.Undo = new class extends rL {
      constructor() {
        super(HP);
      }
      runDOMCommand() {
        document.execCommand("undo");
      }
      runEditorCommand(t, i, n) {
        if (!(!i.hasModel() || i.getOption(81) === !0))
          return i.getModel().undo();
      }
    }(), s.Redo = new class extends rL {
      constructor() {
        super(zP);
      }
      runDOMCommand() {
        document.execCommand("redo");
      }
      runEditorCommand(t, i, n) {
        if (!(!i.hasModel() || i.getOption(81) === !0))
          return i.getModel().redo();
      }
    }();
  })(ju || (ju = {}));
  class iT extends Hv {
    constructor(e, t, i) {
      super({
        id: e,
        precondition: void 0,
        description: i
      }), this._handlerId = t;
    }
    runCommand(e, t) {
      const i = e.get(St).getFocusedCodeEditor();
      !i || i.trigger("keyboard", this._handlerId, t);
    }
  }
  function Th(s, e) {
    tT(new iT("default:" + s, s)), tT(new iT(s, s, e));
  }
  Th("type", {
    description: "Type",
    args: [{
      name: "args",
      schema: {
        type: "object",
        required: ["text"],
        properties: {
          text: {
            type: "string"
          }
        }
      }
    }]
  });
  Th("replacePreviousChar");
  Th("compositionType");
  Th("compositionStart");
  Th("compositionEnd");
  Th("paste");
  Th("cut");
  const GI = st("markerDecorationsService");
  var cH = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, dH = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Km = class {
    constructor(e, t) {
    }
    dispose() {
    }
  };
  Km.ID = "editor.contrib.markerDecorations";
  Km = cH([
    dH(1, GI)
  ], Km);
  vt(Km.ID, Km);
  function ja(s) {
    if (!s || typeof s != "object" || s instanceof RegExp)
      return s;
    const e = Array.isArray(s) ? [] : {};
    return Object.keys(s).forEach((t) => {
      s[t] && typeof s[t] == "object" ? e[t] = ja(s[t]) : e[t] = s[t];
    }), e;
  }
  function hH(s) {
    if (!s || typeof s != "object")
      return s;
    const e = [s];
    for (; e.length > 0; ) {
      const t = e.shift();
      Object.freeze(t);
      for (const i in t)
        if (a5.call(t, i)) {
          const n = t[i];
          typeof n == "object" && !Object.isFrozen(n) && e.push(n);
        }
    }
    return s;
  }
  const a5 = Object.prototype.hasOwnProperty;
  function uH(s, e) {
    return aL(s, e, /* @__PURE__ */ new Set());
  }
  function aL(s, e, t) {
    if (Ws(s))
      return s;
    const i = e(s);
    if (typeof i < "u")
      return i;
    if (X4(s)) {
      const n = [];
      for (const o of s)
        n.push(aL(o, e, t));
      return n;
    }
    if (ls(s)) {
      if (t.has(s))
        throw new Error("Cannot clone recursive data-structure");
      t.add(s);
      const n = {};
      for (let o in s)
        a5.call(s, o) && (n[o] = aL(s[o], e, t));
      return t.delete(s), n;
    }
    return s;
  }
  function Sa(s, e, t = !0) {
    return ls(s) ? (ls(e) && Object.keys(e).forEach((i) => {
      i in s ? t && (ls(s[i]) && ls(e[i]) ? Sa(s[i], e[i], t) : s[i] = e[i]) : s[i] = e[i];
    }), s) : e;
  }
  function po(s, e) {
    if (s === e)
      return !0;
    if (s == null || e === null || e === void 0 || typeof s != typeof e || typeof s != "object" || Array.isArray(s) !== Array.isArray(e))
      return !1;
    let t, i;
    if (Array.isArray(s)) {
      if (s.length !== e.length)
        return !1;
      for (t = 0; t < s.length; t++)
        if (!po(s[t], e[t]))
          return !1;
    } else {
      const n = [];
      for (i in s)
        n.push(i);
      n.sort();
      const o = [];
      for (i in e)
        o.push(i);
      if (o.sort(), !po(n, o))
        return !1;
      for (t = 0; t < n.length; t++)
        if (!po(s[n[t]], e[n[t]]))
          return !1;
    }
    return !0;
  }
  function xr(s, e, t) {
    const i = e(s);
    return typeof i > "u" ? t : i;
  }
  class l5 extends z {
    constructor(e, t) {
      super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._referenceDomElement = e, this._width = -1, this._height = -1, this._resizeObserver = null, this.measureReferenceDomElement(!1, t);
    }
    dispose() {
      this.stopObserving(), super.dispose();
    }
    getWidth() {
      return this._width;
    }
    getHeight() {
      return this._height;
    }
    startObserving() {
      !this._resizeObserver && this._referenceDomElement && (this._resizeObserver = new ResizeObserver((e) => {
        e && e[0] && e[0].contentRect ? this.observe({ width: e[0].contentRect.width, height: e[0].contentRect.height }) : this.observe();
      }), this._resizeObserver.observe(this._referenceDomElement));
    }
    stopObserving() {
      this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null);
    }
    observe(e) {
      this.measureReferenceDomElement(!0, e);
    }
    measureReferenceDomElement(e, t) {
      let i = 0, n = 0;
      t ? (i = t.width, n = t.height) : this._referenceDomElement && (i = this._referenceDomElement.clientWidth, n = this._referenceDomElement.clientHeight), i = Math.max(5, i), n = Math.max(5, n), (this._width !== i || this._height !== n) && (this._width = i, this._height = n, e && this._onDidChange.fire());
    }
  }
  class c5 {
    constructor(e) {
      this.domNode = e, this._maxWidth = -1, this._width = -1, this._height = -1, this._top = -1, this._left = -1, this._bottom = -1, this._right = -1, this._fontFamily = "", this._fontWeight = "", this._fontSize = -1, this._fontStyle = "", this._fontFeatureSettings = "", this._textDecoration = "", this._lineHeight = -1, this._letterSpacing = -100, this._className = "", this._display = "", this._position = "", this._visibility = "", this._color = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
    }
    setMaxWidth(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.domNode.style.maxWidth = this._maxWidth + "px");
    }
    setWidth(e) {
      this._width !== e && (this._width = e, this.domNode.style.width = this._width + "px");
    }
    setHeight(e) {
      this._height !== e && (this._height = e, this.domNode.style.height = this._height + "px");
    }
    setTop(e) {
      this._top !== e && (this._top = e, this.domNode.style.top = this._top + "px");
    }
    unsetTop() {
      this._top !== -1 && (this._top = -1, this.domNode.style.top = "");
    }
    setLeft(e) {
      this._left !== e && (this._left = e, this.domNode.style.left = this._left + "px");
    }
    setBottom(e) {
      this._bottom !== e && (this._bottom = e, this.domNode.style.bottom = this._bottom + "px");
    }
    setRight(e) {
      this._right !== e && (this._right = e, this.domNode.style.right = this._right + "px");
    }
    setFontFamily(e) {
      this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
    }
    setFontWeight(e) {
      this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
    }
    setFontSize(e) {
      this._fontSize !== e && (this._fontSize = e, this.domNode.style.fontSize = this._fontSize + "px");
    }
    setFontStyle(e) {
      this._fontStyle !== e && (this._fontStyle = e, this.domNode.style.fontStyle = this._fontStyle);
    }
    setFontFeatureSettings(e) {
      this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
    }
    setTextDecoration(e) {
      this._textDecoration !== e && (this._textDecoration = e, this.domNode.style.textDecoration = this._textDecoration);
    }
    setLineHeight(e) {
      this._lineHeight !== e && (this._lineHeight = e, this.domNode.style.lineHeight = this._lineHeight + "px");
    }
    setLetterSpacing(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.domNode.style.letterSpacing = this._letterSpacing + "px");
    }
    setClassName(e) {
      this._className !== e && (this._className = e, this.domNode.className = this._className);
    }
    toggleClassName(e, t) {
      this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
    }
    setDisplay(e) {
      this._display !== e && (this._display = e, this.domNode.style.display = this._display);
    }
    setPosition(e) {
      this._position !== e && (this._position = e, this.domNode.style.position = this._position);
    }
    setVisibility(e) {
      this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
    }
    setColor(e) {
      this._color !== e && (this._color = e, this.domNode.style.color = this._color);
    }
    setBackgroundColor(e) {
      this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
    }
    setLayerHinting(e) {
      this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
    }
    setBoxShadow(e) {
      this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
    }
    setContain(e) {
      this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
    }
    setAttribute(e, t) {
      this.domNode.setAttribute(e, t);
    }
    removeAttribute(e) {
      this.domNode.removeAttribute(e);
    }
    appendChild(e) {
      this.domNode.appendChild(e.domNode);
    }
    removeChild(e) {
      this.domNode.removeChild(e.domNode);
    }
  }
  function dt(s) {
    return new c5(s);
  }
  const On = {
    tabSize: 4,
    indentSize: 4,
    insertSpaces: !0,
    detectIndentation: !0,
    trimAutoWhitespace: !0,
    largeFileOptimizations: !0,
    bracketPairColorizationOptions: { enabled: !1 }
  }, Rl = 8;
  class d5 {
    constructor(e) {
      this._values = e;
    }
    hasChanged(e) {
      return this._values[e];
    }
  }
  class h5 {
    constructor() {
      this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
    }
  }
  class Wi {
    constructor(e, t, i, n) {
      this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
    }
    applyUpdate(e, t) {
      return Gv(e, t);
    }
    compute(e, t, i) {
      return i;
    }
  }
  class nm {
    constructor(e, t) {
      this.newValue = e, this.didChange = t;
    }
  }
  function Gv(s, e) {
    if (typeof s != "object" || typeof e != "object" || !s || !e)
      return new nm(e, s !== e);
    if (Array.isArray(s) || Array.isArray(e)) {
      const i = Array.isArray(s) && Array.isArray(e) && Gs(s, e);
      return new nm(e, i);
    }
    let t = !1;
    for (const i in e)
      if (e.hasOwnProperty(i)) {
        const n = Gv(s[i], e[i]);
        n.didChange && (s[i] = n.newValue, t = !0);
      }
    return new nm(s, t);
  }
  class ig {
    constructor(e) {
      this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
    }
    applyUpdate(e, t) {
      return Gv(e, t);
    }
    validate(e) {
      return this.defaultValue;
    }
  }
  class Mh {
    constructor(e, t, i, n) {
      this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
    }
    applyUpdate(e, t) {
      return Gv(e, t);
    }
    validate(e) {
      return typeof e > "u" ? this.defaultValue : e;
    }
    compute(e, t, i) {
      return i;
    }
  }
  function De(s, e) {
    return typeof s > "u" ? e : s === "false" ? !1 : Boolean(s);
  }
  class nt extends Mh {
    constructor(e, t, i, n = void 0) {
      typeof n < "u" && (n.type = "boolean", n.default = i), super(e, t, i, n);
    }
    validate(e) {
      return De(e, this.defaultValue);
    }
  }
  function lL(s, e, t, i) {
    if (typeof s > "u")
      return e;
    let n = parseInt(s, 10);
    return isNaN(n) ? e : (n = Math.max(t, n), n = Math.min(i, n), n | 0);
  }
  class zt extends Mh {
    constructor(e, t, i, n, o, r = void 0) {
      typeof r < "u" && (r.type = "integer", r.default = i, r.minimum = n, r.maximum = o), super(e, t, i, r), this.minimum = n, this.maximum = o;
    }
    static clampedInt(e, t, i, n) {
      return lL(e, t, i, n);
    }
    validate(e) {
      return zt.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
    }
  }
  class Xr extends Mh {
    constructor(e, t, i, n, o) {
      typeof o < "u" && (o.type = "number", o.default = i), super(e, t, i, o), this.validationFn = n;
    }
    static clamp(e, t, i) {
      return e < t ? t : e > i ? i : e;
    }
    static float(e, t) {
      if (typeof e == "number")
        return e;
      if (typeof e > "u")
        return t;
      const i = parseFloat(e);
      return isNaN(i) ? t : i;
    }
    validate(e) {
      return this.validationFn(Xr.float(e, this.defaultValue));
    }
  }
  class Cs extends Mh {
    static string(e, t) {
      return typeof e != "string" ? t : e;
    }
    constructor(e, t, i, n = void 0) {
      typeof n < "u" && (n.type = "string", n.default = i), super(e, t, i, n);
    }
    validate(e) {
      return Cs.string(e, this.defaultValue);
    }
  }
  function rs(s, e, t) {
    return typeof s != "string" || t.indexOf(s) === -1 ? e : s;
  }
  class Ti extends Mh {
    constructor(e, t, i, n, o = void 0) {
      typeof o < "u" && (o.type = "string", o.enum = n, o.default = i), super(e, t, i, o), this._allowedValues = n;
    }
    validate(e) {
      return rs(e, this.defaultValue, this._allowedValues);
    }
  }
  class vg extends Wi {
    constructor(e, t, i, n, o, r, a = void 0) {
      typeof a < "u" && (a.type = "string", a.enum = o, a.default = n), super(e, t, i, a), this._allowedValues = o, this._convert = r;
    }
    validate(e) {
      return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
    }
  }
  function fH(s) {
    switch (s) {
      case "none":
        return 0;
      case "keep":
        return 1;
      case "brackets":
        return 2;
      case "advanced":
        return 3;
      case "full":
        return 4;
    }
  }
  class gH extends Wi {
    constructor() {
      super(2, "accessibilitySupport", 0, {
        type: "string",
        enum: ["auto", "on", "off"],
        enumDescriptions: [
          m("accessibilitySupport.auto", "The editor will use platform APIs to detect when a Screen Reader is attached."),
          m("accessibilitySupport.on", "The editor will be permanently optimized for usage with a Screen Reader. Word wrapping will be disabled."),
          m("accessibilitySupport.off", "The editor will never be optimized for usage with a Screen Reader.")
        ],
        default: "auto",
        description: m("accessibilitySupport", "Controls whether the editor should run in a mode where it is optimized for screen readers. Setting to on will disable word wrapping.")
      });
    }
    validate(e) {
      switch (e) {
        case "auto":
          return 0;
        case "off":
          return 1;
        case "on":
          return 2;
      }
      return this.defaultValue;
    }
    compute(e, t, i) {
      return i === 0 ? e.accessibilitySupport : i;
    }
  }
  class mH extends Wi {
    constructor() {
      const e = {
        insertSpace: !0,
        ignoreEmptyLines: !0
      };
      super(19, "comments", e, {
        "editor.comments.insertSpace": {
          type: "boolean",
          default: e.insertSpace,
          description: m("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
        },
        "editor.comments.ignoreEmptyLines": {
          type: "boolean",
          default: e.ignoreEmptyLines,
          description: m("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        insertSpace: De(t.insertSpace, this.defaultValue.insertSpace),
        ignoreEmptyLines: De(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
      };
    }
  }
  function pH(s) {
    switch (s) {
      case "blink":
        return 1;
      case "smooth":
        return 2;
      case "phase":
        return 3;
      case "expand":
        return 4;
      case "solid":
        return 5;
    }
  }
  var sn;
  (function(s) {
    s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
  })(sn || (sn = {}));
  function _H(s) {
    switch (s) {
      case "line":
        return sn.Line;
      case "block":
        return sn.Block;
      case "underline":
        return sn.Underline;
      case "line-thin":
        return sn.LineThin;
      case "block-outline":
        return sn.BlockOutline;
      case "underline-thin":
        return sn.UnderlineThin;
    }
  }
  class bH extends ig {
    constructor() {
      super(128);
    }
    compute(e, t, i) {
      const n = ["monaco-editor"];
      return t.get(33) && n.push(t.get(33)), e.extraEditorClassName && n.push(e.extraEditorClassName), t.get(66) === "default" ? n.push("mouse-default") : t.get(66) === "copy" && n.push("mouse-copy"), t.get(100) && n.push("showUnused"), t.get(126) && n.push("showDeprecated"), n.join(" ");
    }
  }
  class vH extends nt {
    constructor() {
      super(32, "emptySelectionClipboard", !0, { description: m("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
    }
    compute(e, t, i) {
      return i && e.emptySelectionClipboard;
    }
  }
  class CH extends Wi {
    constructor() {
      const e = {
        cursorMoveOnType: !0,
        seedSearchStringFromSelection: "always",
        autoFindInSelection: "never",
        globalFindClipboard: !1,
        addExtraSpaceOnTop: !0,
        loop: !0
      };
      super(35, "find", e, {
        "editor.find.cursorMoveOnType": {
          type: "boolean",
          default: e.cursorMoveOnType,
          description: m("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
        },
        "editor.find.seedSearchStringFromSelection": {
          type: "string",
          enum: ["never", "always", "selection"],
          default: e.seedSearchStringFromSelection,
          enumDescriptions: [
            m("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
            m("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
            m("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
          ],
          description: m("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
        },
        "editor.find.autoFindInSelection": {
          type: "string",
          enum: ["never", "always", "multiline"],
          default: e.autoFindInSelection,
          enumDescriptions: [
            m("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
            m("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
            m("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
          ],
          description: m("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
        },
        "editor.find.globalFindClipboard": {
          type: "boolean",
          default: e.globalFindClipboard,
          description: m("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
          included: Ye
        },
        "editor.find.addExtraSpaceOnTop": {
          type: "boolean",
          default: e.addExtraSpaceOnTop,
          description: m("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
        },
        "editor.find.loop": {
          type: "boolean",
          default: e.loop,
          description: m("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        cursorMoveOnType: De(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
        seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : rs(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
        autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : rs(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
        globalFindClipboard: De(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
        addExtraSpaceOnTop: De(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
        loop: De(t.loop, this.defaultValue.loop)
      };
    }
  }
  class zs extends Wi {
    constructor() {
      super(45, "fontLigatures", zs.OFF, {
        anyOf: [
          {
            type: "boolean",
            description: m("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
          },
          {
            type: "string",
            description: m("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
          }
        ],
        description: m("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
        default: !1
      });
    }
    validate(e) {
      return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? zs.OFF : e === "true" ? zs.ON : e : Boolean(e) ? zs.ON : zs.OFF;
    }
  }
  zs.OFF = '"liga" off, "calt" off';
  zs.ON = '"liga" on, "calt" on';
  class wH extends ig {
    constructor() {
      super(44);
    }
    compute(e, t, i) {
      return e.fontInfo;
    }
  }
  class SH extends Mh {
    constructor() {
      super(46, "fontSize", Fn.fontSize, {
        type: "number",
        minimum: 6,
        maximum: 100,
        default: Fn.fontSize,
        description: m("fontSize", "Controls the font size in pixels.")
      });
    }
    validate(e) {
      const t = Xr.float(e, this.defaultValue);
      return t === 0 ? Fn.fontSize : Xr.clamp(t, 6, 100);
    }
    compute(e, t, i) {
      return e.fontInfo.fontSize;
    }
  }
  class Kr extends Wi {
    constructor() {
      super(47, "fontWeight", Fn.fontWeight, {
        anyOf: [
          {
            type: "number",
            minimum: Kr.MINIMUM_VALUE,
            maximum: Kr.MAXIMUM_VALUE,
            errorMessage: m("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
          },
          {
            type: "string",
            pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
          },
          {
            enum: Kr.SUGGESTION_VALUES
          }
        ],
        default: Fn.fontWeight,
        description: m("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
      });
    }
    validate(e) {
      return e === "normal" || e === "bold" ? e : String(zt.clampedInt(e, Fn.fontWeight, Kr.MINIMUM_VALUE, Kr.MAXIMUM_VALUE));
    }
  }
  Kr.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
  Kr.MINIMUM_VALUE = 1;
  Kr.MAXIMUM_VALUE = 1e3;
  class yH extends Wi {
    constructor() {
      const e = {
        multiple: "peek",
        multipleDefinitions: "peek",
        multipleTypeDefinitions: "peek",
        multipleDeclarations: "peek",
        multipleImplementations: "peek",
        multipleReferences: "peek",
        alternativeDefinitionCommand: "editor.action.goToReferences",
        alternativeTypeDefinitionCommand: "editor.action.goToReferences",
        alternativeDeclarationCommand: "editor.action.goToReferences",
        alternativeImplementationCommand: "",
        alternativeReferenceCommand: ""
      }, t = {
        type: "string",
        enum: ["peek", "gotoAndPeek", "goto"],
        default: e.multiple,
        enumDescriptions: [
          m("editor.gotoLocation.multiple.peek", "Show peek view of the results (default)"),
          m("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a peek view"),
          m("editor.gotoLocation.multiple.goto", "Go to the primary result and enable peek-less navigation to others")
        ]
      }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
      super(51, "gotoLocation", e, {
        "editor.gotoLocation.multiple": {
          deprecationMessage: m("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
        },
        "editor.gotoLocation.multipleDefinitions": Object.assign({ description: m("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.") }, t),
        "editor.gotoLocation.multipleTypeDefinitions": Object.assign({ description: m("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.") }, t),
        "editor.gotoLocation.multipleDeclarations": Object.assign({ description: m("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.") }, t),
        "editor.gotoLocation.multipleImplementations": Object.assign({ description: m("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.") }, t),
        "editor.gotoLocation.multipleReferences": Object.assign({ description: m("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist.") }, t),
        "editor.gotoLocation.alternativeDefinitionCommand": {
          type: "string",
          default: e.alternativeDefinitionCommand,
          enum: i,
          description: m("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
        },
        "editor.gotoLocation.alternativeTypeDefinitionCommand": {
          type: "string",
          default: e.alternativeTypeDefinitionCommand,
          enum: i,
          description: m("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
        },
        "editor.gotoLocation.alternativeDeclarationCommand": {
          type: "string",
          default: e.alternativeDeclarationCommand,
          enum: i,
          description: m("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
        },
        "editor.gotoLocation.alternativeImplementationCommand": {
          type: "string",
          default: e.alternativeImplementationCommand,
          enum: i,
          description: m("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
        },
        "editor.gotoLocation.alternativeReferenceCommand": {
          type: "string",
          default: e.alternativeReferenceCommand,
          enum: i,
          description: m("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
        }
      });
    }
    validate(e) {
      var t, i, n, o, r;
      if (!e || typeof e != "object")
        return this.defaultValue;
      const a = e;
      return {
        multiple: rs(a.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
        multipleDefinitions: (t = a.multipleDefinitions) !== null && t !== void 0 ? t : rs(a.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleTypeDefinitions: (i = a.multipleTypeDefinitions) !== null && i !== void 0 ? i : rs(a.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleDeclarations: (n = a.multipleDeclarations) !== null && n !== void 0 ? n : rs(a.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleImplementations: (o = a.multipleImplementations) !== null && o !== void 0 ? o : rs(a.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleReferences: (r = a.multipleReferences) !== null && r !== void 0 ? r : rs(a.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
        alternativeDefinitionCommand: Cs.string(a.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
        alternativeTypeDefinitionCommand: Cs.string(a.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
        alternativeDeclarationCommand: Cs.string(a.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
        alternativeImplementationCommand: Cs.string(a.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
        alternativeReferenceCommand: Cs.string(a.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
      };
    }
  }
  class LH extends Wi {
    constructor() {
      const e = {
        enabled: !0,
        delay: 300,
        sticky: !0,
        above: !0
      };
      super(53, "hover", e, {
        "editor.hover.enabled": {
          type: "boolean",
          default: e.enabled,
          description: m("hover.enabled", "Controls whether the hover is shown.")
        },
        "editor.hover.delay": {
          type: "number",
          default: e.delay,
          minimum: 0,
          maximum: 1e4,
          description: m("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
        },
        "editor.hover.sticky": {
          type: "boolean",
          default: e.sticky,
          description: m("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
        },
        "editor.hover.above": {
          type: "boolean",
          default: e.above,
          description: m("hover.above", "Prefer showing hovers above the line, if there's space.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        enabled: De(t.enabled, this.defaultValue.enabled),
        delay: zt.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
        sticky: De(t.sticky, this.defaultValue.sticky),
        above: De(t.above, this.defaultValue.above)
      };
    }
  }
  class Ku extends ig {
    constructor() {
      super(131);
    }
    compute(e, t, i) {
      return Ku.computeLayout(t, {
        memory: e.memory,
        outerWidth: e.outerWidth,
        outerHeight: e.outerHeight,
        isDominatedByLongLines: e.isDominatedByLongLines,
        lineHeight: e.fontInfo.lineHeight,
        viewLineCount: e.viewLineCount,
        lineNumbersDigitCount: e.lineNumbersDigitCount,
        typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
        maxDigitWidth: e.fontInfo.maxDigitWidth,
        pixelRatio: e.pixelRatio
      });
    }
    static computeContainedMinimapLineCount(e) {
      const t = e.height / e.lineHeight, i = e.scrollBeyondLastLine ? t - 1 : 0, n = (e.viewLineCount + i) / (e.pixelRatio * e.height), o = Math.floor(e.viewLineCount / n);
      return { typicalViewportLineCount: t, extraLinesBeyondLastLine: i, desiredRatio: n, minimapLineCount: o };
    }
    static _computeMinimapLayout(e, t) {
      const i = e.outerWidth, n = e.outerHeight, o = e.pixelRatio;
      if (!e.minimap.enabled)
        return {
          renderMinimap: 0,
          minimapLeft: 0,
          minimapWidth: 0,
          minimapHeightIsEditorHeight: !1,
          minimapIsSampling: !1,
          minimapScale: 1,
          minimapLineHeight: 1,
          minimapCanvasInnerWidth: 0,
          minimapCanvasInnerHeight: Math.floor(o * n),
          minimapCanvasOuterWidth: 0,
          minimapCanvasOuterHeight: n
        };
      const r = t.stableMinimapLayoutInput, a = r && e.outerHeight === r.outerHeight && e.lineHeight === r.lineHeight && e.typicalHalfwidthCharacterWidth === r.typicalHalfwidthCharacterWidth && e.pixelRatio === r.pixelRatio && e.scrollBeyondLastLine === r.scrollBeyondLastLine && e.minimap.enabled === r.minimap.enabled && e.minimap.side === r.minimap.side && e.minimap.size === r.minimap.size && e.minimap.showSlider === r.minimap.showSlider && e.minimap.renderCharacters === r.minimap.renderCharacters && e.minimap.maxColumn === r.minimap.maxColumn && e.minimap.scale === r.minimap.scale && e.verticalScrollbarWidth === r.verticalScrollbarWidth && e.isViewportWrapping === r.isViewportWrapping, l = e.lineHeight, c = e.typicalHalfwidthCharacterWidth, d = e.scrollBeyondLastLine, h = e.minimap.renderCharacters;
      let u = o >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
      const f = e.minimap.maxColumn, g = e.minimap.size, _ = e.minimap.side, b = e.verticalScrollbarWidth, C = e.viewLineCount, v = e.remainingWidth, w = e.isViewportWrapping, S = h ? 2 : 3;
      let L = Math.floor(o * n);
      const x = L / o;
      let y = !1, k = !1, I = S * u, F = u / o, R = 1;
      if (g === "fill" || g === "fit") {
        const { typicalViewportLineCount: xe, extraLinesBeyondLastLine: Ve, desiredRatio: Ct, minimapLineCount: bt } = Ku.computeContainedMinimapLineCount({
          viewLineCount: C,
          scrollBeyondLastLine: d,
          height: n,
          lineHeight: l,
          pixelRatio: o
        });
        if (C / bt > 1)
          y = !0, k = !0, u = 1, I = 1, F = u / o;
        else {
          let pe = !1, ft = u + 1;
          if (g === "fit") {
            const Hi = Math.ceil((C + Ve) * I);
            w && a && v <= t.stableFitRemainingWidth ? (pe = !0, ft = t.stableFitMaxMinimapScale) : pe = Hi > L;
          }
          if (g === "fill" || pe) {
            y = !0;
            const Hi = u;
            I = Math.min(l * o, Math.max(1, Math.floor(1 / Ct))), w && a && v <= t.stableFitRemainingWidth && (ft = t.stableFitMaxMinimapScale), u = Math.min(ft, Math.max(1, Math.floor(I / S))), u > Hi && (R = Math.min(2, u / Hi)), F = u / o / R, L = Math.ceil(Math.max(xe, C + Ve) * I), w ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = v, t.stableFitMaxMinimapScale = u) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0);
          }
        }
      }
      const $ = Math.floor(f * F), j = Math.min($, Math.max(0, Math.floor((v - b - 2) * F / (c + F))) + Rl);
      let le = Math.floor(o * j);
      const he = le / o;
      le = Math.floor(le * R);
      const Ce = h ? 1 : 2, Ne = _ === "left" ? 0 : i - j - b;
      return {
        renderMinimap: Ce,
        minimapLeft: Ne,
        minimapWidth: j,
        minimapHeightIsEditorHeight: y,
        minimapIsSampling: k,
        minimapScale: u,
        minimapLineHeight: I,
        minimapCanvasInnerWidth: le,
        minimapCanvasInnerHeight: L,
        minimapCanvasOuterWidth: he,
        minimapCanvasOuterHeight: x
      };
    }
    static computeLayout(e, t) {
      const i = t.outerWidth | 0, n = t.outerHeight | 0, o = t.lineHeight | 0, r = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, c = t.pixelRatio, d = t.viewLineCount, h = e.get(123), u = h === "inherit" ? e.get(122) : h, f = u === "inherit" ? e.get(118) : u, g = e.get(121), _ = e.get(2), b = t.isDominatedByLongLines, C = e.get(50), v = e.get(60).renderType !== 0, w = e.get(61), S = e.get(94), L = e.get(65), x = e.get(92), y = x.verticalScrollbarSize, k = x.verticalHasArrows, I = x.arrowSize, F = x.horizontalScrollbarSize, R = e.get(58), $ = e.get(37);
      let j;
      if (typeof R == "string" && /^\d+(\.\d+)?ch$/.test(R)) {
        const Ao = parseFloat(R.substr(0, R.length - 2));
        j = zt.clampedInt(Ao * a, 0, 0, 1e3);
      } else
        j = zt.clampedInt(R, 0, 0, 1e3);
      $ && (j += 16);
      let le = 0;
      if (v) {
        const Ao = Math.max(r, w);
        le = Math.round(Ao * l);
      }
      let he = 0;
      C && (he = o);
      let Ce = 0, Ne = Ce + he, xe = Ne + le, Ve = xe + j;
      const Ct = i - he - le - j;
      let bt = !1, ve = !1, pe = -1;
      _ !== 2 && (u === "inherit" && b ? (bt = !0, ve = !0) : f === "on" || f === "bounded" ? ve = !0 : f === "wordWrapColumn" && (pe = g));
      const ft = Ku._computeMinimapLayout({
        outerWidth: i,
        outerHeight: n,
        lineHeight: o,
        typicalHalfwidthCharacterWidth: a,
        pixelRatio: c,
        scrollBeyondLastLine: S,
        minimap: L,
        verticalScrollbarWidth: y,
        viewLineCount: d,
        remainingWidth: Ct,
        isViewportWrapping: ve
      }, t.memory || new h5());
      ft.renderMinimap !== 0 && ft.minimapLeft === 0 && (Ce += ft.minimapWidth, Ne += ft.minimapWidth, xe += ft.minimapWidth, Ve += ft.minimapWidth);
      const Hi = Ct - ft.minimapWidth, Ri = Math.max(1, Math.floor((Hi - y - 2) / a)), ms = k ? I : 0;
      return ve && (pe = Math.max(1, Ri), f === "bounded" && (pe = Math.min(pe, g))), {
        width: i,
        height: n,
        glyphMarginLeft: Ce,
        glyphMarginWidth: he,
        lineNumbersLeft: Ne,
        lineNumbersWidth: le,
        decorationsLeft: xe,
        decorationsWidth: j,
        contentLeft: Ve,
        contentWidth: Hi,
        minimap: ft,
        viewportColumn: Ri,
        isWordWrapMinified: bt,
        isViewportWrapping: ve,
        wrappingColumn: pe,
        verticalScrollbarWidth: y,
        horizontalScrollbarHeight: F,
        overviewRuler: {
          top: ms,
          width: y,
          height: n - 2 * ms,
          right: 0
        }
      };
    }
  }
  class kH extends Wi {
    constructor() {
      const e = { enabled: !0 };
      super(57, "lightbulb", e, {
        "editor.lightbulb.enabled": {
          type: "boolean",
          default: e.enabled,
          description: m("codeActions", "Enables the code action lightbulb in the editor.")
        }
      });
    }
    validate(e) {
      return !e || typeof e != "object" ? this.defaultValue : {
        enabled: De(e.enabled, this.defaultValue.enabled)
      };
    }
  }
  class DH extends Wi {
    constructor() {
      const e = { enabled: !0, fontSize: 0, fontFamily: "" };
      super(127, "inlayHints", e, {
        "editor.inlayHints.enabled": {
          type: "boolean",
          default: e.enabled,
          description: m("inlayHints.enable", "Enables the inlay hints in the editor.")
        },
        "editor.inlayHints.fontSize": {
          type: "number",
          default: e.fontSize,
          markdownDescription: m("inlayHints.fontSize", "Controls font size of inlay hints in the editor. A default of 90% of `#editor.fontSize#` is used when the configured value is less than `5` or greater than the editor font size.")
        },
        "editor.inlayHints.fontFamily": {
          type: "string",
          default: e.fontFamily,
          markdownDescription: m("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the `#editor.fontFamily#` is used.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        enabled: De(t.enabled, this.defaultValue.enabled),
        fontSize: zt.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
        fontFamily: Cs.string(t.fontFamily, this.defaultValue.fontFamily)
      };
    }
  }
  class xH extends Xr {
    constructor() {
      super(59, "lineHeight", Fn.lineHeight, (e) => Xr.clamp(e, 0, 150), { markdownDescription: m("lineHeight", `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`) });
    }
    compute(e, t, i) {
      return e.fontInfo.lineHeight;
    }
  }
  class IH extends Wi {
    constructor() {
      const e = {
        enabled: !0,
        size: "proportional",
        side: "right",
        showSlider: "mouseover",
        renderCharacters: !0,
        maxColumn: 120,
        scale: 1
      };
      super(65, "minimap", e, {
        "editor.minimap.enabled": {
          type: "boolean",
          default: e.enabled,
          description: m("minimap.enabled", "Controls whether the minimap is shown.")
        },
        "editor.minimap.size": {
          type: "string",
          enum: ["proportional", "fill", "fit"],
          enumDescriptions: [
            m("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
            m("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
            m("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
          ],
          default: e.size,
          description: m("minimap.size", "Controls the size of the minimap.")
        },
        "editor.minimap.side": {
          type: "string",
          enum: ["left", "right"],
          default: e.side,
          description: m("minimap.side", "Controls the side where to render the minimap.")
        },
        "editor.minimap.showSlider": {
          type: "string",
          enum: ["always", "mouseover"],
          default: e.showSlider,
          description: m("minimap.showSlider", "Controls when the minimap slider is shown.")
        },
        "editor.minimap.scale": {
          type: "number",
          default: e.scale,
          minimum: 1,
          maximum: 3,
          enum: [1, 2, 3],
          description: m("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
        },
        "editor.minimap.renderCharacters": {
          type: "boolean",
          default: e.renderCharacters,
          description: m("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
        },
        "editor.minimap.maxColumn": {
          type: "number",
          default: e.maxColumn,
          description: m("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        enabled: De(t.enabled, this.defaultValue.enabled),
        size: rs(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
        side: rs(t.side, this.defaultValue.side, ["right", "left"]),
        showSlider: rs(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
        renderCharacters: De(t.renderCharacters, this.defaultValue.renderCharacters),
        scale: zt.clampedInt(t.scale, 1, 1, 3),
        maxColumn: zt.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
      };
    }
  }
  function EH(s) {
    return s === "ctrlCmd" ? Ye ? "metaKey" : "ctrlKey" : "altKey";
  }
  class NH extends Wi {
    constructor() {
      super(75, "padding", { top: 0, bottom: 0 }, {
        "editor.padding.top": {
          type: "number",
          default: 0,
          minimum: 0,
          maximum: 1e3,
          description: m("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
        },
        "editor.padding.bottom": {
          type: "number",
          default: 0,
          minimum: 0,
          maximum: 1e3,
          description: m("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        top: zt.clampedInt(t.top, 0, 0, 1e3),
        bottom: zt.clampedInt(t.bottom, 0, 0, 1e3)
      };
    }
  }
  class TH extends Wi {
    constructor() {
      const e = {
        enabled: !0,
        cycle: !1
      };
      super(76, "parameterHints", e, {
        "editor.parameterHints.enabled": {
          type: "boolean",
          default: e.enabled,
          description: m("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
        },
        "editor.parameterHints.cycle": {
          type: "boolean",
          default: e.cycle,
          description: m("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        enabled: De(t.enabled, this.defaultValue.enabled),
        cycle: De(t.cycle, this.defaultValue.cycle)
      };
    }
  }
  class MH extends ig {
    constructor() {
      super(129);
    }
    compute(e, t, i) {
      return e.pixelRatio;
    }
  }
  class AH extends Wi {
    constructor() {
      const e = {
        other: !0,
        comments: !1,
        strings: !1
      };
      super(79, "quickSuggestions", e, {
        anyOf: [
          {
            type: "boolean"
          },
          {
            type: "object",
            properties: {
              strings: {
                type: "boolean",
                default: e.strings,
                description: m("quickSuggestions.strings", "Enable quick suggestions inside strings.")
              },
              comments: {
                type: "boolean",
                default: e.comments,
                description: m("quickSuggestions.comments", "Enable quick suggestions inside comments.")
              },
              other: {
                type: "boolean",
                default: e.other,
                description: m("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
              }
            }
          }
        ],
        default: e,
        description: m("quickSuggestions", "Controls whether suggestions should automatically show up while typing.")
      }), this.defaultValue = e;
    }
    validate(e) {
      if (typeof e == "boolean")
        return e;
      if (e && typeof e == "object") {
        const t = e, i = {
          other: De(t.other, this.defaultValue.other),
          comments: De(t.comments, this.defaultValue.comments),
          strings: De(t.strings, this.defaultValue.strings)
        };
        return i.other && i.comments && i.strings ? !0 : !i.other && !i.comments && !i.strings ? !1 : i;
      }
      return this.defaultValue;
    }
  }
  class RH extends Wi {
    constructor() {
      super(60, "lineNumbers", { renderType: 1, renderFn: null }, {
        type: "string",
        enum: ["off", "on", "relative", "interval"],
        enumDescriptions: [
          m("lineNumbers.off", "Line numbers are not rendered."),
          m("lineNumbers.on", "Line numbers are rendered as absolute number."),
          m("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
          m("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
        ],
        default: "on",
        description: m("lineNumbers", "Controls the display of line numbers.")
      });
    }
    validate(e) {
      let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
      return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
        renderType: t,
        renderFn: i
      };
    }
  }
  function o1(s) {
    const e = s.get(87);
    return e === "editable" ? s.get(81) : e !== "on";
  }
  class OH extends Wi {
    constructor() {
      const e = [], t = { type: "number", description: m("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
      super(91, "rulers", e, {
        type: "array",
        items: {
          anyOf: [
            t,
            {
              type: [
                "object"
              ],
              properties: {
                column: t,
                color: {
                  type: "string",
                  description: m("rulers.color", "Color of this editor ruler."),
                  format: "color-hex"
                }
              }
            }
          ]
        },
        default: e,
        description: m("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
      });
    }
    validate(e) {
      if (Array.isArray(e)) {
        const t = [];
        for (let i of e)
          if (typeof i == "number")
            t.push({
              column: zt.clampedInt(i, 0, 0, 1e4),
              color: null
            });
          else if (i && typeof i == "object") {
            const n = i;
            t.push({
              column: zt.clampedInt(n.column, 0, 0, 1e4),
              color: n.color
            });
          }
        return t.sort((i, n) => i.column - n.column), t;
      }
      return this.defaultValue;
    }
  }
  function nT(s, e) {
    if (typeof s != "string")
      return e;
    switch (s) {
      case "hidden":
        return 2;
      case "visible":
        return 3;
      default:
        return 1;
    }
  }
  class PH extends Wi {
    constructor() {
      const e = {
        vertical: 1,
        horizontal: 1,
        arrowSize: 11,
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        horizontalScrollbarSize: 12,
        horizontalSliderSize: 12,
        verticalScrollbarSize: 14,
        verticalSliderSize: 14,
        handleMouseWheel: !0,
        alwaysConsumeMouseWheel: !0,
        scrollByPage: !1
      };
      super(92, "scrollbar", e, {
        "editor.scrollbar.vertical": {
          type: "string",
          enum: ["auto", "visible", "hidden"],
          enumDescriptions: [
            m("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
            m("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
            m("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
          ],
          default: "auto",
          description: m("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
        },
        "editor.scrollbar.horizontal": {
          type: "string",
          enum: ["auto", "visible", "hidden"],
          enumDescriptions: [
            m("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
            m("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
            m("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
          ],
          default: "auto",
          description: m("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
        },
        "editor.scrollbar.verticalScrollbarSize": {
          type: "number",
          default: e.verticalScrollbarSize,
          description: m("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
        },
        "editor.scrollbar.horizontalScrollbarSize": {
          type: "number",
          default: e.horizontalScrollbarSize,
          description: m("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
        },
        "editor.scrollbar.scrollByPage": {
          type: "boolean",
          default: e.scrollByPage,
          description: m("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e, i = zt.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), n = zt.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
      return {
        arrowSize: zt.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
        vertical: nT(t.vertical, this.defaultValue.vertical),
        horizontal: nT(t.horizontal, this.defaultValue.horizontal),
        useShadows: De(t.useShadows, this.defaultValue.useShadows),
        verticalHasArrows: De(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
        horizontalHasArrows: De(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
        handleMouseWheel: De(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
        alwaysConsumeMouseWheel: De(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
        horizontalScrollbarSize: i,
        horizontalSliderSize: zt.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
        verticalScrollbarSize: n,
        verticalSliderSize: zt.clampedInt(t.verticalSliderSize, n, 0, 1e3),
        scrollByPage: De(t.scrollByPage, this.defaultValue.scrollByPage)
      };
    }
  }
  const Fs = "inUntrustedWorkspace", ss = {
    allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
    invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
    nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
    ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
    includeComments: "editor.unicodeHighlight.includeComments",
    includeStrings: "editor.unicodeHighlight.includeStrings",
    allowedLocales: "editor.unicodeHighlight.allowedLocales"
  };
  class FH extends Wi {
    constructor() {
      const e = {
        nonBasicASCII: Fs,
        invisibleCharacters: !0,
        ambiguousCharacters: !0,
        includeComments: Fs,
        includeStrings: !0,
        allowedCharacters: {},
        allowedLocales: { _os: !0, _vscode: !0 }
      };
      super(113, "unicodeHighlight", e, {
        [ss.nonBasicASCII]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Fs],
          default: e.nonBasicASCII,
          description: m("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
        },
        [ss.invisibleCharacters]: {
          restricted: !0,
          type: "boolean",
          default: e.invisibleCharacters,
          description: m("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
        },
        [ss.ambiguousCharacters]: {
          restricted: !0,
          type: "boolean",
          default: e.ambiguousCharacters,
          description: m("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
        },
        [ss.includeComments]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Fs],
          default: e.includeComments,
          description: m("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to unicode highlighting.")
        },
        [ss.includeStrings]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Fs],
          default: e.includeStrings,
          description: m("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to unicode highlighting.")
        },
        [ss.allowedCharacters]: {
          restricted: !0,
          type: "object",
          default: e.allowedCharacters,
          description: m("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
          additionalProperties: {
            type: "boolean"
          }
        },
        [ss.allowedLocales]: {
          restricted: !0,
          type: "object",
          additionalProperties: {
            type: "boolean"
          },
          default: e.allowedLocales,
          description: m("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
        }
      });
    }
    applyUpdate(e, t) {
      let i = !1;
      t.allowedCharacters && (po(e.allowedCharacters, t.allowedCharacters) || (e = Object.assign(Object.assign({}, e), { allowedCharacters: t.allowedCharacters }), i = !0)), t.allowedLocales && (po(e.allowedLocales, t.allowedLocales) || (e = Object.assign(Object.assign({}, e), { allowedLocales: t.allowedLocales }), i = !0));
      const n = super.applyUpdate(e, t);
      return i ? new nm(n.newValue, !0) : n;
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        nonBasicASCII: sm(t.nonBasicASCII, Fs, [!0, !1, Fs]),
        invisibleCharacters: De(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
        ambiguousCharacters: De(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
        includeComments: sm(t.includeComments, Fs, [!0, !1, Fs]),
        includeStrings: sm(t.includeStrings, Fs, [!0, !1, Fs]),
        allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
        allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
      };
    }
    validateBooleanMap(e, t) {
      if (typeof e != "object" || !e)
        return t;
      const i = {};
      for (const [n, o] of Object.entries(e))
        o === !0 && (i[n] = !0);
      return i;
    }
  }
  class BH extends Wi {
    constructor() {
      const e = {
        enabled: !0,
        mode: "subwordSmart"
      };
      super(55, "inlineSuggest", e, {
        "editor.inlineSuggest.enabled": {
          type: "boolean",
          default: e.enabled,
          description: m("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        enabled: De(t.enabled, this.defaultValue.enabled),
        mode: rs(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"])
      };
    }
  }
  class WH extends Wi {
    constructor() {
      const e = {
        enabled: On.bracketPairColorizationOptions.enabled
      };
      super(12, "bracketPairColorization", e, {
        "editor.bracketPairColorization.enabled": {
          type: "boolean",
          default: e.enabled,
          description: m("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use 'workbench.colorCustomizations' to override the bracket highlight colors.")
        }
      });
    }
    validate(e) {
      return !e || typeof e != "object" ? this.defaultValue : {
        enabled: De(e.enabled, this.defaultValue.enabled)
      };
    }
  }
  class VH extends Wi {
    constructor() {
      const e = {
        bracketPairs: !1,
        bracketPairsHorizontal: "active",
        highlightActiveBracketPair: !0,
        indentation: !0,
        highlightActiveIndentation: !0
      };
      super(13, "guides", e, {
        "editor.guides.bracketPairs": {
          type: ["boolean", "string"],
          enum: [!0, "active", !1],
          enumDescriptions: [
            m("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
            m("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
            m("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
          ],
          default: e.bracketPairs,
          description: m("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
        },
        "editor.guides.bracketPairsHorizontal": {
          type: ["boolean", "string"],
          enum: [!0, "active", !1],
          enumDescriptions: [
            m("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
            m("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
            m("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
          ],
          default: e.bracketPairsHorizontal,
          description: m("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
        },
        "editor.guides.highlightActiveBracketPair": {
          type: "boolean",
          default: e.highlightActiveBracketPair,
          description: m("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
        },
        "editor.guides.indentation": {
          type: "boolean",
          default: e.indentation,
          description: m("editor.guides.indentation", "Controls whether the editor should render indent guides.")
        },
        "editor.guides.highlightActiveIndentation": {
          type: "boolean",
          default: e.highlightActiveIndentation,
          description: m("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        bracketPairs: sm(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
        bracketPairsHorizontal: sm(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [!0, !1, "active"]),
        highlightActiveBracketPair: De(t.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
        indentation: De(t.indentation, this.defaultValue.indentation),
        highlightActiveIndentation: De(t.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation)
      };
    }
  }
  function sm(s, e, t) {
    const i = t.indexOf(s);
    return i === -1 ? e : t[i];
  }
  class HH extends Wi {
    constructor() {
      const e = {
        insertMode: "insert",
        filterGraceful: !0,
        snippetsPreventQuickSuggestions: !0,
        localityBonus: !1,
        shareSuggestSelections: !1,
        showIcons: !0,
        showStatusBar: !1,
        preview: !1,
        previewMode: "subwordSmart",
        showInlineDetails: !0,
        showMethods: !0,
        showFunctions: !0,
        showConstructors: !0,
        showDeprecated: !0,
        showFields: !0,
        showVariables: !0,
        showClasses: !0,
        showStructs: !0,
        showInterfaces: !0,
        showModules: !0,
        showProperties: !0,
        showEvents: !0,
        showOperators: !0,
        showUnits: !0,
        showValues: !0,
        showConstants: !0,
        showEnums: !0,
        showEnumMembers: !0,
        showKeywords: !0,
        showWords: !0,
        showColors: !0,
        showFiles: !0,
        showReferences: !0,
        showFolders: !0,
        showTypeParameters: !0,
        showSnippets: !0,
        showUsers: !0,
        showIssues: !0
      };
      super(106, "suggest", e, {
        "editor.suggest.insertMode": {
          type: "string",
          enum: ["insert", "replace"],
          enumDescriptions: [
            m("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
            m("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
          ],
          default: e.insertMode,
          description: m("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
        },
        "editor.suggest.filterGraceful": {
          type: "boolean",
          default: e.filterGraceful,
          description: m("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
        },
        "editor.suggest.localityBonus": {
          type: "boolean",
          default: e.localityBonus,
          description: m("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
        },
        "editor.suggest.shareSuggestSelections": {
          type: "boolean",
          default: e.shareSuggestSelections,
          markdownDescription: m("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
        },
        "editor.suggest.snippetsPreventQuickSuggestions": {
          type: "boolean",
          default: e.snippetsPreventQuickSuggestions,
          description: m("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
        },
        "editor.suggest.showIcons": {
          type: "boolean",
          default: e.showIcons,
          description: m("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
        },
        "editor.suggest.showStatusBar": {
          type: "boolean",
          default: e.showStatusBar,
          description: m("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
        },
        "editor.suggest.preview": {
          type: "boolean",
          default: e.preview,
          description: m("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
        },
        "editor.suggest.showInlineDetails": {
          type: "boolean",
          default: e.showInlineDetails,
          description: m("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget")
        },
        "editor.suggest.maxVisibleSuggestions": {
          type: "number",
          deprecationMessage: m("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
        },
        "editor.suggest.filteredTypes": {
          type: "object",
          deprecationMessage: m("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
        },
        "editor.suggest.showMethods": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
        },
        "editor.suggest.showFunctions": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
        },
        "editor.suggest.showConstructors": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
        },
        "editor.suggest.showDeprecated": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
        },
        "editor.suggest.showFields": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
        },
        "editor.suggest.showVariables": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
        },
        "editor.suggest.showClasses": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
        },
        "editor.suggest.showStructs": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
        },
        "editor.suggest.showInterfaces": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
        },
        "editor.suggest.showModules": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
        },
        "editor.suggest.showProperties": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
        },
        "editor.suggest.showEvents": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
        },
        "editor.suggest.showOperators": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
        },
        "editor.suggest.showUnits": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
        },
        "editor.suggest.showValues": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
        },
        "editor.suggest.showConstants": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
        },
        "editor.suggest.showEnums": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
        },
        "editor.suggest.showEnumMembers": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
        },
        "editor.suggest.showKeywords": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
        },
        "editor.suggest.showWords": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
        },
        "editor.suggest.showColors": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
        },
        "editor.suggest.showFiles": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
        },
        "editor.suggest.showReferences": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
        },
        "editor.suggest.showCustomcolors": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
        },
        "editor.suggest.showFolders": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
        },
        "editor.suggest.showTypeParameters": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
        },
        "editor.suggest.showSnippets": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
        },
        "editor.suggest.showUsers": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
        },
        "editor.suggest.showIssues": {
          type: "boolean",
          default: !0,
          markdownDescription: m("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
        }
      });
    }
    validate(e) {
      if (!e || typeof e != "object")
        return this.defaultValue;
      const t = e;
      return {
        insertMode: rs(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
        filterGraceful: De(t.filterGraceful, this.defaultValue.filterGraceful),
        snippetsPreventQuickSuggestions: De(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
        localityBonus: De(t.localityBonus, this.defaultValue.localityBonus),
        shareSuggestSelections: De(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
        showIcons: De(t.showIcons, this.defaultValue.showIcons),
        showStatusBar: De(t.showStatusBar, this.defaultValue.showStatusBar),
        preview: De(t.preview, this.defaultValue.preview),
        previewMode: rs(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
        showInlineDetails: De(t.showInlineDetails, this.defaultValue.showInlineDetails),
        showMethods: De(t.showMethods, this.defaultValue.showMethods),
        showFunctions: De(t.showFunctions, this.defaultValue.showFunctions),
        showConstructors: De(t.showConstructors, this.defaultValue.showConstructors),
        showDeprecated: De(t.showDeprecated, this.defaultValue.showDeprecated),
        showFields: De(t.showFields, this.defaultValue.showFields),
        showVariables: De(t.showVariables, this.defaultValue.showVariables),
        showClasses: De(t.showClasses, this.defaultValue.showClasses),
        showStructs: De(t.showStructs, this.defaultValue.showStructs),
        showInterfaces: De(t.showInterfaces, this.defaultValue.showInterfaces),
        showModules: De(t.showModules, this.defaultValue.showModules),
        showProperties: De(t.showProperties, this.defaultValue.showProperties),
        showEvents: De(t.showEvents, this.defaultValue.showEvents),
        showOperators: De(t.showOperators, this.defaultValue.showOperators),
        showUnits: De(t.showUnits, this.defaultValue.showUnits),
        showValues: De(t.showValues, this.defaultValue.showValues),
        showConstants: De(t.showConstants, this.defaultValue.showConstants),
        showEnums: De(t.showEnums, this.defaultValue.showEnums),
        showEnumMembers: De(t.showEnumMembers, this.defaultValue.showEnumMembers),
        showKeywords: De(t.showKeywords, this.defaultValue.showKeywords),
        showWords: De(t.showWords, this.defaultValue.showWords),
        showColors: De(t.showColors, this.defaultValue.showColors),
        showFiles: De(t.showFiles, this.defaultValue.showFiles),
        showReferences: De(t.showReferences, this.defaultValue.showReferences),
        showFolders: De(t.showFolders, this.defaultValue.showFolders),
        showTypeParameters: De(t.showTypeParameters, this.defaultValue.showTypeParameters),
        showSnippets: De(t.showSnippets, this.defaultValue.showSnippets),
        showUsers: De(t.showUsers, this.defaultValue.showUsers),
        showIssues: De(t.showIssues, this.defaultValue.showIssues)
      };
    }
  }
  class zH extends Wi {
    constructor() {
      super(102, "smartSelect", {
        selectLeadingAndTrailingWhitespace: !0
      }, {
        "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
          description: m("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
          default: !0,
          type: "boolean"
        }
      });
    }
    validate(e) {
      return !e || typeof e != "object" ? this.defaultValue : {
        selectLeadingAndTrailingWhitespace: De(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace)
      };
    }
  }
  class UH extends ig {
    constructor() {
      super(130);
    }
    compute(e, t, i) {
      return t.get(81) ? !0 : e.tabFocusMode;
    }
  }
  function $H(s) {
    switch (s) {
      case "none":
        return 0;
      case "same":
        return 1;
      case "indent":
        return 2;
      case "deepIndent":
        return 3;
    }
  }
  class jH extends ig {
    constructor() {
      super(132);
    }
    compute(e, t, i) {
      const n = t.get(131);
      return {
        isDominatedByLongLines: e.isDominatedByLongLines,
        isWordWrapMinified: n.isWordWrapMinified,
        isViewportWrapping: n.isViewportWrapping,
        wrappingColumn: n.wrappingColumn
      };
    }
  }
  const KH = "Consolas, 'Courier New', monospace", qH = "Menlo, Monaco, 'Courier New', monospace", GH = "'Droid Sans Mono', 'monospace', monospace", Fn = {
    fontFamily: Ye ? qH : Nn ? GH : KH,
    fontWeight: "normal",
    fontSize: Ye ? 12 : 14,
    lineHeight: 0,
    letterSpacing: 0
  }, xu = [];
  function ie(s) {
    return xu[s.id] = s, s;
  }
  const yr = {
    acceptSuggestionOnCommitCharacter: ie(new nt(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: m("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
    acceptSuggestionOnEnter: ie(new Ti(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
      markdownEnumDescriptions: [
        "",
        m("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
        ""
      ],
      markdownDescription: m("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
    })),
    accessibilitySupport: ie(new gH()),
    accessibilityPageSize: ie(new zt(3, "accessibilityPageSize", 10, 1, 1073741824, {
      description: m("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.")
    })),
    ariaLabel: ie(new Cs(4, "ariaLabel", m("editorViewAccessibleLabel", "Editor content"))),
    autoClosingBrackets: ie(new Ti(5, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
      enumDescriptions: [
        "",
        m("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
        m("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
        ""
      ],
      description: m("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
    })),
    autoClosingDelete: ie(new Ti(6, "autoClosingDelete", "auto", ["always", "auto", "never"], {
      enumDescriptions: [
        "",
        m("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
        ""
      ],
      description: m("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
    })),
    autoClosingOvertype: ie(new Ti(7, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
      enumDescriptions: [
        "",
        m("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
        ""
      ],
      description: m("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
    })),
    autoClosingQuotes: ie(new Ti(8, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
      enumDescriptions: [
        "",
        m("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
        m("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
        ""
      ],
      description: m("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
    })),
    autoIndent: ie(new vg(9, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], fH, {
      enumDescriptions: [
        m("editor.autoIndent.none", "The editor will not insert indentation automatically."),
        m("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
        m("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
        m("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
        m("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
      ],
      description: m("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
    })),
    automaticLayout: ie(new nt(10, "automaticLayout", !1)),
    autoSurround: ie(new Ti(11, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
      enumDescriptions: [
        m("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
        m("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
        m("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
        ""
      ],
      description: m("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
    })),
    bracketPairColorization: ie(new WH()),
    bracketPairGuides: ie(new VH()),
    stickyTabStops: ie(new nt(104, "stickyTabStops", !1, { description: m("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
    codeLens: ie(new nt(14, "codeLens", !0, { description: m("codeLens", "Controls whether the editor shows CodeLens.") })),
    codeLensFontFamily: ie(new Cs(15, "codeLensFontFamily", "", { description: m("codeLensFontFamily", "Controls the font family for CodeLens.") })),
    codeLensFontSize: ie(new zt(16, "codeLensFontSize", 0, 0, 100, {
      type: "number",
      default: 0,
      minimum: 0,
      maximum: 100,
      markdownDescription: m("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to `0`, 90% of `#editor.fontSize#` is used.")
    })),
    colorDecorators: ie(new nt(17, "colorDecorators", !0, { description: m("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
    columnSelection: ie(new nt(18, "columnSelection", !1, { description: m("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
    comments: ie(new mH()),
    contextmenu: ie(new nt(20, "contextmenu", !0)),
    copyWithSyntaxHighlighting: ie(new nt(21, "copyWithSyntaxHighlighting", !0, { description: m("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
    cursorBlinking: ie(new vg(22, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], pH, { description: m("cursorBlinking", "Control the cursor animation style.") })),
    cursorSmoothCaretAnimation: ie(new nt(23, "cursorSmoothCaretAnimation", !1, { description: m("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.") })),
    cursorStyle: ie(new vg(24, "cursorStyle", sn.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], _H, { description: m("cursorStyle", "Controls the cursor style.") })),
    cursorSurroundingLines: ie(new zt(25, "cursorSurroundingLines", 0, 0, 1073741824, { description: m("cursorSurroundingLines", "Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
    cursorSurroundingLinesStyle: ie(new Ti(26, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
      enumDescriptions: [
        m("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
        m("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
      ],
      description: m("cursorSurroundingLinesStyle", "Controls when `cursorSurroundingLines` should be enforced.")
    })),
    cursorWidth: ie(new zt(27, "cursorWidth", 0, 0, 1073741824, { markdownDescription: m("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
    disableLayerHinting: ie(new nt(28, "disableLayerHinting", !1)),
    disableMonospaceOptimizations: ie(new nt(29, "disableMonospaceOptimizations", !1)),
    domReadOnly: ie(new nt(30, "domReadOnly", !1)),
    dragAndDrop: ie(new nt(31, "dragAndDrop", !0, { description: m("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
    emptySelectionClipboard: ie(new vH()),
    extraEditorClassName: ie(new Cs(33, "extraEditorClassName", "")),
    fastScrollSensitivity: ie(new Xr(34, "fastScrollSensitivity", 5, (s) => s <= 0 ? 5 : s, { markdownDescription: m("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
    find: ie(new CH()),
    fixedOverflowWidgets: ie(new nt(36, "fixedOverflowWidgets", !1)),
    folding: ie(new nt(37, "folding", !0, { description: m("folding", "Controls whether the editor has code folding enabled.") })),
    foldingStrategy: ie(new Ti(38, "foldingStrategy", "auto", ["auto", "indentation"], {
      enumDescriptions: [
        m("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
        m("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
      ],
      description: m("foldingStrategy", "Controls the strategy for computing folding ranges.")
    })),
    foldingHighlight: ie(new nt(39, "foldingHighlight", !0, { description: m("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
    foldingImportsByDefault: ie(new nt(40, "foldingImportsByDefault", !1, { description: m("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
    foldingMaximumRegions: ie(new zt(41, "foldingMaximumRegions", 5e3, 10, 65e3, { description: m("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") })),
    unfoldOnClickAfterEndOfLine: ie(new nt(42, "unfoldOnClickAfterEndOfLine", !1, { description: m("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
    fontFamily: ie(new Cs(43, "fontFamily", Fn.fontFamily, { description: m("fontFamily", "Controls the font family.") })),
    fontInfo: ie(new wH()),
    fontLigatures2: ie(new zs()),
    fontSize: ie(new SH()),
    fontWeight: ie(new Kr()),
    formatOnPaste: ie(new nt(48, "formatOnPaste", !1, { description: m("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
    formatOnType: ie(new nt(49, "formatOnType", !1, { description: m("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
    glyphMargin: ie(new nt(50, "glyphMargin", !0, { description: m("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
    gotoLocation: ie(new yH()),
    hideCursorInOverviewRuler: ie(new nt(52, "hideCursorInOverviewRuler", !1, { description: m("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
    hover: ie(new LH()),
    inDiffEditor: ie(new nt(54, "inDiffEditor", !1)),
    letterSpacing: ie(new Xr(56, "letterSpacing", Fn.letterSpacing, (s) => Xr.clamp(s, -5, 20), { description: m("letterSpacing", "Controls the letter spacing in pixels.") })),
    lightbulb: ie(new kH()),
    lineDecorationsWidth: ie(new Mh(58, "lineDecorationsWidth", 10)),
    lineHeight: ie(new xH()),
    lineNumbers: ie(new RH()),
    lineNumbersMinChars: ie(new zt(61, "lineNumbersMinChars", 5, 1, 300)),
    linkedEditing: ie(new nt(62, "linkedEditing", !1, { description: m("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols, e.g. HTML tags, are updated while editing.") })),
    links: ie(new nt(63, "links", !0, { description: m("links", "Controls whether the editor should detect links and make them clickable.") })),
    matchBrackets: ie(new Ti(64, "matchBrackets", "always", ["always", "near", "never"], { description: m("matchBrackets", "Highlight matching brackets.") })),
    minimap: ie(new IH()),
    mouseStyle: ie(new Ti(66, "mouseStyle", "text", ["text", "default", "copy"])),
    mouseWheelScrollSensitivity: ie(new Xr(67, "mouseWheelScrollSensitivity", 1, (s) => s === 0 ? 1 : s, { markdownDescription: m("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
    mouseWheelZoom: ie(new nt(68, "mouseWheelZoom", !1, { markdownDescription: m("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
    multiCursorMergeOverlapping: ie(new nt(69, "multiCursorMergeOverlapping", !0, { description: m("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
    multiCursorModifier: ie(new vg(70, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], EH, {
      markdownEnumDescriptions: [
        m("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        m("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      markdownDescription: m({
        key: "multiCursorModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier. [Read more](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
    })),
    multiCursorPaste: ie(new Ti(71, "multiCursorPaste", "spread", ["spread", "full"], {
      markdownEnumDescriptions: [
        m("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
        m("multiCursorPaste.full", "Each cursor pastes the full text.")
      ],
      markdownDescription: m("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
    })),
    occurrencesHighlight: ie(new nt(72, "occurrencesHighlight", !0, { description: m("occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences.") })),
    overviewRulerBorder: ie(new nt(73, "overviewRulerBorder", !0, { description: m("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
    overviewRulerLanes: ie(new zt(74, "overviewRulerLanes", 3, 0, 3)),
    padding: ie(new NH()),
    parameterHints: ie(new TH()),
    peekWidgetDefaultFocus: ie(new Ti(77, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
      enumDescriptions: [
        m("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
        m("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
      ],
      description: m("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
    })),
    definitionLinkOpensInPeek: ie(new nt(78, "definitionLinkOpensInPeek", !1, { description: m("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
    quickSuggestions: ie(new AH()),
    quickSuggestionsDelay: ie(new zt(80, "quickSuggestionsDelay", 10, 0, 1073741824, { description: m("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
    readOnly: ie(new nt(81, "readOnly", !1)),
    renameOnType: ie(new nt(82, "renameOnType", !1, { description: m("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: m("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
    renderControlCharacters: ie(new nt(83, "renderControlCharacters", !0, { description: m("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: !0 })),
    renderFinalNewline: ie(new nt(84, "renderFinalNewline", !0, { description: m("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
    renderLineHighlight: ie(new Ti(85, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
      enumDescriptions: [
        "",
        "",
        "",
        m("renderLineHighlight.all", "Highlights both the gutter and the current line.")
      ],
      description: m("renderLineHighlight", "Controls how the editor should render the current line highlight.")
    })),
    renderLineHighlightOnlyWhenFocus: ie(new nt(86, "renderLineHighlightOnlyWhenFocus", !1, { description: m("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
    renderValidationDecorations: ie(new Ti(87, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
    renderWhitespace: ie(new Ti(88, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
      enumDescriptions: [
        "",
        m("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
        m("renderWhitespace.selection", "Render whitespace characters only on selected text."),
        m("renderWhitespace.trailing", "Render only trailing whitespace characters."),
        ""
      ],
      description: m("renderWhitespace", "Controls how the editor should render whitespace characters.")
    })),
    revealHorizontalRightPadding: ie(new zt(89, "revealHorizontalRightPadding", 30, 0, 1e3)),
    roundedSelection: ie(new nt(90, "roundedSelection", !0, { description: m("roundedSelection", "Controls whether selections should have rounded corners.") })),
    rulers: ie(new OH()),
    scrollbar: ie(new PH()),
    scrollBeyondLastColumn: ie(new zt(93, "scrollBeyondLastColumn", 5, 0, 1073741824, { description: m("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
    scrollBeyondLastLine: ie(new nt(94, "scrollBeyondLastLine", !0, { description: m("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
    scrollPredominantAxis: ie(new nt(95, "scrollPredominantAxis", !0, { description: m("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
    selectionClipboard: ie(new nt(96, "selectionClipboard", !0, {
      description: m("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
      included: Nn
    })),
    selectionHighlight: ie(new nt(97, "selectionHighlight", !0, { description: m("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
    selectOnLineNumbers: ie(new nt(98, "selectOnLineNumbers", !0)),
    showFoldingControls: ie(new Ti(99, "showFoldingControls", "mouseover", ["always", "mouseover"], {
      enumDescriptions: [
        m("showFoldingControls.always", "Always show the folding controls."),
        m("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
      ],
      description: m("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
    })),
    showUnused: ie(new nt(100, "showUnused", !0, { description: m("showUnused", "Controls fading out of unused code.") })),
    showDeprecated: ie(new nt(126, "showDeprecated", !0, { description: m("showDeprecated", "Controls strikethrough deprecated variables.") })),
    inlayHints: ie(new DH()),
    snippetSuggestions: ie(new Ti(101, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
      enumDescriptions: [
        m("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
        m("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
        m("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
        m("snippetSuggestions.none", "Do not show snippet suggestions.")
      ],
      description: m("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
    })),
    smartSelect: ie(new zH()),
    smoothScrolling: ie(new nt(103, "smoothScrolling", !1, { description: m("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
    stopRenderingLineAfter: ie(new zt(105, "stopRenderingLineAfter", 1e4, -1, 1073741824)),
    suggest: ie(new HH()),
    inlineSuggest: ie(new BH()),
    suggestFontSize: ie(new zt(107, "suggestFontSize", 0, 0, 1e3, { markdownDescription: m("suggestFontSize", "Font size for the suggest widget. When set to `0`, the value of `#editor.fontSize#` is used.") })),
    suggestLineHeight: ie(new zt(108, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: m("suggestLineHeight", "Line height for the suggest widget. When set to `0`, the value of `#editor.lineHeight#` is used. The minimum value is 8.") })),
    suggestOnTriggerCharacters: ie(new nt(109, "suggestOnTriggerCharacters", !0, { description: m("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
    suggestSelection: ie(new Ti(110, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
      markdownEnumDescriptions: [
        m("suggestSelection.first", "Always select the first suggestion."),
        m("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
        m("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
      ],
      description: m("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
    })),
    tabCompletion: ie(new Ti(111, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
      enumDescriptions: [
        m("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
        m("tabCompletion.off", "Disable tab completions."),
        m("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
      ],
      description: m("tabCompletion", "Enables tab completions.")
    })),
    tabIndex: ie(new zt(112, "tabIndex", 0, -1, 1073741824)),
    unicodeHighlight: ie(new FH()),
    unusualLineTerminators: ie(new Ti(114, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
      enumDescriptions: [
        m("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
        m("unusualLineTerminators.off", "Unusual line terminators are ignored."),
        m("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
      ],
      description: m("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
    })),
    useShadowDOM: ie(new nt(115, "useShadowDOM", !0)),
    useTabStops: ie(new nt(116, "useTabStops", !0, { description: m("useTabStops", "Inserting and deleting whitespace follows tab stops.") })),
    wordSeparators: ie(new Cs(117, "wordSeparators", UP, { description: m("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
    wordWrap: ie(new Ti(118, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
      markdownEnumDescriptions: [
        m("wordWrap.off", "Lines will never wrap."),
        m("wordWrap.on", "Lines will wrap at the viewport width."),
        m({
          key: "wordWrap.wordWrapColumn",
          comment: [
            "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
          ]
        }, "Lines will wrap at `#editor.wordWrapColumn#`."),
        m({
          key: "wordWrap.bounded",
          comment: [
            "- viewport means the edge of the visible window size.",
            "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
          ]
        }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
      ],
      description: m({
        key: "wordWrap",
        comment: [
          "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Controls how lines should wrap.")
    })),
    wordWrapBreakAfterCharacters: ie(new Cs(119, "wordWrapBreakAfterCharacters", " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63")),
    wordWrapBreakBeforeCharacters: ie(new Cs(120, "wordWrapBreakBeforeCharacters", "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B")),
    wordWrapColumn: ie(new zt(121, "wordWrapColumn", 80, 1, 1073741824, {
      markdownDescription: m({
        key: "wordWrapColumn",
        comment: [
          "- `editor.wordWrap` refers to a different setting and should not be localized.",
          "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
        ]
      }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
    })),
    wordWrapOverride1: ie(new Ti(122, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
    wordWrapOverride2: ie(new Ti(123, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
    wrappingIndent: ie(new vg(124, "wrappingIndent", 1, "same", ["none", "same", "indent", "deepIndent"], $H, {
      enumDescriptions: [
        m("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
        m("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
        m("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
        m("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
      ],
      description: m("wrappingIndent", "Controls the indentation of wrapped lines.")
    })),
    wrappingStrategy: ie(new Ti(125, "wrappingStrategy", "simple", ["simple", "advanced"], {
      enumDescriptions: [
        m("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
        m("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
      ],
      description: m("wrappingStrategy", "Controls the algorithm that computes wrapping points.")
    })),
    editorClassName: ie(new bH()),
    pixelRatio: ie(new MH()),
    tabFocusMode: ie(new UH()),
    layoutInfo: ie(new Ku()),
    wrappingInfo: ie(new jH())
  };
  function En(s, e) {
    s instanceof c5 ? (s.setFontFamily(e.getMassagedFontFamily(Zo ? Fn.fontFamily : null)), s.setFontWeight(e.fontWeight), s.setFontSize(e.fontSize), s.setFontFeatureSettings(e.fontFeatureSettings), s.setLineHeight(e.lineHeight), s.setLetterSpacing(e.letterSpacing)) : (s.style.fontFamily = e.getMassagedFontFamily(Zo ? Fn.fontFamily : null), s.style.fontWeight = e.fontWeight, s.style.fontSize = e.fontSize + "px", s.style.fontFeatureSettings = e.fontFeatureSettings, s.style.lineHeight = e.lineHeight + "px", s.style.letterSpacing = e.letterSpacing + "px");
  }
  class ZH {
    constructor(e, t) {
      this.chr = e, this.type = t, this.width = 0;
    }
    fulfill(e) {
      this.width = e;
    }
  }
  class ZI {
    constructor(e, t) {
      this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
    }
    read() {
      this._createDomElements(), document.body.appendChild(this._container), this._readFromDomElements(), document.body.removeChild(this._container), this._container = null, this._testElements = null;
    }
    _createDomElements() {
      const e = document.createElement("div");
      e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
      const t = document.createElement("div");
      En(t, this._bareFontInfo), e.appendChild(t);
      const i = document.createElement("div");
      En(i, this._bareFontInfo), i.style.fontWeight = "bold", e.appendChild(i);
      const n = document.createElement("div");
      En(n, this._bareFontInfo), n.style.fontStyle = "italic", e.appendChild(n);
      const o = [];
      for (const r of this._requests) {
        let a;
        r.type === 0 && (a = t), r.type === 2 && (a = i), r.type === 1 && (a = n), a.appendChild(document.createElement("br"));
        const l = document.createElement("span");
        ZI._render(l, r), a.appendChild(l), o.push(l);
      }
      this._container = e, this._testElements = o;
    }
    static _render(e, t) {
      if (t.chr === " ") {
        let i = "\xA0";
        for (let n = 0; n < 8; n++)
          i += i;
        e.innerText = i;
      } else {
        let i = t.chr;
        for (let n = 0; n < 8; n++)
          i += i;
        e.textContent = i;
      }
    }
    _readFromDomElements() {
      for (let e = 0, t = this._requests.length; e < t; e++) {
        const i = this._requests[e], n = this._testElements[e];
        i.fulfill(n.offsetWidth / 256);
      }
    }
  }
  function YH(s, e) {
    new ZI(s, e).read();
  }
  const fl = new class {
    constructor() {
      this._zoomLevel = 0, this._onDidChangeZoomLevel = new B(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
    }
    getZoomLevel() {
      return this._zoomLevel;
    }
    setZoomLevel(s) {
      s = Math.min(Math.max(-5, s), 20), this._zoomLevel !== s && (this._zoomLevel = s, this._onDidChangeZoomLevel.fire(this._zoomLevel));
    }
  }(), XH = Ye ? 1.5 : 1.35, zw = 8;
  class xd {
    constructor(e) {
      this._bareFontInfoBrand = void 0, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
    }
    static createFromValidatedSettings(e, t, i) {
      const n = e.get(43), o = e.get(47), r = e.get(46), a = e.get(45), l = e.get(59), c = e.get(56);
      return xd._create(n, o, r, a, l, c, t, i);
    }
    static _create(e, t, i, n, o, r, a, l) {
      o === 0 ? o = XH * i : o < zw && (o = o * i), o = Math.round(o), o < zw && (o = zw);
      const c = 1 + (l ? 0 : fl.getZoomLevel() * 0.1);
      return i *= c, o *= c, new xd({
        pixelRatio: a,
        fontFamily: e,
        fontWeight: t,
        fontSize: i,
        fontFeatureSettings: n,
        lineHeight: o,
        letterSpacing: r
      });
    }
    getId() {
      return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.lineHeight}-${this.letterSpacing}`;
    }
    getMassagedFontFamily(e) {
      const t = xd._wrapInQuotes(this.fontFamily);
      return e && this.fontFamily !== e ? `${t}, ${e}` : t;
    }
    static _wrapInQuotes(e) {
      return /[,"']/.test(e) ? e : /[+ ]/.test(e) ? `"${e}"` : e;
    }
  }
  const QH = 1;
  class cL extends xd {
    constructor(e, t) {
      super(e), this._editorStylingBrand = void 0, this.version = QH, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
    }
    equals(e) {
      return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
    }
  }
  class JH extends z {
    constructor() {
      super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._cache = new sT(), this._evictUntrustedReadingsTimeout = -1;
    }
    dispose() {
      this._evictUntrustedReadingsTimeout !== -1 && (window.clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
    }
    clearAllFontInfos() {
      this._cache = new sT(), this._onDidChange.fire();
    }
    _writeToCache(e, t) {
      this._cache.put(e, t), !t.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = window.setTimeout(() => {
        this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings();
      }, 5e3));
    }
    _evictUntrustedReadings() {
      const e = this._cache.getValues();
      let t = !1;
      for (const i of e)
        i.isTrusted || (t = !0, this._cache.remove(i));
      t && this._onDidChange.fire();
    }
    readFontInfo(e) {
      if (!this._cache.has(e)) {
        let t = this._actualReadFontInfo(e);
        (t.typicalHalfwidthCharacterWidth <= 2 || t.typicalFullwidthCharacterWidth <= 2 || t.spaceWidth <= 2 || t.maxDigitWidth <= 2) && (t = new cL({
          pixelRatio: hf.value,
          fontFamily: t.fontFamily,
          fontWeight: t.fontWeight,
          fontSize: t.fontSize,
          fontFeatureSettings: t.fontFeatureSettings,
          lineHeight: t.lineHeight,
          letterSpacing: t.letterSpacing,
          isMonospace: t.isMonospace,
          typicalHalfwidthCharacterWidth: Math.max(t.typicalHalfwidthCharacterWidth, 5),
          typicalFullwidthCharacterWidth: Math.max(t.typicalFullwidthCharacterWidth, 5),
          canUseHalfwidthRightwardsArrow: t.canUseHalfwidthRightwardsArrow,
          spaceWidth: Math.max(t.spaceWidth, 5),
          middotWidth: Math.max(t.middotWidth, 5),
          wsmiddotWidth: Math.max(t.wsmiddotWidth, 5),
          maxDigitWidth: Math.max(t.maxDigitWidth, 5)
        }, !1)), this._writeToCache(e, t);
      }
      return this._cache.get(e);
    }
    _createRequest(e, t, i, n) {
      const o = new ZH(e, t);
      return i.push(o), n && n.push(o), o;
    }
    _actualReadFontInfo(e) {
      const t = [], i = [], n = this._createRequest("n", 0, t, i), o = this._createRequest("\uFF4D", 0, t, null), r = this._createRequest(" ", 0, t, i), a = this._createRequest("0", 0, t, i), l = this._createRequest("1", 0, t, i), c = this._createRequest("2", 0, t, i), d = this._createRequest("3", 0, t, i), h = this._createRequest("4", 0, t, i), u = this._createRequest("5", 0, t, i), f = this._createRequest("6", 0, t, i), g = this._createRequest("7", 0, t, i), _ = this._createRequest("8", 0, t, i), b = this._createRequest("9", 0, t, i), C = this._createRequest("\u2192", 0, t, i), v = this._createRequest("\uFFEB", 0, t, null), w = this._createRequest("\xB7", 0, t, i), S = this._createRequest(String.fromCharCode(11825), 0, t, null), L = "|/-_ilm%";
      for (let F = 0, R = L.length; F < R; F++)
        this._createRequest(L.charAt(F), 0, t, i), this._createRequest(L.charAt(F), 1, t, i), this._createRequest(L.charAt(F), 2, t, i);
      YH(e, t);
      const x = Math.max(a.width, l.width, c.width, d.width, h.width, u.width, f.width, g.width, _.width, b.width);
      let y = e.fontFeatureSettings === zs.OFF;
      const k = i[0].width;
      for (let F = 1, R = i.length; y && F < R; F++) {
        const $ = k - i[F].width;
        if ($ < -1e-3 || $ > 1e-3) {
          y = !1;
          break;
        }
      }
      let I = !0;
      return y && v.width !== k && (I = !1), v.width > C.width && (I = !1), new cL({
        pixelRatio: hf.value,
        fontFamily: e.fontFamily,
        fontWeight: e.fontWeight,
        fontSize: e.fontSize,
        fontFeatureSettings: e.fontFeatureSettings,
        lineHeight: e.lineHeight,
        letterSpacing: e.letterSpacing,
        isMonospace: y,
        typicalHalfwidthCharacterWidth: n.width,
        typicalFullwidthCharacterWidth: o.width,
        canUseHalfwidthRightwardsArrow: I,
        spaceWidth: r.width,
        middotWidth: w.width,
        wsmiddotWidth: S.width,
        maxDigitWidth: x
      }, !0);
    }
  }
  class sT {
    constructor() {
      this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
    }
    has(e) {
      const t = e.getId();
      return !!this._values[t];
    }
    get(e) {
      const t = e.getId();
      return this._values[t];
    }
    put(e, t) {
      const i = e.getId();
      this._keys[i] = e, this._values[i] = t;
    }
    remove(e) {
      const t = e.getId();
      delete this._keys[t], delete this._values[t];
    }
    getValues() {
      return Object.keys(this._keys).map((e) => this._values[e]);
    }
  }
  const dL = new JH(), ez = Object.prototype.hasOwnProperty;
  function tz(s, e) {
    for (let t in s)
      if (ez.call(s, t) && e({ key: t, value: s[t] }, function() {
        delete s[t];
      }) === !1)
        return;
  }
  class iz {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    add(e, t) {
      let i = this.map.get(e);
      i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
    }
    delete(e, t) {
      const i = this.map.get(e);
      !i || (i.delete(t), i.size === 0 && this.map.delete(e));
    }
    forEach(e, t) {
      const i = this.map.get(e);
      !i || i.forEach(t);
    }
  }
  function nz(s) {
    const e = s.wordWrap;
    e === !0 ? s.wordWrap = "on" : e === !1 && (s.wordWrap = "off");
    const t = s.lineNumbers;
    t === !0 ? s.lineNumbers = "on" : t === !1 && (s.lineNumbers = "off"), s.autoClosingBrackets === !1 && (s.autoClosingBrackets = "never", s.autoClosingQuotes = "never", s.autoSurround = "never"), s.cursorBlinking === "visible" && (s.cursorBlinking = "solid");
    const o = s.renderWhitespace;
    o === !0 ? s.renderWhitespace = "boundary" : o === !1 && (s.renderWhitespace = "none");
    const r = s.renderLineHighlight;
    r === !0 ? s.renderLineHighlight = "line" : r === !1 && (s.renderLineHighlight = "none");
    const a = s.acceptSuggestionOnEnter;
    a === !0 ? s.acceptSuggestionOnEnter = "on" : a === !1 && (s.acceptSuggestionOnEnter = "off");
    const l = s.tabCompletion;
    l === !1 ? s.tabCompletion = "off" : l === !0 && (s.tabCompletion = "onlySnippets");
    const c = s.suggest;
    if (c && typeof c.filteredTypes == "object" && c.filteredTypes) {
      const b = {};
      b.method = "showMethods", b.function = "showFunctions", b.constructor = "showConstructors", b.deprecated = "showDeprecated", b.field = "showFields", b.variable = "showVariables", b.class = "showClasses", b.struct = "showStructs", b.interface = "showInterfaces", b.module = "showModules", b.property = "showProperties", b.event = "showEvents", b.operator = "showOperators", b.unit = "showUnits", b.value = "showValues", b.constant = "showConstants", b.enum = "showEnums", b.enumMember = "showEnumMembers", b.keyword = "showKeywords", b.text = "showWords", b.color = "showColors", b.file = "showFiles", b.reference = "showReferences", b.folder = "showFolders", b.typeParameter = "showTypeParameters", b.snippet = "showSnippets", tz(b, (C) => {
        const v = c.filteredTypes[C.key];
        v === !1 && (c[C.value] = v);
      });
    }
    const d = s.hover;
    d === !0 ? s.hover = {
      enabled: !0
    } : d === !1 && (s.hover = {
      enabled: !1
    });
    const h = s.parameterHints;
    h === !0 ? s.parameterHints = {
      enabled: !0
    } : h === !1 && (s.parameterHints = {
      enabled: !1
    });
    const u = s.autoIndent;
    u === !0 ? s.autoIndent = "full" : u === !1 && (s.autoIndent = "advanced");
    const f = s.matchBrackets;
    f === !0 ? s.matchBrackets = "always" : f === !1 && (s.matchBrackets = "never");
    const { renderIndentGuides: g, highlightActiveIndentGuide: _ } = s;
    s.guides || (s.guides = {}), g !== void 0 && (s.guides.indentation = !!g), _ !== void 0 && (s.guides.highlightActiveIndentation = !!_);
  }
  class sz {
    constructor() {
      this._tabFocus = !1, this._onDidChangeTabFocus = new B(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
    }
    getTabFocusMode() {
      return this._tabFocus;
    }
    setTabFocusMode(e) {
      this._tabFocus !== e && (this._tabFocus = e, this._onDidChangeTabFocus.fire(this._tabFocus));
    }
  }
  const r1 = new sz(), Ts = st("accessibilityService"), l_ = new ue("accessibilityModeEnabled", !1);
  var oz = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, rz = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let hL = class extends z {
    constructor(e, t, i, n) {
      super(), this._accessibilityService = n, this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new B()), this.onDidChangeFast = this._onDidChangeFast.event, this._isDominatedByLongLines = !1, this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._reservedHeight = 0, this._computeOptionsMemory = new h5(), this.isSimpleWidget = e, this._containerObserver = this._register(new l5(i, t.dimension)), this._rawOptions = oT(t), this._validatedOptions = Hl.validateOptions(this._rawOptions), this.options = this._computeOptions(), this.options.get(10) && this._containerObserver.startObserving(), this._register(fl.onDidChangeZoomLevel(() => this._recomputeOptions())), this._register(r1.onDidChangeTabFocus(() => this._recomputeOptions())), this._register(this._containerObserver.onDidChange(() => this._recomputeOptions())), this._register(dL.onDidChange(() => this._recomputeOptions())), this._register(hf.onDidChange(() => this._recomputeOptions())), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
    }
    _recomputeOptions() {
      const e = this._computeOptions(), t = Hl.checkEquals(this.options, e);
      t !== null && (this.options = e, this._onDidChangeFast.fire(t), this._onDidChange.fire(t));
    }
    _computeOptions() {
      const e = this._readEnvConfiguration(), t = xd.createFromValidatedSettings(this._validatedOptions, e.pixelRatio, this.isSimpleWidget), i = this._readFontInfo(t), n = {
        memory: this._computeOptionsMemory,
        outerWidth: e.outerWidth,
        outerHeight: e.outerHeight - this._reservedHeight,
        fontInfo: i,
        extraEditorClassName: e.extraEditorClassName,
        isDominatedByLongLines: this._isDominatedByLongLines,
        viewLineCount: this._viewLineCount,
        lineNumbersDigitCount: this._lineNumbersDigitCount,
        emptySelectionClipboard: e.emptySelectionClipboard,
        pixelRatio: e.pixelRatio,
        tabFocusMode: r1.getTabFocusMode(),
        accessibilitySupport: e.accessibilitySupport
      };
      return Hl.computeOptions(this._validatedOptions, n);
    }
    _readEnvConfiguration() {
      return {
        extraEditorClassName: lz(),
        outerWidth: this._containerObserver.getWidth(),
        outerHeight: this._containerObserver.getHeight(),
        emptySelectionClipboard: Ql || Xs,
        pixelRatio: hf.value,
        accessibilitySupport: this._accessibilityService.isScreenReaderOptimized() ? 2 : this._accessibilityService.getAccessibilitySupport()
      };
    }
    _readFontInfo(e) {
      return dL.readFontInfo(e);
    }
    getRawOptions() {
      return this._rawOptions;
    }
    updateOptions(e) {
      const t = oT(e);
      !Hl.applyUpdate(this._rawOptions, t) || (this._validatedOptions = Hl.validateOptions(this._rawOptions), this._recomputeOptions());
    }
    observeContainer(e) {
      this._containerObserver.observe(e);
    }
    setIsDominatedByLongLines(e) {
      this._isDominatedByLongLines !== e && (this._isDominatedByLongLines = e, this._recomputeOptions());
    }
    setModelLineCount(e) {
      const t = az(e);
      this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
    }
    setViewLineCount(e) {
      this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
    }
    setReservedHeight(e) {
      this._reservedHeight !== e && (this._reservedHeight = e, this._recomputeOptions());
    }
  };
  hL = oz([
    rz(3, Ts)
  ], hL);
  function az(s) {
    let e = 0;
    for (; s; )
      s = Math.floor(s / 10), e++;
    return e || 1;
  }
  function lz() {
    let s = "";
    return !Zo && !gI && (s += "no-user-select "), Zo && (s += "no-minimap-shadow "), Ye && (s += "mac "), s;
  }
  class cz {
    constructor() {
      this._values = [];
    }
    _read(e) {
      return this._values[e];
    }
    get(e) {
      return this._values[e];
    }
    _write(e, t) {
      this._values[e] = t;
    }
  }
  class dz {
    constructor() {
      this._values = [];
    }
    _read(e) {
      if (e >= this._values.length)
        throw new Error("Cannot read uninitialized value");
      return this._values[e];
    }
    get(e) {
      return this._read(e);
    }
    _write(e, t) {
      this._values[e] = t;
    }
  }
  class Hl {
    static validateOptions(e) {
      const t = new cz();
      for (const i of xu) {
        const n = i.name === "_never_" ? void 0 : e[i.name];
        t._write(i.id, i.validate(n));
      }
      return t;
    }
    static computeOptions(e, t) {
      const i = new dz();
      for (const n of xu)
        i._write(n.id, n.compute(t, i, e._read(n.id)));
      return i;
    }
    static _deepEquals(e, t) {
      if (typeof e != "object" || typeof t != "object" || !e || !t)
        return e === t;
      if (Array.isArray(e) || Array.isArray(t))
        return Array.isArray(e) && Array.isArray(t) ? Gs(e, t) : !1;
      if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
      for (const i in e)
        if (!Hl._deepEquals(e[i], t[i]))
          return !1;
      return !0;
    }
    static checkEquals(e, t) {
      const i = [];
      let n = !1;
      for (const o of xu) {
        const r = !Hl._deepEquals(e._read(o.id), t._read(o.id));
        i[o.id] = r, r && (n = !0);
      }
      return n ? new d5(i) : null;
    }
    static applyUpdate(e, t) {
      let i = !1;
      for (const n of xu)
        if (t.hasOwnProperty(n.name)) {
          const o = n.applyUpdate(e[n.name], t[n.name]);
          e[n.name] = o.newValue, i = i || o.didChange;
        }
      return i;
    }
  }
  function oT(s) {
    const e = ja(s);
    return nz(e), e;
  }
  function Ai(s, e, t) {
    let i = null, n = null;
    if (typeof t.value == "function" ? (i = "value", n = t.value, n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", n = t.get), !n)
      throw new Error("not supported");
    const o = `$memoize$${e}`;
    t[i] = function(...r) {
      return this.hasOwnProperty(o) || Object.defineProperty(this, o, {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: n.apply(this, r)
      }), this[o];
    };
  }
  var hz = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Bt;
  (function(s) {
    s.Tap = "-monaco-gesturetap", s.Change = "-monaco-gesturechange", s.Start = "-monaco-gesturestart", s.End = "-monaco-gesturesend", s.Contextmenu = "-monaco-gesturecontextmenu";
  })(Bt || (Bt = {}));
  class kt extends z {
    constructor() {
      super(), this.dispatched = !1, this.activeTouches = {}, this.handle = null, this.targets = [], this.ignoreTargets = [], this._lastSetTapCountTime = 0, this._register(ee(document, "touchstart", (e) => this.onTouchStart(e), { passive: !1 })), this._register(ee(document, "touchend", (e) => this.onTouchEnd(e))), this._register(ee(document, "touchmove", (e) => this.onTouchMove(e), { passive: !1 }));
    }
    static addTarget(e) {
      return kt.isTouchDevice() ? (kt.INSTANCE || (kt.INSTANCE = new kt()), kt.INSTANCE.targets.push(e), {
        dispose: () => {
          kt.INSTANCE.targets = kt.INSTANCE.targets.filter((t) => t !== e);
        }
      }) : z.None;
    }
    static ignoreTarget(e) {
      return kt.isTouchDevice() ? (kt.INSTANCE || (kt.INSTANCE = new kt()), kt.INSTANCE.ignoreTargets.push(e), {
        dispose: () => {
          kt.INSTANCE.ignoreTargets = kt.INSTANCE.ignoreTargets.filter((t) => t !== e);
        }
      }) : z.None;
    }
    static isTouchDevice() {
      return "ontouchstart" in window || navigator.maxTouchPoints > 0;
    }
    dispose() {
      this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
    }
    onTouchStart(e) {
      let t = Date.now();
      this.handle && (this.handle.dispose(), this.handle = null);
      for (let i = 0, n = e.targetTouches.length; i < n; i++) {
        let o = e.targetTouches.item(i);
        this.activeTouches[o.identifier] = {
          id: o.identifier,
          initialTarget: o.target,
          initialTimeStamp: t,
          initialPageX: o.pageX,
          initialPageY: o.pageY,
          rollingTimestamps: [t],
          rollingPageX: [o.pageX],
          rollingPageY: [o.pageY]
        };
        let r = this.newGestureEvent(Bt.Start, o.target);
        r.pageX = o.pageX, r.pageY = o.pageY, this.dispatchEvent(r);
      }
      this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
    }
    onTouchEnd(e) {
      let t = Date.now(), i = Object.keys(this.activeTouches).length;
      for (let n = 0, o = e.changedTouches.length; n < o; n++) {
        let r = e.changedTouches.item(n);
        if (!this.activeTouches.hasOwnProperty(String(r.identifier))) {
          console.warn("move of an UNKNOWN touch", r);
          continue;
        }
        let a = this.activeTouches[r.identifier], l = Date.now() - a.initialTimeStamp;
        if (l < kt.HOLD_DELAY && Math.abs(a.initialPageX - io(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - io(a.rollingPageY)) < 30) {
          let c = this.newGestureEvent(Bt.Tap, a.initialTarget);
          c.pageX = io(a.rollingPageX), c.pageY = io(a.rollingPageY), this.dispatchEvent(c);
        } else if (l >= kt.HOLD_DELAY && Math.abs(a.initialPageX - io(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - io(a.rollingPageY)) < 30) {
          let c = this.newGestureEvent(Bt.Contextmenu, a.initialTarget);
          c.pageX = io(a.rollingPageX), c.pageY = io(a.rollingPageY), this.dispatchEvent(c);
        } else if (i === 1) {
          let c = io(a.rollingPageX), d = io(a.rollingPageY), h = io(a.rollingTimestamps) - a.rollingTimestamps[0], u = c - a.rollingPageX[0], f = d - a.rollingPageY[0];
          const g = this.targets.filter((_) => a.initialTarget instanceof Node && _.contains(a.initialTarget));
          this.inertia(g, t, Math.abs(u) / h, u > 0 ? 1 : -1, c, Math.abs(f) / h, f > 0 ? 1 : -1, d);
        }
        this.dispatchEvent(this.newGestureEvent(Bt.End, a.initialTarget)), delete this.activeTouches[r.identifier];
      }
      this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
    }
    newGestureEvent(e, t) {
      let i = document.createEvent("CustomEvent");
      return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
    }
    dispatchEvent(e) {
      if (e.type === Bt.Tap) {
        const t = new Date().getTime();
        let i = 0;
        t - this._lastSetTapCountTime > kt.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
      } else
        (e.type === Bt.Change || e.type === Bt.Contextmenu) && (this._lastSetTapCountTime = 0);
      for (let t = 0; t < this.ignoreTargets.length; t++)
        if (e.initialTarget instanceof Node && this.ignoreTargets[t].contains(e.initialTarget))
          return;
      this.targets.forEach((t) => {
        e.initialTarget instanceof Node && t.contains(e.initialTarget) && (t.dispatchEvent(e), this.dispatched = !0);
      });
    }
    inertia(e, t, i, n, o, r, a, l) {
      this.handle = _r(() => {
        let c = Date.now(), d = c - t, h = 0, u = 0, f = !0;
        i += kt.SCROLL_FRICTION * d, r += kt.SCROLL_FRICTION * d, i > 0 && (f = !1, h = n * i * d), r > 0 && (f = !1, u = a * r * d);
        let g = this.newGestureEvent(Bt.Change);
        g.translationX = h, g.translationY = u, e.forEach((_) => _.dispatchEvent(g)), f || this.inertia(e, c, i, n, o + h, r, a, l + u);
      });
    }
    onTouchMove(e) {
      let t = Date.now();
      for (let i = 0, n = e.changedTouches.length; i < n; i++) {
        let o = e.changedTouches.item(i);
        if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
          console.warn("end of an UNKNOWN touch", o);
          continue;
        }
        let r = this.activeTouches[o.identifier], a = this.newGestureEvent(Bt.Change, r.initialTarget);
        a.translationX = o.pageX - io(r.rollingPageX), a.translationY = o.pageY - io(r.rollingPageY), a.pageX = o.pageX, a.pageY = o.pageY, this.dispatchEvent(a), r.rollingPageX.length > 3 && (r.rollingPageX.shift(), r.rollingPageY.shift(), r.rollingTimestamps.shift()), r.rollingPageX.push(o.pageX), r.rollingPageY.push(o.pageY), r.rollingTimestamps.push(t);
      }
      this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
    }
  }
  kt.SCROLL_FRICTION = -5e-3;
  kt.HOLD_DELAY = 700;
  kt.CLEAR_TAP_COUNT_TIME = 400;
  hz([
    Ai
  ], kt, "isTouchDevice", null);
  function ng(s, e) {
    let t = new ho(e);
    return t.preventDefault(), {
      leftButton: t.leftButton,
      buttons: t.buttons,
      posx: t.posx,
      posy: t.posy
    };
  }
  class Ah {
    constructor() {
      this._hooks = new te(), this._mouseMoveEventMerger = null, this._mouseMoveCallback = null, this._onStopCallback = null;
    }
    dispose() {
      this.stopMonitoring(!1), this._hooks.dispose();
    }
    stopMonitoring(e, t) {
      if (!this.isMonitoring())
        return;
      this._hooks.clear(), this._mouseMoveEventMerger = null, this._mouseMoveCallback = null;
      const i = this._onStopCallback;
      this._onStopCallback = null, e && i && i(t);
    }
    isMonitoring() {
      return !!this._mouseMoveEventMerger;
    }
    startMonitoring(e, t, i, n, o) {
      if (this.isMonitoring())
        return;
      this._mouseMoveEventMerger = i, this._mouseMoveCallback = n, this._onStopCallback = o;
      const r = jy.getSameOriginWindowChain(), a = aa ? "pointermove" : "mousemove", l = "mouseup", c = r.map((h) => h.window.document), d = mc(e);
      d && c.unshift(d);
      for (const h of c)
        this._hooks.add(DI(h, a, (u) => {
          if (u.buttons !== t) {
            this.stopMonitoring(!0);
            return;
          }
          this._mouseMoveCallback(u);
        }, (u, f) => this._mouseMoveEventMerger(u, f))), this._hooks.add(ee(h, l, (u) => this.stopMonitoring(!0)));
      if (jy.hasDifferentOriginAncestor()) {
        let h = r[r.length - 1];
        this._hooks.add(ee(h.window.document, "mouseout", (u) => {
          new ho(u).target.tagName.toLowerCase() === "html" && this.stopMonitoring(!0);
        })), this._hooks.add(ee(h.window.document, "mouseover", (u) => {
          new ho(u).target.tagName.toLowerCase() === "html" && this.stopMonitoring(!0);
        })), this._hooks.add(ee(h.window.document.body, "mouseleave", (u) => {
          this.stopMonitoring(!0);
        }));
      }
    }
  }
  function tc(s, e) {
    const t = Math.pow(10, e);
    return Math.round(s * t) / t;
  }
  class tt {
    constructor(e, t, i, n = 1) {
      this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = tc(Math.max(Math.min(1, n), 0), 3);
    }
    static equals(e, t) {
      return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
    }
  }
  class lr {
    constructor(e, t, i, n) {
      this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = tc(Math.max(Math.min(1, t), 0), 3), this.l = tc(Math.max(Math.min(1, i), 0), 3), this.a = tc(Math.max(Math.min(1, n), 0), 3);
    }
    static equals(e, t) {
      return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
    }
    static fromRGBA(e) {
      const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = e.a, r = Math.max(t, i, n), a = Math.min(t, i, n);
      let l = 0, c = 0;
      const d = (a + r) / 2, h = r - a;
      if (h > 0) {
        switch (c = Math.min(d <= 0.5 ? h / (2 * d) : h / (2 - 2 * d), 1), r) {
          case t:
            l = (i - n) / h + (i < n ? 6 : 0);
            break;
          case i:
            l = (n - t) / h + 2;
            break;
          case n:
            l = (t - i) / h + 4;
            break;
        }
        l *= 60, l = Math.round(l);
      }
      return new lr(l, c, d, o);
    }
    static _hue2rgb(e, t, i) {
      return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
    }
    static toRGBA(e) {
      const t = e.h / 360, { s: i, l: n, a: o } = e;
      let r, a, l;
      if (i === 0)
        r = a = l = n;
      else {
        const c = n < 0.5 ? n * (1 + i) : n + i - n * i, d = 2 * n - c;
        r = lr._hue2rgb(d, c, t + 1 / 3), a = lr._hue2rgb(d, c, t), l = lr._hue2rgb(d, c, t - 1 / 3);
      }
      return new tt(Math.round(r * 255), Math.round(a * 255), Math.round(l * 255), o);
    }
  }
  class Qr {
    constructor(e, t, i, n) {
      this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = tc(Math.max(Math.min(1, t), 0), 3), this.v = tc(Math.max(Math.min(1, i), 0), 3), this.a = tc(Math.max(Math.min(1, n), 0), 3);
    }
    static equals(e, t) {
      return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
    }
    static fromRGBA(e) {
      const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = Math.max(t, i, n), r = Math.min(t, i, n), a = o - r, l = o === 0 ? 0 : a / o;
      let c;
      return a === 0 ? c = 0 : o === t ? c = ((i - n) / a % 6 + 6) % 6 : o === i ? c = (n - t) / a + 2 : c = (t - i) / a + 4, new Qr(Math.round(c * 60), l, o, e.a);
    }
    static toRGBA(e) {
      const { h: t, s: i, v: n, a: o } = e, r = n * i, a = r * (1 - Math.abs(t / 60 % 2 - 1)), l = n - r;
      let [c, d, h] = [0, 0, 0];
      return t < 60 ? (c = r, d = a) : t < 120 ? (c = a, d = r) : t < 180 ? (d = r, h = a) : t < 240 ? (d = a, h = r) : t < 300 ? (c = a, h = r) : t <= 360 && (c = r, h = a), c = Math.round((c + l) * 255), d = Math.round((d + l) * 255), h = Math.round((h + l) * 255), new tt(c, d, h, o);
    }
  }
  class H {
    constructor(e) {
      if (e)
        if (e instanceof tt)
          this.rgba = e;
        else if (e instanceof lr)
          this._hsla = e, this.rgba = lr.toRGBA(e);
        else if (e instanceof Qr)
          this._hsva = e, this.rgba = Qr.toRGBA(e);
        else
          throw new Error("Invalid color ctor argument");
      else
        throw new Error("Color needs a value");
    }
    static fromHex(e) {
      return H.Format.CSS.parseHex(e) || H.red;
    }
    get hsla() {
      return this._hsla ? this._hsla : lr.fromRGBA(this.rgba);
    }
    get hsva() {
      return this._hsva ? this._hsva : Qr.fromRGBA(this.rgba);
    }
    equals(e) {
      return !!e && tt.equals(this.rgba, e.rgba) && lr.equals(this.hsla, e.hsla) && Qr.equals(this.hsva, e.hsva);
    }
    getRelativeLuminance() {
      const e = H._relativeLuminanceForComponent(this.rgba.r), t = H._relativeLuminanceForComponent(this.rgba.g), i = H._relativeLuminanceForComponent(this.rgba.b), n = 0.2126 * e + 0.7152 * t + 0.0722 * i;
      return tc(n, 4);
    }
    static _relativeLuminanceForComponent(e) {
      const t = e / 255;
      return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
    }
    isLighter() {
      return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
    }
    isLighterThan(e) {
      const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
      return t > i;
    }
    isDarkerThan(e) {
      const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
      return t < i;
    }
    lighten(e) {
      return new H(new lr(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
    }
    darken(e) {
      return new H(new lr(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
    }
    transparent(e) {
      const { r: t, g: i, b: n, a: o } = this.rgba;
      return new H(new tt(t, i, n, o * e));
    }
    isTransparent() {
      return this.rgba.a === 0;
    }
    isOpaque() {
      return this.rgba.a === 1;
    }
    opposite() {
      return new H(new tt(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    toString() {
      return this._toString || (this._toString = H.Format.CSS.format(this)), this._toString;
    }
    static getLighterColor(e, t, i) {
      if (e.isLighterThan(t))
        return e;
      i = i || 0.5;
      const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
      return i = i * (o - n) / o, e.lighten(i);
    }
    static getDarkerColor(e, t, i) {
      if (e.isDarkerThan(t))
        return e;
      i = i || 0.5;
      const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
      return i = i * (n - o) / n, e.darken(i);
    }
  }
  H.white = new H(new tt(255, 255, 255, 1));
  H.black = new H(new tt(0, 0, 0, 1));
  H.red = new H(new tt(255, 0, 0, 1));
  H.blue = new H(new tt(0, 0, 255, 1));
  H.green = new H(new tt(0, 255, 0, 1));
  H.cyan = new H(new tt(0, 255, 255, 1));
  H.lightgrey = new H(new tt(211, 211, 211, 1));
  H.transparent = new H(new tt(0, 0, 0, 0));
  (function(s) {
    (function(e) {
      (function(t) {
        function i(f) {
          return f.rgba.a === 1 ? `rgb(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b})` : s.Format.CSS.formatRGBA(f);
        }
        t.formatRGB = i;
        function n(f) {
          return `rgba(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b}, ${+f.rgba.a.toFixed(2)})`;
        }
        t.formatRGBA = n;
        function o(f) {
          return f.hsla.a === 1 ? `hsl(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%)` : s.Format.CSS.formatHSLA(f);
        }
        t.formatHSL = o;
        function r(f) {
          return `hsla(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%, ${f.hsla.a.toFixed(2)})`;
        }
        t.formatHSLA = r;
        function a(f) {
          const g = f.toString(16);
          return g.length !== 2 ? "0" + g : g;
        }
        function l(f) {
          return `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}`;
        }
        t.formatHex = l;
        function c(f, g = !1) {
          return g && f.rgba.a === 1 ? s.Format.CSS.formatHex(f) : `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}${a(Math.round(f.rgba.a * 255))}`;
        }
        t.formatHexA = c;
        function d(f) {
          return f.isOpaque() ? s.Format.CSS.formatHex(f) : s.Format.CSS.formatRGBA(f);
        }
        t.format = d;
        function h(f) {
          const g = f.length;
          if (g === 0 || f.charCodeAt(0) !== 35)
            return null;
          if (g === 7) {
            const _ = 16 * u(f.charCodeAt(1)) + u(f.charCodeAt(2)), b = 16 * u(f.charCodeAt(3)) + u(f.charCodeAt(4)), C = 16 * u(f.charCodeAt(5)) + u(f.charCodeAt(6));
            return new s(new tt(_, b, C, 1));
          }
          if (g === 9) {
            const _ = 16 * u(f.charCodeAt(1)) + u(f.charCodeAt(2)), b = 16 * u(f.charCodeAt(3)) + u(f.charCodeAt(4)), C = 16 * u(f.charCodeAt(5)) + u(f.charCodeAt(6)), v = 16 * u(f.charCodeAt(7)) + u(f.charCodeAt(8));
            return new s(new tt(_, b, C, v / 255));
          }
          if (g === 4) {
            const _ = u(f.charCodeAt(1)), b = u(f.charCodeAt(2)), C = u(f.charCodeAt(3));
            return new s(new tt(16 * _ + _, 16 * b + b, 16 * C + C));
          }
          if (g === 5) {
            const _ = u(f.charCodeAt(1)), b = u(f.charCodeAt(2)), C = u(f.charCodeAt(3)), v = u(f.charCodeAt(4));
            return new s(new tt(16 * _ + _, 16 * b + b, 16 * C + C, (16 * v + v) / 255));
          }
          return null;
        }
        t.parseHex = h;
        function u(f) {
          switch (f) {
            case 48:
              return 0;
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case 97:
              return 10;
            case 65:
              return 10;
            case 98:
              return 11;
            case 66:
              return 11;
            case 99:
              return 12;
            case 67:
              return 12;
            case 100:
              return 13;
            case 68:
              return 13;
            case 101:
              return 14;
            case 69:
              return 14;
            case 102:
              return 15;
            case 70:
              return 15;
          }
          return 0;
        }
      })(e.CSS || (e.CSS = {}));
    })(s.Format || (s.Format = {}));
  })(H || (H = {}));
  const Zv = {
    JSONContribution: "base.contributions.json"
  };
  function uz(s) {
    return s.length > 0 && s.charAt(s.length - 1) === "#" ? s.substring(0, s.length - 1) : s;
  }
  class fz {
    constructor() {
      this._onDidChangeSchema = new B(), this.schemasById = {};
    }
    registerSchema(e, t) {
      this.schemasById[uz(e)] = t, this._onDidChangeSchema.fire(e);
    }
    notifySchemaChanged(e) {
      this._onDidChangeSchema.fire(e);
    }
  }
  const gz = new fz();
  Si.add(Zv.JSONContribution, gz);
  function u5(s) {
    return `--vscode-${s.replace(/\./g, "-")}`;
  }
  const f5 = {
    ColorContribution: "base.contributions.colors"
  };
  class mz {
    constructor() {
      this._onDidChangeSchema = new B(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
    }
    registerColor(e, t, i, n = !1, o) {
      let r = { id: e, description: i, defaults: t, needsTransparency: n, deprecationMessage: o };
      this.colorsById[e] = r;
      let a = { type: "string", description: i, format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
      return o && (a.deprecationMessage = o), this.colorSchema.properties[e] = a, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
    }
    getColors() {
      return Object.keys(this.colorsById).map((e) => this.colorsById[e]);
    }
    resolveDefaultColor(e, t) {
      const i = this.colorsById[e];
      if (i && i.defaults) {
        const n = i.defaults[t.type];
        return Wa(n, t);
      }
    }
    getColorSchema() {
      return this.colorSchema;
    }
    toString() {
      let e = (t, i) => {
        let n = t.indexOf(".") === -1 ? 0 : 1, o = i.indexOf(".") === -1 ? 0 : 1;
        return n !== o ? n - o : t.localeCompare(i);
      };
      return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
    }
  }
  const Yv = new mz();
  Si.add(f5.ColorContribution, Yv);
  function M(s, e, t, i, n) {
    return Yv.registerColor(s, e, t, i, n);
  }
  const fe = M("foreground", { dark: "#CCCCCC", light: "#616161", hc: "#FFFFFF" }, m("foreground", "Overall foreground color. This color is only used if not overridden by a component.")), pz = M("errorForeground", { dark: "#F48771", light: "#A1260D", hc: "#F48771" }, m("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
  M("descriptionForeground", { light: "#717171", dark: Re(fe, 0.7), hc: Re(fe, 0.7) }, m("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
  const Uw = M("icon.foreground", { dark: "#C5C5C5", light: "#424242", hc: "#FFFFFF" }, m("iconForeground", "The default color for icons in the workbench.")), sa = M("focusBorder", { dark: "#007FD4", light: "#0090F1", hc: "#F38518" }, m("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), qt = M("contrastBorder", { light: null, dark: null, hc: "#6FC3DF" }, m("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), Bn = M("contrastActiveBorder", { light: null, dark: null, hc: sa }, m("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
  M("selection.background", { light: null, dark: null, hc: null }, m("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
  M("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hc: H.black }, m("textSeparatorForeground", "Color for text separators."));
  const Xv = M("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hc: "#3794FF" }, m("textLinkForeground", "Foreground color for links in text.")), Qv = M("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hc: "#3794FF" }, m("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
  M("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hc: "#D7BA7D" }, m("textPreformatForeground", "Foreground color for preformatted text segments."));
  M("textBlockQuote.background", { light: "#7f7f7f1a", dark: "#7f7f7f1a", hc: null }, m("textBlockQuoteBackground", "Background color for block quotes in text."));
  M("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hc: H.white }, m("textBlockQuoteBorder", "Border color for block quotes in text."));
  const g5 = M("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hc: H.black }, m("textCodeBlockBackground", "Background color for code blocks in text.")), wc = M("widget.shadow", { dark: Re(H.black, 0.36), light: Re(H.black, 0.16), hc: null }, m("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), YI = M("input.background", { dark: "#3C3C3C", light: H.white, hc: H.black }, m("inputBoxBackground", "Input box background.")), XI = M("input.foreground", { dark: fe, light: fe, hc: fe }, m("inputBoxForeground", "Input box foreground.")), QI = M("input.border", { dark: null, light: null, hc: qt }, m("inputBoxBorder", "Input box border.")), uL = M("inputOption.activeBorder", { dark: "#007ACC00", light: "#007ACC00", hc: qt }, m("inputBoxActiveOptionBorder", "Border color of activated options in input fields."));
  M("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hc: null }, m("inputOption.hoverBackground", "Background color of activated options in input fields."));
  const fL = M("inputOption.activeBackground", { dark: Re(sa, 0.4), light: Re(sa, 0.2), hc: H.transparent }, m("inputOption.activeBackground", "Background hover color of options in input fields.")), gL = M("inputOption.activeForeground", { dark: H.white, light: H.black, hc: null }, m("inputOption.activeForeground", "Foreground color of activated options in input fields."));
  M("input.placeholderForeground", { light: Re(fe, 0.5), dark: Re(fe, 0.5), hc: Re(fe, 0.7) }, m("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
  const m5 = M("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hc: H.black }, m("inputValidationInfoBackground", "Input validation background color for information severity.")), p5 = M("inputValidation.infoForeground", { dark: null, light: null, hc: null }, m("inputValidationInfoForeground", "Input validation foreground color for information severity.")), _5 = M("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hc: qt }, m("inputValidationInfoBorder", "Input validation border color for information severity.")), b5 = M("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hc: H.black }, m("inputValidationWarningBackground", "Input validation background color for warning severity.")), v5 = M("inputValidation.warningForeground", { dark: null, light: null, hc: null }, m("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), C5 = M("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hc: qt }, m("inputValidationWarningBorder", "Input validation border color for warning severity.")), w5 = M("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hc: H.black }, m("inputValidationErrorBackground", "Input validation background color for error severity.")), S5 = M("inputValidation.errorForeground", { dark: null, light: null, hc: null }, m("inputValidationErrorForeground", "Input validation foreground color for error severity.")), y5 = M("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hc: qt }, m("inputValidationErrorBorder", "Input validation border color for error severity.")), Id = M("dropdown.background", { dark: "#3C3C3C", light: H.white, hc: H.black }, m("dropdownBackground", "Dropdown background."));
  M("dropdown.listBackground", { dark: null, light: null, hc: H.black }, m("dropdownListBackground", "Dropdown list background."));
  const om = M("dropdown.foreground", { dark: "#F0F0F0", light: null, hc: H.white }, m("dropdownForeground", "Dropdown foreground.")), $w = M("dropdown.border", { dark: Id, light: "#CECECE", hc: qt }, m("dropdownBorder", "Dropdown border."));
  M("checkbox.background", { dark: Id, light: Id, hc: Id }, m("checkbox.background", "Background color of checkbox widget."));
  M("checkbox.foreground", { dark: om, light: om, hc: om }, m("checkbox.foreground", "Foreground color of checkbox widget."));
  M("checkbox.border", { dark: $w, light: $w, hc: $w }, m("checkbox.border", "Border color of checkbox widget."));
  const _z = M("button.foreground", { dark: H.white, light: H.white, hc: H.white }, m("buttonForeground", "Button foreground color.")), mL = M("button.background", { dark: "#0E639C", light: "#007ACC", hc: null }, m("buttonBackground", "Button background color.")), bz = M("button.hoverBackground", { dark: Sc(mL, 0.2), light: og(mL, 0.2), hc: null }, m("buttonHoverBackground", "Button background color when hovering."));
  M("button.border", { dark: qt, light: qt, hc: qt }, m("buttonBorder", "Button border color."));
  M("button.secondaryForeground", { dark: H.white, light: H.white, hc: H.white }, m("buttonSecondaryForeground", "Secondary button foreground color."));
  const rT = M("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hc: null }, m("buttonSecondaryBackground", "Secondary button background color."));
  M("button.secondaryHoverBackground", { dark: Sc(rT, 0.2), light: og(rT, 0.2), hc: null }, m("buttonSecondaryHoverBackground", "Secondary button background color when hovering."));
  const rm = M("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hc: H.black }, m("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), am = M("badge.foreground", { dark: H.white, light: "#333", hc: H.white }, m("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), sg = M("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hc: null }, m("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), qu = M("scrollbarSlider.background", { dark: H.fromHex("#797979").transparent(0.4), light: H.fromHex("#646464").transparent(0.4), hc: Re(qt, 0.6) }, m("scrollbarSliderBackground", "Scrollbar slider background color.")), Gu = M("scrollbarSlider.hoverBackground", { dark: H.fromHex("#646464").transparent(0.7), light: H.fromHex("#646464").transparent(0.7), hc: Re(qt, 0.8) }, m("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), Zu = M("scrollbarSlider.activeBackground", { dark: H.fromHex("#BFBFBF").transparent(0.4), light: H.fromHex("#000000").transparent(0.6), hc: qt }, m("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), vz = M("progressBar.background", { dark: H.fromHex("#0E70C0"), light: H.fromHex("#0E70C0"), hc: qt }, m("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), Cz = M("editorError.background", { dark: null, light: null, hc: null }, m("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), ic = M("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hc: null }, m("editorError.foreground", "Foreground color of error squigglies in the editor.")), L5 = M("editorError.border", { dark: null, light: null, hc: H.fromHex("#E47777").transparent(0.8) }, m("errorBorder", "Border color of error boxes in the editor.")), wz = M("editorWarning.background", { dark: null, light: null, hc: null }, m("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Ko = M("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hc: null }, m("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), Jv = M("editorWarning.border", { dark: null, light: null, hc: H.fromHex("#FFCC00").transparent(0.8) }, m("warningBorder", "Border color of warning boxes in the editor.")), Sz = M("editorInfo.background", { dark: null, light: null, hc: null }, m("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Zs = M("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hc: "#3794FF" }, m("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), JI = M("editorInfo.border", { dark: null, light: null, hc: H.fromHex("#3794FF").transparent(0.8) }, m("infoBorder", "Border color of info boxes in the editor.")), yz = M("editorHint.foreground", { dark: H.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hc: null }, m("editorHint.foreground", "Foreground color of hint squigglies in the editor.")), Lz = M("editorHint.border", { dark: null, light: null, hc: H.fromHex("#eeeeee").transparent(0.8) }, m("hintBorder", "Border color of hint boxes in the editor."));
  M("sash.hoverBorder", { dark: sa, light: sa, hc: sa }, m("sashActiveBorder", "Border color of active sashes."));
  const cs = M("editor.background", { light: "#fffffe", dark: "#1E1E1E", hc: H.black }, m("editorBackground", "Editor background color.")), nc = M("editor.foreground", { light: "#333333", dark: "#BBBBBB", hc: H.white }, m("editorForeground", "Editor default foreground color.")), Kn = M("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hc: "#0C141F" }, m("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), ll = M("editorWidget.foreground", { dark: fe, light: fe, hc: fe }, m("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), Ed = M("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hc: qt }, m("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.")), kz = M("editorWidget.resizeBorder", { light: null, dark: null, hc: null }, m("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget.")), aT = M("quickInput.background", { dark: Kn, light: Kn, hc: Kn }, m("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), Dz = M("quickInput.foreground", { dark: ll, light: ll, hc: ll }, m("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), xz = M("quickInputTitle.background", { dark: new H(new tt(255, 255, 255, 0.105)), light: new H(new tt(0, 0, 0, 0.06)), hc: "#000000" }, m("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), Iz = M("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hc: H.white }, m("pickerGroupForeground", "Quick picker color for grouping labels.")), Ez = M("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hc: H.white }, m("pickerGroupBorder", "Quick picker color for grouping borders.")), Nz = M("keybindingLabel.background", { dark: new H(new tt(128, 128, 128, 0.17)), light: new H(new tt(221, 221, 221, 0.4)), hc: H.transparent }, m("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), Tz = M("keybindingLabel.foreground", { dark: H.fromHex("#CCCCCC"), light: H.fromHex("#555555"), hc: H.white }, m("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), Mz = M("keybindingLabel.border", { dark: new H(new tt(51, 51, 51, 0.6)), light: new H(new tt(204, 204, 204, 0.4)), hc: new H(new tt(111, 195, 223)) }, m("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), Az = M("keybindingLabel.bottomBorder", { dark: new H(new tt(68, 68, 68, 0.6)), light: new H(new tt(187, 187, 187, 0.4)), hc: new H(new tt(111, 195, 223)) }, m("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), sc = M("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hc: "#f3f518" }, m("editorSelectionBackground", "Color of the editor selection.")), Rz = M("editor.selectionForeground", { light: null, dark: null, hc: "#000000" }, m("editorSelectionForeground", "Color of the selected text for high contrast.")), eE = M("editor.inactiveSelectionBackground", { light: Re(sc, 0.5), dark: Re(sc, 0.5), hc: Re(sc, 0.5) }, m("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), tE = M("editor.selectionHighlightBackground", { light: fT(sc, cs, 0.3, 0.6), dark: fT(sc, cs, 0.3, 0.6), hc: null }, m("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0), Oz = M("editor.selectionHighlightBorder", { light: null, dark: null, hc: Bn }, m("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection.")), Pz = M("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hc: null }, m("editorFindMatch", "Color of the current search match.")), oc = M("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hc: null }, m("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0), Fz = M("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hc: null }, m("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0), Bz = M("editor.findMatchBorder", { light: null, dark: null, hc: Bn }, m("editorFindMatchBorder", "Border color of the current search match.")), Yu = M("editor.findMatchHighlightBorder", { light: null, dark: null, hc: Bn }, m("findMatchHighlightBorder", "Border color of the other search matches.")), Wz = M("editor.findRangeHighlightBorder", { dark: null, light: null, hc: Re(Bn, 0.4) }, m("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
  M("searchEditor.findMatchBackground", { light: Re(oc, 0.66), dark: Re(oc, 0.66), hc: oc }, m("searchEditor.queryMatch", "Color of the Search Editor query matches."));
  M("searchEditor.findMatchBorder", { light: Re(Yu, 0.66), dark: Re(Yu, 0.66), hc: Yu }, m("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
  const Vz = M("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hc: "#ADD6FF26" }, m("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0), Yd = M("editorHoverWidget.background", { light: Kn, dark: Kn, hc: Kn }, m("hoverBackground", "Background color of the editor hover.")), iE = M("editorHoverWidget.foreground", { light: ll, dark: ll, hc: ll }, m("hoverForeground", "Foreground color of the editor hover.")), nE = M("editorHoverWidget.border", { light: Ed, dark: Ed, hc: Ed }, m("hoverBorder", "Border color of the editor hover.")), Hz = M("editorHoverWidget.statusBarBackground", { dark: Sc(Yd, 0.2), light: og(Yd, 0.05), hc: Kn }, m("statusBarBackground", "Background color of the editor hover status bar.")), sE = M("editorLink.activeForeground", { dark: "#4E94CE", light: H.blue, hc: H.cyan }, m("activeLinkForeground", "Color of active links.")), Nd = M("editorInlayHint.foreground", { dark: Re(am, 0.8), light: Re(am, 0.8), hc: am }, m("editorInlayHintForeground", "Foreground color of inline hints")), Td = M("editorInlayHint.background", { dark: Re(rm, 0.6), light: Re(rm, 0.3), hc: rm }, m("editorInlayHintBackground", "Background color of inline hints")), zz = M("editorInlayHint.typeForeground", { dark: Nd, light: Nd, hc: Nd }, m("editorInlayHintForegroundTypes", "Foreground color of inline hints for types")), Uz = M("editorInlayHint.typeBackground", { dark: Td, light: Td, hc: Td }, m("editorInlayHintBackgroundTypes", "Background color of inline hints for types")), $z = M("editorInlayHint.parameterForeground", { dark: Nd, light: Nd, hc: Nd }, m("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters")), jz = M("editorInlayHint.parameterBackground", { dark: Td, light: Td, hc: Td }, m("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters")), Kz = M("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hc: "#FFCC00" }, m("editorLightBulbForeground", "The color used for the lightbulb actions icon.")), qz = M("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hc: "#75BEFF" }, m("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon.")), pL = new H(new tt(155, 185, 85, 0.2)), _L = new H(new tt(255, 0, 0, 0.2)), k5 = M("diffEditor.insertedTextBackground", { dark: pL, light: pL, hc: null }, m("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), D5 = M("diffEditor.removedTextBackground", { dark: _L, light: _L, hc: null }, m("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0), Gz = M("diffEditor.insertedLineBackground", { dark: null, light: null, hc: null }, m("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), Zz = M("diffEditor.removedLineBackground", { dark: null, light: null, hc: null }, m("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), !0), Yz = M("diffEditorGutter.insertedLineBackground", { dark: null, light: null, hc: null }, m("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted.")), Xz = M("diffEditorGutter.removedLineBackground", { dark: null, light: null, hc: null }, m("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed.")), Qz = M("diffEditorOverview.insertedForeground", { dark: null, light: null, hc: null }, m("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content.")), Jz = M("diffEditorOverview.removedForeground", { dark: null, light: null, hc: null }, m("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content.")), eU = M("diffEditor.insertedTextBorder", { dark: null, light: null, hc: "#33ff2eff" }, m("diffEditorInsertedOutline", "Outline color for the text that got inserted.")), tU = M("diffEditor.removedTextBorder", { dark: null, light: null, hc: "#FF008F" }, m("diffEditorRemovedOutline", "Outline color for text that got removed.")), iU = M("diffEditor.border", { dark: null, light: null, hc: qt }, m("diffEditorBorder", "Border color between the two text editors.")), nU = M("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hc: null }, m("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views.")), sU = M("list.focusBackground", { dark: null, light: null, hc: null }, m("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), oU = M("list.focusForeground", { dark: null, light: null, hc: null }, m("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), rU = M("list.focusOutline", { dark: sa, light: sa, hc: Bn }, m("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), rc = M("list.activeSelectionBackground", { dark: "#094771", light: "#0060C0", hc: null }, m("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), ac = M("list.activeSelectionForeground", { dark: H.white, light: H.white, hc: null }, m("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), r0 = M("list.activeSelectionIconForeground", { dark: null, light: null, hc: null }, m("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), aU = M("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hc: null }, m("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), lU = M("list.inactiveSelectionForeground", { dark: null, light: null, hc: null }, m("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), cU = M("list.inactiveSelectionIconForeground", { dark: null, light: null, hc: null }, m("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), dU = M("list.inactiveFocusBackground", { dark: null, light: null, hc: null }, m("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), hU = M("list.inactiveFocusOutline", { dark: null, light: null, hc: null }, m("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), uU = M("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hc: null }, m("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), fU = M("list.hoverForeground", { dark: null, light: null, hc: null }, m("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), gU = M("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hc: null }, m("listDropBackground", "List/Tree drag and drop background when moving items around using the mouse.")), cl = M("list.highlightForeground", { dark: "#18A3FF", light: "#0066BF", hc: sa }, m("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree.")), jw = M("list.focusHighlightForeground", { dark: cl, light: WU(rc, cl, "#9DDDFF"), hc: cl }, m("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
  M("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hc: "#B89500" }, m("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
  M("list.errorForeground", { dark: "#F88070", light: "#B01011", hc: null }, m("listErrorForeground", "Foreground color of list items containing errors."));
  M("list.warningForeground", { dark: "#CCA700", light: "#855F00", hc: null }, m("listWarningForeground", "Foreground color of list items containing warnings."));
  const mU = M("listFilterWidget.background", { light: "#efc1ad", dark: "#653723", hc: H.black }, m("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), pU = M("listFilterWidget.outline", { dark: H.transparent, light: H.transparent, hc: "#f38518" }, m("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), _U = M("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hc: qt }, m("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches."));
  M("list.filterMatchBackground", { dark: oc, light: oc, hc: null }, m("listFilterMatchHighlight", "Background color of the filtered match."));
  M("list.filterMatchBorder", { dark: Yu, light: Yu, hc: qt }, m("listFilterMatchHighlightBorder", "Border color of the filtered match."));
  const bU = M("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hc: "#a9a9a9" }, m("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), vU = M("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hc: null }, m("tableColumnsBorder", "Table border color between columns.")), CU = M("tree.tableOddRowsBackground", { dark: Re(fe, 0.04), light: Re(fe, 0.04), hc: null }, m("tableOddRowsBackgroundColor", "Background color for odd table rows."));
  M("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hc: "#A7A8A9" }, m("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized. "));
  const lT = M("quickInput.list.focusBackground", { dark: null, light: null, hc: null }, "", void 0, m("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), a0 = M("quickInputList.focusForeground", { dark: ac, light: ac, hc: ac }, m("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), l0 = M("quickInputList.focusIconForeground", { dark: r0, light: r0, hc: r0 }, m("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item.")), c0 = M("quickInputList.focusBackground", { dark: qm(lT, rc), light: qm(lT, rc), hc: null }, m("quickInput.listFocusBackground", "Quick picker background color for the focused item.")), wU = M("menu.border", { dark: null, light: null, hc: qt }, m("menuBorder", "Border color of menus.")), SU = M("menu.foreground", { dark: om, light: fe, hc: om }, m("menuForeground", "Foreground color of menu items.")), yU = M("menu.background", { dark: Id, light: Id, hc: Id }, m("menuBackground", "Background color of menu items.")), LU = M("menu.selectionForeground", { dark: ac, light: ac, hc: ac }, m("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), kU = M("menu.selectionBackground", { dark: rc, light: rc, hc: rc }, m("menuSelectionBackground", "Background color of the selected menu item in menus.")), DU = M("menu.selectionBorder", { dark: null, light: null, hc: Bn }, m("menuSelectionBorder", "Border color of the selected menu item in menus.")), xU = M("menu.separatorBackground", { dark: "#BBBBBB", light: "#888888", hc: qt }, m("menuSeparatorBackground", "Color of a separator menu item in menus.")), bL = M("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hc: null }, m("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
  M("toolbar.hoverOutline", { dark: null, light: null, hc: Bn }, m("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
  M("toolbar.activeBackground", { dark: Sc(bL, 0.1), light: og(bL, 0.1), hc: null }, m("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
  M("editor.snippetTabstopHighlightBackground", { dark: new H(new tt(124, 124, 124, 0.3)), light: new H(new tt(10, 50, 100, 0.2)), hc: new H(new tt(124, 124, 124, 0.3)) }, m("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
  M("editor.snippetTabstopHighlightBorder", { dark: null, light: null, hc: null }, m("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
  M("editor.snippetFinalTabstopHighlightBackground", { dark: null, light: null, hc: null }, m("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
  M("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new H(new tt(10, 50, 100, 0.5)), hc: "#525252" }, m("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
  M("breadcrumb.foreground", { light: Re(fe, 0.8), dark: Re(fe, 0.8), hc: Re(fe, 0.8) }, m("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
  M("breadcrumb.background", { light: cs, dark: cs, hc: cs }, m("breadcrumbsBackground", "Background color of breadcrumb items."));
  M("breadcrumb.focusForeground", { light: og(fe, 0.2), dark: Sc(fe, 0.1), hc: Sc(fe, 0.1) }, m("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
  M("breadcrumb.activeSelectionForeground", { light: og(fe, 0.2), dark: Sc(fe, 0.1), hc: Sc(fe, 0.1) }, m("breadcrumbsSelectedForegound", "Color of selected breadcrumb items."));
  M("breadcrumbPicker.background", { light: Kn, dark: Kn, hc: Kn }, m("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
  const x5 = 0.5, cT = H.fromHex("#40C8AE").transparent(x5), dT = H.fromHex("#40A6FF").transparent(x5), hT = H.fromHex("#606060").transparent(0.4), dl = 0.4, vf = 1, lm = M("merge.currentHeaderBackground", { dark: cT, light: cT, hc: null }, m("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
  M("merge.currentContentBackground", { dark: Re(lm, dl), light: Re(lm, dl), hc: Re(lm, dl) }, m("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
  const cm = M("merge.incomingHeaderBackground", { dark: dT, light: dT, hc: null }, m("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
  M("merge.incomingContentBackground", { dark: Re(cm, dl), light: Re(cm, dl), hc: Re(cm, dl) }, m("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
  const dm = M("merge.commonHeaderBackground", { dark: hT, light: hT, hc: null }, m("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
  M("merge.commonContentBackground", { dark: Re(dm, dl), light: Re(dm, dl), hc: Re(dm, dl) }, m("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
  const oE = M("merge.border", { dark: null, light: null, hc: "#C3DF6F" }, m("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
  M("editorOverviewRuler.currentContentForeground", { dark: Re(lm, vf), light: Re(lm, vf), hc: oE }, m("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
  M("editorOverviewRuler.incomingContentForeground", { dark: Re(cm, vf), light: Re(cm, vf), hc: oE }, m("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
  M("editorOverviewRuler.commonContentForeground", { dark: Re(dm, vf), light: Re(dm, vf), hc: oE }, m("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
  const rE = M("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hc: "#AB5A00" }, m("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0), I5 = M("editorOverviewRuler.selectionHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC" }, m("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0), hm = M("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hc: "#AB5A00" }, m("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0), eC = M("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hc: "#ffffff" }, m("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), !0), uT = M("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hc: "#ffffff" }, m("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), IU = M("minimap.errorHighlight", { dark: new H(new tt(255, 18, 18, 0.7)), light: new H(new tt(255, 18, 18, 0.7)), hc: new H(new tt(255, 50, 50, 1)) }, m("minimapError", "Minimap marker color for errors.")), EU = M("minimap.warningHighlight", { dark: Ko, light: Ko, hc: Jv }, m("overviewRuleWarning", "Minimap marker color for warnings.")), NU = M("minimap.background", { dark: null, light: null, hc: null }, m("minimapBackground", "Minimap background color.")), TU = M("minimap.foregroundOpacity", { dark: H.fromHex("#000f"), light: H.fromHex("#000f"), hc: H.fromHex("#000f") }, m("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.')), MU = M("minimapSlider.background", { light: Re(qu, 0.5), dark: Re(qu, 0.5), hc: Re(qu, 0.5) }, m("minimapSliderBackground", "Minimap slider background color.")), AU = M("minimapSlider.hoverBackground", { light: Re(Gu, 0.5), dark: Re(Gu, 0.5), hc: Re(Gu, 0.5) }, m("minimapSliderHoverBackground", "Minimap slider background color when hovering.")), RU = M("minimapSlider.activeBackground", { light: Re(Zu, 0.5), dark: Re(Zu, 0.5), hc: Re(Zu, 0.5) }, m("minimapSliderActiveBackground", "Minimap slider background color when clicked on.")), OU = M("problemsErrorIcon.foreground", { dark: ic, light: ic, hc: ic }, m("problemsErrorIconForeground", "The color used for the problems error icon.")), PU = M("problemsWarningIcon.foreground", { dark: Ko, light: Ko, hc: Ko }, m("problemsWarningIconForeground", "The color used for the problems warning icon.")), FU = M("problemsInfoIcon.foreground", { dark: Zs, light: Zs, hc: Zs }, m("problemsInfoIconForeground", "The color used for the problems info icon."));
  M("charts.foreground", { dark: fe, light: fe, hc: fe }, m("chartsForeground", "The foreground color used in charts."));
  M("charts.lines", { dark: Re(fe, 0.5), light: Re(fe, 0.5), hc: Re(fe, 0.5) }, m("chartsLines", "The color used for horizontal lines in charts."));
  M("charts.red", { dark: ic, light: ic, hc: ic }, m("chartsRed", "The red color used in chart visualizations."));
  M("charts.blue", { dark: Zs, light: Zs, hc: Zs }, m("chartsBlue", "The blue color used in chart visualizations."));
  M("charts.yellow", { dark: Ko, light: Ko, hc: Ko }, m("chartsYellow", "The yellow color used in chart visualizations."));
  M("charts.orange", { dark: hm, light: hm, hc: hm }, m("chartsOrange", "The orange color used in chart visualizations."));
  M("charts.green", { dark: "#89D185", light: "#388A34", hc: "#89D185" }, m("chartsGreen", "The green color used in chart visualizations."));
  M("charts.purple", { dark: "#B180D7", light: "#652D90", hc: "#B180D7" }, m("chartsPurple", "The purple color used in chart visualizations."));
  function BU(s, e) {
    var t, i, n;
    switch (s.op) {
      case 0:
        return (t = Wa(s.value, e)) === null || t === void 0 ? void 0 : t.darken(s.factor);
      case 1:
        return (i = Wa(s.value, e)) === null || i === void 0 ? void 0 : i.lighten(s.factor);
      case 2:
        return (n = Wa(s.value, e)) === null || n === void 0 ? void 0 : n.transparent(s.factor);
      case 3:
        for (const o of s.values) {
          const r = Wa(o, e);
          if (r)
            return r;
        }
        return;
      case 5:
        return Wa(e.defines(s.if) ? s.then : s.else, e);
      case 4: {
        const o = Wa(s.value, e);
        if (!o)
          return;
        const r = Wa(s.background, e);
        return r ? o.isDarkerThan(r) ? H.getLighterColor(o, r, s.factor).transparent(s.transparency) : H.getDarkerColor(o, r, s.factor).transparent(s.transparency) : o.transparent(s.factor * s.transparency);
      }
      default:
        throw _I();
    }
  }
  function og(s, e) {
    return { op: 0, value: s, factor: e };
  }
  function Sc(s, e) {
    return { op: 1, value: s, factor: e };
  }
  function Re(s, e) {
    return { op: 2, value: s, factor: e };
  }
  function qm(...s) {
    return { op: 3, values: s };
  }
  function WU(s, e, t) {
    return { op: 5, if: s, then: e, else: t };
  }
  function fT(s, e, t, i) {
    return { op: 4, value: s, background: e, factor: t, transparency: i };
  }
  function Wa(s, e) {
    if (s !== null) {
      if (typeof s == "string")
        return s[0] === "#" ? H.fromHex(s) : e.getColor(s);
      if (s instanceof H)
        return s;
      if (typeof s == "object")
        return BU(s, e);
    }
  }
  const E5 = "vscode://schemas/workbench-colors";
  let N5 = Si.as(Zv.JSONContribution);
  N5.registerSchema(E5, Yv.getColorSchema());
  const gT = new It(() => N5.notifySchemaChanged(E5), 200);
  Yv.onDidChangeSchema(() => {
    gT.isScheduled() || gT.schedule();
  });
  class aE {
    constructor(e, t) {
      this.x = e, this.y = t, this._pageCoordinatesBrand = void 0;
    }
    toClientCoordinates() {
      return new T5(this.x - rl.scrollX, this.y - rl.scrollY);
    }
  }
  class T5 {
    constructor(e, t) {
      this.clientX = e, this.clientY = t, this._clientCoordinatesBrand = void 0;
    }
    toPageCoordinates() {
      return new aE(this.clientX + rl.scrollX, this.clientY + rl.scrollY);
    }
  }
  class VU {
    constructor(e, t, i, n) {
      this.x = e, this.y = t, this.width = i, this.height = n, this._editorPagePositionBrand = void 0;
    }
  }
  class HU {
    constructor(e, t) {
      this.x = e, this.y = t, this._positionRelativeToEditorBrand = void 0;
    }
  }
  function M5(s) {
    const e = mn(s);
    return new VU(e.left, e.top, e.width, e.height);
  }
  function A5(s, e, t) {
    const i = e.width / s.offsetWidth, n = e.height / s.offsetHeight, o = (t.x - e.x) / i, r = (t.y - e.y) / n;
    return new HU(o, r);
  }
  class Xd extends ho {
    constructor(e, t) {
      super(e), this._editorMouseEventBrand = void 0, this.pos = new aE(this.posx, this.posy), this.editorPos = M5(t), this.relativePos = A5(t, this.editorPos, this.pos);
    }
  }
  class zU {
    constructor(e) {
      this._editorViewDomNode = e;
    }
    _create(e) {
      return new Xd(e, this._editorViewDomNode);
    }
    onContextMenu(e, t) {
      return ee(e, "contextmenu", (i) => {
        t(this._create(i));
      });
    }
    onMouseUp(e, t) {
      return ee(e, "mouseup", (i) => {
        t(this._create(i));
      });
    }
    onMouseDown(e, t) {
      return ee(e, "mousedown", (i) => {
        t(this._create(i));
      });
    }
    onMouseLeave(e, t) {
      return kI(e, (i) => {
        t(this._create(i));
      });
    }
    onMouseMoveThrottled(e, t, i, n) {
      return DI(e, "mousemove", t, (r, a) => i(r, this._create(a)), n);
    }
  }
  class UU {
    constructor(e) {
      this._editorViewDomNode = e;
    }
    _create(e) {
      return new Xd(e, this._editorViewDomNode);
    }
    onPointerUp(e, t) {
      return ee(e, "pointerup", (i) => {
        t(this._create(i));
      });
    }
    onPointerDown(e, t) {
      return ee(e, "pointerdown", (i) => {
        t(this._create(i));
      });
    }
    onPointerLeave(e, t) {
      return LW(e, (i) => {
        t(this._create(i));
      });
    }
    onPointerMoveThrottled(e, t, i, n) {
      return DI(e, "pointermove", t, (r, a) => i(r, this._create(a)), n);
    }
  }
  class $U extends z {
    constructor(e) {
      super(), this._editorViewDomNode = e, this._globalMouseMoveMonitor = this._register(new Ah()), this._keydownListener = null;
    }
    startMonitoring(e, t, i, n, o) {
      this._keydownListener = on(document, "keydown", (a) => {
        a.toKeybinding().isModifierKey() || this._globalMouseMoveMonitor.stopMonitoring(!0, a.browserEvent);
      }, !0);
      const r = (a, l) => i(a, new Xd(l, this._editorViewDomNode));
      this._globalMouseMoveMonitor.startMonitoring(e, t, r, n, (a) => {
        this._keydownListener.dispose(), o(a);
      });
    }
    stopMonitoring() {
      this._globalMouseMoveMonitor.stopMonitoring(!0);
    }
  }
  class c_ {
    constructor(e) {
      this._editor = e, this._instanceId = ++c_._idPool, this._counter = 0, this._rules = /* @__PURE__ */ new Map(), this._garbageCollectionScheduler = new It(() => this.garbageCollect(), 1e3);
    }
    createClassNameRef(e) {
      const t = this.getOrCreateRule(e);
      return t.increaseRefCount(), {
        className: t.className,
        dispose: () => {
          t.decreaseRefCount(), this._garbageCollectionScheduler.schedule();
        }
      };
    }
    getOrCreateRule(e) {
      const t = this.computeUniqueKey(e);
      let i = this._rules.get(t);
      if (!i) {
        const n = this._counter++;
        i = new jU(t, `dyn-rule-${this._instanceId}-${n}`, Vm(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0, e), this._rules.set(t, i);
      }
      return i;
    }
    computeUniqueKey(e) {
      return JSON.stringify(e);
    }
    garbageCollect() {
      for (const e of this._rules.values())
        e.hasReferences() || (this._rules.delete(e.key), e.dispose());
    }
  }
  c_._idPool = 0;
  class jU {
    constructor(e, t, i, n) {
      this.key = e, this.className = t, this.properties = n, this._referenceCount = 0, this._styleElement = Co(i), this._styleElement.textContent = this.getCssText(this.className, this.properties);
    }
    getCssText(e, t) {
      let i = `.${e} {`;
      for (const n in t) {
        const o = t[n];
        let r;
        typeof o == "object" ? r = `var(${u5(o.id)})` : r = o, i += `
	${KU(n)}: ${r};`;
      }
      return i += `
}`, i;
    }
    dispose() {
      this._styleElement.remove();
    }
    increaseRefCount() {
      this._referenceCount++;
    }
    decreaseRefCount() {
      this._referenceCount--;
    }
    hasReferences() {
      return this._referenceCount > 0;
    }
  }
  function KU(s) {
    return s.replace(/(^[A-Z])/, ([e]) => e.toLowerCase()).replace(/([A-Z])/g, ([e]) => `-${e.toLowerCase()}`);
  }
  class d_ extends z {
    constructor() {
      super(), this._shouldRender = !0;
    }
    shouldRender() {
      return this._shouldRender;
    }
    forceShouldRender() {
      this._shouldRender = !0;
    }
    setShouldRender() {
      this._shouldRender = !0;
    }
    onDidRender() {
      this._shouldRender = !1;
    }
    onCompositionStart(e) {
      return !1;
    }
    onCompositionEnd(e) {
      return !1;
    }
    onConfigurationChanged(e) {
      return !1;
    }
    onCursorStateChanged(e) {
      return !1;
    }
    onDecorationsChanged(e) {
      return !1;
    }
    onFlushed(e) {
      return !1;
    }
    onFocusChanged(e) {
      return !1;
    }
    onLanguageConfigurationChanged(e) {
      return !1;
    }
    onLineMappingChanged(e) {
      return !1;
    }
    onLinesChanged(e) {
      return !1;
    }
    onLinesDeleted(e) {
      return !1;
    }
    onLinesInserted(e) {
      return !1;
    }
    onRevealRangeRequest(e) {
      return !1;
    }
    onScrollChanged(e) {
      return !1;
    }
    onThemeChanged(e) {
      return !1;
    }
    onTokensChanged(e) {
      return !1;
    }
    onTokensColorsChanged(e) {
      return !1;
    }
    onZonesChanged(e) {
      return !1;
    }
    handleEvents(e) {
      let t = !1;
      for (let i = 0, n = e.length; i < n; i++) {
        const o = e[i];
        switch (o.type) {
          case 0:
            this.onCompositionStart(o) && (t = !0);
            break;
          case 1:
            this.onCompositionEnd(o) && (t = !0);
            break;
          case 2:
            this.onConfigurationChanged(o) && (t = !0);
            break;
          case 3:
            this.onCursorStateChanged(o) && (t = !0);
            break;
          case 4:
            this.onDecorationsChanged(o) && (t = !0);
            break;
          case 5:
            this.onFlushed(o) && (t = !0);
            break;
          case 6:
            this.onFocusChanged(o) && (t = !0);
            break;
          case 7:
            this.onLanguageConfigurationChanged(o) && (t = !0);
            break;
          case 8:
            this.onLineMappingChanged(o) && (t = !0);
            break;
          case 9:
            this.onLinesChanged(o) && (t = !0);
            break;
          case 10:
            this.onLinesDeleted(o) && (t = !0);
            break;
          case 11:
            this.onLinesInserted(o) && (t = !0);
            break;
          case 12:
            this.onRevealRangeRequest(o) && (t = !0);
            break;
          case 13:
            this.onScrollChanged(o) && (t = !0);
            break;
          case 15:
            this.onTokensChanged(o) && (t = !0);
            break;
          case 14:
            this.onThemeChanged(o) && (t = !0);
            break;
          case 16:
            this.onTokensColorsChanged(o) && (t = !0);
            break;
          case 17:
            this.onZonesChanged(o) && (t = !0);
            break;
          default:
            console.info("View received unknown event: "), console.info(o);
        }
      }
      t && (this._shouldRender = !0);
    }
  }
  class Do extends d_ {
    constructor(e) {
      super(), this._context = e, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), super.dispose();
    }
  }
  class ha {
    static write(e, t) {
      e.setAttribute("data-mprt", String(t));
    }
    static read(e) {
      const t = e.getAttribute("data-mprt");
      return t === null ? 0 : parseInt(t, 10);
    }
    static collect(e, t) {
      const i = [];
      let n = 0;
      for (; e && e !== document.body && e !== t; )
        e.nodeType === e.ELEMENT_NODE && (i[n++] = this.read(e)), e = e.parentElement;
      const o = new Uint8Array(n);
      for (let r = 0; r < n; r++)
        o[r] = i[n - r - 1];
      return o;
    }
  }
  class qU {
    constructor(e, t) {
      this._restrictedRenderingContextBrand = void 0, this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
      const i = this._viewLayout.getCurrentViewport();
      this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
    }
    getScrolledTopFromAbsoluteTop(e) {
      return e - this.scrollTop;
    }
    getVerticalOffsetForLineNumber(e) {
      return this._viewLayout.getVerticalOffsetForLineNumber(e);
    }
    getDecorationsInViewport() {
      return this.viewportData.getDecorationsInViewport();
    }
  }
  class GU extends qU {
    constructor(e, t, i) {
      super(e, t), this._renderingContextBrand = void 0, this._viewLines = i;
    }
    linesVisibleRangesForRange(e, t) {
      return this._viewLines.linesVisibleRangesForRange(e, t);
    }
    visibleRangeForPosition(e) {
      return this._viewLines.visibleRangeForPosition(e);
    }
  }
  class ZU {
    constructor(e, t, i) {
      this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i;
    }
  }
  class tC {
    constructor(e, t) {
      this._horizontalRangeBrand = void 0, this.left = Math.round(e), this.width = Math.round(t);
    }
    static from(e) {
      const t = new Array(e.length);
      for (let i = 0, n = e.length; i < n; i++) {
        const o = e[i];
        t[i] = new tC(o.left, o.width);
      }
      return t;
    }
    toString() {
      return `[${this.left},${this.width}]`;
    }
  }
  class Xu {
    constructor(e, t) {
      this._floatHorizontalRangeBrand = void 0, this.left = e, this.width = t;
    }
    toString() {
      return `[${this.left},${this.width}]`;
    }
    static compare(e, t) {
      return e.left - t.left;
    }
  }
  class YU {
    constructor(e, t) {
      this.outsideRenderedLine = e, this.originalLeft = t, this.left = Math.round(this.originalLeft);
    }
  }
  class XU {
    constructor(e, t) {
      this.outsideRenderedLine = e, this.ranges = t;
    }
  }
  class Kw {
    static _createRange() {
      return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
    }
    static _detachRange(e, t) {
      e.selectNodeContents(t);
    }
    static _readClientRects(e, t, i, n, o) {
      const r = this._createRange();
      try {
        return r.setStart(e, t), r.setEnd(i, n), r.getClientRects();
      } catch {
        return null;
      } finally {
        this._detachRange(r, o);
      }
    }
    static _mergeAdjacentRanges(e) {
      if (e.length === 1)
        return e;
      e.sort(Xu.compare);
      const t = [];
      let i = 0, n = e[0];
      for (let o = 1, r = e.length; o < r; o++) {
        const a = e[o];
        n.left + n.width + 0.9 >= a.left ? n.width = Math.max(n.width, a.left + a.width - n.left) : (t[i++] = n, n = a);
      }
      return t[i++] = n, t;
    }
    static _createHorizontalRangesFromClientRects(e, t, i) {
      if (!e || e.length === 0)
        return null;
      const n = [];
      for (let o = 0, r = e.length; o < r; o++) {
        const a = e[o];
        n[o] = new Xu(Math.max(0, (a.left - t) / i), a.width / i);
      }
      return this._mergeAdjacentRanges(n);
    }
    static readHorizontalRanges(e, t, i, n, o, r, a, l) {
      const d = e.children.length - 1;
      if (0 > d)
        return null;
      if (t = Math.min(d, Math.max(0, t)), n = Math.min(d, Math.max(0, n)), t === n && i === o && i === 0 && !e.children[t].firstChild) {
        const g = e.children[t].getClientRects();
        return this._createHorizontalRangesFromClientRects(g, r, a);
      }
      t !== n && n > 0 && o === 0 && (n--, o = 1073741824);
      let h = e.children[t].firstChild, u = e.children[n].firstChild;
      if ((!h || !u) && (!h && i === 0 && t > 0 && (h = e.children[t - 1].firstChild, i = 1073741824), !u && o === 0 && n > 0 && (u = e.children[n - 1].firstChild, o = 1073741824)), !h || !u)
        return null;
      i = Math.min(h.textContent.length, Math.max(0, i)), o = Math.min(u.textContent.length, Math.max(0, o));
      const f = this._readClientRects(h, i, u, o, l);
      return this._createHorizontalRangesFromClientRects(f, r, a);
    }
  }
  class js {
    constructor(e, t, i, n) {
      this.startColumn = e, this.endColumn = t, this.className = i, this.type = n, this._lineDecorationBrand = void 0;
    }
    static _equals(e, t) {
      return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
    }
    static equalsArr(e, t) {
      const i = e.length, n = t.length;
      if (i !== n)
        return !1;
      for (let o = 0; o < i; o++)
        if (!js._equals(e[o], t[o]))
          return !1;
      return !0;
    }
    static extractWrapped(e, t, i) {
      if (e.length === 0)
        return e;
      const n = t + 1, o = i + 1, r = i - t, a = [];
      let l = 0;
      for (const c of e)
        c.endColumn <= n || c.startColumn >= o || (a[l++] = new js(Math.max(1, c.startColumn - n + 1), Math.min(r + 1, c.endColumn - n + 1), c.className, c.type));
      return a;
    }
    static filter(e, t, i, n) {
      if (e.length === 0)
        return [];
      const o = [];
      let r = 0;
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a], d = c.range;
        if (d.endLineNumber < t || d.startLineNumber > t || d.isEmpty() && (c.type === 0 || c.type === 3))
          continue;
        const h = d.startLineNumber === t ? d.startColumn : i, u = d.endLineNumber === t ? d.endColumn : n;
        o[r++] = new js(h, u, c.inlineClassName, c.type);
      }
      return o;
    }
    static _typeCompare(e, t) {
      const i = [2, 0, 1, 3];
      return i[e] - i[t];
    }
    static compare(e, t) {
      if (e.startColumn !== t.startColumn)
        return e.startColumn - t.startColumn;
      if (e.endColumn !== t.endColumn)
        return e.endColumn - t.endColumn;
      const i = js._typeCompare(e.type, t.type);
      return i !== 0 ? i : e.className !== t.className ? e.className < t.className ? -1 : 1 : 0;
    }
  }
  class mT {
    constructor(e, t, i, n) {
      this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = n;
    }
  }
  class a1 {
    constructor() {
      this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
    }
    static _metadata(e) {
      let t = 0;
      for (let i = 0, n = e.length; i < n; i++)
        t |= e[i];
      return t;
    }
    consumeLowerThan(e, t, i) {
      for (; this.count > 0 && this.stopOffsets[0] < e; ) {
        let n = 0;
        for (; n + 1 < this.count && this.stopOffsets[n] === this.stopOffsets[n + 1]; )
          n++;
        i.push(new mT(t, this.stopOffsets[n], this.classNames.join(" "), a1._metadata(this.metadata))), t = this.stopOffsets[n] + 1, this.stopOffsets.splice(0, n + 1), this.classNames.splice(0, n + 1), this.metadata.splice(0, n + 1), this.count -= n + 1;
      }
      return this.count > 0 && t < e && (i.push(new mT(t, e - 1, this.classNames.join(" "), a1._metadata(this.metadata))), t = e), t;
    }
    insert(e, t, i) {
      if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
        this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
      else
        for (let n = 0; n < this.count; n++)
          if (this.stopOffsets[n] >= e) {
            this.stopOffsets.splice(n, 0, e), this.classNames.splice(n, 0, t), this.metadata.splice(n, 0, i);
            break;
          }
      this.count++;
    }
  }
  class QU {
    static normalize(e, t) {
      if (t.length === 0)
        return [];
      const i = [], n = new a1();
      let o = 0;
      for (let r = 0, a = t.length; r < a; r++) {
        const l = t[r];
        let c = l.startColumn, d = l.endColumn;
        const h = l.className, u = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
        if (c > 1) {
          const _ = e.charCodeAt(c - 2);
          Pi(_) && c--;
        }
        if (d > 1) {
          const _ = e.charCodeAt(d - 2);
          Pi(_) && d--;
        }
        const f = c - 1, g = d - 2;
        o = n.consumeLowerThan(f, o, i), n.count === 0 && (o = f), n.insert(g, h, u);
      }
      return n.consumeLowerThan(1073741824, o, i), i;
    }
  }
  class qi {
    constructor(e, t, i) {
      this._linePartBrand = void 0, this.endIndex = e, this.type = t, this.metadata = i;
    }
    isWhitespace() {
      return !!(this.metadata & 1);
    }
    isPseudoAfter() {
      return !!(this.metadata & 4);
    }
  }
  class JU {
    constructor(e, t) {
      this.startOffset = e, this.endOffset = t;
    }
    equals(e) {
      return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
    }
  }
  class Rh {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u, f, g, _, b, C, v, w) {
      this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = n, this.isBasicASCII = o, this.containsRTL = r, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = c.sort(js.compare), this.tabSize = d, this.startVisibleColumn = h, this.spaceWidth = u, this.stopRenderingLineAfter = _, this.renderWhitespace = b === "all" ? 4 : b === "boundary" ? 1 : b === "selection" ? 2 : b === "trailing" ? 3 : 0, this.renderControlCharacters = C, this.fontLigatures = v, this.selectionsOnLine = w && w.sort((x, y) => x.startOffset < y.startOffset ? -1 : 1);
      const S = Math.abs(g - u), L = Math.abs(f - u);
      S < L ? (this.renderSpaceWidth = g, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = f, this.renderSpaceCharCode = 183);
    }
    sameSelection(e) {
      if (this.selectionsOnLine === null)
        return e === null;
      if (e === null || e.length !== this.selectionsOnLine.length)
        return !1;
      for (let t = 0; t < this.selectionsOnLine.length; t++)
        if (!this.selectionsOnLine[t].equals(e[t]))
          return !1;
      return !0;
    }
    equals(e) {
      return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && js.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
    }
  }
  class lE {
    constructor(e, t) {
      this.partIndex = e, this.charIndex = t;
    }
  }
  class Hr {
    constructor(e, t) {
      this.length = e, this._data = new Uint32Array(this.length), this._absoluteOffsets = new Uint32Array(this.length);
    }
    static getPartIndex(e) {
      return (e & 4294901760) >>> 16;
    }
    static getCharIndex(e) {
      return (e & 65535) >>> 0;
    }
    setColumnInfo(e, t, i, n) {
      const o = (t << 16 | i << 0) >>> 0;
      this._data[e - 1] = o, this._absoluteOffsets[e - 1] = n + i;
    }
    getAbsoluteOffset(e) {
      return this._absoluteOffsets.length === 0 ? 0 : this._absoluteOffsets[e - 1];
    }
    charOffsetToPartData(e) {
      return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
    }
    getDomPosition(e) {
      const t = this.charOffsetToPartData(e - 1), i = Hr.getPartIndex(t), n = Hr.getCharIndex(t);
      return new lE(i, n);
    }
    getColumn(e, t) {
      return this.partDataToCharOffset(e.partIndex, t, e.charIndex) + 1;
    }
    partDataToCharOffset(e, t, i) {
      if (this.length === 0)
        return 0;
      const n = (e << 16 | i << 0) >>> 0;
      let o = 0, r = this.length - 1;
      for (; o + 1 < r; ) {
        const _ = o + r >>> 1, b = this._data[_];
        if (b === n)
          return _;
        b > n ? r = _ : o = _;
      }
      if (o === r)
        return o;
      const a = this._data[o], l = this._data[r];
      if (a === n)
        return o;
      if (l === n)
        return r;
      const c = Hr.getPartIndex(a), d = Hr.getCharIndex(a), h = Hr.getPartIndex(l);
      let u;
      c !== h ? u = t : u = Hr.getCharIndex(l);
      const f = i - d, g = u - i;
      return f <= g ? o : r;
    }
  }
  class vL {
    constructor(e, t, i) {
      this._renderLineOutputBrand = void 0, this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
    }
  }
  function iC(s, e) {
    if (s.lineContent.length === 0) {
      if (s.lineDecorations.length > 0) {
        e.appendASCIIString("<span>");
        let t = 0, i = 0, n = 0;
        for (const r of s.lineDecorations)
          (r.type === 1 || r.type === 2) && (e.appendASCIIString('<span class="'), e.appendASCIIString(r.className), e.appendASCIIString('"></span>'), r.type === 1 && (n |= 1, t++), r.type === 2 && (n |= 2, i++));
        e.appendASCIIString("</span>");
        const o = new Hr(1, t + i);
        return o.setColumnInfo(1, t, 0, 0), new vL(o, !1, n);
      }
      return e.appendASCIIString("<span><span></span></span>"), new vL(new Hr(0, 0), !1, 0);
    }
    return l$(i$(s), e);
  }
  class e$ {
    constructor(e, t, i, n) {
      this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = n;
    }
  }
  function nC(s) {
    const e = Zd(1e4), t = iC(s, e);
    return new e$(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
  }
  class t$ {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u, f, g, _) {
      this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = n, this.isOverflowing = o, this.parts = r, this.containsForeignElements = a, this.fauxIndentLength = l, this.tabSize = c, this.startVisibleColumn = d, this.containsRTL = h, this.spaceWidth = u, this.renderSpaceCharCode = f, this.renderWhitespace = g, this.renderControlCharacters = _;
    }
  }
  function i$(s) {
    const e = s.lineContent;
    let t, i;
    s.stopRenderingLineAfter !== -1 && s.stopRenderingLineAfter < e.length ? (t = !0, i = s.stopRenderingLineAfter) : (t = !1, i = e.length);
    let n = n$(s.lineTokens, s.fauxIndentLength, i);
    s.renderControlCharacters && !s.isBasicASCII && (n = o$(e, n)), (s.renderWhitespace === 4 || s.renderWhitespace === 1 || s.renderWhitespace === 2 && !!s.selectionsOnLine || s.renderWhitespace === 3) && (n = r$(s, e, i, n));
    let o = 0;
    if (s.lineDecorations.length > 0) {
      for (let r = 0, a = s.lineDecorations.length; r < a; r++) {
        const l = s.lineDecorations[r];
        l.type === 3 || l.type === 1 ? o |= 1 : l.type === 2 && (o |= 2);
      }
      n = a$(e, i, n, s.lineDecorations);
    }
    return s.containsRTL || (n = s$(e, n, !s.isBasicASCII || s.fontLigatures)), new t$(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, e, i, t, n, o, s.fauxIndentLength, s.tabSize, s.startVisibleColumn, s.containsRTL, s.spaceWidth, s.renderSpaceCharCode, s.renderWhitespace, s.renderControlCharacters);
  }
  function n$(s, e, t) {
    const i = [];
    let n = 0;
    e > 0 && (i[n++] = new qi(e, "", 0));
    for (let o = 0, r = s.getCount(); o < r; o++) {
      const a = s.getEndOffset(o);
      if (a <= e)
        continue;
      const l = s.getClassName(o);
      if (a >= t) {
        i[n++] = new qi(t, l, 0);
        break;
      }
      i[n++] = new qi(a, l, 0);
    }
    return i;
  }
  function s$(s, e, t) {
    let i = 0;
    const n = [];
    let o = 0;
    if (t)
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r], c = l.endIndex;
        if (i + 50 < c) {
          const d = l.type, h = l.metadata;
          let u = -1, f = i;
          for (let g = i; g < c; g++)
            s.charCodeAt(g) === 32 && (u = g), u !== -1 && g - f >= 50 && (n[o++] = new qi(u + 1, d, h), f = u + 1, u = -1);
          f !== c && (n[o++] = new qi(c, d, h));
        } else
          n[o++] = l;
        i = c;
      }
    else
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r], c = l.endIndex, d = c - i;
        if (d > 50) {
          const h = l.type, u = l.metadata, f = Math.ceil(d / 50);
          for (let g = 1; g < f; g++) {
            const _ = i + g * 50;
            n[o++] = new qi(_, h, u);
          }
          n[o++] = new qi(c, h, u);
        } else
          n[o++] = l;
        i = c;
      }
    return n;
  }
  function R5(s) {
    return s < 32 ? s !== 9 : s === 127 || s >= 8234 && s <= 8238 || s >= 8294 && s <= 8297 || s >= 8206 && s <= 8207 || s === 1564;
  }
  function o$(s, e) {
    const t = [];
    let i = new qi(0, "", 0), n = 0;
    for (const o of e) {
      const r = o.endIndex;
      for (; n < r; n++) {
        const a = s.charCodeAt(n);
        R5(a) && (n > i.endIndex && (i = new qi(n, o.type, o.metadata), t.push(i)), i = new qi(n + 1, "mtkcontrol", o.metadata), t.push(i));
      }
      n > i.endIndex && (i = new qi(r, o.type, o.metadata), t.push(i));
    }
    return t;
  }
  function r$(s, e, t, i) {
    const n = s.continuesWithWrappedLine, o = s.fauxIndentLength, r = s.tabSize, a = s.startVisibleColumn, l = s.useMonospaceOptimizations, c = s.selectionsOnLine, d = s.renderWhitespace === 1, h = s.renderWhitespace === 3, u = s.renderSpaceWidth !== s.spaceWidth, f = [];
    let g = 0, _ = 0, b = i[_].type, C = i[_].endIndex;
    const v = i.length;
    let w = !1, S = jn(e), L;
    S === -1 ? (w = !0, S = t, L = t) : L = ia(e);
    let x = !1, y = 0, k = c && c[y], I = a % r;
    for (let R = o; R < t; R++) {
      const $ = e.charCodeAt(R);
      k && R >= k.endOffset && (y++, k = c && c[y]);
      let j;
      if (R < S || R > L)
        j = !0;
      else if ($ === 9)
        j = !0;
      else if ($ === 32)
        if (d)
          if (x)
            j = !0;
          else {
            const le = R + 1 < t ? e.charCodeAt(R + 1) : 0;
            j = le === 32 || le === 9;
          }
        else
          j = !0;
      else
        j = !1;
      if (j && c && (j = !!k && k.startOffset <= R && k.endOffset > R), j && h && (j = w || R > L), x) {
        if (!j || !l && I >= r) {
          if (u) {
            const le = g > 0 ? f[g - 1].endIndex : o;
            for (let he = le + 1; he <= R; he++)
              f[g++] = new qi(he, "mtkw", 1);
          } else
            f[g++] = new qi(R, "mtkw", 1);
          I = I % r;
        }
      } else
        (R === C || j && R > o) && (f[g++] = new qi(R, b, 0), I = I % r);
      for ($ === 9 ? I = r : _c($) ? I += 2 : I++, x = j; R === C && (_++, _ < v); )
        b = i[_].type, C = i[_].endIndex;
    }
    let F = !1;
    if (x)
      if (n && d) {
        const R = t > 0 ? e.charCodeAt(t - 1) : 0, $ = t > 1 ? e.charCodeAt(t - 2) : 0;
        R === 32 && $ !== 32 && $ !== 9 || (F = !0);
      } else
        F = !0;
    if (F)
      if (u) {
        const R = g > 0 ? f[g - 1].endIndex : o;
        for (let $ = R + 1; $ <= t; $++)
          f[g++] = new qi($, "mtkw", 1);
      } else
        f[g++] = new qi(t, "mtkw", 1);
    else
      f[g++] = new qi(t, b, 0);
    return f;
  }
  function a$(s, e, t, i) {
    i.sort(js.compare);
    const n = QU.normalize(s, i), o = n.length;
    let r = 0;
    const a = [];
    let l = 0, c = 0;
    for (let h = 0, u = t.length; h < u; h++) {
      const f = t[h], g = f.endIndex, _ = f.type, b = f.metadata;
      for (; r < o && n[r].startOffset < g; ) {
        const C = n[r];
        if (C.startOffset > c && (c = C.startOffset, a[l++] = new qi(c, _, b)), C.endOffset + 1 <= g)
          c = C.endOffset + 1, a[l++] = new qi(c, _ + " " + C.className, b | C.metadata), r++;
        else {
          c = g, a[l++] = new qi(c, _ + " " + C.className, b | C.metadata);
          break;
        }
      }
      g > c && (c = g, a[l++] = new qi(c, _, b));
    }
    const d = t[t.length - 1].endIndex;
    if (r < o && n[r].startOffset === d)
      for (; r < o && n[r].startOffset === d; ) {
        const h = n[r];
        a[l++] = new qi(c, h.className, h.metadata), r++;
      }
    return a;
  }
  function l$(s, e) {
    const t = s.fontIsMonospace, i = s.canUseHalfwidthRightwardsArrow, n = s.containsForeignElements, o = s.lineContent, r = s.len, a = s.isOverflowing, l = s.parts, c = s.fauxIndentLength, d = s.tabSize, h = s.startVisibleColumn, u = s.containsRTL, f = s.spaceWidth, g = s.renderSpaceCharCode, _ = s.renderWhitespace, b = s.renderControlCharacters, C = new Hr(r + 1, l.length);
    let v = !1, w = 0, S = h, L = 0, x = 0, y = 0, k = 0;
    u ? e.appendASCIIString('<span dir="ltr">') : e.appendASCIIString("<span>");
    for (let I = 0, F = l.length; I < F; I++) {
      k += y;
      const R = l[I], $ = R.endIndex, j = R.type, le = _ !== 0 && R.isWhitespace(), he = le && !t && (j === "mtkw" || !n), Ce = w === $ && R.isPseudoAfter();
      if (L = 0, e.appendASCIIString('<span class="'), e.appendASCIIString(he ? "mtkz" : j), e.appendASCII(34), le) {
        let Ne = 0;
        {
          let xe = w, Ve = S;
          for (; xe < $; xe++) {
            const bt = (o.charCodeAt(xe) === 9 ? d - Ve % d : 1) | 0;
            Ne += bt, xe >= c && (Ve += bt);
          }
        }
        for (he && (e.appendASCIIString(' style="width:'), e.appendASCIIString(String(f * Ne)), e.appendASCIIString('px"')), e.appendASCII(62); w < $; w++) {
          C.setColumnInfo(w + 1, I - x, L, k), x = 0;
          const xe = o.charCodeAt(w);
          let Ve;
          if (xe === 9) {
            Ve = d - S % d | 0, !i || Ve > 1 ? e.write1(8594) : e.write1(65515);
            for (let Ct = 2; Ct <= Ve; Ct++)
              e.write1(160);
          } else
            Ve = 1, e.write1(g);
          L += Ve, w >= c && (S += Ve);
        }
        y = Ne;
      } else {
        let Ne = 0;
        for (e.appendASCII(62); w < $; w++) {
          C.setColumnInfo(w + 1, I - x, L, k), x = 0;
          const xe = o.charCodeAt(w);
          let Ve = 1, Ct = 1;
          switch (xe) {
            case 9:
              Ve = d - S % d, Ct = Ve;
              for (let bt = 1; bt <= Ve; bt++)
                e.write1(160);
              break;
            case 32:
              e.write1(160);
              break;
            case 60:
              e.appendASCIIString("&lt;");
              break;
            case 62:
              e.appendASCIIString("&gt;");
              break;
            case 38:
              e.appendASCIIString("&amp;");
              break;
            case 0:
              b ? e.write1(9216) : e.appendASCIIString("&#00;");
              break;
            case 65279:
            case 8232:
            case 8233:
            case 133:
              e.write1(65533);
              break;
            default:
              _c(xe) && Ct++, b && xe < 32 ? e.write1(9216 + xe) : b && xe === 127 ? e.write1(9249) : b && R5(xe) ? (e.appendASCIIString("[U+"), e.appendASCIIString(c$(xe)), e.appendASCIIString("]"), Ve = 8) : e.write1(xe);
          }
          L += Ve, Ne += Ve, w >= c && (S += Ct);
        }
        y = Ne;
      }
      Ce ? x++ : x = 0, w >= r && !v && R.isPseudoAfter() && (v = !0, C.setColumnInfo(w + 1, I, L, k)), e.appendASCIIString("</span>");
    }
    return v || C.setColumnInfo(r + 1, l.length - 1, L, k), a && e.appendASCIIString("<span>&hellip;</span>"), e.appendASCIIString("</span>"), new vL(C, u, n);
  }
  function c$(s) {
    return s.toString(16).toUpperCase().padStart(4, "0");
  }
  const d$ = function() {
    return gr ? !0 : !(Nn || Xs || Zo);
  }();
  let Qu = !0;
  class pT {
    constructor(e, t) {
      this._domNode = e, this._clientRectDeltaLeft = 0, this._clientRectScale = 1, this._clientRectRead = !1, this.endNode = t;
    }
    readClientRect() {
      if (!this._clientRectRead) {
        this._clientRectRead = !0;
        const e = this._domNode.getBoundingClientRect();
        this._clientRectDeltaLeft = e.left, this._clientRectScale = e.width / this._domNode.offsetWidth;
      }
    }
    get clientRectDeltaLeft() {
      return this._clientRectRead || this.readClientRect(), this._clientRectDeltaLeft;
    }
    get clientRectScale() {
      return this._clientRectRead || this.readClientRect(), this._clientRectScale;
    }
  }
  class _T {
    constructor(e, t) {
      this.themeType = t;
      const i = e.options, n = i.get(44);
      this.renderWhitespace = i.get(88), this.renderControlCharacters = i.get(83), this.spaceWidth = n.spaceWidth, this.middotWidth = n.middotWidth, this.wsmiddotWidth = n.wsmiddotWidth, this.useMonospaceOptimizations = n.isMonospace && !i.get(29), this.canUseHalfwidthRightwardsArrow = n.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(59), this.stopRenderingLineAfter = i.get(105), this.fontLigatures = i.get(45);
    }
    equals(e) {
      return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
    }
  }
  class qr {
    constructor(e) {
      this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
    }
    getDomNode() {
      return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
    }
    setDomNode(e) {
      if (this._renderedViewLine)
        this._renderedViewLine.domNode = dt(e);
      else
        throw new Error("I have no rendered view line to set the dom node to...");
    }
    onContentChanged() {
      this._isMaybeInvalid = !0;
    }
    onTokensChanged() {
      this._isMaybeInvalid = !0;
    }
    onDecorationsChanged() {
      this._isMaybeInvalid = !0;
    }
    onOptionsChanged(e) {
      this._isMaybeInvalid = !0, this._options = e;
    }
    onSelectionChanged() {
      return this._options.themeType === jo.HIGH_CONTRAST || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
    }
    renderLine(e, t, i, n) {
      if (this._isMaybeInvalid === !1)
        return !1;
      this._isMaybeInvalid = !1;
      const o = i.getViewLineRenderingData(e), r = this._options, a = js.filter(o.inlineDecorations, e, o.minColumn, o.maxColumn);
      let l = null;
      if (r.themeType === jo.HIGH_CONTRAST || this._options.renderWhitespace === "selection") {
        const u = i.selections;
        for (const f of u) {
          if (f.endLineNumber < e || f.startLineNumber > e)
            continue;
          const g = f.startLineNumber === e ? f.startColumn : o.minColumn, _ = f.endLineNumber === e ? f.endColumn : o.maxColumn;
          g < _ && (r.themeType === jo.HIGH_CONTRAST || this._options.renderWhitespace !== "selection" ? a.push(new js(g, _, "inline-selected-text", 0)) : (l || (l = []), l.push(new JU(g - 1, _ - 1))));
        }
      }
      const c = new Rh(r.useMonospaceOptimizations, r.canUseHalfwidthRightwardsArrow, o.content, o.continuesWithWrappedLine, o.isBasicASCII, o.containsRTL, o.minColumn - 1, o.tokens, a, o.tabSize, o.startVisibleColumn, r.spaceWidth, r.middotWidth, r.wsmiddotWidth, r.stopRenderingLineAfter, r.renderWhitespace, r.renderControlCharacters, r.fontLigatures !== zs.OFF, l);
      if (this._renderedViewLine && this._renderedViewLine.input.equals(c))
        return !1;
      n.appendASCIIString('<div style="top:'), n.appendASCIIString(String(t)), n.appendASCIIString("px;height:"), n.appendASCIIString(String(this._options.lineHeight)), n.appendASCIIString('px;" class="'), n.appendASCIIString(qr.CLASS_NAME), n.appendASCIIString('">');
      const d = iC(c, n);
      n.appendASCIIString("</div>");
      let h = null;
      return Qu && d$ && o.isBasicASCII && r.useMonospaceOptimizations && d.containsForeignElements === 0 && o.content.length < 300 && c.lineTokens.getCount() < 100 && (h = new G_(this._renderedViewLine ? this._renderedViewLine.domNode : null, c, d.characterMapping)), h || (h = P5(this._renderedViewLine ? this._renderedViewLine.domNode : null, c, d.characterMapping, d.containsRTL, d.containsForeignElements)), this._renderedViewLine = h, !0;
    }
    layoutLine(e, t) {
      this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(this._options.lineHeight));
    }
    getWidth() {
      return this._renderedViewLine ? this._renderedViewLine.getWidth() : 0;
    }
    getWidthIsFast() {
      return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
    }
    needsMonospaceFontCheck() {
      return this._renderedViewLine ? this._renderedViewLine instanceof G_ : !1;
    }
    monospaceAssumptionsAreValid() {
      return this._renderedViewLine && this._renderedViewLine instanceof G_ ? this._renderedViewLine.monospaceAssumptionsAreValid() : Qu;
    }
    onMonospaceAssumptionsInvalidated() {
      this._renderedViewLine && this._renderedViewLine instanceof G_ && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
    }
    getVisibleRangesForRange(e, t, i, n) {
      if (!this._renderedViewLine)
        return null;
      t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t)), i = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, i));
      const o = this._renderedViewLine.input.stopRenderingLineAfter;
      let r = !1;
      o !== -1 && t > o + 1 && i > o + 1 && (r = !0), o !== -1 && t > o + 1 && (t = o + 1), o !== -1 && i > o + 1 && (i = o + 1);
      const a = this._renderedViewLine.getVisibleRangesForRange(e, t, i, n);
      return a && a.length > 0 ? new XU(r, a) : null;
    }
    getColumnOfNodeOffset(e, t, i) {
      return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t, i) : 1;
    }
  }
  qr.CLASS_NAME = "view-line";
  class G_ {
    constructor(e, t, i) {
      this.domNode = e, this.input = t, this._characterMapping = i, this._charWidth = t.spaceWidth;
    }
    getWidth() {
      return Math.round(this._getCharPosition(this._characterMapping.length));
    }
    getWidthIsFast() {
      return !0;
    }
    monospaceAssumptionsAreValid() {
      if (!this.domNode)
        return Qu;
      const e = this.getWidth(), t = this.domNode.domNode.firstChild.offsetWidth;
      return Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), Qu = !1), Qu;
    }
    toSlowRenderedLine() {
      return P5(this.domNode, this.input, this._characterMapping, !1, 0);
    }
    getVisibleRangesForRange(e, t, i, n) {
      const o = this._getCharPosition(t), r = this._getCharPosition(i);
      return [new Xu(o, r - o)];
    }
    _getCharPosition(e) {
      const t = this._characterMapping.getAbsoluteOffset(e);
      return this._charWidth * t;
    }
    getColumnOfNodeOffset(e, t, i) {
      const n = t.textContent.length;
      let o = -1;
      for (; t; )
        t = t.previousSibling, o++;
      return this._characterMapping.getColumn(new lE(o, i), n);
    }
  }
  class O5 {
    constructor(e, t, i, n, o) {
      if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !n || this._characterMapping.length === 0) {
        this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
        for (let r = 0, a = this._characterMapping.length; r <= a; r++)
          this._pixelOffsetCache[r] = -1;
      }
    }
    _getReadingTarget(e) {
      return e.domNode.firstChild;
    }
    getWidth() {
      return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth), this._cachedWidth) : 0;
    }
    getWidthIsFast() {
      return this._cachedWidth !== -1;
    }
    getVisibleRangesForRange(e, t, i, n) {
      if (!this.domNode)
        return null;
      if (this._pixelOffsetCache !== null) {
        const o = this._readPixelOffset(this.domNode, e, t, n);
        if (o === -1)
          return null;
        const r = this._readPixelOffset(this.domNode, e, i, n);
        return r === -1 ? null : [new Xu(o, r - o)];
      }
      return this._readVisibleRangesForRange(this.domNode, e, t, i, n);
    }
    _readVisibleRangesForRange(e, t, i, n, o) {
      if (i === n) {
        const r = this._readPixelOffset(e, t, i, o);
        return r === -1 ? null : [new Xu(r, 0)];
      } else
        return this._readRawVisibleRangesForRange(e, i, n, o);
    }
    _readPixelOffset(e, t, i, n) {
      if (this._characterMapping.length === 0) {
        if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
          return 0;
        if (this._containsForeignElements === 1)
          return this.getWidth();
        const o = this._getReadingTarget(e);
        return o.firstChild ? o.firstChild.offsetWidth : 0;
      }
      if (this._pixelOffsetCache !== null) {
        const o = this._pixelOffsetCache[i];
        if (o !== -1)
          return o;
        const r = this._actualReadPixelOffset(e, t, i, n);
        return this._pixelOffsetCache[i] = r, r;
      }
      return this._actualReadPixelOffset(e, t, i, n);
    }
    _actualReadPixelOffset(e, t, i, n) {
      if (this._characterMapping.length === 0) {
        const l = Kw.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, n.clientRectDeltaLeft, n.clientRectScale, n.endNode);
        return !l || l.length === 0 ? -1 : l[0].left;
      }
      if (i === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
        return this.getWidth();
      const o = this._characterMapping.getDomPosition(i), r = Kw.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, o.partIndex, o.charIndex, n.clientRectDeltaLeft, n.clientRectScale, n.endNode);
      if (!r || r.length === 0)
        return -1;
      const a = r[0].left;
      if (this.input.isBasicASCII) {
        const l = this._characterMapping.getAbsoluteOffset(i), c = Math.round(this.input.spaceWidth * l);
        if (Math.abs(c - a) <= 1)
          return c;
      }
      return a;
    }
    _readRawVisibleRangesForRange(e, t, i, n) {
      if (t === 1 && i === this._characterMapping.length)
        return [new Xu(0, this.getWidth())];
      const o = this._characterMapping.getDomPosition(t), r = this._characterMapping.getDomPosition(i);
      return Kw.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, r.partIndex, r.charIndex, n.clientRectDeltaLeft, n.clientRectScale, n.endNode);
    }
    getColumnOfNodeOffset(e, t, i) {
      const n = t.textContent.length;
      let o = -1;
      for (; t; )
        t = t.previousSibling, o++;
      return this._characterMapping.getColumn(new lE(o, i), n);
    }
  }
  class h$ extends O5 {
    _readVisibleRangesForRange(e, t, i, n, o) {
      const r = super._readVisibleRangesForRange(e, t, i, n, o);
      if (!r || r.length === 0 || i === n || i === 1 && n === this._characterMapping.length)
        return r;
      if (!this.input.containsRTL) {
        const a = this._readPixelOffset(e, t, n, o);
        if (a !== -1) {
          const l = r[r.length - 1];
          l.left < a && (l.width = a - l.left);
        }
      }
      return r;
    }
  }
  const P5 = function() {
    return Ql ? u$ : f$;
  }();
  function u$(s, e, t, i, n) {
    return new h$(s, e, t, i, n);
  }
  function f$(s, e, t, i, n) {
    return new O5(s, e, t, i, n);
  }
  class Ol {
    constructor(e = null) {
      this.hitTarget = e, this.type = 0;
    }
  }
  class CL {
    constructor(e, t, i) {
      this.position = e, this.spanNode = t, this.injectedText = i, this.type = 1;
    }
  }
  var ld;
  (function(s) {
    function e(t, i, n) {
      const o = t.getPositionFromDOMInfo(i, n);
      return o ? new CL(o, i, null) : new Ol(i);
    }
    s.createFromDOMInfo = e;
  })(ld || (ld = {}));
  class g$ {
    constructor(e, t) {
      this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
    }
  }
  class ns {
    static _deduceRage(e, t = null) {
      return !t && e ? new D(e.lineNumber, e.column, e.lineNumber, e.column) : t ?? null;
    }
    static createUnknown(e, t, i) {
      return { type: 0, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
    }
    static createTextarea(e, t) {
      return { type: 1, element: e, mouseColumn: t, position: null, range: null };
    }
    static createMargin(e, t, i, n, o, r) {
      return { type: e, element: t, mouseColumn: i, position: n, range: o, detail: r };
    }
    static createViewZone(e, t, i, n, o) {
      return { type: e, element: t, mouseColumn: i, position: n, range: this._deduceRage(n), detail: o };
    }
    static createContentText(e, t, i, n, o) {
      return { type: 6, element: e, mouseColumn: t, position: i, range: this._deduceRage(i, n), detail: o };
    }
    static createContentEmpty(e, t, i, n) {
      return { type: 7, element: e, mouseColumn: t, position: i, range: this._deduceRage(i), detail: n };
    }
    static createContentWidget(e, t, i) {
      return { type: 9, element: e, mouseColumn: t, position: null, range: null, detail: i };
    }
    static createScrollbar(e, t, i) {
      return { type: 11, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
    }
    static createOverlayWidget(e, t, i) {
      return { type: 12, element: e, mouseColumn: t, position: null, range: null, detail: i };
    }
    static createOutsideEditor(e, t) {
      return { type: 13, element: null, mouseColumn: e, position: t, range: this._deduceRage(t) };
    }
    static _typeToString(e) {
      return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
    }
    static toString(e) {
      return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + JSON.stringify(e.detail);
    }
  }
  class Oo {
    static isTextArea(e) {
      return e.length === 2 && e[0] === 3 && e[1] === 6;
    }
    static isChildOfViewLines(e) {
      return e.length >= 4 && e[0] === 3 && e[3] === 7;
    }
    static isStrictChildOfViewLines(e) {
      return e.length > 4 && e[0] === 3 && e[3] === 7;
    }
    static isChildOfScrollableElement(e) {
      return e.length >= 2 && e[0] === 3 && e[1] === 5;
    }
    static isChildOfMinimap(e) {
      return e.length >= 2 && e[0] === 3 && e[1] === 8;
    }
    static isChildOfContentWidgets(e) {
      return e.length >= 4 && e[0] === 3 && e[3] === 1;
    }
    static isChildOfOverflowingContentWidgets(e) {
      return e.length >= 1 && e[0] === 2;
    }
    static isChildOfOverlayWidgets(e) {
      return e.length >= 2 && e[0] === 3 && e[1] === 4;
    }
  }
  class Cf {
    constructor(e, t, i) {
      this.viewModel = e.viewModel;
      const n = e.configuration.options;
      this.layoutInfo = n.get(131), this.viewDomNode = t.viewDomNode, this.lineHeight = n.get(59), this.stickyTabStops = n.get(104), this.typicalHalfwidthCharacterWidth = n.get(44).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
    }
    getZoneAtCoord(e) {
      return Cf.getZoneAtCoord(this._context, e);
    }
    static getZoneAtCoord(e, t) {
      const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
      if (i) {
        const n = i.verticalOffset + i.height / 2, o = e.viewModel.getLineCount();
        let r = null, a, l = null;
        return i.afterLineNumber !== o && (l = new V(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (r = new V(i.afterLineNumber, e.viewModel.getLineMaxColumn(i.afterLineNumber))), l === null ? a = r : r === null ? a = l : t < n ? a = r : a = l, {
          viewZoneId: i.id,
          afterLineNumber: i.afterLineNumber,
          positionBefore: r,
          positionAfter: l,
          position: a
        };
      }
      return null;
    }
    getFullLineRangeAtCoord(e) {
      if (this._context.viewLayout.isAfterLines(e)) {
        const n = this._context.viewModel.getLineCount(), o = this._context.viewModel.getLineMaxColumn(n);
        return {
          range: new D(n, o, n, o),
          isAfterLines: !0
        };
      }
      const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.viewModel.getLineMaxColumn(t);
      return {
        range: new D(t, 1, t, i),
        isAfterLines: !1
      };
    }
    getLineNumberAtVerticalOffset(e) {
      return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
    }
    isAfterLines(e) {
      return this._context.viewLayout.isAfterLines(e);
    }
    isInTopPadding(e) {
      return this._context.viewLayout.isInTopPadding(e);
    }
    isInBottomPadding(e) {
      return this._context.viewLayout.isInBottomPadding(e);
    }
    getVerticalOffsetForLineNumber(e) {
      return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
    }
    findAttribute(e, t) {
      return Cf._findAttribute(e, t, this._viewHelper.viewDomNode);
    }
    static _findAttribute(e, t, i) {
      for (; e && e !== document.body; ) {
        if (e.hasAttribute && e.hasAttribute(t))
          return e.getAttribute(t);
        if (e === i)
          return null;
        e = e.parentNode;
      }
      return null;
    }
    getLineWidth(e) {
      return this._viewHelper.getLineWidth(e);
    }
    visibleRangeForPosition(e, t) {
      return this._viewHelper.visibleRangeForPosition(e, t);
    }
    getPositionFromDOMInfo(e, t) {
      return this._viewHelper.getPositionFromDOMInfo(e, t);
    }
    getCurrentScrollTop() {
      return this._context.viewLayout.getCurrentScrollTop();
    }
    getCurrentScrollLeft() {
      return this._context.viewLayout.getCurrentScrollLeft();
    }
  }
  class m$ {
    constructor(e, t, i, n) {
      this.editorPos = t, this.pos = i, this.relativePos = n, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + this.relativePos.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + this.relativePos.x - e.layoutInfo.contentLeft, this.isInMarginArea = this.relativePos.x < e.layoutInfo.contentLeft && this.relativePos.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, yn._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
    }
  }
  class cE extends m$ {
    constructor(e, t, i, n, o) {
      super(e, t, i, n), this._ctx = e, o ? (this.target = o, this.targetPath = ha.collect(o, e.viewDomNode)) : (this.target = null, this.targetPath = new Uint8Array(0));
    }
    toString() {
      return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
    }
    _getMouseColumn(e = null) {
      return e && e.column < this._ctx.viewModel.getLineMaxColumn(e.lineNumber) ? Oi.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(e.lineNumber), e.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
    }
    fulfillUnknown(e = null) {
      return ns.createUnknown(this.target, this._getMouseColumn(e), e);
    }
    fulfillTextarea() {
      return ns.createTextarea(this.target, this._getMouseColumn());
    }
    fulfillMargin(e, t, i, n) {
      return ns.createMargin(e, this.target, this._getMouseColumn(t), t, i, n);
    }
    fulfillViewZone(e, t, i) {
      return ns.createViewZone(e, this.target, this._getMouseColumn(t), t, i);
    }
    fulfillContentText(e, t, i) {
      return ns.createContentText(this.target, this._getMouseColumn(e), e, t, i);
    }
    fulfillContentEmpty(e, t) {
      return ns.createContentEmpty(this.target, this._getMouseColumn(e), e, t);
    }
    fulfillContentWidget(e) {
      return ns.createContentWidget(this.target, this._getMouseColumn(), e);
    }
    fulfillScrollbar(e) {
      return ns.createScrollbar(this.target, this._getMouseColumn(e), e);
    }
    fulfillOverlayWidget(e) {
      return ns.createOverlayWidget(this.target, this._getMouseColumn(), e);
    }
    withTarget(e) {
      return new cE(this._ctx, this.editorPos, this.pos, this.relativePos, e);
    }
  }
  const bT = { isAfterLines: !0 };
  function qw(s) {
    return {
      isAfterLines: !1,
      horizontalDistanceToText: s
    };
  }
  class yn {
    constructor(e, t) {
      this._context = e, this._viewHelper = t;
    }
    mouseTargetIsWidget(e) {
      const t = e.target, i = ha.collect(t, this._viewHelper.viewDomNode);
      return !!(Oo.isChildOfContentWidgets(i) || Oo.isChildOfOverflowingContentWidgets(i) || Oo.isChildOfOverlayWidgets(i));
    }
    createMouseTarget(e, t, i, n, o) {
      const r = new Cf(this._context, this._viewHelper, e), a = new cE(r, t, i, n, o);
      try {
        return yn._createMouseTarget(r, a, !1);
      } catch {
        return a.fulfillUnknown();
      }
    }
    static _createMouseTarget(e, t, i) {
      if (t.target === null) {
        if (i)
          return t.fulfillUnknown();
        const r = yn._doHitTest(e, t);
        return r.type === 1 ? yn.createMouseTargetFromHitTestPosition(e, t, r.spanNode, r.position, r.injectedText) : this._createMouseTarget(e, t.withTarget(r.hitTarget), !0);
      }
      const n = t;
      let o = null;
      return o = o || yn._hitTestContentWidget(e, n), o = o || yn._hitTestOverlayWidget(e, n), o = o || yn._hitTestMinimap(e, n), o = o || yn._hitTestScrollbarSlider(e, n), o = o || yn._hitTestViewZone(e, n), o = o || yn._hitTestMargin(e, n), o = o || yn._hitTestViewCursor(e, n), o = o || yn._hitTestTextArea(e, n), o = o || yn._hitTestViewLines(e, n, i), o = o || yn._hitTestScrollbar(e, n), o || t.fulfillUnknown();
    }
    static _hitTestContentWidget(e, t) {
      if (Oo.isChildOfContentWidgets(t.targetPath) || Oo.isChildOfOverflowingContentWidgets(t.targetPath)) {
        const i = e.findAttribute(t.target, "widgetId");
        return i ? t.fulfillContentWidget(i) : t.fulfillUnknown();
      }
      return null;
    }
    static _hitTestOverlayWidget(e, t) {
      if (Oo.isChildOfOverlayWidgets(t.targetPath)) {
        const i = e.findAttribute(t.target, "widgetId");
        return i ? t.fulfillOverlayWidget(i) : t.fulfillUnknown();
      }
      return null;
    }
    static _hitTestViewCursor(e, t) {
      if (t.target) {
        const i = e.lastRenderData.lastViewCursorsRenderData;
        for (const n of i)
          if (t.target === n.domNode)
            return t.fulfillContentText(n.position, null, { mightBeForeignElement: !1, injectedText: null });
      }
      if (t.isInContentArea) {
        const i = e.lastRenderData.lastViewCursorsRenderData, n = t.mouseContentHorizontalOffset, o = t.mouseVerticalOffset;
        for (const r of i) {
          if (n < r.contentLeft || n > r.contentLeft + r.width)
            continue;
          const a = e.getVerticalOffsetForLineNumber(r.position.lineNumber);
          if (a <= o && o <= a + r.height)
            return t.fulfillContentText(r.position, null, { mightBeForeignElement: !1, injectedText: null });
        }
      }
      return null;
    }
    static _hitTestViewZone(e, t) {
      const i = e.getZoneAtCoord(t.mouseVerticalOffset);
      if (i) {
        const n = t.isInContentArea ? 8 : 5;
        return t.fulfillViewZone(n, i.position, i);
      }
      return null;
    }
    static _hitTestTextArea(e, t) {
      return Oo.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfillContentText(e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1, injectedText: null }) : t.fulfillTextarea() : null;
    }
    static _hitTestMargin(e, t) {
      if (t.isInMarginArea) {
        const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), n = i.range.getStartPosition();
        let o = Math.abs(t.relativePos.x);
        const r = {
          isAfterLines: i.isAfterLines,
          glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
          glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
          lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
          offsetX: o
        };
        return o -= e.layoutInfo.glyphMarginLeft, o <= e.layoutInfo.glyphMarginWidth ? t.fulfillMargin(2, n, i.range, r) : (o -= e.layoutInfo.glyphMarginWidth, o <= e.layoutInfo.lineNumbersWidth ? t.fulfillMargin(3, n, i.range, r) : (o -= e.layoutInfo.lineNumbersWidth, t.fulfillMargin(4, n, i.range, r)));
      }
      return null;
    }
    static _hitTestViewLines(e, t, i) {
      if (!Oo.isChildOfViewLines(t.targetPath))
        return null;
      if (e.isInTopPadding(t.mouseVerticalOffset))
        return t.fulfillContentEmpty(new V(1, 1), bT);
      if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
        const o = e.viewModel.getLineCount(), r = e.viewModel.getLineMaxColumn(o);
        return t.fulfillContentEmpty(new V(o, r), bT);
      }
      if (i) {
        if (Oo.isStrictChildOfViewLines(t.targetPath)) {
          const o = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
          if (e.viewModel.getLineLength(o) === 0) {
            const a = e.getLineWidth(o), l = qw(t.mouseContentHorizontalOffset - a);
            return t.fulfillContentEmpty(new V(o, 1), l);
          }
          const r = e.getLineWidth(o);
          if (t.mouseContentHorizontalOffset >= r) {
            const a = qw(t.mouseContentHorizontalOffset - r), l = new V(o, e.viewModel.getLineMaxColumn(o));
            return t.fulfillContentEmpty(l, a);
          }
        }
        return t.fulfillUnknown();
      }
      const n = yn._doHitTest(e, t);
      return n.type === 1 ? yn.createMouseTargetFromHitTestPosition(e, t, n.spanNode, n.position, n.injectedText) : this._createMouseTarget(e, t.withTarget(n.hitTarget), !0);
    }
    static _hitTestMinimap(e, t) {
      if (Oo.isChildOfMinimap(t.targetPath)) {
        const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
        return t.fulfillScrollbar(new V(i, n));
      }
      return null;
    }
    static _hitTestScrollbarSlider(e, t) {
      if (Oo.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
        const i = t.target.className;
        if (i && /\b(slider|scrollbar)\b/.test(i)) {
          const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.viewModel.getLineMaxColumn(n);
          return t.fulfillScrollbar(new V(n, o));
        }
      }
      return null;
    }
    static _hitTestScrollbar(e, t) {
      if (Oo.isChildOfScrollableElement(t.targetPath)) {
        const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
        return t.fulfillScrollbar(new V(i, n));
      }
      return null;
    }
    getMouseColumn(e) {
      const t = this._context.configuration.options, i = t.get(131), n = this._context.viewLayout.getCurrentScrollLeft() + e.x - i.contentLeft;
      return yn._getMouseColumn(n, t.get(44).typicalHalfwidthCharacterWidth);
    }
    static _getMouseColumn(e, t) {
      return e < 0 ? 1 : Math.round(e / t) + 1;
    }
    static createMouseTargetFromHitTestPosition(e, t, i, n, o) {
      const r = n.lineNumber, a = n.column, l = e.getLineWidth(r);
      if (t.mouseContentHorizontalOffset > l) {
        const b = qw(t.mouseContentHorizontalOffset - l);
        return t.fulfillContentEmpty(n, b);
      }
      const c = e.visibleRangeForPosition(r, a);
      if (!c)
        return t.fulfillUnknown(n);
      const d = c.left;
      if (t.mouseContentHorizontalOffset === d)
        return t.fulfillContentText(n, null, { mightBeForeignElement: !!o, injectedText: o });
      const h = [];
      if (h.push({ offset: c.left, column: a }), a > 1) {
        const b = e.visibleRangeForPosition(r, a - 1);
        b && h.push({ offset: b.left, column: a - 1 });
      }
      const u = e.viewModel.getLineMaxColumn(r);
      if (a < u) {
        const b = e.visibleRangeForPosition(r, a + 1);
        b && h.push({ offset: b.left, column: a + 1 });
      }
      h.sort((b, C) => b.offset - C.offset);
      const f = t.pos.toClientCoordinates(), g = i.getBoundingClientRect(), _ = g.left <= f.clientX && f.clientX <= g.right;
      for (let b = 1; b < h.length; b++) {
        const C = h[b - 1], v = h[b];
        if (C.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= v.offset) {
          const w = new D(r, C.column, r, v.column);
          return t.fulfillContentText(n, w, { mightBeForeignElement: !_ || !!o, injectedText: o });
        }
      }
      return t.fulfillContentText(n, null, { mightBeForeignElement: !_ || !!o, injectedText: o });
    }
    static _doHitTestWithCaretRangeFromPoint(e, t) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.getVerticalOffsetForLineNumber(i) + Math.floor(e.lineHeight / 2);
      let r = t.pos.y + (o - t.mouseVerticalOffset);
      r <= t.editorPos.y && (r = t.editorPos.y + 1), r >= t.editorPos.y + t.editorPos.height && (r = t.editorPos.y + t.editorPos.height - 1);
      const a = new aE(t.pos.x, r), l = this._actualDoHitTestWithCaretRangeFromPoint(e, a.toClientCoordinates());
      return l.type === 1 ? l : this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates());
    }
    static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
      const i = mc(e.viewDomNode);
      let n;
      if (i ? typeof i.caretRangeFromPoint > "u" ? n = p$(i, t.clientX, t.clientY) : n = i.caretRangeFromPoint(t.clientX, t.clientY) : n = document.caretRangeFromPoint(t.clientX, t.clientY), !n || !n.startContainer)
        return new Ol();
      const o = n.startContainer;
      if (o.nodeType === o.TEXT_NODE) {
        const r = o.parentNode, a = r ? r.parentNode : null, l = a ? a.parentNode : null;
        return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === qr.CLASS_NAME ? ld.createFromDOMInfo(e, r, n.startOffset) : new Ol(o.parentNode);
      } else if (o.nodeType === o.ELEMENT_NODE) {
        const r = o.parentNode, a = r ? r.parentNode : null;
        return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === qr.CLASS_NAME ? ld.createFromDOMInfo(e, o, o.textContent.length) : new Ol(o);
      }
      return new Ol();
    }
    static _doHitTestWithCaretPositionFromPoint(e, t) {
      const i = document.caretPositionFromPoint(t.clientX, t.clientY);
      if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
        const n = i.offsetNode.parentNode, o = n ? n.parentNode : null, r = o ? o.parentNode : null;
        return (r && r.nodeType === r.ELEMENT_NODE ? r.className : null) === qr.CLASS_NAME ? ld.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new Ol(i.offsetNode.parentNode);
      }
      if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
        const n = i.offsetNode.parentNode, o = n && n.nodeType === n.ELEMENT_NODE ? n.className : null, r = n ? n.parentNode : null, a = r && r.nodeType === r.ELEMENT_NODE ? r.className : null;
        if (o === qr.CLASS_NAME) {
          const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
          if (l)
            return ld.createFromDOMInfo(e, l, 0);
        } else if (a === qr.CLASS_NAME)
          return ld.createFromDOMInfo(e, i.offsetNode, 0);
      }
      return new Ol(i.offsetNode);
    }
    static _snapToSoftTabBoundary(e, t) {
      const i = t.getLineContent(e.lineNumber), { tabSize: n } = t.model.getOptions(), o = Um.atomicPosition(i, e.column - 1, n, 2);
      return o !== -1 ? new V(e.lineNumber, o + 1) : e;
    }
    static _doHitTest(e, t) {
      let i = new Ol();
      if (typeof document.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : document.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates())), i.type === 1) {
        const n = e.viewModel.getInjectedTextAt(i.position), o = e.viewModel.normalizePosition(i.position, 2);
        (n || !o.equals(i.position)) && (i = new CL(o, i.spanNode, n));
      }
      return i.type === 1 && e.stickyTabStops && (i = new CL(this._snapToSoftTabBoundary(i.position, e.viewModel), i.spanNode, i.injectedText)), i;
    }
  }
  function p$(s, e, t) {
    const i = document.createRange();
    let n = s.elementFromPoint(e, t);
    if (n !== null) {
      for (; n && n.firstChild && n.firstChild.nodeType !== n.firstChild.TEXT_NODE && n.lastChild && n.lastChild.firstChild; )
        n = n.lastChild;
      const o = n.getBoundingClientRect(), r = window.getComputedStyle(n, null).getPropertyValue("font"), a = n.innerText;
      let l = o.left, c = 0, d;
      if (e > o.left + o.width)
        c = a.length;
      else {
        const h = Cd.getInstance();
        for (let u = 0; u < a.length + 1; u++) {
          if (d = h.getCharWidth(a.charAt(u), r) / 2, l += d, e < l) {
            c = u;
            break;
          }
          l += d;
        }
      }
      i.setStart(n.firstChild, c), i.setEnd(n.firstChild, c);
    }
    return i;
  }
  class Cd {
    constructor() {
      this._cache = {}, this._canvas = document.createElement("canvas");
    }
    static getInstance() {
      return Cd._INSTANCE || (Cd._INSTANCE = new Cd()), Cd._INSTANCE;
    }
    getCharWidth(e, t) {
      const i = e + t;
      if (this._cache[i])
        return this._cache[i];
      const n = this._canvas.getContext("2d");
      n.font = t;
      const r = n.measureText(e).width;
      return this._cache[i] = r, r;
    }
  }
  Cd._INSTANCE = null;
  function l1(s) {
    return function(e, t) {
      let i = !1;
      return s && (i = s.mouseTargetIsWidget(t)), i || t.preventDefault(), t;
    };
  }
  class Qd extends d_ {
    constructor(e, t, i) {
      super(), this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new yn(this._context, i), this._mouseDownOperation = this._register(new _$(this._context, this.viewController, this.viewHelper, (r, a) => this._createMouseTarget(r, a), (r) => this._getMouseColumn(r))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(131).height;
      const n = new zU(this.viewHelper.viewDomNode);
      this._register(n.onContextMenu(this.viewHelper.viewDomNode, (r) => this._onContextMenu(r, !0))), this._register(n.onMouseMoveThrottled(this.viewHelper.viewDomNode, (r) => this._onMouseMove(r), l1(this.mouseTargetFactory), Qd.MOUSE_MOVE_MINIMUM_TIME)), this._register(n.onMouseUp(this.viewHelper.viewDomNode, (r) => this._onMouseUp(r))), this._register(n.onMouseLeave(this.viewHelper.viewDomNode, (r) => this._onMouseLeave(r))), this._register(n.onMouseDown(this.viewHelper.viewDomNode, (r) => this._onMouseDown(r)));
      const o = (r) => {
        if (this.viewController.emitMouseWheel(r), !this._context.configuration.options.get(68))
          return;
        const a = new uf(r);
        if (Ye ? (r.metaKey || r.ctrlKey) && !r.shiftKey && !r.altKey : r.ctrlKey && !r.metaKey && !r.shiftKey && !r.altKey) {
          const c = fl.getZoomLevel(), d = a.deltaY > 0 ? 1 : -1;
          fl.setZoomLevel(c + d), a.preventDefault(), a.stopPropagation();
        }
      };
      this._register(ee(this.viewHelper.viewDomNode, ye.MOUSE_WHEEL, o, { capture: !0, passive: !1 })), this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), super.dispose();
    }
    onConfigurationChanged(e) {
      if (e.hasChanged(131)) {
        const t = this._context.configuration.options.get(131).height;
        this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
      }
      return !1;
    }
    onCursorStateChanged(e) {
      return this._mouseDownOperation.onCursorStateChanged(e), !1;
    }
    onFocusChanged(e) {
      return !1;
    }
    onScrollChanged(e) {
      return this._mouseDownOperation.onScrollChanged(), !1;
    }
    getTargetAtClientPoint(e, t) {
      const n = new T5(e, t).toPageCoordinates(), o = M5(this.viewHelper.viewDomNode);
      if (n.y < o.y || n.y > o.y + o.height || n.x < o.x || n.x > o.x + o.width)
        return null;
      const r = A5(this.viewHelper.viewDomNode, o, n);
      return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), o, n, r, null);
    }
    _createMouseTarget(e, t) {
      let i = e.target;
      if (!this.viewHelper.viewDomNode.contains(i)) {
        const n = mc(this.viewHelper.viewDomNode);
        n && (i = n.elementsFromPoint(e.posx, e.posy).find((o) => this.viewHelper.viewDomNode.contains(o)));
      }
      return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, t ? i : null);
    }
    _getMouseColumn(e) {
      return this.mouseTargetFactory.getMouseColumn(e.relativePos);
    }
    _onContextMenu(e, t) {
      this.viewController.emitContextMenu({
        event: e,
        target: this._createMouseTarget(e, t)
      });
    }
    _onMouseMove(e) {
      this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime || this.viewController.emitMouseMove({
        event: e,
        target: this._createMouseTarget(e, !0)
      });
    }
    _onMouseLeave(e) {
      this.lastMouseLeaveTime = new Date().getTime(), this.viewController.emitMouseLeave({
        event: e,
        target: null
      });
    }
    _onMouseUp(e) {
      this.viewController.emitMouseUp({
        event: e,
        target: this._createMouseTarget(e, !0)
      });
    }
    _onMouseDown(e) {
      const t = this._createMouseTarget(e, !0), i = t.type === 6 || t.type === 7, n = t.type === 2 || t.type === 3 || t.type === 4, o = t.type === 3, r = this._context.configuration.options.get(98), a = t.type === 8 || t.type === 5, l = t.type === 9;
      let c = e.leftButton || e.middleButton;
      Ye && e.leftButton && e.ctrlKey && (c = !1);
      const d = () => {
        e.preventDefault(), this.viewHelper.focusTextArea();
      };
      if (c && (i || o && r))
        d(), this._mouseDownOperation.start(t.type, e);
      else if (n)
        e.preventDefault();
      else if (a) {
        const h = t.detail;
        this.viewHelper.shouldSuppressMouseDownOnViewZone(h.viewZoneId) && (d(), this._mouseDownOperation.start(t.type, e), e.preventDefault());
      } else
        l && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail) && (d(), e.preventDefault());
      this.viewController.emitMouseDown({
        event: e,
        target: t
      });
    }
  }
  Qd.MOUSE_MOVE_MINIMUM_TIME = 100;
  class _$ extends z {
    constructor(e, t, i, n, o) {
      super(), this._context = e, this._viewController = t, this._viewHelper = i, this._createMouseTarget = n, this._getMouseColumn = o, this._mouseMoveMonitor = this._register(new $U(this._viewHelper.viewDomNode)), this._onScrollTimeout = this._register(new Ns()), this._mouseState = new sC(), this._currentSelection = new ae(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
    }
    dispose() {
      super.dispose();
    }
    isActive() {
      return this._isActive;
    }
    _onMouseDownThenMove(e) {
      this._lastMouseEvent = e, this._mouseState.setModifiers(e);
      const t = this._findMousePosition(e, !0);
      !t || (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
        event: e,
        target: t
      }) : this._dispatchMouse(t, !0));
    }
    start(e, t) {
      this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(e === 3), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
      const i = this._findMousePosition(t, !0);
      if (!i || !i.position)
        return;
      this._mouseState.trySetCount(t.detail, i.position), t.detail = this._mouseState.count;
      const n = this._context.configuration.options;
      if (!n.get(81) && n.get(31) && !n.get(18) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && i.type === 6 && i.position && this._currentSelection.containsPosition(i.position)) {
        this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(t.target, t.buttons, l1(null), (o) => this._onMouseDownThenMove(o), (o) => {
          const r = this._findMousePosition(this._lastMouseEvent, !0);
          o && o instanceof KeyboardEvent ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
            event: this._lastMouseEvent,
            target: r ? this._createMouseTarget(this._lastMouseEvent, !0) : null
          }), this._stop();
        });
        return;
      }
      this._mouseState.isDragAndDrop = !1, this._dispatchMouse(i, t.shiftKey), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(t.target, t.buttons, l1(null), (o) => this._onMouseDownThenMove(o), () => this._stop()));
    }
    _stop() {
      this._isActive = !1, this._onScrollTimeout.cancel();
    }
    onHeightChanged() {
      this._mouseMoveMonitor.stopMonitoring();
    }
    onScrollChanged() {
      !this._isActive || this._onScrollTimeout.setIfNotSet(() => {
        if (!this._lastMouseEvent)
          return;
        const e = this._findMousePosition(this._lastMouseEvent, !1);
        !e || this._mouseState.isDragAndDrop || this._dispatchMouse(e, !0);
      }, 10);
    }
    onCursorStateChanged(e) {
      this._currentSelection = e.selections[0];
    }
    _getPositionOutsideEditor(e) {
      const t = e.editorPos, i = this._context.viewModel, n = this._context.viewLayout, o = this._getMouseColumn(e);
      if (e.posy < t.y) {
        const a = Math.max(n.getCurrentScrollTop() - (t.y - e.posy), 0), l = Cf.getZoneAtCoord(this._context, a);
        if (l) {
          const d = this._helpPositionJumpOverViewZone(l);
          if (d)
            return ns.createOutsideEditor(o, d);
        }
        const c = n.getLineNumberAtVerticalOffset(a);
        return ns.createOutsideEditor(o, new V(c, 1));
      }
      if (e.posy > t.y + t.height) {
        const a = n.getCurrentScrollTop() + e.relativePos.y, l = Cf.getZoneAtCoord(this._context, a);
        if (l) {
          const d = this._helpPositionJumpOverViewZone(l);
          if (d)
            return ns.createOutsideEditor(o, d);
        }
        const c = n.getLineNumberAtVerticalOffset(a);
        return ns.createOutsideEditor(o, new V(c, i.getLineMaxColumn(c)));
      }
      const r = n.getLineNumberAtVerticalOffset(n.getCurrentScrollTop() + e.relativePos.y);
      return e.posx < t.x ? ns.createOutsideEditor(o, new V(r, 1)) : e.posx > t.x + t.width ? ns.createOutsideEditor(o, new V(r, i.getLineMaxColumn(r))) : null;
    }
    _findMousePosition(e, t) {
      const i = this._getPositionOutsideEditor(e);
      if (i)
        return i;
      const n = this._createMouseTarget(e, t);
      if (!n.position)
        return null;
      if (n.type === 8 || n.type === 5) {
        const r = this._helpPositionJumpOverViewZone(n.detail);
        if (r)
          return ns.createViewZone(n.type, n.element, n.mouseColumn, r, n.detail);
      }
      return n;
    }
    _helpPositionJumpOverViewZone(e) {
      const t = new V(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, n = e.positionAfter;
      return i && n ? i.isBefore(t) ? i : n : null;
    }
    _dispatchMouse(e, t) {
      !e.position || this._viewController.dispatchMouse({
        position: e.position,
        mouseColumn: e.mouseColumn,
        startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
        inSelectionMode: t,
        mouseDownCount: this._mouseState.count,
        altKey: this._mouseState.altKey,
        ctrlKey: this._mouseState.ctrlKey,
        metaKey: this._mouseState.metaKey,
        shiftKey: this._mouseState.shiftKey,
        leftButton: this._mouseState.leftButton,
        middleButton: this._mouseState.middleButton,
        onInjectedText: e.type === 6 && e.detail.injectedText !== null
      });
    }
  }
  class sC {
    constructor() {
      this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
    }
    get altKey() {
      return this._altKey;
    }
    get ctrlKey() {
      return this._ctrlKey;
    }
    get metaKey() {
      return this._metaKey;
    }
    get shiftKey() {
      return this._shiftKey;
    }
    get leftButton() {
      return this._leftButton;
    }
    get middleButton() {
      return this._middleButton;
    }
    get startedOnLineNumbers() {
      return this._startedOnLineNumbers;
    }
    get count() {
      return this._lastMouseDownCount;
    }
    setModifiers(e) {
      this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
    }
    setStartButtons(e) {
      this._leftButton = e.leftButton, this._middleButton = e.middleButton;
    }
    setStartedOnLineNumbers(e) {
      this._startedOnLineNumbers = e;
    }
    trySetCount(e, t) {
      const i = new Date().getTime();
      i - this._lastSetMouseDownCountTime > sC.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
    }
  }
  sC.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
  var cr;
  (function(s) {
    s.text = "text/plain", s.binary = "application/octet-stream", s.unknown = "application/unknown", s.markdown = "text/markdown", s.latex = "text/latex", s.uriList = "text/uri-list";
  })(cr || (cr = {}));
  class kn {
    constructor(e, t, i, n, o) {
      this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selectionStartPosition = n, this.selectionEndPosition = o;
    }
    toString() {
      return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
    }
    static readFromTextArea(e) {
      return new kn(e.getValue(), e.getSelectionStart(), e.getSelectionEnd(), null, null);
    }
    collapseSelection() {
      return new kn(this.value, this.value.length, this.value.length, null, null);
    }
    writeToTextArea(e, t, i) {
      t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
    }
    deduceEditorPosition(e) {
      if (e <= this.selectionStart) {
        const n = this.value.substring(e, this.selectionStart);
        return this._finishDeduceEditorPosition(this.selectionStartPosition, n, -1);
      }
      if (e >= this.selectionEnd) {
        const n = this.value.substring(this.selectionEnd, e);
        return this._finishDeduceEditorPosition(this.selectionEndPosition, n, 1);
      }
      const t = this.value.substring(this.selectionStart, e);
      if (t.indexOf(String.fromCharCode(8230)) === -1)
        return this._finishDeduceEditorPosition(this.selectionStartPosition, t, 1);
      const i = this.value.substring(e, this.selectionEnd);
      return this._finishDeduceEditorPosition(this.selectionEndPosition, i, -1);
    }
    _finishDeduceEditorPosition(e, t, i) {
      let n = 0, o = -1;
      for (; (o = t.indexOf(`
`, o + 1)) !== -1; )
        n++;
      return [e, i * t.length, n];
    }
    static deduceInput(e, t, i) {
      if (!e)
        return {
          text: "",
          replacePrevCharCnt: 0,
          replaceNextCharCnt: 0,
          positionDelta: 0
        };
      const n = Math.min(pf(e.value, t.value), e.selectionStart, t.selectionStart), o = Math.min(K0(e.value, t.value), e.value.length - e.selectionEnd, t.value.length - t.selectionEnd);
      e.value.substring(n, e.value.length - o);
      const r = t.value.substring(n, t.value.length - o), a = e.selectionStart - n, l = e.selectionEnd - n, c = t.selectionStart - n, d = t.selectionEnd - n;
      if (c === d) {
        const u = e.selectionStart - n;
        return {
          text: r,
          replacePrevCharCnt: u,
          replaceNextCharCnt: 0,
          positionDelta: 0
        };
      }
      const h = l - a;
      return {
        text: r,
        replacePrevCharCnt: h,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    static deduceAndroidCompositionInput(e, t) {
      if (!e)
        return {
          text: "",
          replacePrevCharCnt: 0,
          replaceNextCharCnt: 0,
          positionDelta: 0
        };
      if (e.value === t.value)
        return {
          text: "",
          replacePrevCharCnt: 0,
          replaceNextCharCnt: 0,
          positionDelta: t.selectionEnd - e.selectionEnd
        };
      const i = Math.min(pf(e.value, t.value), e.selectionEnd), n = Math.min(K0(e.value, t.value), e.value.length - e.selectionEnd), o = e.value.substring(i, e.value.length - n), r = t.value.substring(i, t.value.length - n);
      e.selectionStart - i;
      const a = e.selectionEnd - i;
      t.selectionStart - i;
      const l = t.selectionEnd - i;
      return {
        text: r,
        replacePrevCharCnt: a,
        replaceNextCharCnt: o.length - a,
        positionDelta: l - r.length
      };
    }
  }
  kn.EMPTY = new kn("", 0, 0, null, null);
  class Iu {
    static _getPageOfLine(e, t) {
      return Math.floor((e - 1) / t);
    }
    static _getRangeForPage(e, t) {
      const i = e * t, n = i + 1, o = i + t;
      return new D(n, 1, o + 1, 1);
    }
    static fromEditorSelection(e, t, i, n, o) {
      const r = Iu._getPageOfLine(i.startLineNumber, n), a = Iu._getRangeForPage(r, n), l = Iu._getPageOfLine(i.endLineNumber, n), c = Iu._getRangeForPage(l, n), d = a.intersectRanges(new D(1, 1, i.startLineNumber, i.startColumn));
      let h = t.getValueInRange(d, 1);
      const u = t.getLineCount(), f = t.getLineMaxColumn(u), g = c.intersectRanges(new D(i.endLineNumber, i.endColumn, u, f));
      let _ = t.getValueInRange(g, 1), b;
      if (r === l || r + 1 === l)
        b = t.getValueInRange(i, 1);
      else {
        const C = a.intersectRanges(i), v = c.intersectRanges(i);
        b = t.getValueInRange(C, 1) + String.fromCharCode(8230) + t.getValueInRange(v, 1);
      }
      return o && (h.length > 500 && (h = h.substring(h.length - 500, h.length)), _.length > 500 && (_ = _.substring(0, 500)), b.length > 2 * 500 && (b = b.substring(0, 500) + String.fromCharCode(8230) + b.substring(b.length - 500, b.length))), new kn(h + b + _, h.length, h.length + b.length, new V(i.startLineNumber, i.startColumn), new V(i.endLineNumber, i.endColumn));
    }
  }
  var c1;
  (function(s) {
    s.Tap = "-monaco-textarea-synthetic-tap";
  })(c1 || (c1 = {}));
  const wL = {
    forceCopyWithSyntaxHighlighting: !1
  };
  class Gm {
    constructor() {
      this._lastState = null;
    }
    set(e, t) {
      this._lastState = { lastCopiedValue: e, data: t };
    }
    get(e) {
      return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
    }
  }
  Gm.INSTANCE = new Gm();
  class b$ {
    constructor() {
      this._lastTypeTextLength = 0;
    }
    handleCompositionUpdate(e) {
      e = e || "";
      const t = {
        text: e,
        replacePrevCharCnt: this._lastTypeTextLength,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
      return this._lastTypeTextLength = e.length, t;
    }
  }
  class v$ extends z {
    constructor(e, t, i, n) {
      super(), this._host = e, this._textArea = t, this._OS = i, this._browser = n, this._onFocus = this._register(new B()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new B()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new B()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new B()), this.onCut = this._onCut.event, this._onPaste = this._register(new B()), this.onPaste = this._onPaste.event, this._onType = this._register(new B()), this.onType = this._onType.event, this._onCompositionStart = this._register(new B()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new B()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new B()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new B()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._asyncTriggerCut = this._register(new It(() => this._onCut.fire(), 0)), this._asyncFocusGainWriteScreenReaderContent = this._register(new It(() => this.writeScreenReaderContent("asyncFocusGain"), 0)), this._textAreaState = kn.EMPTY, this._selectionChangeListener = null, this.writeScreenReaderContent("ctor"), this._hasFocus = !1, this._currentComposition = null;
      let o = null;
      this._register(this._textArea.onKeyDown((r) => {
        const a = new $t(r);
        (a.keyCode === 109 || this._currentComposition && a.keyCode === 1) && a.stopPropagation(), a.equals(9) && a.preventDefault(), o = a, this._onKeyDown.fire(a);
      })), this._register(this._textArea.onKeyUp((r) => {
        const a = new $t(r);
        this._onKeyUp.fire(a);
      })), this._register(this._textArea.onCompositionStart((r) => {
        const a = new b$();
        if (this._currentComposition) {
          this._currentComposition = a;
          return;
        }
        if (this._currentComposition = a, this._OS === 2 && o && o.equals(109) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === r.data && (o.code === "ArrowRight" || o.code === "ArrowLeft")) {
          a.handleCompositionUpdate("x"), this._onCompositionStart.fire({ data: r.data });
          return;
        }
        if (this._browser.isAndroid) {
          this._onCompositionStart.fire({ data: r.data });
          return;
        }
        this._onCompositionStart.fire({ data: r.data });
      })), this._register(this._textArea.onCompositionUpdate((r) => {
        const a = this._currentComposition;
        if (!a)
          return;
        if (this._browser.isAndroid) {
          const c = kn.readFromTextArea(this._textArea), d = kn.deduceAndroidCompositionInput(this._textAreaState, c);
          this._textAreaState = c, this._onType.fire(d), this._onCompositionUpdate.fire(r);
          return;
        }
        const l = a.handleCompositionUpdate(r.data);
        this._textAreaState = kn.readFromTextArea(this._textArea), this._onType.fire(l), this._onCompositionUpdate.fire(r);
      })), this._register(this._textArea.onCompositionEnd((r) => {
        const a = this._currentComposition;
        if (!a)
          return;
        if (this._currentComposition = null, this._browser.isAndroid) {
          const c = kn.readFromTextArea(this._textArea), d = kn.deduceAndroidCompositionInput(this._textAreaState, c);
          this._textAreaState = c, this._onType.fire(d), this._onCompositionEnd.fire();
          return;
        }
        const l = a.handleCompositionUpdate(r.data);
        this._textAreaState = kn.readFromTextArea(this._textArea), this._onType.fire(l), this._onCompositionEnd.fire();
      })), this._register(this._textArea.onInput((r) => {
        if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._currentComposition)
          return;
        const a = kn.readFromTextArea(this._textArea), l = kn.deduceInput(this._textAreaState, a, this._OS === 2);
        l.replacePrevCharCnt === 0 && l.text.length === 1 && Pi(l.text.charCodeAt(0)) || (this._textAreaState = a, (l.text !== "" || l.replacePrevCharCnt !== 0 || l.replaceNextCharCnt !== 0 || l.positionDelta !== 0) && this._onType.fire(l));
      })), this._register(this._textArea.onCut((r) => {
        this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(r), this._asyncTriggerCut.schedule();
      })), this._register(this._textArea.onCopy((r) => {
        this._ensureClipboardGetsEditorSelection(r);
      })), this._register(this._textArea.onPaste((r) => {
        if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), r.preventDefault(), !r.clipboardData)
          return;
        let [a, l] = vT.getTextData(r.clipboardData);
        !a || (l = l || Gm.INSTANCE.get(a), this._onPaste.fire({
          text: a,
          metadata: l
        }));
      })), this._register(this._textArea.onFocus(() => {
        const r = this._hasFocus;
        this._setHasFocus(!0), this._browser.isSafari && !r && this._hasFocus && this._asyncFocusGainWriteScreenReaderContent.schedule();
      })), this._register(this._textArea.onBlur(() => {
        this._currentComposition && (this._currentComposition = null, this.writeScreenReaderContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
      })), this._register(this._textArea.onSyntheticTap(() => {
        this._browser.isAndroid && this._currentComposition && (this._currentComposition = null, this.writeScreenReaderContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
      }));
    }
    _installSelectionChangeListener() {
      let e = 0;
      return ee(document, "selectionchange", (t) => {
        if (!this._hasFocus || this._currentComposition || !this._browser.isChrome)
          return;
        const i = Date.now(), n = i - e;
        if (e = i, n < 5)
          return;
        const o = i - this._textArea.getIgnoreSelectionChangeTime();
        if (this._textArea.resetSelectionChangeTime(), o < 100 || !this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition)
          return;
        const r = this._textArea.getValue();
        if (this._textAreaState.value !== r)
          return;
        const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
        if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
          return;
        const c = this._textAreaState.deduceEditorPosition(a), d = this._host.deduceModelPosition(c[0], c[1], c[2]), h = this._textAreaState.deduceEditorPosition(l), u = this._host.deduceModelPosition(h[0], h[1], h[2]), f = new ae(d.lineNumber, d.column, u.lineNumber, u.column);
        this._onSelectionChangeRequest.fire(f);
      });
    }
    dispose() {
      super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
    }
    focusTextArea() {
      this._setHasFocus(!0), this.refreshFocusState();
    }
    isFocused() {
      return this._hasFocus;
    }
    refreshFocusState() {
      this._setHasFocus(this._textArea.hasFocus());
    }
    _setHasFocus(e) {
      this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeScreenReaderContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
    }
    _setAndWriteTextAreaState(e, t) {
      this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
    }
    writeScreenReaderContent(e) {
      this._currentComposition || this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent(this._textAreaState));
    }
    _ensureClipboardGetsEditorSelection(e) {
      const t = this._host.getDataToCopy(), i = {
        version: 1,
        isFromEmptySelection: t.isFromEmptySelection,
        multicursorText: t.multicursorText,
        mode: t.mode
      };
      Gm.INSTANCE.set(this._browser.isFirefox ? t.text.replace(/\r\n/g, `
`) : t.text, i), e.preventDefault(), e.clipboardData && vT.setTextData(e.clipboardData, t.text, t.html, i);
    }
  }
  class vT {
    static getTextData(e) {
      const t = e.getData(cr.text);
      let i = null;
      const n = e.getData("vscode-editor-data");
      if (typeof n == "string")
        try {
          i = JSON.parse(n), i.version !== 1 && (i = null);
        } catch {
        }
      return [t, i];
    }
    static setTextData(e, t, i, n) {
      e.setData(cr.text, t), typeof i == "string" && e.setData("text/html", i), e.setData("vscode-editor-data", JSON.stringify(n));
    }
  }
  class C$ extends z {
    constructor(e) {
      super(), this._actual = e, this.onKeyDown = this._register(tr(this._actual, "keydown")).event, this.onKeyUp = this._register(tr(this._actual, "keyup")).event, this.onCompositionStart = this._register(tr(this._actual, "compositionstart")).event, this.onCompositionUpdate = this._register(tr(this._actual, "compositionupdate")).event, this.onCompositionEnd = this._register(tr(this._actual, "compositionend")).event, this.onInput = this._register(tr(this._actual, "input")).event, this.onCut = this._register(tr(this._actual, "cut")).event, this.onCopy = this._register(tr(this._actual, "copy")).event, this.onPaste = this._register(tr(this._actual, "paste")).event, this.onFocus = this._register(tr(this._actual, "focus")).event, this.onBlur = this._register(tr(this._actual, "blur")).event, this._onSyntheticTap = this._register(new B()), this.onSyntheticTap = this._onSyntheticTap.event, this._ignoreSelectionChangeTime = 0, this._register(ee(this._actual, c1.Tap, () => this._onSyntheticTap.fire()));
    }
    hasFocus() {
      const e = mc(this._actual);
      return e ? e.activeElement === this._actual : yI(this._actual) ? document.activeElement === this._actual : !1;
    }
    setIgnoreSelectionChangeTime(e) {
      this._ignoreSelectionChangeTime = Date.now();
    }
    getIgnoreSelectionChangeTime() {
      return this._ignoreSelectionChangeTime;
    }
    resetSelectionChangeTime() {
      this._ignoreSelectionChangeTime = 0;
    }
    getValue() {
      return this._actual.value;
    }
    setValue(e, t) {
      const i = this._actual;
      i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
    }
    getSelectionStart() {
      return this._actual.selectionDirection === "backward" ? this._actual.selectionEnd : this._actual.selectionStart;
    }
    getSelectionEnd() {
      return this._actual.selectionDirection === "backward" ? this._actual.selectionStart : this._actual.selectionEnd;
    }
    setSelectionRange(e, t, i) {
      const n = this._actual;
      let o = null;
      const r = mc(n);
      r ? o = r.activeElement : o = document.activeElement;
      const a = o === n, l = n.selectionStart, c = n.selectionEnd;
      if (a && l === t && c === i) {
        Xs && window.parent !== window && n.focus();
        return;
      }
      if (a) {
        this.setIgnoreSelectionChangeTime("setSelectionRange"), n.setSelectionRange(t, i), Xs && window.parent !== window && n.focus();
        return;
      }
      try {
        const d = MW(n);
        this.setIgnoreSelectionChangeTime("setSelectionRange"), n.focus(), n.setSelectionRange(t, i), AW(n, d);
      } catch {
      }
    }
  }
  class w$ extends Qd {
    constructor(e, t, i) {
      super(e, t, i), this._register(kt.addTarget(this.viewHelper.linesContentDomNode)), this._register(ee(this.viewHelper.linesContentDomNode, Bt.Tap, (o) => this.onTap(o))), this._register(ee(this.viewHelper.linesContentDomNode, Bt.Change, (o) => this.onChange(o))), this._register(ee(this.viewHelper.linesContentDomNode, Bt.Contextmenu, (o) => this._onContextMenu(new Xd(o, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register(ee(this.viewHelper.linesContentDomNode, "pointerdown", (o) => {
        const r = o.pointerType;
        if (r === "mouse") {
          this._lastPointerType = "mouse";
          return;
        } else
          r === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
      }));
      const n = new UU(this.viewHelper.viewDomNode);
      this._register(n.onPointerMoveThrottled(this.viewHelper.viewDomNode, (o) => this._onMouseMove(o), l1(this.mouseTargetFactory), Qd.MOUSE_MOVE_MINIMUM_TIME)), this._register(n.onPointerUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(n.onPointerLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o))), this._register(n.onPointerDown(this.viewHelper.viewDomNode, (o) => this._onMouseDown(o)));
    }
    onTap(e) {
      if (!e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget))
        return;
      e.preventDefault(), this.viewHelper.focusTextArea();
      const t = this._createMouseTarget(new Xd(e, this.viewHelper.viewDomNode), !1);
      t.position && this.viewController.dispatchMouse({
        position: t.position,
        mouseColumn: t.position.column,
        startedOnLineNumbers: !1,
        mouseDownCount: e.tapCount,
        inSelectionMode: !1,
        altKey: !1,
        ctrlKey: !1,
        metaKey: !1,
        shiftKey: !1,
        leftButton: !1,
        middleButton: !1,
        onInjectedText: t.type === 6 && t.detail.injectedText !== null
      });
    }
    onChange(e) {
      this._lastPointerType === "touch" && this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
    }
    _onMouseDown(e) {
      e.browserEvent.pointerType !== "touch" && super._onMouseDown(e);
    }
  }
  class S$ extends Qd {
    constructor(e, t, i) {
      super(e, t, i), this._register(kt.addTarget(this.viewHelper.linesContentDomNode)), this._register(ee(this.viewHelper.linesContentDomNode, Bt.Tap, (n) => this.onTap(n))), this._register(ee(this.viewHelper.linesContentDomNode, Bt.Change, (n) => this.onChange(n))), this._register(ee(this.viewHelper.linesContentDomNode, Bt.Contextmenu, (n) => this._onContextMenu(new Xd(n, this.viewHelper.viewDomNode), !1)));
    }
    onTap(e) {
      e.preventDefault(), this.viewHelper.focusTextArea();
      const t = this._createMouseTarget(new Xd(e, this.viewHelper.viewDomNode), !1);
      if (t.position) {
        const i = document.createEvent("CustomEvent");
        i.initEvent(c1.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(t.position);
      }
    }
    onChange(e) {
      this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
    }
  }
  class y$ extends z {
    constructor(e, t, i) {
      super(), aa && Ev.pointerEvents ? this.handler = this._register(new w$(e, t, i)) : window.TouchEvent ? this.handler = this._register(new S$(e, t, i)) : this.handler = this._register(new Qd(e, t, i));
    }
    getTargetAtClientPoint(e, t) {
      return this.handler.getTargetAtClientPoint(e, t);
    }
  }
  class rg extends d_ {
  }
  const L$ = M("editor.lineHighlightBackground", { dark: null, light: null, hc: null }, m("lineHighlight", "Background color for the highlight of line at the cursor position.")), CT = M("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hc: "#f38518" }, m("lineHighlightBorderBox", "Background color for the border around the line at the cursor position.")), k$ = M("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hc: null }, m("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0), D$ = M("editor.rangeHighlightBorder", { dark: null, light: null, hc: Bn }, m("rangeHighlightBorder", "Background color of the border around highlighted ranges."), !0), x$ = M("editor.symbolHighlightBackground", { dark: oc, light: oc, hc: null }, m("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0), I$ = M("editor.symbolHighlightBorder", { dark: null, light: null, hc: Bn }, m("symbolHighlightBorder", "Background color of the border around highlighted symbols."), !0), F5 = M("editorCursor.foreground", { dark: "#AEAFAD", light: H.black, hc: H.white }, m("caret", "Color of the editor cursor.")), E$ = M("editorCursor.background", null, m("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), Md = M("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hc: "#e3e4e229" }, m("editorWhitespaces", "Color of whitespace characters in the editor.")), oC = M("editorIndentGuide.background", { dark: Md, light: Md, hc: Md }, m("editorIndentGuides", "Color of the editor indentation guides.")), rC = M("editorIndentGuide.activeBackground", { dark: Md, light: Md, hc: Md }, m("editorActiveIndentGuide", "Color of the active editor indentation guides.")), B5 = M("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hc: H.white }, m("editorLineNumbers", "Color of editor line numbers.")), Gw = M("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hc: Bn }, m("editorActiveLineNumber", "Color of editor active line number"), !1, m("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead.")), N$ = M("editorLineNumber.activeForeground", { dark: Gw, light: Gw, hc: Gw }, m("editorActiveLineNumber", "Color of editor active line number")), T$ = M("editorRuler.foreground", { dark: "#5A5A5A", light: H.lightgrey, hc: H.white }, m("editorRuler", "Color of the editor rulers."));
  M("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hc: "#999999" }, m("editorCodeLensForeground", "Foreground color of editor CodeLens"));
  const M$ = M("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hc: "#0064001a" }, m("editorBracketMatchBackground", "Background color behind matching brackets")), W5 = M("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hc: qt }, m("editorBracketMatchBorder", "Color for matching brackets boxes")), A$ = M("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hc: "#7f7f7f4d" }, m("editorOverviewRulerBorder", "Color of the overview ruler border.")), R$ = M("editorOverviewRuler.background", null, m("editorOverviewRulerBackground", "Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor.")), O$ = M("editorGutter.background", { dark: cs, light: cs, hc: cs }, m("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.")), P$ = M("editorUnnecessaryCode.border", { dark: null, light: null, hc: H.fromHex("#fff").transparent(0.8) }, m("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor.")), F$ = M("editorUnnecessaryCode.opacity", { dark: H.fromHex("#000a"), light: H.fromHex("#0007"), hc: null }, m("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`)), B$ = M("editorGhostText.border", { dark: null, light: null, hc: H.fromHex("#fff").transparent(0.8) }, m("editorGhostTextBorder", "Border color of ghost text in the editor.")), W$ = M("editorGhostText.foreground", { dark: H.fromHex("#ffffff56"), light: H.fromHex("#0007"), hc: null }, m("editorGhostTextForeground", "Foreground color of the ghost text in the editor.")), V$ = M("editorGhostText.background", { dark: null, light: null, hc: null }, m("editorGhostTextBackground", "Background color of the ghost text in the editor.")), Zw = new H(new tt(0, 122, 204, 0.6)), H$ = M("editorOverviewRuler.rangeHighlightForeground", { dark: Zw, light: Zw, hc: Zw }, m("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0), z$ = M("editorOverviewRuler.errorForeground", { dark: new H(new tt(255, 18, 18, 0.7)), light: new H(new tt(255, 18, 18, 0.7)), hc: new H(new tt(255, 50, 50, 1)) }, m("overviewRuleError", "Overview ruler marker color for errors.")), U$ = M("editorOverviewRuler.warningForeground", { dark: Ko, light: Ko, hc: Jv }, m("overviewRuleWarning", "Overview ruler marker color for warnings.")), $$ = M("editorOverviewRuler.infoForeground", { dark: Zs, light: Zs, hc: JI }, m("overviewRuleInfo", "Overview ruler marker color for infos.")), V5 = M("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hc: "#FFD700" }, m("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization.")), H5 = M("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hc: "#DA70D6" }, m("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization.")), z5 = M("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hc: "#87CEFA" }, m("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization.")), U5 = M("editorBracketHighlight.foreground4", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization.")), $5 = M("editorBracketHighlight.foreground5", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization.")), j5 = M("editorBracketHighlight.foreground6", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization.")), j$ = M("editorBracketHighlight.unexpectedBracket.foreground", { dark: new H(new tt(255, 18, 18, 0.8)), light: new H(new tt(255, 18, 18, 0.8)), hc: new H(new tt(255, 50, 50, 1)) }, m("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets.")), K$ = M("editorBracketPairGuide.background1", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.")), q$ = M("editorBracketPairGuide.background2", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.")), G$ = M("editorBracketPairGuide.background3", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.")), Z$ = M("editorBracketPairGuide.background4", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.")), Y$ = M("editorBracketPairGuide.background5", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.")), X$ = M("editorBracketPairGuide.background6", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.")), Q$ = M("editorBracketPairGuide.activeBackground1", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides.")), J$ = M("editorBracketPairGuide.activeBackground2", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides.")), ej = M("editorBracketPairGuide.activeBackground3", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides.")), tj = M("editorBracketPairGuide.activeBackground4", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides.")), ij = M("editorBracketPairGuide.activeBackground5", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides.")), nj = M("editorBracketPairGuide.activeBackground6", { dark: "#00000000", light: "#00000000", hc: "#00000000" }, m("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
  M("editorUnicodeHighlight.border", { dark: "#BD9B03", light: "#CEA33D", hc: "#ff0000" }, m("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
  Vt((s, e) => {
    const t = s.getColor(cs);
    t && e.addRule(`.monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: ${t}; }`);
    const i = s.getColor(nc);
    i && e.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${i}; }`);
    const n = s.getColor(O$);
    n && e.addRule(`.monaco-editor .margin { background-color: ${n}; }`);
    const o = s.getColor(k$);
    o && e.addRule(`.monaco-editor .rangeHighlight { background-color: ${o}; }`);
    const r = s.getColor(D$);
    r && e.addRule(`.monaco-editor .rangeHighlight { border: 1px ${s.type === "hc" ? "dotted" : "solid"} ${r}; }`);
    const a = s.getColor(x$);
    a && e.addRule(`.monaco-editor .symbolHighlight { background-color: ${a}; }`);
    const l = s.getColor(I$);
    l && e.addRule(`.monaco-editor .symbolHighlight { border: 1px ${s.type === "hc" ? "dotted" : "solid"} ${l}; }`);
    const c = s.getColor(Md);
    c && (e.addRule(`.monaco-editor .mtkw { color: ${c} !important; }`), e.addRule(`.monaco-editor .mtkz { color: ${c} !important; }`));
  });
  class wf extends rg {
    constructor(e) {
      super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new V(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
    }
    _readConfig() {
      const e = this._context.configuration.options;
      this._lineHeight = e.get(59);
      const t = e.get(60);
      this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(84);
      const i = e.get(131);
      this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
    }
    dispose() {
      this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
    }
    onConfigurationChanged(e) {
      return this._readConfig(), !0;
    }
    onCursorStateChanged(e) {
      const t = e.selections[0].getPosition();
      this._lastCursorModelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(t);
      let i = !1;
      return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    _getLineRenderLineNumber(e) {
      const t = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(e, 1));
      if (t.column !== 1)
        return "";
      const i = t.lineNumber;
      if (this._renderCustomLineNumbers)
        return this._renderCustomLineNumbers(i);
      if (this._renderLineNumbers === 2) {
        const n = Math.abs(this._lastCursorModelPosition.lineNumber - i);
        return n === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(n);
      }
      return this._renderLineNumbers === 3 ? this._lastCursorModelPosition.lineNumber === i || i % 10 === 0 ? String(i) : "" : String(i);
    }
    prepareRender(e) {
      if (this._renderLineNumbers === 0) {
        this._renderResult = null;
        return;
      }
      const t = Nn ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = '<div class="' + wf.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">', r = this._context.viewModel.getLineCount(), a = [];
      for (let l = i; l <= n; l++) {
        const c = l - i;
        if (!this._renderFinalNewline && l === r && this._context.viewModel.getLineLength(l) === 0) {
          a[c] = "";
          continue;
        }
        const d = this._getLineRenderLineNumber(l);
        d ? l === this._activeLineNumber ? a[c] = '<div class="active-line-number ' + wf.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">' + d + "</div>" : a[c] = o + d + "</div>" : a[c] = "";
      }
      this._renderResult = a;
    }
    render(e, t) {
      if (!this._renderResult)
        return "";
      const i = t - e;
      return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
    }
  }
  wf.CLASS_NAME = "line-numbers";
  Vt((s, e) => {
    const t = s.getColor(B5);
    t && e.addRule(`.monaco-editor .line-numbers { color: ${t}; }`);
    const i = s.getColor(N$);
    i && e.addRule(`.monaco-editor .line-numbers.active-line-number { color: ${i}; }`);
  });
  class Jd extends Do {
    constructor(e) {
      super(e);
      const t = this._context.configuration.options, i = t.get(131);
      this._canUseLayerHinting = !t.get(28), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = dt(document.createElement("div")), this._domNode.setClassName(Jd.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = dt(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(Jd.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
    }
    dispose() {
      super.dispose();
    }
    getDomNode() {
      return this._domNode;
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options, i = t.get(131);
      return this._canUseLayerHinting = !t.get(28), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
    }
    onScrollChanged(e) {
      return super.onScrollChanged(e) || e.scrollTopChanged;
    }
    prepareRender(e) {
    }
    render(e) {
      this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
      const t = e.scrollTop - e.bigNumbersDelta;
      this._domNode.setTop(-t);
      const i = Math.min(e.scrollHeight, 1e6);
      this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
    }
  }
  Jd.CLASS_NAME = "glyph-margin";
  Jd.OUTER_CLASS_NAME = "margin";
  const Ad = "monaco-mouse-cursor-text";
  var SL = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class sj {
    constructor() {
      this._map = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
    }
    fire(e) {
      this._onDidChange.fire({
        changedLanguages: e,
        changedColorMap: !1
      });
    }
    register(e, t) {
      return this._map.set(e, t), this.fire([e]), qe(() => {
        this._map.get(e) === t && (this._map.delete(e), this.fire([e]));
      });
    }
    registerFactory(e, t) {
      var i;
      (i = this._factories.get(e)) === null || i === void 0 || i.dispose();
      const n = new oj(this, e, t);
      return this._factories.set(e, n), qe(() => {
        const o = this._factories.get(e);
        !o || o !== n || (this._factories.delete(e), o.dispose());
      });
    }
    getOrCreate(e) {
      return SL(this, void 0, void 0, function* () {
        const t = this.get(e);
        if (t)
          return t;
        const i = this._factories.get(e);
        return !i || i.isResolved ? null : (yield i.resolve(), this.get(e));
      });
    }
    get(e) {
      return this._map.get(e) || null;
    }
    isResolved(e) {
      if (this.get(e))
        return !0;
      const i = this._factories.get(e);
      return !!(!i || i.isResolved);
    }
    setColorMap(e) {
      this._colorMap = e, this._onDidChange.fire({
        changedLanguages: Array.from(this._map.keys()),
        changedColorMap: !0
      });
    }
    getColorMap() {
      return this._colorMap;
    }
    getDefaultBackground() {
      return this._colorMap && this._colorMap.length > 2 ? this._colorMap[2] : null;
    }
  }
  class oj extends z {
    constructor(e, t, i) {
      super(), this._registry = e, this._languageId = t, this._factory = i, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
    }
    get isResolved() {
      return this._isResolved;
    }
    dispose() {
      this._isDisposed = !0, super.dispose();
    }
    resolve() {
      return SL(this, void 0, void 0, function* () {
        return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
      });
    }
    _create() {
      return SL(this, void 0, void 0, function* () {
        const e = yield Promise.resolve(this._factory.createTokenizationSupport());
        this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
      });
    }
  }
  class In {
    static getLanguageId(e) {
      return (e & 255) >>> 0;
    }
    static getTokenType(e) {
      return (e & 768) >>> 8;
    }
    static getFontStyle(e) {
      return (e & 15360) >>> 10;
    }
    static getForeground(e) {
      return (e & 8372224) >>> 14;
    }
    static getBackground(e) {
      return (e & 4286578688) >>> 23;
    }
    static getClassNameFromMetadata(e) {
      const t = this.getForeground(e);
      let i = "mtk" + t;
      const n = this.getFontStyle(e);
      return n & 1 && (i += " mtki"), n & 2 && (i += " mtkb"), n & 4 && (i += " mtku"), n & 8 && (i += " mtks"), i;
    }
    static getInlineStyleFromMetadata(e, t) {
      const i = this.getForeground(e), n = this.getFontStyle(e);
      let o = `color: ${t[i]};`;
      n & 1 && (o += "font-style: italic;"), n & 2 && (o += "font-weight: bold;");
      let r = "";
      return n & 4 && (r += " underline"), n & 8 && (r += " line-through"), r && (o += `text-decoration:${r};`), o;
    }
    static getPresentationFromMetadata(e) {
      const t = this.getForeground(e), i = this.getFontStyle(e);
      return {
        foreground: t,
        italic: Boolean(i & 1),
        bold: Boolean(i & 2),
        underline: Boolean(i & 4),
        strikethrough: Boolean(i & 8)
      };
    }
  }
  class Zm {
    constructor(e, t, i) {
      this._tokenBrand = void 0, this.offset = e, this.type = t, this.language = i;
    }
    toString() {
      return "(" + this.offset + ", " + this.type + ")";
    }
  }
  class dE {
    constructor(e, t) {
      this._tokenizationResultBrand = void 0, this.tokens = e, this.endState = t;
    }
  }
  class aC {
    constructor(e, t) {
      this._encodedTokenizationResultBrand = void 0, this.tokens = e, this.endState = t;
    }
  }
  var Ym;
  (function(s) {
    const e = /* @__PURE__ */ new Map();
    e.set(0, p.symbolMethod), e.set(1, p.symbolFunction), e.set(2, p.symbolConstructor), e.set(3, p.symbolField), e.set(4, p.symbolVariable), e.set(5, p.symbolClass), e.set(6, p.symbolStruct), e.set(7, p.symbolInterface), e.set(8, p.symbolModule), e.set(9, p.symbolProperty), e.set(10, p.symbolEvent), e.set(11, p.symbolOperator), e.set(12, p.symbolUnit), e.set(13, p.symbolValue), e.set(15, p.symbolEnum), e.set(14, p.symbolConstant), e.set(15, p.symbolEnum), e.set(16, p.symbolEnumMember), e.set(17, p.symbolKeyword), e.set(27, p.symbolSnippet), e.set(18, p.symbolText), e.set(19, p.symbolColor), e.set(20, p.symbolFile), e.set(21, p.symbolReference), e.set(22, p.symbolCustomColor), e.set(23, p.symbolFolder), e.set(24, p.symbolTypeParameter), e.set(25, p.account), e.set(26, p.issues);
    function t(o) {
      let r = e.get(o);
      return r || (console.info("No codicon found for CompletionItemKind " + o), r = p.symbolProperty), r;
    }
    s.toIcon = t;
    const i = /* @__PURE__ */ new Map();
    i.set("method", 0), i.set("function", 1), i.set("constructor", 2), i.set("field", 3), i.set("variable", 4), i.set("class", 5), i.set("struct", 6), i.set("interface", 7), i.set("module", 8), i.set("property", 9), i.set("event", 10), i.set("operator", 11), i.set("unit", 12), i.set("value", 13), i.set("constant", 14), i.set("enum", 15), i.set("enum-member", 16), i.set("enumMember", 16), i.set("keyword", 17), i.set("snippet", 27), i.set("text", 18), i.set("color", 19), i.set("file", 20), i.set("reference", 21), i.set("customcolor", 22), i.set("folder", 23), i.set("type-parameter", 24), i.set("typeParameter", 24), i.set("account", 25), i.set("issue", 26);
    function n(o, r) {
      let a = i.get(o);
      return typeof a > "u" && !r && (a = 9), a;
    }
    s.fromString = n;
  })(Ym || (Ym = {}));
  var ao;
  (function(s) {
    s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
  })(ao || (ao = {}));
  var oa;
  (function(s) {
    s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
  })(oa || (oa = {}));
  var Xm;
  (function(s) {
    s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
  })(Xm || (Xm = {}));
  function rj(s) {
    return s && Ee.isUri(s.uri) && D.isIRange(s.range) && (D.isIRange(s.originSelectionRange) || D.isIRange(s.targetSelectionRange));
  }
  var yL;
  (function(s) {
    const e = /* @__PURE__ */ new Map();
    e.set(0, p.symbolFile), e.set(1, p.symbolModule), e.set(2, p.symbolNamespace), e.set(3, p.symbolPackage), e.set(4, p.symbolClass), e.set(5, p.symbolMethod), e.set(6, p.symbolProperty), e.set(7, p.symbolField), e.set(8, p.symbolConstructor), e.set(9, p.symbolEnum), e.set(10, p.symbolInterface), e.set(11, p.symbolFunction), e.set(12, p.symbolVariable), e.set(13, p.symbolConstant), e.set(14, p.symbolString), e.set(15, p.symbolNumber), e.set(16, p.symbolBoolean), e.set(17, p.symbolArray), e.set(18, p.symbolObject), e.set(19, p.symbolKey), e.set(20, p.symbolNull), e.set(21, p.symbolEnumMember), e.set(22, p.symbolStruct), e.set(23, p.symbolEvent), e.set(24, p.symbolOperator), e.set(25, p.symbolTypeParameter);
    function t(i) {
      let n = e.get(i);
      return n || (console.info("No codicon found for SymbolKind " + i), n = p.symbolProperty), n;
    }
    s.toIcon = t;
  })(yL || (yL = {}));
  class br {
    constructor(e) {
      this.value = e;
    }
  }
  br.Comment = new br("comment");
  br.Imports = new br("imports");
  br.Region = new br("region");
  var LL;
  (function(s) {
    function e(t) {
      return !t || typeof t != "object" ? !1 : typeof t.id == "string" && typeof t.title == "string";
    }
    s.is = e;
  })(LL || (LL = {}));
  var d1;
  (function(s) {
    s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
  })(d1 || (d1 = {}));
  const Yt = new sj();
  class aj {
    constructor(e, t, i, n, o) {
      this._context = e, this.modelLineNumber = t, this.distanceToModelLineStart = i, this.widthOfHiddenLineTextBefore = n, this.distanceToModelLineEnd = o, this._visibleTextAreaBrand = void 0, this.startPosition = null, this.endPosition = null, this.visibleTextareaStart = null, this.visibleTextareaEnd = null, this._previousPresentation = null;
    }
    prepareRender(e) {
      const t = new V(this.modelLineNumber, this.distanceToModelLineStart + 1), i = new V(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
      this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t), this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i), this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = e.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = e.visibleRangeForPosition(this.endPosition)) : (this.visibleTextareaStart = null, this.visibleTextareaEnd = null);
    }
    definePresentation(e) {
      return this._previousPresentation || (e ? this._previousPresentation = e : this._previousPresentation = {
        foreground: 1,
        italic: !1,
        bold: !1,
        underline: !1,
        strikethrough: !1
      }), this._previousPresentation;
    }
  }
  const Cg = Xs;
  class lj extends Do {
    constructor(e, t, i) {
      super(e), this._primaryCursorPosition = new V(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._visibleRangeProvider = i, this._scrollLeft = 0, this._scrollTop = 0;
      const n = this._context.configuration.options, o = n.get(131);
      this._setAccessibilityOptions(n), this._contentLeft = o.contentLeft, this._contentWidth = o.contentWidth, this._contentHeight = o.height, this._fontInfo = n.get(44), this._lineHeight = n.get(59), this._emptySelectionClipboard = n.get(32), this._copyWithSyntaxHighlighting = n.get(21), this._visibleTextArea = null, this._selections = [new ae(1, 1, 1, 1)], this._modelSelections = [new ae(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = dt(document.createElement("textarea")), ha.write(this.textArea, 6), this.textArea.setClassName(`inputarea ${Ad}`), this.textArea.setAttribute("wrap", "off"), this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(n)), this.textArea.setAttribute("tabindex", String(n.get(112))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", m("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), n.get(30) && n.get(81) && this.textArea.setAttribute("readonly", "true"), this.textAreaCover = dt(document.createElement("div")), this.textAreaCover.setPosition("absolute");
      const r = {
        getLineCount: () => this._context.viewModel.getLineCount(),
        getLineMaxColumn: (c) => this._context.viewModel.getLineMaxColumn(c),
        getValueInRange: (c, d) => this._context.viewModel.getValueInRange(c, d)
      }, a = {
        getDataToCopy: () => {
          const c = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, rn), d = this._context.viewModel.model.getEOL(), h = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), u = Array.isArray(c) ? c : null, f = Array.isArray(c) ? c.join(d) : c;
          let g, _ = null;
          if (wL.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && f.length < 65536) {
            const b = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
            b && (g = b.html, _ = b.mode);
          }
          return {
            isFromEmptySelection: h,
            multicursorText: u,
            text: f,
            html: g,
            mode: _
          };
        },
        getScreenReaderContent: (c) => {
          if (this._accessibilitySupport === 1) {
            if (Ye) {
              const d = this._selections[0];
              if (d.isEmpty()) {
                const h = d.getStartPosition();
                let u = this._getWordBeforePosition(h);
                if (u.length === 0 && (u = this._getCharacterBeforePosition(h)), u.length > 0)
                  return new kn(u, u.length, u.length, h, h);
              }
            }
            return kn.EMPTY;
          }
          if (Y4) {
            const d = this._selections[0];
            if (d.isEmpty()) {
              const h = d.getStartPosition(), [u, f] = this._getAndroidWordAtPosition(h);
              if (u.length > 0)
                return new kn(u, f, f, h, h);
            }
            return kn.EMPTY;
          }
          return Iu.fromEditorSelection(c, r, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0);
        },
        deduceModelPosition: (c, d, h) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(c, d, h)
      }, l = this._register(new C$(this.textArea.domNode));
      this._textAreaInput = this._register(new v$(a, l, oo, OB)), this._register(this._textAreaInput.onKeyDown((c) => {
        this._viewController.emitKeyDown(c);
      })), this._register(this._textAreaInput.onKeyUp((c) => {
        this._viewController.emitKeyUp(c);
      })), this._register(this._textAreaInput.onPaste((c) => {
        let d = !1, h = null, u = null;
        c.metadata && (d = this._emptySelectionClipboard && !!c.metadata.isFromEmptySelection, h = typeof c.metadata.multicursorText < "u" ? c.metadata.multicursorText : null, u = c.metadata.mode), this._viewController.paste(c.text, d, h, u);
      })), this._register(this._textAreaInput.onCut(() => {
        this._viewController.cut();
      })), this._register(this._textAreaInput.onType((c) => {
        c.replacePrevCharCnt || c.replaceNextCharCnt || c.positionDelta ? this._viewController.compositionType(c.text, c.replacePrevCharCnt, c.replaceNextCharCnt, c.positionDelta) : this._viewController.type(c.text);
      })), this._register(this._textAreaInput.onSelectionChangeRequest((c) => {
        this._viewController.setSelection(c);
      })), this._register(this._textAreaInput.onCompositionStart((c) => {
        const d = this.textArea.domNode, h = this._modelSelections[0], { distanceToModelLineStart: u, widthOfHiddenTextBefore: f } = (() => {
          const _ = d.value.substring(0, Math.min(d.selectionStart, d.selectionEnd)), b = _.lastIndexOf(`
`), C = _.substring(b + 1), v = C.lastIndexOf("	"), w = C.length - v - 1, S = h.getStartPosition(), L = Math.min(S.column - 1, w), x = S.column - 1 - L, y = C.substring(0, C.length - L), k = cj(y, this._fontInfo);
          return { distanceToModelLineStart: x, widthOfHiddenTextBefore: k };
        })(), { distanceToModelLineEnd: g } = (() => {
          const _ = d.value.substring(Math.max(d.selectionStart, d.selectionEnd)), b = _.indexOf(`
`), C = b === -1 ? _ : _.substring(0, b), v = C.indexOf("	"), w = v === -1 ? C.length : C.length - v - 1, S = h.getEndPosition(), L = Math.min(this._context.viewModel.model.getLineMaxColumn(S.lineNumber) - S.column, w);
          return { distanceToModelLineEnd: this._context.viewModel.model.getLineMaxColumn(S.lineNumber) - S.column - L };
        })();
        this._context.viewModel.revealRange("keyboard", !0, D.fromPositions(this._selections[0].getStartPosition()), 0, 1), this._visibleTextArea = new aj(this._context, h.startLineNumber, u, f, g), this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render(), this.textArea.setClassName(`inputarea ${Ad} ime-input`), this._viewController.compositionStart(), this._context.viewModel.onCompositionStart();
      })), this._register(this._textAreaInput.onCompositionUpdate((c) => {
        !this._visibleTextArea || (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
      })), this._register(this._textAreaInput.onCompositionEnd(() => {
        this._visibleTextArea = null, this._render(), this.textArea.setClassName(`inputarea ${Ad}`), this._viewController.compositionEnd(), this._context.viewModel.onCompositionEnd();
      })), this._register(this._textAreaInput.onFocus(() => {
        this._context.viewModel.setHasFocus(!0);
      })), this._register(this._textAreaInput.onBlur(() => {
        this._context.viewModel.setHasFocus(!1);
      }));
    }
    dispose() {
      super.dispose();
    }
    _getAndroidWordAtPosition(e) {
      const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.viewModel.getLineContent(e.lineNumber), n = yo(t);
      let o = !0, r = e.column, a = !0, l = e.column, c = 0;
      for (; c < 50 && (o || a); ) {
        if (o && r <= 1 && (o = !1), o) {
          const d = i.charCodeAt(r - 2);
          n.get(d) !== 0 ? o = !1 : r--;
        }
        if (a && l > i.length && (a = !1), a) {
          const d = i.charCodeAt(l - 1);
          n.get(d) !== 0 ? a = !1 : l++;
        }
        c++;
      }
      return [i.substring(r - 1, l - 1), e.column - r];
    }
    _getWordBeforePosition(e) {
      const t = this._context.viewModel.getLineContent(e.lineNumber), i = yo(this._context.configuration.options.get(117));
      let n = e.column, o = 0;
      for (; n > 1; ) {
        const r = t.charCodeAt(n - 2);
        if (i.get(r) !== 0 || o > 50)
          return t.substring(n - 1, e.column - 1);
        o++, n--;
      }
      return t.substring(0, e.column - 1);
    }
    _getCharacterBeforePosition(e) {
      if (e.column > 1) {
        const i = this._context.viewModel.getLineContent(e.lineNumber).charAt(e.column - 2);
        if (!Pi(i.charCodeAt(0)))
          return i;
      }
      return "";
    }
    _getAriaLabel(e) {
      return e.get(2) === 1 ? m("accessibilityOffAriaLabel", "The editor is not accessible at this time. Press {0} for options.", Nn ? "Shift+Alt+F1" : "Alt+F1") : e.get(4);
    }
    _setAccessibilityOptions(e) {
      this._accessibilitySupport = e.get(2);
      const t = e.get(3);
      this._accessibilitySupport === 2 && t === yr.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options, i = t.get(131);
      return this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(44), this._lineHeight = t.get(59), this._emptySelectionClipboard = t.get(32), this._copyWithSyntaxHighlighting = t.get(21), this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("tabindex", String(t.get(112))), (e.hasChanged(30) || e.hasChanged(81)) && (t.get(30) && t.get(81) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly")), e.hasChanged(2) && this._textAreaInput.writeScreenReaderContent("strategy changed"), !0;
    }
    onCursorStateChanged(e) {
      return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeScreenReaderContent("selection changed"), !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
    }
    onZonesChanged(e) {
      return !0;
    }
    isFocused() {
      return this._textAreaInput.isFocused();
    }
    focusTextArea() {
      this._textAreaInput.focusTextArea();
    }
    getLastRenderData() {
      return this._lastRenderPosition;
    }
    setAriaOptions(e) {
      e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
    }
    prepareRender(e) {
      this._primaryCursorPosition = new V(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition), this._visibleTextArea && this._visibleTextArea.prepareRender(e);
    }
    render(e) {
      this._textAreaInput.writeScreenReaderContent("render"), this._render();
    }
    _render() {
      if (this._visibleTextArea) {
        const i = this._visibleTextArea.visibleTextareaStart, n = this._visibleTextArea.visibleTextareaEnd, o = this._visibleTextArea.startPosition, r = this._visibleTextArea.endPosition;
        if (o && r && i && n && n.left >= this._scrollLeft && i.left <= this._scrollLeft + this._contentWidth) {
          const a = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop, l = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
          let c = this._visibleTextArea.widthOfHiddenLineTextBefore, d = this._contentLeft + i.left - this._scrollLeft, h = n.left - i.left + 1;
          if (d < this._contentLeft) {
            const C = this._contentLeft - d;
            d += C, c += C, h -= C;
          }
          h > this._contentWidth && (h = this._contentWidth);
          const u = this._context.viewModel.getViewLineData(o.lineNumber), f = u.tokens.findTokenIndexAtOffset(o.column - 1), g = u.tokens.findTokenIndexAtOffset(r.column - 1), _ = f === g, b = this._visibleTextArea.definePresentation(_ ? u.tokens.getPresentation(f) : null);
          this.textArea.domNode.scrollTop = l * this._lineHeight, this.textArea.domNode.scrollLeft = c, this._doRender({
            lastRenderPosition: null,
            top: a,
            left: d,
            width: h,
            height: this._lineHeight,
            useCover: !1,
            color: (Yt.getColorMap() || [])[b.foreground],
            italic: b.italic,
            bold: b.bold,
            underline: b.underline,
            strikethrough: b.strikethrough
          });
        }
        return;
      }
      if (!this._primaryCursorVisibleRange) {
        this._renderAtTopLeft();
        return;
      }
      const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
      if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
        this._renderAtTopLeft();
        return;
      }
      const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
      if (t < 0 || t > this._contentHeight) {
        this._renderAtTopLeft();
        return;
      }
      if (Ye) {
        this._doRender({
          lastRenderPosition: this._primaryCursorPosition,
          top: t,
          left: e,
          width: Cg ? 0 : 1,
          height: this._lineHeight,
          useCover: !1
        }), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
        const i = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
        this.textArea.domNode.scrollTop = i * this._lineHeight;
        return;
      }
      this._doRender({
        lastRenderPosition: this._primaryCursorPosition,
        top: t,
        left: e,
        width: Cg ? 0 : 1,
        height: Cg ? 0 : 1,
        useCover: !1
      });
    }
    _newlinecount(e) {
      let t = 0, i = -1;
      do {
        if (i = e.indexOf(`
`, i + 1), i === -1)
          break;
        t++;
      } while (!0);
      return t;
    }
    _renderAtTopLeft() {
      this._doRender({
        lastRenderPosition: null,
        top: 0,
        left: 0,
        width: Cg ? 0 : 1,
        height: Cg ? 0 : 1,
        useCover: !0
      });
    }
    _doRender(e) {
      this._lastRenderPosition = e.lastRenderPosition;
      const t = this.textArea, i = this.textAreaCover;
      En(t, this._fontInfo), t.setTop(e.top), t.setLeft(e.left), t.setWidth(e.width), t.setHeight(e.height), t.setColor(e.color ? H.Format.CSS.formatHex(e.color) : ""), t.setFontStyle(e.italic ? "italic" : ""), e.bold && t.setFontWeight("bold"), t.setTextDecoration(`${e.underline ? " underline" : ""}${e.strikethrough ? " line-through" : ""}`), i.setTop(e.useCover ? e.top : 0), i.setLeft(e.useCover ? e.left : 0), i.setWidth(e.useCover ? e.width : 0), i.setHeight(e.useCover ? e.height : 0);
      const n = this._context.configuration.options;
      n.get(50) ? i.setClassName("monaco-editor-background textAreaCover " + Jd.OUTER_CLASS_NAME) : n.get(60).renderType !== 0 ? i.setClassName("monaco-editor-background textAreaCover " + wf.CLASS_NAME) : i.setClassName("monaco-editor-background textAreaCover");
    }
  }
  function cj(s, e) {
    if (s.length === 0)
      return 0;
    const t = document.createElement("div");
    t.style.position = "absolute", t.style.top = "-50000px", t.style.width = "50000px";
    const i = document.createElement("span");
    En(i, e), i.style.whiteSpace = "pre", i.append(s), t.appendChild(i), document.body.appendChild(t);
    const n = i.offsetWidth;
    return document.body.removeChild(t), n;
  }
  class dj {
    constructor(e, t, i, n) {
      this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = n;
    }
    paste(e, t, i, n) {
      this.commandDelegate.paste(e, t, i, n);
    }
    type(e) {
      this.commandDelegate.type(e);
    }
    compositionType(e, t, i, n) {
      this.commandDelegate.compositionType(e, t, i, n);
    }
    compositionStart() {
      this.commandDelegate.startComposition();
    }
    compositionEnd() {
      this.commandDelegate.endComposition();
    }
    cut() {
      this.commandDelegate.cut();
    }
    setSelection(e) {
      Ui.SetSelection.runCoreEditorCommand(this.viewModel, {
        source: "keyboard",
        selection: e
      });
    }
    _validateViewColumn(e) {
      const t = this.viewModel.getLineMinColumn(e.lineNumber);
      return e.column < t ? new V(e.lineNumber, t) : e;
    }
    _hasMulticursorModifier(e) {
      switch (this.configuration.options.get(70)) {
        case "altKey":
          return e.altKey;
        case "ctrlKey":
          return e.ctrlKey;
        case "metaKey":
          return e.metaKey;
        default:
          return !1;
      }
    }
    _hasNonMulticursorModifier(e) {
      switch (this.configuration.options.get(70)) {
        case "altKey":
          return e.ctrlKey || e.metaKey;
        case "ctrlKey":
          return e.altKey || e.metaKey;
        case "metaKey":
          return e.ctrlKey || e.altKey;
        default:
          return !1;
      }
    }
    dispatchMouse(e) {
      const t = this.configuration.options, i = Nn && t.get(96), n = t.get(18);
      e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position) : this._lastCursorLineSelect(e.position) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount === 2 ? e.onInjectedText || (this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position) : e.inSelectionMode ? this._wordSelectDrag(e.position) : this._wordSelect(e.position)) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : n ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position) : this.moveTo(e.position);
    }
    _usualArgs(e) {
      return e = this._validateViewColumn(e), {
        source: "mouse",
        position: this._convertViewToModelPosition(e),
        viewPosition: e
      };
    }
    moveTo(e) {
      Ui.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _moveToSelect(e) {
      Ui.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _columnSelect(e, t, i) {
      e = this._validateViewColumn(e), Ui.ColumnSelect.runCoreEditorCommand(this.viewModel, {
        source: "mouse",
        position: this._convertViewToModelPosition(e),
        viewPosition: e,
        mouseColumn: t,
        doColumnSelect: i
      });
    }
    _createCursor(e, t) {
      e = this._validateViewColumn(e), Ui.CreateCursor.runCoreEditorCommand(this.viewModel, {
        source: "mouse",
        position: this._convertViewToModelPosition(e),
        viewPosition: e,
        wholeLine: t
      });
    }
    _lastCursorMoveToSelect(e) {
      Ui.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _wordSelect(e) {
      Ui.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _wordSelectDrag(e) {
      Ui.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _lastCursorWordSelect(e) {
      Ui.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _lineSelect(e) {
      Ui.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _lineSelectDrag(e) {
      Ui.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _lastCursorLineSelect(e) {
      Ui.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _lastCursorLineSelectDrag(e) {
      Ui.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
    }
    _selectAll() {
      Ui.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
    }
    _convertViewToModelPosition(e) {
      return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
    }
    emitKeyDown(e) {
      this.userInputEvents.emitKeyDown(e);
    }
    emitKeyUp(e) {
      this.userInputEvents.emitKeyUp(e);
    }
    emitContextMenu(e) {
      this.userInputEvents.emitContextMenu(e);
    }
    emitMouseMove(e) {
      this.userInputEvents.emitMouseMove(e);
    }
    emitMouseLeave(e) {
      this.userInputEvents.emitMouseLeave(e);
    }
    emitMouseUp(e) {
      this.userInputEvents.emitMouseUp(e);
    }
    emitMouseDown(e) {
      this.userInputEvents.emitMouseDown(e);
    }
    emitMouseDrag(e) {
      this.userInputEvents.emitMouseDrag(e);
    }
    emitMouseDrop(e) {
      this.userInputEvents.emitMouseDrop(e);
    }
    emitMouseDropCanceled() {
      this.userInputEvents.emitMouseDropCanceled();
    }
    emitMouseWheel(e) {
      this.userInputEvents.emitMouseWheel(e);
    }
  }
  class lC {
    constructor(e) {
      this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
    }
    emitKeyDown(e) {
      this.onKeyDown && this.onKeyDown(e);
    }
    emitKeyUp(e) {
      this.onKeyUp && this.onKeyUp(e);
    }
    emitContextMenu(e) {
      this.onContextMenu && this.onContextMenu(this._convertViewToModelMouseEvent(e));
    }
    emitMouseMove(e) {
      this.onMouseMove && this.onMouseMove(this._convertViewToModelMouseEvent(e));
    }
    emitMouseLeave(e) {
      this.onMouseLeave && this.onMouseLeave(this._convertViewToModelMouseEvent(e));
    }
    emitMouseDown(e) {
      this.onMouseDown && this.onMouseDown(this._convertViewToModelMouseEvent(e));
    }
    emitMouseUp(e) {
      this.onMouseUp && this.onMouseUp(this._convertViewToModelMouseEvent(e));
    }
    emitMouseDrag(e) {
      this.onMouseDrag && this.onMouseDrag(this._convertViewToModelMouseEvent(e));
    }
    emitMouseDrop(e) {
      this.onMouseDrop && this.onMouseDrop(this._convertViewToModelMouseEvent(e));
    }
    emitMouseDropCanceled() {
      this.onMouseDropCanceled && this.onMouseDropCanceled();
    }
    emitMouseWheel(e) {
      this.onMouseWheel && this.onMouseWheel(e);
    }
    _convertViewToModelMouseEvent(e) {
      return e.target ? {
        event: e.event,
        target: this._convertViewToModelMouseTarget(e.target)
      } : e;
    }
    _convertViewToModelMouseTarget(e) {
      return lC.convertViewToModelMouseTarget(e, this._coordinatesConverter);
    }
    static convertViewToModelMouseTarget(e, t) {
      const i = Object.assign({}, e);
      return i.position && (i.position = t.convertViewPositionToModelPosition(i.position)), i.range && (i.range = t.convertViewRangeToModelRange(i.range)), i;
    }
  }
  var Yw;
  class K5 {
    constructor(e) {
      this._createLine = e, this._set(1, []);
    }
    flush() {
      this._set(1, []);
    }
    _set(e, t) {
      this._lines = t, this._rendLineNumberStart = e;
    }
    _get() {
      return {
        rendLineNumberStart: this._rendLineNumberStart,
        lines: this._lines
      };
    }
    getStartLineNumber() {
      return this._rendLineNumberStart;
    }
    getEndLineNumber() {
      return this._rendLineNumberStart + this._lines.length - 1;
    }
    getCount() {
      return this._lines.length;
    }
    getLine(e) {
      const t = e - this._rendLineNumberStart;
      if (t < 0 || t >= this._lines.length)
        throw new Error("Illegal value for lineNumber");
      return this._lines[t];
    }
    onLinesDeleted(e, t) {
      if (this.getCount() === 0)
        return null;
      const i = this.getStartLineNumber(), n = this.getEndLineNumber();
      if (t < i) {
        const l = t - e + 1;
        return this._rendLineNumberStart -= l, null;
      }
      if (e > n)
        return null;
      let o = 0, r = 0;
      for (let l = i; l <= n; l++) {
        const c = l - this._rendLineNumberStart;
        e <= l && l <= t && (r === 0 ? (o = c, r = 1) : r++);
      }
      if (e < i) {
        let l = 0;
        t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
      }
      return this._lines.splice(o, r);
    }
    onLinesChanged(e, t) {
      if (this.getCount() === 0)
        return !1;
      const i = this.getStartLineNumber(), n = this.getEndLineNumber();
      let o = !1;
      for (let r = e; r <= t; r++)
        r >= i && r <= n && (this._lines[r - this._rendLineNumberStart].onContentChanged(), o = !0);
      return o;
    }
    onLinesInserted(e, t) {
      if (this.getCount() === 0)
        return null;
      const i = t - e + 1, n = this.getStartLineNumber(), o = this.getEndLineNumber();
      if (e <= n)
        return this._rendLineNumberStart += i, null;
      if (e > o)
        return null;
      if (i + e > o)
        return this._lines.splice(e - this._rendLineNumberStart, o - e + 1);
      const r = [];
      for (let h = 0; h < i; h++)
        r[h] = this._createLine();
      const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), c = this._lines.slice(a, this._lines.length - i), d = this._lines.slice(this._lines.length - i, this._lines.length);
      return this._lines = l.concat(r).concat(c), d;
    }
    onTokensChanged(e) {
      if (this.getCount() === 0)
        return !1;
      const t = this.getStartLineNumber(), i = this.getEndLineNumber();
      let n = !1;
      for (let o = 0, r = e.length; o < r; o++) {
        const a = e[o];
        if (a.toLineNumber < t || a.fromLineNumber > i)
          continue;
        const l = Math.max(t, a.fromLineNumber), c = Math.min(i, a.toLineNumber);
        for (let d = l; d <= c; d++) {
          const h = d - this._rendLineNumberStart;
          this._lines[h].onTokensChanged(), n = !0;
        }
      }
      return n;
    }
  }
  class q5 {
    constructor(e) {
      this._host = e, this.domNode = this._createDomNode(), this._linesCollection = new K5(() => this._host.createVisibleLine());
    }
    _createDomNode() {
      const e = dt(document.createElement("div"));
      return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
    }
    onConfigurationChanged(e) {
      return !!e.hasChanged(131);
    }
    onFlushed(e) {
      return this._linesCollection.flush(), !0;
    }
    onLinesChanged(e) {
      return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);
    }
    onLinesDeleted(e) {
      const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
      if (t)
        for (let i = 0, n = t.length; i < n; i++) {
          const o = t[i].getDomNode();
          o && this.domNode.domNode.removeChild(o);
        }
      return !0;
    }
    onLinesInserted(e) {
      const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
      if (t)
        for (let i = 0, n = t.length; i < n; i++) {
          const o = t[i].getDomNode();
          o && this.domNode.domNode.removeChild(o);
        }
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onTokensChanged(e) {
      return this._linesCollection.onTokensChanged(e.ranges);
    }
    onZonesChanged(e) {
      return !0;
    }
    getStartLineNumber() {
      return this._linesCollection.getStartLineNumber();
    }
    getEndLineNumber() {
      return this._linesCollection.getEndLineNumber();
    }
    getVisibleLine(e) {
      return this._linesCollection.getLine(e);
    }
    renderLines(e) {
      const t = this._linesCollection._get(), i = new Xa(this.domNode.domNode, this._host, e), n = {
        rendLineNumberStart: t.rendLineNumberStart,
        lines: t.lines,
        linesLength: t.lines.length
      }, o = i.render(n, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
      this._linesCollection._set(o.rendLineNumberStart, o.lines);
    }
  }
  class Xa {
    constructor(e, t, i) {
      this.domNode = e, this.host = t, this.viewportData = i;
    }
    render(e, t, i, n) {
      const o = {
        rendLineNumberStart: e.rendLineNumberStart,
        lines: e.lines.slice(0),
        linesLength: e.linesLength
      };
      if (o.rendLineNumberStart + o.linesLength - 1 < t || i < o.rendLineNumberStart) {
        o.rendLineNumberStart = t, o.linesLength = i - t + 1, o.lines = [];
        for (let r = t; r <= i; r++)
          o.lines[r - t] = this.host.createVisibleLine();
        return this._finishRendering(o, !0, n), o;
      }
      if (this._renderUntouchedLines(o, Math.max(t - o.rendLineNumberStart, 0), Math.min(i - o.rendLineNumberStart, o.linesLength - 1), n, t), o.rendLineNumberStart > t) {
        const r = t, a = Math.min(i, o.rendLineNumberStart - 1);
        r <= a && (this._insertLinesBefore(o, r, a, n, t), o.linesLength += a - r + 1);
      } else if (o.rendLineNumberStart < t) {
        const r = Math.min(o.linesLength, t - o.rendLineNumberStart);
        r > 0 && (this._removeLinesBefore(o, r), o.linesLength -= r);
      }
      if (o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < i) {
        const r = o.rendLineNumberStart + o.linesLength, a = i;
        r <= a && (this._insertLinesAfter(o, r, a, n, t), o.linesLength += a - r + 1);
      } else if (o.rendLineNumberStart + o.linesLength - 1 > i) {
        const r = Math.max(0, i - o.rendLineNumberStart + 1), l = o.linesLength - 1 - r + 1;
        l > 0 && (this._removeLinesAfter(o, l), o.linesLength -= l);
      }
      return this._finishRendering(o, !1, n), o;
    }
    _renderUntouchedLines(e, t, i, n, o) {
      const r = e.rendLineNumberStart, a = e.lines;
      for (let l = t; l <= i; l++) {
        const c = r + l;
        a[l].layoutLine(c, n[c - o]);
      }
    }
    _insertLinesBefore(e, t, i, n, o) {
      const r = [];
      let a = 0;
      for (let l = t; l <= i; l++)
        r[a++] = this.host.createVisibleLine();
      e.lines = r.concat(e.lines);
    }
    _removeLinesBefore(e, t) {
      for (let i = 0; i < t; i++) {
        const n = e.lines[i].getDomNode();
        n && this.domNode.removeChild(n);
      }
      e.lines.splice(0, t);
    }
    _insertLinesAfter(e, t, i, n, o) {
      const r = [];
      let a = 0;
      for (let l = t; l <= i; l++)
        r[a++] = this.host.createVisibleLine();
      e.lines = e.lines.concat(r);
    }
    _removeLinesAfter(e, t) {
      const i = e.linesLength - t;
      for (let n = 0; n < t; n++) {
        const o = e.lines[i + n].getDomNode();
        o && this.domNode.removeChild(o);
      }
      e.lines.splice(i, t);
    }
    _finishRenderingNewLines(e, t, i, n) {
      Xa._ttPolicy && (i = Xa._ttPolicy.createHTML(i));
      const o = this.domNode.lastChild;
      t || !o ? this.domNode.innerHTML = i : o.insertAdjacentHTML("afterend", i);
      let r = this.domNode.lastChild;
      for (let a = e.linesLength - 1; a >= 0; a--) {
        const l = e.lines[a];
        n[a] && (l.setDomNode(r), r = r.previousSibling);
      }
    }
    _finishRenderingInvalidLines(e, t, i) {
      const n = document.createElement("div");
      Xa._ttPolicy && (t = Xa._ttPolicy.createHTML(t)), n.innerHTML = t;
      for (let o = 0; o < e.linesLength; o++) {
        const r = e.lines[o];
        if (i[o]) {
          const a = n.firstChild, l = r.getDomNode();
          l.parentNode.replaceChild(a, l), r.setDomNode(a);
        }
      }
    }
    _finishRendering(e, t, i) {
      const n = Xa._sb, o = e.linesLength, r = e.lines, a = e.rendLineNumberStart, l = [];
      {
        n.reset();
        let c = !1;
        for (let d = 0; d < o; d++) {
          const h = r[d];
          l[d] = !1, !(h.getDomNode() || !h.renderLine(d + a, i[d], this.viewportData, n)) && (l[d] = !0, c = !0);
        }
        c && this._finishRenderingNewLines(e, t, n.build(), l);
      }
      {
        n.reset();
        let c = !1;
        const d = [];
        for (let h = 0; h < o; h++) {
          const u = r[h];
          d[h] = !1, !(l[h] || !u.renderLine(h + a, i[h], this.viewportData, n)) && (d[h] = !0, c = !0);
        }
        c && this._finishRenderingInvalidLines(e, n.build(), d);
      }
    }
  }
  Xa._ttPolicy = (Yw = window.trustedTypes) === null || Yw === void 0 ? void 0 : Yw.createPolicy("editorViewLayer", { createHTML: (s) => s });
  Xa._sb = Zd(1e5);
  class G5 extends Do {
    constructor(e) {
      super(e), this._visibleLines = new q5(this), this.domNode = this._visibleLines.domNode, this._dynamicOverlays = [], this._isFocused = !1, this.domNode.setClassName("view-overlays");
    }
    shouldRender() {
      if (super.shouldRender())
        return !0;
      for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
        if (this._dynamicOverlays[e].shouldRender())
          return !0;
      return !1;
    }
    dispose() {
      super.dispose();
      for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
        this._dynamicOverlays[e].dispose();
      this._dynamicOverlays = [];
    }
    getDomNode() {
      return this.domNode;
    }
    createVisibleLine() {
      return new hj(this._context.configuration, this._dynamicOverlays);
    }
    addDynamicOverlay(e) {
      this._dynamicOverlays.push(e);
    }
    onConfigurationChanged(e) {
      this._visibleLines.onConfigurationChanged(e);
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let n = t; n <= i; n++)
        this._visibleLines.getVisibleLine(n).onConfigurationChanged(e);
      return !0;
    }
    onFlushed(e) {
      return this._visibleLines.onFlushed(e);
    }
    onFocusChanged(e) {
      return this._isFocused = e.isFocused, !0;
    }
    onLinesChanged(e) {
      return this._visibleLines.onLinesChanged(e);
    }
    onLinesDeleted(e) {
      return this._visibleLines.onLinesDeleted(e);
    }
    onLinesInserted(e) {
      return this._visibleLines.onLinesInserted(e);
    }
    onScrollChanged(e) {
      return this._visibleLines.onScrollChanged(e) || !0;
    }
    onTokensChanged(e) {
      return this._visibleLines.onTokensChanged(e);
    }
    onZonesChanged(e) {
      return this._visibleLines.onZonesChanged(e);
    }
    prepareRender(e) {
      const t = this._dynamicOverlays.filter((i) => i.shouldRender());
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i];
        o.prepareRender(e), o.onDidRender();
      }
    }
    render(e) {
      this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
    }
    _viewOverlaysRender(e) {
      this._visibleLines.renderLines(e.viewportData);
    }
  }
  class hj {
    constructor(e, t) {
      this._configuration = e, this._lineHeight = this._configuration.options.get(59), this._dynamicOverlays = t, this._domNode = null, this._renderedContent = null;
    }
    getDomNode() {
      return this._domNode ? this._domNode.domNode : null;
    }
    setDomNode(e) {
      this._domNode = dt(e);
    }
    onContentChanged() {
    }
    onTokensChanged() {
    }
    onConfigurationChanged(e) {
      this._lineHeight = this._configuration.options.get(59);
    }
    renderLine(e, t, i, n) {
      let o = "";
      for (let r = 0, a = this._dynamicOverlays.length; r < a; r++)
        o += this._dynamicOverlays[r].render(i.startLineNumber, e);
      return this._renderedContent === o ? !1 : (this._renderedContent = o, n.appendASCIIString('<div style="position:absolute;top:'), n.appendASCIIString(String(t)), n.appendASCIIString("px;width:100%;height:"), n.appendASCIIString(String(this._lineHeight)), n.appendASCIIString('px;">'), n.appendASCIIString(o), n.appendASCIIString("</div>"), !0);
    }
    layoutLine(e, t) {
      this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(this._lineHeight));
    }
  }
  class uj extends G5 {
    constructor(e) {
      super(e);
      const i = this._context.configuration.options.get(131);
      this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
    }
    onConfigurationChanged(e) {
      const i = this._context.configuration.options.get(131);
      return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
    }
    onScrollChanged(e) {
      return super.onScrollChanged(e) || e.scrollWidthChanged;
    }
    _viewOverlaysRender(e) {
      super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
    }
  }
  class fj extends G5 {
    constructor(e) {
      super(e);
      const t = this._context.configuration.options, i = t.get(131);
      this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), En(this.domNode, t.get(44));
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options;
      En(this.domNode, t.get(44));
      const i = t.get(131);
      return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
    }
    onScrollChanged(e) {
      return super.onScrollChanged(e) || e.scrollHeightChanged;
    }
    _viewOverlaysRender(e) {
      super._viewOverlaysRender(e);
      const t = Math.min(e.scrollHeight, 1e6);
      this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
    }
  }
  class wg {
    constructor(e, t) {
      this._coordinateBrand = void 0, this.top = e, this.left = t;
    }
  }
  class gj extends Do {
    constructor(e, t) {
      super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = dt(document.createElement("div")), ha.write(this.domNode, 1), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = dt(document.createElement("div")), ha.write(this.overflowingContentWidgetsDomNode, 2), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
    }
    dispose() {
      super.dispose(), this._widgets = {};
    }
    onConfigurationChanged(e) {
      const t = Object.keys(this._widgets);
      for (const i of t)
        this._widgets[i].onConfigurationChanged(e);
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLineMappingChanged(e) {
      const t = Object.keys(this._widgets);
      for (const i of t)
        this._widgets[i].onLineMappingChanged(e);
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return !0;
    }
    onZonesChanged(e) {
      return !0;
    }
    addWidget(e) {
      const t = new mj(this._context, this._viewDomNode, e);
      this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
    }
    setWidgetPosition(e, t, i) {
      this._widgets[e.getId()].setPosition(t, i), this.setShouldRender();
    }
    removeWidget(e) {
      const t = e.getId();
      if (this._widgets.hasOwnProperty(t)) {
        const i = this._widgets[t];
        delete this._widgets[t];
        const n = i.domNode.domNode;
        n.parentNode.removeChild(n), n.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
      }
    }
    shouldSuppressMouseDownOnWidget(e) {
      return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
    }
    onBeforeRender(e) {
      const t = Object.keys(this._widgets);
      for (const i of t)
        this._widgets[i].onBeforeRender(e);
    }
    prepareRender(e) {
      const t = Object.keys(this._widgets);
      for (const i of t)
        this._widgets[i].prepareRender(e);
    }
    render(e) {
      const t = Object.keys(this._widgets);
      for (const i of t)
        this._widgets[i].render(e);
    }
  }
  class mj {
    constructor(e, t, i) {
      this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = dt(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
      const n = this._context.configuration.options, o = n.get(131);
      this._fixedOverflowWidgets = n.get(36), this._contentWidth = o.contentWidth, this._contentLeft = o.contentLeft, this._lineHeight = n.get(59), this._range = null, this._viewRange = null, this._preference = [], this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setDisplay("none"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options;
      if (this._lineHeight = t.get(59), e.hasChanged(131)) {
        const i = t.get(131);
        this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
      }
    }
    onLineMappingChanged(e) {
      this._setPosition(this._range);
    }
    _setPosition(e) {
      if (this._range = e, this._viewRange = null, this._range) {
        const t = this._context.viewModel.model.validateRange(this._range);
        (this._context.viewModel.coordinatesConverter.modelPositionIsVisible(t.getStartPosition()) || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(t.getEndPosition())) && (this._viewRange = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(t));
      }
    }
    _getMaxWidth() {
      return this.allowEditorOverflow ? window.innerWidth || document.documentElement.offsetWidth || document.body.offsetWidth : this._contentWidth;
    }
    setPosition(e, t) {
      this._setPosition(e), this._preference = t, this._viewRange && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none"), this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1;
    }
    _layoutBoxInViewport(e, t, i, n, o) {
      const r = e.top, a = r, l = t.top + this._lineHeight, c = o.viewportHeight - l, d = r - n, h = a >= n, u = l, f = c >= n;
      let g = e.left, _ = t.left;
      return g + i > o.scrollLeft + o.viewportWidth && (g = o.scrollLeft + o.viewportWidth - i), _ + i > o.scrollLeft + o.viewportWidth && (_ = o.scrollLeft + o.viewportWidth - i), g < o.scrollLeft && (g = o.scrollLeft), _ < o.scrollLeft && (_ = o.scrollLeft), {
        fitsAbove: h,
        aboveTop: d,
        aboveLeft: g,
        fitsBelow: f,
        belowTop: u,
        belowLeft: _
      };
    }
    _layoutHorizontalSegmentInPage(e, t, i, n) {
      const o = Math.max(0, t.left - n), r = Math.min(t.left + t.width + n, e.width);
      let a = t.left + i - rl.scrollX;
      if (a + n > r) {
        const l = a - (r - n);
        a -= l, i -= l;
      }
      if (a < o) {
        const l = a - o;
        a -= l, i -= l;
      }
      return [i, a];
    }
    _layoutBoxInPage(e, t, i, n, o) {
      const r = e.top - n, a = t.top + this._lineHeight, l = mn(this._viewDomNode.domNode), c = l.top + r - rl.scrollY, d = l.top + a - rl.scrollY, h = Nv(document.body), [u, f] = this._layoutHorizontalSegmentInPage(h, l, e.left - o.scrollLeft + this._contentLeft, i), [g, _] = this._layoutHorizontalSegmentInPage(h, l, t.left - o.scrollLeft + this._contentLeft, i), b = 22, C = 22, v = c >= b, w = d + n <= h.height - C;
      return this._fixedOverflowWidgets ? {
        fitsAbove: v,
        aboveTop: Math.max(c, b),
        aboveLeft: f,
        fitsBelow: w,
        belowTop: d,
        belowLeft: _
      } : {
        fitsAbove: v,
        aboveTop: r,
        aboveLeft: u,
        fitsBelow: w,
        belowTop: a,
        belowLeft: g
      };
    }
    _prepareRenderWidgetAtExactPositionOverflowing(e) {
      return new wg(e.top, e.left + this._contentLeft);
    }
    _getTopAndBottomLeft(e) {
      if (!this._viewRange)
        return [null, null];
      const t = e.linesVisibleRangesForRange(this._viewRange, !1);
      if (!t || t.length === 0)
        return [null, null];
      let i = t[0], n = t[0];
      for (const h of t)
        h.lineNumber < i.lineNumber && (i = h), h.lineNumber > n.lineNumber && (n = h);
      let o = 1073741824;
      for (const h of i.ranges)
        h.left < o && (o = h.left);
      let r = 1073741824;
      for (const h of n.ranges)
        h.left < r && (r = h.left);
      const a = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.scrollTop, l = new wg(a, o), c = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.scrollTop, d = new wg(c, r);
      return [l, d];
    }
    _prepareRenderWidget(e) {
      if (!this._preference || this._preference.length === 0)
        return null;
      const [t, i] = this._getTopAndBottomLeft(e);
      if (!t || !i)
        return null;
      if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
        let o = null;
        if (typeof this._actual.beforeRender == "function" && (o = Xw(this._actual.beforeRender, this._actual)), o)
          this._cachedDomNodeOffsetWidth = o.width, this._cachedDomNodeOffsetHeight = o.height;
        else {
          const r = this.domNode.domNode;
          this._cachedDomNodeOffsetWidth = r.offsetWidth, this._cachedDomNodeOffsetHeight = r.offsetHeight;
        }
      }
      let n;
      this.allowEditorOverflow ? n = this._layoutBoxInPage(t, i, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e) : n = this._layoutBoxInViewport(t, i, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e);
      for (let o = 1; o <= 2; o++)
        for (const r of this._preference)
          if (r === 1) {
            if (!n)
              return null;
            if (o === 2 || n.fitsAbove)
              return { coordinate: new wg(n.aboveTop, n.aboveLeft), position: 1 };
          } else if (r === 2) {
            if (!n)
              return null;
            if (o === 2 || n.fitsBelow)
              return { coordinate: new wg(n.belowTop, n.belowLeft), position: 2 };
          } else
            return this.allowEditorOverflow ? { coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(t), position: 0 } : { coordinate: t, position: 0 };
      return null;
    }
    onBeforeRender(e) {
      !this._viewRange || !this._preference || this._viewRange.endLineNumber < e.startLineNumber || this._viewRange.startLineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
    }
    prepareRender(e) {
      this._renderData = this._prepareRenderWidget(e);
    }
    render(e) {
      if (!this._renderData) {
        this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && Xw(this._actual.afterRender, this._actual, null);
        return;
      }
      this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && Xw(this._actual.afterRender, this._actual, this._renderData.position);
    }
  }
  function Xw(s, e, ...t) {
    try {
      return s.call(e, ...t);
    } catch {
      return null;
    }
  }
  class Z5 extends rg {
    constructor(e) {
      super(), this._context = e;
      const t = this._context.configuration.options, i = t.get(131);
      this._lineHeight = t.get(59), this._renderLineHighlight = t.get(85), this._renderLineHighlightOnlyWhenFocus = t.get(86), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new ae(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), super.dispose();
    }
    _readFromSelections() {
      let e = !1;
      const t = this._selections.map((n) => n.positionLineNumber);
      t.sort((n, o) => n - o), Gs(this._cursorLineNumbers, t) || (this._cursorLineNumbers = t, e = !0);
      const i = this._selections.every((n) => n.isEmpty());
      return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, e = !0), e;
    }
    onThemeChanged(e) {
      return this._readFromSelections();
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options, i = t.get(131);
      return this._lineHeight = t.get(59), this._renderLineHighlight = t.get(85), this._renderLineHighlightOnlyWhenFocus = t.get(86), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
    }
    onCursorStateChanged(e) {
      return this._selections = e.selections, this._readFromSelections();
    }
    onFlushed(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollWidthChanged || e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    onFocusChanged(e) {
      return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
    }
    prepareRender(e) {
      if (!this._shouldRenderThis()) {
        this._renderData = null;
        return;
      }
      const t = this._renderOne(e), i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = this._cursorLineNumbers.length;
      let r = 0;
      const a = [];
      for (let l = i; l <= n; l++) {
        const c = l - i;
        for (; r < o && this._cursorLineNumbers[r] < l; )
          r++;
        r < o && this._cursorLineNumbers[r] === l ? a[c] = t : a[c] = "";
      }
      this._renderData = a;
    }
    render(e, t) {
      if (!this._renderData)
        return "";
      const i = t - e;
      return i >= this._renderData.length ? "" : this._renderData[i];
    }
    _shouldRenderInMargin() {
      return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
    }
    _shouldRenderInContent() {
      return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
    }
  }
  class pj extends Z5 {
    _renderOne(e) {
      return `<div class="${"current-line" + (this._shouldRenderOther() ? " current-line-both" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px; height:${this._lineHeight}px;"></div>`;
    }
    _shouldRenderThis() {
      return this._shouldRenderInContent();
    }
    _shouldRenderOther() {
      return this._shouldRenderInMargin();
    }
  }
  class _j extends Z5 {
    _renderOne(e) {
      return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "")}" style="width:${this._contentLeft}px; height:${this._lineHeight}px;"></div>`;
    }
    _shouldRenderThis() {
      return !0;
    }
    _shouldRenderOther() {
      return this._shouldRenderInContent();
    }
  }
  Vt((s, e) => {
    const t = s.getColor(L$);
    if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || s.defines(CT)) {
      const i = s.getColor(CT);
      i && (e.addRule(`.monaco-editor .view-overlays .current-line { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid ${i}; }`), s.type === "hc" && (e.addRule(".monaco-editor .view-overlays .current-line { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }")));
    }
  });
  class bj extends rg {
    constructor(e) {
      super(), this._context = e;
      const t = this._context.configuration.options;
      this._lineHeight = t.get(59), this._typicalHalfwidthCharacterWidth = t.get(44).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options;
      return this._lineHeight = t.get(59), this._typicalHalfwidthCharacterWidth = t.get(44).typicalHalfwidthCharacterWidth, !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged || e.scrollWidthChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    prepareRender(e) {
      const t = e.getDecorationsInViewport();
      let i = [], n = 0;
      for (let l = 0, c = t.length; l < c; l++) {
        const d = t[l];
        d.options.className && (i[n++] = d);
      }
      i = i.sort((l, c) => {
        if (l.options.zIndex < c.options.zIndex)
          return -1;
        if (l.options.zIndex > c.options.zIndex)
          return 1;
        const d = l.options.className, h = c.options.className;
        return d < h ? -1 : d > h ? 1 : D.compareRangesUsingStarts(l.range, c.range);
      });
      const o = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, a = [];
      for (let l = o; l <= r; l++) {
        const c = l - o;
        a[c] = "";
      }
      this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
    }
    _renderWholeLineDecorations(e, t, i) {
      const n = String(this._lineHeight), o = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber;
      for (let a = 0, l = t.length; a < l; a++) {
        const c = t[a];
        if (!c.options.isWholeLine)
          continue;
        const d = '<div class="cdr ' + c.options.className + '" style="left:0;width:100%;height:' + n + 'px;"></div>', h = Math.max(c.range.startLineNumber, o), u = Math.min(c.range.endLineNumber, r);
        for (let f = h; f <= u; f++) {
          const g = f - o;
          i[g] += d;
        }
      }
    }
    _renderNormalDecorations(e, t, i) {
      const n = String(this._lineHeight), o = e.visibleRange.startLineNumber;
      let r = null, a = !1, l = null;
      for (let c = 0, d = t.length; c < d; c++) {
        const h = t[c];
        if (h.options.isWholeLine)
          continue;
        const u = h.options.className, f = Boolean(h.options.showIfCollapsed);
        let g = h.range;
        if (f && g.endColumn === 1 && g.endLineNumber !== g.startLineNumber && (g = new D(g.startLineNumber, g.startColumn, g.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(g.endLineNumber - 1))), r === u && a === f && D.areIntersectingOrTouching(l, g)) {
          l = D.plusRange(l, g);
          continue;
        }
        r !== null && this._renderNormalDecoration(e, l, r, a, n, o, i), r = u, a = f, l = g;
      }
      r !== null && this._renderNormalDecoration(e, l, r, a, n, o, i);
    }
    _renderNormalDecoration(e, t, i, n, o, r, a) {
      const l = e.linesVisibleRangesForRange(t, i === "findMatch");
      if (!!l)
        for (let c = 0, d = l.length; c < d; c++) {
          const h = l[c];
          if (h.outsideRenderedLine)
            continue;
          const u = h.lineNumber - r;
          if (n && h.ranges.length === 1) {
            const f = h.ranges[0];
            if (f.width < this._typicalHalfwidthCharacterWidth) {
              const g = Math.round(f.left + f.width / 2), _ = Math.max(0, Math.round(g - this._typicalHalfwidthCharacterWidth / 2));
              h.ranges[0] = new tC(_, this._typicalHalfwidthCharacterWidth);
            }
          }
          for (let f = 0, g = h.ranges.length; f < g; f++) {
            const _ = h.ranges[f], b = '<div class="cdr ' + i + '" style="left:' + String(_.left) + "px;width:" + String(_.width) + "px;height:" + o + 'px;"></div>';
            a[u] += b;
          }
        }
    }
    render(e, t) {
      if (!this._renderResult)
        return "";
      const i = t - e;
      return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
    }
  }
  class Qo extends z {
    onclick(e, t) {
      this._register(ee(e, ye.CLICK, (i) => t(new ho(i))));
    }
    onmousedown(e, t) {
      this._register(ee(e, ye.MOUSE_DOWN, (i) => t(new ho(i))));
    }
    onmouseover(e, t) {
      this._register(ee(e, ye.MOUSE_OVER, (i) => t(new ho(i))));
    }
    onnonbubblingmouseout(e, t) {
      this._register(kI(e, (i) => t(new ho(i))));
    }
    onkeydown(e, t) {
      this._register(ee(e, ye.KEY_DOWN, (i) => t(new $t(i))));
    }
    onkeyup(e, t) {
      this._register(ee(e, ye.KEY_UP, (i) => t(new $t(i))));
    }
    oninput(e, t) {
      this._register(ee(e, ye.INPUT, t));
    }
    onblur(e, t) {
      this._register(ee(e, ye.BLUR, t));
    }
    onfocus(e, t) {
      this._register(ee(e, ye.FOCUS, t));
    }
    ignoreGesture(e) {
      kt.ignoreTarget(e);
    }
  }
  const Sf = 11;
  class vj extends Qo {
    constructor(e) {
      super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...e.icon.classNamesArray), this.domNode.style.position = "absolute", this.domNode.style.width = Sf + "px", this.domNode.style.height = Sf + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._mouseMoveMonitor = this._register(new Ah()), this.onmousedown(this.bgDomNode, (t) => this._arrowMouseDown(t)), this.onmousedown(this.domNode, (t) => this._arrowMouseDown(t)), this._mousedownRepeatTimer = this._register(new o_()), this._mousedownScheduleRepeatTimer = this._register(new Ns());
    }
    _arrowMouseDown(e) {
      const t = () => {
        this._mousedownRepeatTimer.cancelAndSet(() => this._onActivate(), 41.666666666666664);
      };
      this._onActivate(), this._mousedownRepeatTimer.cancel(), this._mousedownScheduleRepeatTimer.cancelAndSet(t, 200), this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, ng, (i) => {
      }, () => {
        this._mousedownRepeatTimer.cancel(), this._mousedownScheduleRepeatTimer.cancel();
      }), e.preventDefault();
    }
  }
  class Cj extends z {
    constructor(e, t, i) {
      super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._rawShouldBeVisible = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new Ns());
    }
    setVisibility(e) {
      this._visibility !== e && (this._visibility = e, this._updateShouldBeVisible());
    }
    setShouldBeVisible(e) {
      this._rawShouldBeVisible = e, this._updateShouldBeVisible();
    }
    _applyVisibilitySetting() {
      return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : this._rawShouldBeVisible;
    }
    _updateShouldBeVisible() {
      const e = this._applyVisibilitySetting();
      this._shouldBeVisible !== e && (this._shouldBeVisible = e, this.ensureVisibility());
    }
    setIsNeeded(e) {
      this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
    }
    setDomNode(e) {
      this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
    }
    ensureVisibility() {
      if (!this._isNeeded) {
        this._hide(!1);
        return;
      }
      this._shouldBeVisible ? this._reveal() : this._hide(!0);
    }
    _reveal() {
      this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
        this._domNode && this._domNode.setClassName(this._visibleClassName);
      }, 0));
    }
    _hide(e) {
      this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, this._domNode && this._domNode.setClassName(this._invisibleClassName + (e ? " fade" : "")));
    }
  }
  const wj = 140;
  class Y5 extends Qo {
    constructor(e) {
      super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new Cj(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._mouseMoveMonitor = this._register(new Ah()), this._shouldRender = !0, this.domNode = dt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this.onmousedown(this.domNode.domNode, (t) => this._domNodeMouseDown(t));
    }
    _createArrow(e) {
      const t = this._register(new vj(e));
      this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
    }
    _createSlider(e, t, i, n) {
      this.slider = dt(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof n == "number" && this.slider.setHeight(n), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this.onmousedown(this.slider.domNode, (o) => {
        o.leftButton && (o.preventDefault(), this._sliderMouseDown(o, () => {
        }));
      }), this.onclick(this.slider.domNode, (o) => {
        o.leftButton && o.stopPropagation();
      });
    }
    _onElementSize(e) {
      return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
    }
    _onElementScrollSize(e) {
      return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
    }
    _onElementScrollPosition(e) {
      return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
    }
    beginReveal() {
      this._visibilityController.setShouldBeVisible(!0);
    }
    beginHide() {
      this._visibilityController.setShouldBeVisible(!1);
    }
    render() {
      !this._shouldRender || (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
    }
    _domNodeMouseDown(e) {
      e.target === this.domNode.domNode && this._onMouseDown(e);
    }
    delegateMouseDown(e) {
      const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), n = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), o = this._sliderMousePosition(e);
      i <= o && o <= n ? e.leftButton && (e.preventDefault(), this._sliderMouseDown(e, () => {
      })) : this._onMouseDown(e);
    }
    _onMouseDown(e) {
      let t, i;
      if (e.target === this.domNode.domNode && typeof e.browserEvent.offsetX == "number" && typeof e.browserEvent.offsetY == "number")
        t = e.browserEvent.offsetX, i = e.browserEvent.offsetY;
      else {
        const o = mn(this.domNode.domNode);
        t = e.posx - o.left, i = e.posy - o.top;
      }
      const n = this._mouseDownRelativePosition(t, i);
      this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(n) : this._scrollbarState.getDesiredScrollPositionFromOffset(n)), e.leftButton && (e.preventDefault(), this._sliderMouseDown(e, () => {
      }));
    }
    _sliderMouseDown(e, t) {
      const i = this._sliderMousePosition(e), n = this._sliderOrthogonalMousePosition(e), o = this._scrollbarState.clone();
      this.slider.toggleClassName("active", !0), this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, ng, (r) => {
        const a = this._sliderOrthogonalMousePosition(r), l = Math.abs(a - n);
        if (rn && l > wj) {
          this._setDesiredScrollPositionNow(o.getScrollPosition());
          return;
        }
        const d = this._sliderMousePosition(r) - i;
        this._setDesiredScrollPositionNow(o.getDesiredScrollPositionFromDelta(d));
      }, () => {
        this.slider.toggleClassName("active", !1), this._host.onDragEnd(), t();
      }), this._host.onDragStart();
    }
    _setDesiredScrollPositionNow(e) {
      const t = {};
      this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
    }
    updateScrollbarSize(e) {
      this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
    }
    isNeeded() {
      return this._scrollbarState.isNeeded();
    }
  }
  const Sj = 20;
  class Qm {
    constructor(e, t, i, n, o, r) {
      this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = n, this._scrollSize = o, this._scrollPosition = r, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
    }
    clone() {
      return new Qm(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    }
    setVisibleSize(e) {
      const t = Math.round(e);
      return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
    }
    setScrollSize(e) {
      const t = Math.round(e);
      return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
    }
    setScrollPosition(e) {
      const t = Math.round(e);
      return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
    }
    setScrollbarSize(e) {
      this._scrollbarSize = Math.round(e);
    }
    setOppositeScrollbarSize(e) {
      this._oppositeScrollbarSize = Math.round(e);
    }
    static _computeValues(e, t, i, n, o) {
      const r = Math.max(0, i - e), a = Math.max(0, r - 2 * t), l = n > 0 && n > i;
      if (!l)
        return {
          computedAvailableSize: Math.round(r),
          computedIsNeeded: l,
          computedSliderSize: Math.round(a),
          computedSliderRatio: 0,
          computedSliderPosition: 0
        };
      const c = Math.round(Math.max(Sj, Math.floor(i * a / n))), d = (a - c) / (n - i), h = o * d;
      return {
        computedAvailableSize: Math.round(r),
        computedIsNeeded: l,
        computedSliderSize: Math.round(c),
        computedSliderRatio: d,
        computedSliderPosition: Math.round(h)
      };
    }
    _refreshComputedValues() {
      const e = Qm._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
      this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
    }
    getArrowSize() {
      return this._arrowSize;
    }
    getScrollPosition() {
      return this._scrollPosition;
    }
    getRectangleLargeSize() {
      return this._computedAvailableSize;
    }
    getRectangleSmallSize() {
      return this._scrollbarSize;
    }
    isNeeded() {
      return this._computedIsNeeded;
    }
    getSliderSize() {
      return this._computedSliderSize;
    }
    getSliderPosition() {
      return this._computedSliderPosition;
    }
    getDesiredScrollPositionFromOffset(e) {
      if (!this._computedIsNeeded)
        return 0;
      const t = e - this._arrowSize - this._computedSliderSize / 2;
      return Math.round(t / this._computedSliderRatio);
    }
    getDesiredScrollPositionFromOffsetPaged(e) {
      if (!this._computedIsNeeded)
        return 0;
      const t = e - this._arrowSize;
      let i = this._scrollPosition;
      return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
    }
    getDesiredScrollPositionFromDelta(e) {
      if (!this._computedIsNeeded)
        return 0;
      const t = this._computedSliderPosition + e;
      return Math.round(t / this._computedSliderRatio);
    }
  }
  class yj extends Y5 {
    constructor(e, t, i) {
      const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
      if (super({
        lazyRender: t.lazyRender,
        host: i,
        scrollbarState: new Qm(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, n.width, n.scrollWidth, o.scrollLeft),
        visibility: t.horizontal,
        extraScrollbarClassName: "horizontal",
        scrollable: e,
        scrollByPage: t.scrollByPage
      }), t.horizontalHasArrows) {
        const r = (t.arrowSize - Sf) / 2, a = (t.horizontalScrollbarSize - Sf) / 2;
        this._createArrow({
          className: "scra",
          icon: p.scrollbarButtonLeft,
          top: a,
          left: r,
          bottom: void 0,
          right: void 0,
          bgWidth: t.arrowSize,
          bgHeight: t.horizontalScrollbarSize,
          onActivate: () => this._host.onMouseWheel(new uf(null, 1, 0))
        }), this._createArrow({
          className: "scra",
          icon: p.scrollbarButtonRight,
          top: a,
          left: void 0,
          bottom: void 0,
          right: r,
          bgWidth: t.arrowSize,
          bgHeight: t.horizontalScrollbarSize,
          onActivate: () => this._host.onMouseWheel(new uf(null, -1, 0))
        });
      }
      this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
    }
    _updateSlider(e, t) {
      this.slider.setWidth(e), this.slider.setLeft(t);
    }
    _renderDomNode(e, t) {
      this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
    }
    onDidScroll(e) {
      return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
    }
    _mouseDownRelativePosition(e, t) {
      return e;
    }
    _sliderMousePosition(e) {
      return e.posx;
    }
    _sliderOrthogonalMousePosition(e) {
      return e.posy;
    }
    _updateScrollbarSize(e) {
      this.slider.setHeight(e);
    }
    writeScrollPosition(e, t) {
      e.scrollLeft = t;
    }
    updateOptions(e) {
      this.updateScrollbarSize(e.horizontal === 2 ? 0 : e.horizontalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._visibilityController.setVisibility(e.horizontal), this._scrollByPage = e.scrollByPage;
    }
  }
  class Lj extends Y5 {
    constructor(e, t, i) {
      const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
      if (super({
        lazyRender: t.lazyRender,
        host: i,
        scrollbarState: new Qm(t.verticalHasArrows ? t.arrowSize : 0, t.vertical === 2 ? 0 : t.verticalScrollbarSize, 0, n.height, n.scrollHeight, o.scrollTop),
        visibility: t.vertical,
        extraScrollbarClassName: "vertical",
        scrollable: e,
        scrollByPage: t.scrollByPage
      }), t.verticalHasArrows) {
        const r = (t.arrowSize - Sf) / 2, a = (t.verticalScrollbarSize - Sf) / 2;
        this._createArrow({
          className: "scra",
          icon: p.scrollbarButtonUp,
          top: r,
          left: a,
          bottom: void 0,
          right: void 0,
          bgWidth: t.verticalScrollbarSize,
          bgHeight: t.arrowSize,
          onActivate: () => this._host.onMouseWheel(new uf(null, 0, 1))
        }), this._createArrow({
          className: "scra",
          icon: p.scrollbarButtonDown,
          top: void 0,
          left: a,
          bottom: r,
          right: void 0,
          bgWidth: t.verticalScrollbarSize,
          bgHeight: t.arrowSize,
          onActivate: () => this._host.onMouseWheel(new uf(null, 0, -1))
        });
      }
      this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
    }
    _updateSlider(e, t) {
      this.slider.setHeight(e), this.slider.setTop(t);
    }
    _renderDomNode(e, t) {
      this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
    }
    onDidScroll(e) {
      return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
    }
    _mouseDownRelativePosition(e, t) {
      return t;
    }
    _sliderMousePosition(e) {
      return e.posy;
    }
    _sliderOrthogonalMousePosition(e) {
      return e.posx;
    }
    _updateScrollbarSize(e) {
      this.slider.setWidth(e);
    }
    writeScrollPosition(e, t) {
      e.scrollTop = t;
    }
    updateOptions(e) {
      this.updateScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(0), this._visibilityController.setVisibility(e.vertical), this._scrollByPage = e.scrollByPage;
    }
  }
  class h1 {
    constructor(e, t, i, n, o, r, a) {
      this._forceIntegerValues = e, this._scrollStateBrand = void 0, this._forceIntegerValues && (t = t | 0, i = i | 0, n = n | 0, o = o | 0, r = r | 0, a = a | 0), this.rawScrollLeft = n, this.rawScrollTop = a, t < 0 && (t = 0), n + t > i && (n = i - t), n < 0 && (n = 0), o < 0 && (o = 0), a + o > r && (a = r - o), a < 0 && (a = 0), this.width = t, this.scrollWidth = i, this.scrollLeft = n, this.height = o, this.scrollHeight = r, this.scrollTop = a;
    }
    equals(e) {
      return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
    }
    withScrollDimensions(e, t) {
      return new h1(this._forceIntegerValues, typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
    }
    withScrollPosition(e) {
      return new h1(this._forceIntegerValues, this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
    }
    createScrollEvent(e, t) {
      const i = this.width !== e.width, n = this.scrollWidth !== e.scrollWidth, o = this.scrollLeft !== e.scrollLeft, r = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
      return {
        inSmoothScrolling: t,
        oldWidth: e.width,
        oldScrollWidth: e.scrollWidth,
        oldScrollLeft: e.scrollLeft,
        width: this.width,
        scrollWidth: this.scrollWidth,
        scrollLeft: this.scrollLeft,
        oldHeight: e.height,
        oldScrollHeight: e.scrollHeight,
        oldScrollTop: e.scrollTop,
        height: this.height,
        scrollHeight: this.scrollHeight,
        scrollTop: this.scrollTop,
        widthChanged: i,
        scrollWidthChanged: n,
        scrollLeftChanged: o,
        heightChanged: r,
        scrollHeightChanged: a,
        scrollTopChanged: l
      };
    }
  }
  class h_ extends z {
    constructor(e) {
      super(), this._scrollableBrand = void 0, this._onScroll = this._register(new B()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e.smoothScrollDuration, this._scheduleAtNextAnimationFrame = e.scheduleAtNextAnimationFrame, this._state = new h1(e.forceIntegerValues, 0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
    }
    dispose() {
      this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
    }
    setSmoothScrollDuration(e) {
      this._smoothScrollDuration = e;
    }
    validateScrollPosition(e) {
      return this._state.withScrollPosition(e);
    }
    getScrollDimensions() {
      return this._state;
    }
    setScrollDimensions(e, t) {
      const i = this._state.withScrollDimensions(e, t);
      this._setState(i, Boolean(this._smoothScrolling)), this._smoothScrolling && this._smoothScrolling.acceptScrollDimensions(this._state);
    }
    getFutureScrollPosition() {
      return this._smoothScrolling ? this._smoothScrolling.to : this._state;
    }
    getCurrentScrollPosition() {
      return this._state;
    }
    setScrollPositionNow(e) {
      const t = this._state.withScrollPosition(e);
      this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
    }
    setScrollPositionSmooth(e, t) {
      if (this._smoothScrollDuration === 0)
        return this.setScrollPositionNow(e);
      if (this._smoothScrolling) {
        e = {
          scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
          scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
        };
        const i = this._state.withScrollPosition(e);
        if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
          return;
        let n;
        t ? n = new Jm(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : n = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = n;
      } else {
        const i = this._state.withScrollPosition(e);
        this._smoothScrolling = Jm.start(this._state, i, this._smoothScrollDuration);
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        !this._smoothScrolling || (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
    _performSmoothScrolling() {
      if (!this._smoothScrolling)
        return;
      const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
      if (this._setState(t, !0), !!this._smoothScrolling) {
        if (e.isDone) {
          this._smoothScrolling.dispose(), this._smoothScrolling = null;
          return;
        }
        this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
          !this._smoothScrolling || (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
        });
      }
    }
    _setState(e, t) {
      const i = this._state;
      i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
    }
  }
  class wT {
    constructor(e, t, i) {
      this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
    }
  }
  function Qw(s, e) {
    const t = e - s;
    return function(i) {
      return s + t * xj(i);
    };
  }
  function kj(s, e, t) {
    return function(i) {
      return i < t ? s(i / t) : e((i - t) / (1 - t));
    };
  }
  class Jm {
    constructor(e, t, i, n) {
      this.from = e, this.to = t, this.duration = n, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
    }
    _initAnimations() {
      this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
    }
    _initAnimation(e, t, i) {
      if (Math.abs(e - t) > 2.5 * i) {
        let o, r;
        return e < t ? (o = e + 0.75 * i, r = t - 0.75 * i) : (o = e - 0.75 * i, r = t + 0.75 * i), kj(Qw(e, o), Qw(r, t), 0.33);
      }
      return Qw(e, t);
    }
    dispose() {
      this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
    }
    acceptScrollDimensions(e) {
      this.to = e.withScrollPosition(this.to), this._initAnimations();
    }
    tick() {
      return this._tick(Date.now());
    }
    _tick(e) {
      const t = (e - this.startTime) / this.duration;
      if (t < 1) {
        const i = this.scrollLeft(t), n = this.scrollTop(t);
        return new wT(i, n, !1);
      }
      return new wT(this.to.scrollLeft, this.to.scrollTop, !0);
    }
    combine(e, t, i) {
      return Jm.start(e, t, i);
    }
    static start(e, t, i) {
      i = i + 10;
      const n = Date.now() - 10;
      return new Jm(e, t, n, i);
    }
  }
  function Dj(s) {
    return Math.pow(s, 3);
  }
  function xj(s) {
    return 1 - Dj(1 - s);
  }
  const Ij = 500, ST = 50;
  class Ej {
    constructor(e, t, i) {
      this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
    }
  }
  class kL {
    constructor() {
      this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
    }
    isPhysicalMouseWheel() {
      if (this._front === -1 && this._rear === -1)
        return !1;
      let e = 1, t = 0, i = 1, n = this._rear;
      do {
        const o = n === this._front ? e : Math.pow(2, -i);
        if (e -= o, t += this._memory[n].score * o, n === this._front)
          break;
        n = (this._capacity + n - 1) % this._capacity, i++;
      } while (!0);
      return t <= 0.5;
    }
    accept(e, t, i) {
      const n = new Ej(e, t, i);
      n.score = this._computeScore(n), this._front === -1 && this._rear === -1 ? (this._memory[0] = n, this._front = 0, this._rear = 0) : (this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = n);
    }
    _computeScore(e) {
      if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
        return 1;
      let t = 0.5;
      return this._front === -1 && this._rear === -1 || this._memory[this._rear], (!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (t += 0.25), Math.min(Math.max(t, 0), 1);
    }
    _isAlmostInt(e) {
      return Math.abs(Math.round(e) - e) < 0.01;
    }
  }
  kL.INSTANCE = new kL();
  class hE extends Qo {
    constructor(e, t, i) {
      super(), this._onScroll = this._register(new B()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new B()), e.style.overflow = "hidden", this._options = Nj(t), this._scrollable = i, this._register(this._scrollable.onScroll((o) => {
        this._onWillScroll.fire(o), this._onDidScroll(o), this._onScroll.fire(o);
      }));
      const n = {
        onMouseWheel: (o) => this._onMouseWheel(o),
        onDragStart: () => this._onDragStart(),
        onDragEnd: () => this._onDragEnd()
      };
      this._verticalScrollbar = this._register(new Lj(this._scrollable, this._options, n)), this._horizontalScrollbar = this._register(new yj(this._scrollable, this._options, n)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = dt(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = dt(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = dt(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (o) => this._onMouseOver(o)), this.onnonbubblingmouseout(this._listenOnDomNode, (o) => this._onMouseOut(o)), this._hideTimeout = this._register(new Ns()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
    }
    get options() {
      return this._options;
    }
    dispose() {
      this._mouseWheelToDispose = at(this._mouseWheelToDispose), super.dispose();
    }
    getDomNode() {
      return this._domNode;
    }
    getOverviewRulerLayoutInfo() {
      return {
        parent: this._domNode,
        insertBefore: this._verticalScrollbar.domNode.domNode
      };
    }
    delegateVerticalScrollbarMouseDown(e) {
      this._verticalScrollbar.delegateMouseDown(e);
    }
    getScrollDimensions() {
      return this._scrollable.getScrollDimensions();
    }
    setScrollDimensions(e) {
      this._scrollable.setScrollDimensions(e, !1);
    }
    updateClassName(e) {
      this._options.className = e, Ye && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
    }
    updateOptions(e) {
      typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontal < "u" && (this._options.horizontal = e.horizontal), typeof e.vertical < "u" && (this._options.vertical = e.vertical), typeof e.horizontalScrollbarSize < "u" && (this._options.horizontalScrollbarSize = e.horizontalScrollbarSize), typeof e.verticalScrollbarSize < "u" && (this._options.verticalScrollbarSize = e.verticalScrollbarSize), typeof e.scrollByPage < "u" && (this._options.scrollByPage = e.scrollByPage), this._horizontalScrollbar.updateOptions(this._options), this._verticalScrollbar.updateOptions(this._options), this._options.lazyRender || this._render();
    }
    _setListeningToMouseWheel(e) {
      if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = at(this._mouseWheelToDispose), e)) {
        const i = (n) => {
          this._onMouseWheel(new uf(n));
        };
        this._mouseWheelToDispose.push(ee(this._listenOnDomNode, ye.MOUSE_WHEEL, i, { passive: !1 }));
      }
    }
    _onMouseWheel(e) {
      const t = kL.INSTANCE;
      {
        const o = window.devicePixelRatio / Z4();
        rn || Nn ? t.accept(Date.now(), e.deltaX / o, e.deltaY / o) : t.accept(Date.now(), e.deltaX, e.deltaY);
      }
      let i = !1;
      if (e.deltaY || e.deltaX) {
        let o = e.deltaY * this._options.mouseWheelScrollSensitivity, r = e.deltaX * this._options.mouseWheelScrollSensitivity;
        this._options.scrollPredominantAxis && (Math.abs(o) >= Math.abs(r) ? r = 0 : o = 0), this._options.flipAxes && ([o, r] = [r, o]);
        const a = !Ye && e.browserEvent && e.browserEvent.shiftKey;
        (this._options.scrollYToX || a) && !r && (r = o, o = 0), e.browserEvent && e.browserEvent.altKey && (r = r * this._options.fastScrollSensitivity, o = o * this._options.fastScrollSensitivity);
        const l = this._scrollable.getFutureScrollPosition();
        let c = {};
        if (o) {
          const d = ST * o, h = l.scrollTop - (d < 0 ? Math.floor(d) : Math.ceil(d));
          this._verticalScrollbar.writeScrollPosition(c, h);
        }
        if (r) {
          const d = ST * r, h = l.scrollLeft - (d < 0 ? Math.floor(d) : Math.ceil(d));
          this._horizontalScrollbar.writeScrollPosition(c, h);
        }
        c = this._scrollable.validateScrollPosition(c), (l.scrollLeft !== c.scrollLeft || l.scrollTop !== c.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(c) : this._scrollable.setScrollPositionNow(c), i = !0);
      }
      let n = i;
      !n && this._options.alwaysConsumeMouseWheel && (n = !0), !n && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (n = !0), n && (e.preventDefault(), e.stopPropagation());
    }
    _onDidScroll(e) {
      this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
    }
    renderNow() {
      if (!this._options.lazyRender)
        throw new Error("Please use `lazyRender` together with `renderNow`!");
      this._render();
    }
    _render() {
      if (!!this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
        const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, n = i ? " left" : "", o = t ? " top" : "", r = i || t ? " top-left-corner" : "";
        this._leftShadowDomNode.setClassName(`shadow${n}`), this._topShadowDomNode.setClassName(`shadow${o}`), this._topLeftShadowDomNode.setClassName(`shadow${r}${o}${n}`);
      }
    }
    _onDragStart() {
      this._isDragging = !0, this._reveal();
    }
    _onDragEnd() {
      this._isDragging = !1, this._hide();
    }
    _onMouseOut(e) {
      this._mouseIsOver = !1, this._hide();
    }
    _onMouseOver(e) {
      this._mouseIsOver = !0, this._reveal();
    }
    _reveal() {
      this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
    }
    _hide() {
      !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
    }
    _scheduleHide() {
      !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), Ij);
    }
  }
  class X5 extends hE {
    constructor(e, t) {
      t = t || {}, t.mouseWheelSmoothScroll = !1;
      const i = new h_({
        forceIntegerValues: !0,
        smoothScrollDuration: 0,
        scheduleAtNextAnimationFrame: (n) => _r(n)
      });
      super(e, t, i), this._register(i);
    }
    setScrollPosition(e) {
      this._scrollable.setScrollPositionNow(e);
    }
  }
  class uE extends hE {
    constructor(e, t, i) {
      super(e, t, i);
    }
    setScrollPosition(e) {
      e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
    }
    getScrollPosition() {
      return this._scrollable.getCurrentScrollPosition();
    }
  }
  class u_ extends hE {
    constructor(e, t) {
      t = t || {}, t.mouseWheelSmoothScroll = !1;
      const i = new h_({
        forceIntegerValues: !1,
        smoothScrollDuration: 0,
        scheduleAtNextAnimationFrame: (n) => _r(n)
      });
      super(e, t, i), this._register(i), this._element = e, this.onScroll((n) => {
        n.scrollTopChanged && (this._element.scrollTop = n.scrollTop), n.scrollLeftChanged && (this._element.scrollLeft = n.scrollLeft);
      }), this.scanDomNode();
    }
    setScrollPosition(e) {
      this._scrollable.setScrollPositionNow(e);
    }
    getScrollPosition() {
      return this._scrollable.getCurrentScrollPosition();
    }
    scanDomNode() {
      this.setScrollDimensions({
        width: this._element.clientWidth,
        scrollWidth: this._element.scrollWidth,
        height: this._element.clientHeight,
        scrollHeight: this._element.scrollHeight
      }), this.setScrollPosition({
        scrollLeft: this._element.scrollLeft,
        scrollTop: this._element.scrollTop
      });
    }
  }
  function Nj(s) {
    const e = {
      lazyRender: typeof s.lazyRender < "u" ? s.lazyRender : !1,
      className: typeof s.className < "u" ? s.className : "",
      useShadows: typeof s.useShadows < "u" ? s.useShadows : !0,
      handleMouseWheel: typeof s.handleMouseWheel < "u" ? s.handleMouseWheel : !0,
      flipAxes: typeof s.flipAxes < "u" ? s.flipAxes : !1,
      consumeMouseWheelIfScrollbarIsNeeded: typeof s.consumeMouseWheelIfScrollbarIsNeeded < "u" ? s.consumeMouseWheelIfScrollbarIsNeeded : !1,
      alwaysConsumeMouseWheel: typeof s.alwaysConsumeMouseWheel < "u" ? s.alwaysConsumeMouseWheel : !1,
      scrollYToX: typeof s.scrollYToX < "u" ? s.scrollYToX : !1,
      mouseWheelScrollSensitivity: typeof s.mouseWheelScrollSensitivity < "u" ? s.mouseWheelScrollSensitivity : 1,
      fastScrollSensitivity: typeof s.fastScrollSensitivity < "u" ? s.fastScrollSensitivity : 5,
      scrollPredominantAxis: typeof s.scrollPredominantAxis < "u" ? s.scrollPredominantAxis : !0,
      mouseWheelSmoothScroll: typeof s.mouseWheelSmoothScroll < "u" ? s.mouseWheelSmoothScroll : !0,
      arrowSize: typeof s.arrowSize < "u" ? s.arrowSize : 11,
      listenOnDomNode: typeof s.listenOnDomNode < "u" ? s.listenOnDomNode : null,
      horizontal: typeof s.horizontal < "u" ? s.horizontal : 1,
      horizontalScrollbarSize: typeof s.horizontalScrollbarSize < "u" ? s.horizontalScrollbarSize : 10,
      horizontalSliderSize: typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : 0,
      horizontalHasArrows: typeof s.horizontalHasArrows < "u" ? s.horizontalHasArrows : !1,
      vertical: typeof s.vertical < "u" ? s.vertical : 1,
      verticalScrollbarSize: typeof s.verticalScrollbarSize < "u" ? s.verticalScrollbarSize : 10,
      verticalHasArrows: typeof s.verticalHasArrows < "u" ? s.verticalHasArrows : !1,
      verticalSliderSize: typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : 0,
      scrollByPage: typeof s.scrollByPage < "u" ? s.scrollByPage : !1
    };
    return e.horizontalSliderSize = typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : e.verticalScrollbarSize, Ye && (e.className += " mac"), e;
  }
  class Tj extends Do {
    constructor(e, t, i, n) {
      super(e);
      const o = this._context.configuration.options, r = o.get(92), a = o.get(67), l = o.get(34), c = o.get(95), d = {
        listenOnDomNode: i.domNode,
        className: "editor-scrollable " + X0(e.theme.type),
        useShadows: !1,
        lazyRender: !0,
        vertical: r.vertical,
        horizontal: r.horizontal,
        verticalHasArrows: r.verticalHasArrows,
        horizontalHasArrows: r.horizontalHasArrows,
        verticalScrollbarSize: r.verticalScrollbarSize,
        verticalSliderSize: r.verticalSliderSize,
        horizontalScrollbarSize: r.horizontalScrollbarSize,
        horizontalSliderSize: r.horizontalSliderSize,
        handleMouseWheel: r.handleMouseWheel,
        alwaysConsumeMouseWheel: r.alwaysConsumeMouseWheel,
        arrowSize: r.arrowSize,
        mouseWheelScrollSensitivity: a,
        fastScrollSensitivity: l,
        scrollPredominantAxis: c,
        scrollByPage: r.scrollByPage
      };
      this.scrollbar = this._register(new uE(t.domNode, d, this._context.viewLayout.getScrollable())), ha.write(this.scrollbar.getDomNode(), 5), this.scrollbarDomNode = dt(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
      const h = (u, f, g) => {
        const _ = {};
        if (f) {
          const b = u.scrollTop;
          b && (_.scrollTop = this._context.viewLayout.getCurrentScrollTop() + b, u.scrollTop = 0);
        }
        if (g) {
          const b = u.scrollLeft;
          b && (_.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + b, u.scrollLeft = 0);
        }
        this._context.viewModel.viewLayout.setScrollPosition(_, 1);
      };
      this._register(ee(i.domNode, "scroll", (u) => h(i.domNode, !0, !0))), this._register(ee(t.domNode, "scroll", (u) => h(t.domNode, !0, !1))), this._register(ee(n.domNode, "scroll", (u) => h(n.domNode, !0, !1))), this._register(ee(this.scrollbarDomNode.domNode, "scroll", (u) => h(this.scrollbarDomNode.domNode, !0, !1)));
    }
    dispose() {
      super.dispose();
    }
    _setLayout() {
      const e = this._context.configuration.options, t = e.get(131);
      this.scrollbarDomNode.setLeft(t.contentLeft), e.get(65).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
    }
    getOverviewRulerLayoutInfo() {
      return this.scrollbar.getOverviewRulerLayoutInfo();
    }
    getDomNode() {
      return this.scrollbarDomNode;
    }
    delegateVerticalScrollbarMouseDown(e) {
      this.scrollbar.delegateVerticalScrollbarMouseDown(e);
    }
    onConfigurationChanged(e) {
      if (e.hasChanged(92) || e.hasChanged(67) || e.hasChanged(34)) {
        const t = this._context.configuration.options, i = t.get(92), n = t.get(67), o = t.get(34), r = t.get(95), a = {
          vertical: i.vertical,
          horizontal: i.horizontal,
          verticalScrollbarSize: i.verticalScrollbarSize,
          horizontalScrollbarSize: i.horizontalScrollbarSize,
          scrollByPage: i.scrollByPage,
          handleMouseWheel: i.handleMouseWheel,
          mouseWheelScrollSensitivity: n,
          fastScrollSensitivity: o,
          scrollPredominantAxis: r
        };
        this.scrollbar.updateOptions(a);
      }
      return e.hasChanged(131) && this._setLayout(), !0;
    }
    onScrollChanged(e) {
      return !0;
    }
    onThemeChanged(e) {
      return this.scrollbar.updateClassName("editor-scrollable " + X0(this._context.theme.type)), !0;
    }
    prepareRender(e) {
    }
    render(e) {
      this.scrollbar.renderNow();
    }
  }
  Vt((s, e) => {
    const t = s.getColor(sg);
    t && e.addRule(`
			.monaco-scrollable-element > .shadow.top {
				box-shadow: ${t} 0 6px 6px -6px inset;
			}

			.monaco-scrollable-element > .shadow.left {
				box-shadow: ${t} 6px 0 6px -6px inset;
			}

			.monaco-scrollable-element > .shadow.top.left {
				box-shadow: ${t} 6px 6px 6px -6px inset;
			}
		`);
    const i = s.getColor(qu);
    i && e.addRule(`
			.monaco-scrollable-element > .scrollbar > .slider {
				background: ${i};
			}
		`);
    const n = s.getColor(Gu);
    n && e.addRule(`
			.monaco-scrollable-element > .scrollbar > .slider:hover {
				background: ${n};
			}
		`);
    const o = s.getColor(Zu);
    o && e.addRule(`
			.monaco-scrollable-element > .scrollbar > .slider.active {
				background: ${o};
			}
		`);
  });
  class u1 {
    constructor(e, t, i) {
      this._decorationToRenderBrand = void 0, this.startLineNumber = +e, this.endLineNumber = +t, this.className = String(i);
    }
  }
  class fE extends rg {
    _render(e, t, i) {
      const n = [];
      for (let a = e; a <= t; a++) {
        const l = a - e;
        n[l] = [];
      }
      if (i.length === 0)
        return n;
      i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
      let o = null, r = 0;
      for (let a = 0, l = i.length; a < l; a++) {
        const c = i[a], d = c.className;
        let h = Math.max(c.startLineNumber, e) - e;
        const u = Math.min(c.endLineNumber, t) - e;
        o === d ? (h = Math.max(r + 1, h), r = Math.max(r, u)) : (o = d, r = u);
        for (let f = h; f <= r; f++)
          n[f].push(o);
      }
      return n;
    }
  }
  class Mj extends fE {
    constructor(e) {
      super(), this._context = e;
      const t = this._context.configuration.options, i = t.get(131);
      this._lineHeight = t.get(59), this._glyphMargin = t.get(50), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._renderResult = null, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options, i = t.get(131);
      return this._lineHeight = t.get(59), this._glyphMargin = t.get(50), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    _getDecorations(e) {
      const t = e.getDecorationsInViewport(), i = [];
      let n = 0;
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.options.glyphMarginClassName;
        l && (i[n++] = new u1(a.range.startLineNumber, a.range.endLineNumber, l));
      }
      return i;
    }
    prepareRender(e) {
      if (!this._glyphMargin) {
        this._renderResult = null;
        return;
      }
      const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = this._lineHeight.toString(), r = this._glyphMarginLeft.toString(), a = this._glyphMarginWidth.toString(), l = '" style="left:' + r + "px;width:" + a + "px;height:" + o + 'px;"></div>', c = [];
      for (let d = t; d <= i; d++) {
        const h = d - t, u = n[h];
        u.length === 0 ? c[h] = "" : c[h] = '<div class="cgmr codicon ' + u.join(" ") + l;
      }
      this._renderResult = c;
    }
    render(e, t) {
      if (!this._renderResult)
        return "";
      const i = t - e;
      return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
    }
  }
  class Aj {
    constructor() {
      this._isDisposed = !1;
    }
    dispose() {
      this._isDisposed = !0;
    }
    assertNotDisposed() {
      if (this._isDisposed)
        throw new Error("TextModelPart is disposed!");
    }
  }
  function cC(s, e) {
    let t = 0, i = 0;
    const n = s.length;
    for (; i < n; ) {
      const o = s.charCodeAt(i);
      if (o === 32)
        t++;
      else if (o === 9)
        t = t - t % e + e;
      else
        break;
      i++;
    }
    return i === n ? -1 : t;
  }
  var Rd;
  (function(s) {
    s[s.Disabled = 0] = "Disabled", s[s.EnabledForActive = 1] = "EnabledForActive", s[s.Enabled = 2] = "Enabled";
  })(Rd || (Rd = {}));
  class Eu {
    constructor(e, t, i) {
      this.visibleColumn = e, this.className = t, this.horizontalLine = i;
    }
  }
  class DL {
    constructor(e, t) {
      this.top = e, this.endColumn = t;
    }
  }
  class Rj extends Aj {
    constructor(e, t) {
      super(), this.textModel = e, this.languageConfigurationService = t;
    }
    getLanguageConfiguration(e) {
      return this.languageConfigurationService.getLanguageConfiguration(e);
    }
    _computeIndentLevel(e) {
      return cC(this.textModel.getLineContent(e + 1), this.textModel.getOptions().tabSize);
    }
    getActiveIndentGuide(e, t, i) {
      this.assertNotDisposed();
      const n = this.textModel.getLineCount();
      if (e < 1 || e > n)
        throw new Error("Illegal value for lineNumber");
      const o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = Boolean(o && o.offSide);
      let a = -2, l = -1, c = -2, d = -1;
      const h = (y) => {
        if (a !== -1 && (a === -2 || a > y - 1)) {
          a = -1, l = -1;
          for (let k = y - 2; k >= 0; k--) {
            const I = this._computeIndentLevel(k);
            if (I >= 0) {
              a = k, l = I;
              break;
            }
          }
        }
        if (c === -2) {
          c = -1, d = -1;
          for (let k = y; k < n; k++) {
            const I = this._computeIndentLevel(k);
            if (I >= 0) {
              c = k, d = I;
              break;
            }
          }
        }
      };
      let u = -2, f = -1, g = -2, _ = -1;
      const b = (y) => {
        if (u === -2) {
          u = -1, f = -1;
          for (let k = y - 2; k >= 0; k--) {
            const I = this._computeIndentLevel(k);
            if (I >= 0) {
              u = k, f = I;
              break;
            }
          }
        }
        if (g !== -1 && (g === -2 || g < y - 1)) {
          g = -1, _ = -1;
          for (let k = y; k < n; k++) {
            const I = this._computeIndentLevel(k);
            if (I >= 0) {
              g = k, _ = I;
              break;
            }
          }
        }
      };
      let C = 0, v = !0, w = 0, S = !0, L = 0, x = 0;
      for (let y = 0; v || S; y++) {
        const k = e - y, I = e + y;
        y > 1 && (k < 1 || k < t) && (v = !1), y > 1 && (I > n || I > i) && (S = !1), y > 5e4 && (v = !1, S = !1);
        let F = -1;
        if (v && k >= 1) {
          const $ = this._computeIndentLevel(k - 1);
          $ >= 0 ? (c = k - 1, d = $, F = Math.ceil($ / this.textModel.getOptions().indentSize)) : (h(k), F = this._getIndentLevelForWhitespaceLine(r, l, d));
        }
        let R = -1;
        if (S && I <= n) {
          const $ = this._computeIndentLevel(I - 1);
          $ >= 0 ? (u = I - 1, f = $, R = Math.ceil($ / this.textModel.getOptions().indentSize)) : (b(I), R = this._getIndentLevelForWhitespaceLine(r, f, _));
        }
        if (y === 0) {
          x = F;
          continue;
        }
        if (y === 1) {
          if (I <= n && R >= 0 && x + 1 === R) {
            v = !1, C = I, w = I, L = R;
            continue;
          }
          if (k >= 1 && F >= 0 && F - 1 === x) {
            S = !1, C = k, w = k, L = F;
            continue;
          }
          if (C = e, w = e, L = x, L === 0)
            return { startLineNumber: C, endLineNumber: w, indent: L };
        }
        v && (F >= L ? C = k : v = !1), S && (R >= L ? w = I : S = !1);
      }
      return { startLineNumber: C, endLineNumber: w, indent: L };
    }
    getLinesBracketGuides(e, t, i, n) {
      var o, r, a, l, c;
      const d = [], h = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new D(e, 1, t, this.textModel.getLineMaxColumn(t)));
      let u;
      if (i && h.length > 0) {
        const C = e <= i.lineNumber && i.lineNumber <= t ? h.filter((v) => D.strictContainsPosition(v.range, i)) : this.textModel.bracketPairs.getBracketPairsInRange(D.fromPositions(i));
        u = (o = RV(C, (v) => v.range.startLineNumber !== v.range.endLineNumber)) === null || o === void 0 ? void 0 : o.range;
      }
      const f = new bf(h), g = new Array(), _ = new Array(), b = new Q5();
      for (let C = e; C <= t; C++) {
        let v = new Array();
        _.length > 0 && (v = v.concat(_), _.length = 0), d.push(v);
        for (const S of f.takeWhile((L) => L.openingBracketRange.startLineNumber <= C) || []) {
          if (S.range.startLineNumber === S.range.endLineNumber)
            continue;
          const L = Math.min(this.getVisibleColumnFromPosition(S.openingBracketRange.getStartPosition()), this.getVisibleColumnFromPosition((a = (r = S.closingBracketRange) === null || r === void 0 ? void 0 : r.getStartPosition()) !== null && a !== void 0 ? a : S.range.getEndPosition()), S.minVisibleColumnIndentation + 1);
          let x = !1;
          S.closingBracketRange && jn(this.textModel.getLineContent(S.closingBracketRange.startLineNumber)) < S.closingBracketRange.startColumn - 1 && (x = !0);
          const y = S.openingBracketRange.getStartPosition(), k = (c = (l = S.closingBracketRange) === null || l === void 0 ? void 0 : l.getStartPosition()) !== null && c !== void 0 ? c : S.range.getEndPosition();
          S.closingBracketRange === void 0 ? g[S.nestingLevel] = null : g[S.nestingLevel] = {
            nestingLevel: S.nestingLevel,
            guideVisibleColumn: L,
            start: y,
            visibleStartColumn: this.getVisibleColumnFromPosition(y),
            end: k,
            visibleEndColumn: this.getVisibleColumnFromPosition(k),
            bracketPair: S,
            renderHorizontalEndLineAtTheBottom: x
          };
        }
        for (const S of g) {
          if (!S)
            continue;
          const L = u && S.bracketPair.range.equalsRange(u), x = b.getInlineClassNameOfLevel(S.nestingLevel) + (n.highlightActive && L ? " " + b.activeClassName : "");
          (L && n.horizontalGuides !== Rd.Disabled || n.includeInactive && n.horizontalGuides === Rd.Enabled) && (S.start.lineNumber === C && S.guideVisibleColumn < S.visibleStartColumn && v.push(new Eu(S.guideVisibleColumn, x, new DL(!1, S.start.column))), S.end.lineNumber === C + 1 && S.guideVisibleColumn < S.visibleEndColumn && _.push(new Eu(S.guideVisibleColumn, x, new DL(!S.renderHorizontalEndLineAtTheBottom, S.end.column))));
        }
        let w = Number.MAX_SAFE_INTEGER;
        for (let S = g.length - 1; S >= 0; S--) {
          const L = g[S];
          if (!L)
            continue;
          const x = n.highlightActive && u && L.bracketPair.range.equalsRange(u), y = b.getInlineClassNameOfLevel(L.nestingLevel) + (x ? " " + b.activeClassName : "");
          (x || n.includeInactive) && L.renderHorizontalEndLineAtTheBottom && L.end.lineNumber === C + 1 && _.push(new Eu(L.guideVisibleColumn, y, null)), !(L.end.lineNumber <= C || L.start.lineNumber >= C) && (L.guideVisibleColumn >= w && !x || (w = L.guideVisibleColumn, (x || n.includeInactive) && v.push(new Eu(L.guideVisibleColumn, y, null))));
        }
        v.sort((S, L) => S.visibleColumn - L.visibleColumn);
      }
      return d;
    }
    getVisibleColumnFromPosition(e) {
      return Oi.visibleColumnFromColumn(this.textModel.getLineContent(e.lineNumber), e.column, this.textModel.getOptions().tabSize) + 1;
    }
    getLinesIndentGuides(e, t) {
      this.assertNotDisposed();
      const i = this.textModel.getLineCount();
      if (e < 1 || e > i)
        throw new Error("Illegal value for startLineNumber");
      if (t < 1 || t > i)
        throw new Error("Illegal value for endLineNumber");
      const n = this.textModel.getOptions(), o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = Boolean(o && o.offSide), a = new Array(t - e + 1);
      let l = -2, c = -1, d = -2, h = -1;
      for (let u = e; u <= t; u++) {
        const f = u - e, g = this._computeIndentLevel(u - 1);
        if (g >= 0) {
          l = u - 1, c = g, a[f] = Math.ceil(g / n.indentSize);
          continue;
        }
        if (l === -2) {
          l = -1, c = -1;
          for (let _ = u - 2; _ >= 0; _--) {
            const b = this._computeIndentLevel(_);
            if (b >= 0) {
              l = _, c = b;
              break;
            }
          }
        }
        if (d !== -1 && (d === -2 || d < u - 1)) {
          d = -1, h = -1;
          for (let _ = u; _ < i; _++) {
            const b = this._computeIndentLevel(_);
            if (b >= 0) {
              d = _, h = b;
              break;
            }
          }
        }
        a[f] = this._getIndentLevelForWhitespaceLine(r, c, h);
      }
      return a;
    }
    _getIndentLevelForWhitespaceLine(e, t, i) {
      const n = this.textModel.getOptions();
      return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / n.indentSize) : t === i || e ? Math.ceil(i / n.indentSize) : 1 + Math.floor(i / n.indentSize);
    }
  }
  class Q5 {
    constructor() {
      this.activeClassName = "indent-active";
    }
    getInlineClassNameOfLevel(e) {
      return `bracket-indent-guide lvl-${e % 30}`;
    }
  }
  class Oj extends rg {
    constructor(e) {
      super(), this._context = e, this._primaryPosition = null;
      const t = this._context.configuration.options, i = t.get(132), n = t.get(44);
      this._lineHeight = t.get(59), this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(13), this._renderResult = null, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options, i = t.get(132), n = t.get(44);
      return this._lineHeight = t.get(59), this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(13), !0;
    }
    onCursorStateChanged(e) {
      var t;
      const n = e.selections[0].getPosition();
      return !((t = this._primaryPosition) === null || t === void 0) && t.equals(n) ? !1 : (this._primaryPosition = n, !0);
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    onLanguageConfigurationChanged(e) {
      return !0;
    }
    prepareRender(e) {
      var t, i, n, o;
      if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === !1) {
        this._renderResult = null;
        return;
      }
      const r = e.visibleRange.startLineNumber, a = e.visibleRange.endLineNumber, l = e.scrollWidth, c = this._lineHeight, d = this._primaryPosition, h = this.getGuidesByLine(r, a, d), u = [];
      for (let f = r; f <= a; f++) {
        const g = f - r, _ = h[g];
        let b = "";
        const C = (i = (t = e.visibleRangeForPosition(new V(f, 1))) === null || t === void 0 ? void 0 : t.left) !== null && i !== void 0 ? i : 0;
        for (const v of _) {
          const w = C + (v.visibleColumn - 1) * this._spaceWidth;
          if (w > l || this._maxIndentLeft > 0 && w > this._maxIndentLeft)
            break;
          const S = v.horizontalLine ? v.horizontalLine.top ? "horizontal-top" : "horizontal-bottom" : "vertical", L = v.horizontalLine ? ((o = (n = e.visibleRangeForPosition(new V(f, v.horizontalLine.endColumn))) === null || n === void 0 ? void 0 : n.left) !== null && o !== void 0 ? o : w + this._spaceWidth) - w : this._spaceWidth;
          b += `<div class="core-guide ${v.className} ${S}" style="left:${w}px;height:${c}px;width:${L}px"></div>`;
        }
        u[g] = b;
      }
      this._renderResult = u;
    }
    getGuidesByLine(e, t, i) {
      const n = this._bracketPairGuideOptions.bracketPairs !== !1 ? this._context.viewModel.getBracketGuidesInRangeByLine(e, t, i, {
        highlightActive: this._bracketPairGuideOptions.highlightActiveBracketPair,
        horizontalGuides: this._bracketPairGuideOptions.bracketPairsHorizontal === !0 ? Rd.Enabled : this._bracketPairGuideOptions.bracketPairsHorizontal === "active" ? Rd.EnabledForActive : Rd.Disabled,
        includeInactive: this._bracketPairGuideOptions.bracketPairs === !0
      }) : null, o = this._bracketPairGuideOptions.indentation ? this._context.viewModel.getLinesIndentGuides(e, t) : null;
      let r = 0, a = 0, l = 0;
      if (this._bracketPairGuideOptions.highlightActiveIndentation && i) {
        const h = this._context.viewModel.getActiveIndentGuide(i.lineNumber, e, t);
        r = h.startLineNumber, a = h.endLineNumber, l = h.indent;
      }
      const { indentSize: c } = this._context.viewModel.model.getOptions(), d = [];
      for (let h = e; h <= t; h++) {
        const u = new Array();
        d.push(u);
        const f = n ? n[h - e] : [], g = new bf(f), _ = o ? o[h - e] : [];
        for (let b = 1; b <= _; b++) {
          const C = (b - 1) * c + 1, v = f.length === 0 && r <= h && h <= a && b === l;
          u.push(...g.takeWhile((S) => S.visibleColumn < C) || []);
          const w = g.peek();
          (!w || w.visibleColumn !== C || w.horizontalLine) && u.push(new Eu(C, v ? "core-guide-indent-active" : "core-guide-indent", null));
        }
        u.push(...g.takeWhile((b) => !0) || []);
      }
      return d;
    }
    render(e, t) {
      if (!this._renderResult)
        return "";
      const i = t - e;
      return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
    }
  }
  function Z_(s) {
    if (!(s && s.isTransparent()))
      return s;
  }
  Vt((s, e) => {
    const t = s.getColor(oC);
    t && e.addRule(`.monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 ${t} inset; }`);
    const i = s.getColor(rC) || t;
    i && e.addRule(`.monaco-editor .lines-content .core-guide-indent-active { box-shadow: 1px 0 0 0 ${i} inset; }`);
    const n = [
      { bracketColor: V5, guideColor: K$, guideColorActive: Q$ },
      { bracketColor: H5, guideColor: q$, guideColorActive: J$ },
      { bracketColor: z5, guideColor: G$, guideColorActive: ej },
      { bracketColor: U5, guideColor: Z$, guideColorActive: tj },
      { bracketColor: $5, guideColor: Y$, guideColorActive: ij },
      { bracketColor: j5, guideColor: X$, guideColorActive: nj }
    ], o = new Q5(), r = n.map((a) => {
      var l, c;
      const d = s.getColor(a.bracketColor), h = s.getColor(a.guideColor), u = s.getColor(a.guideColorActive), f = Z_((l = Z_(h)) !== null && l !== void 0 ? l : d?.transparent(0.3)), g = Z_((c = Z_(u)) !== null && c !== void 0 ? c : d);
      if (!(!f || !g))
        return {
          guideColor: f,
          guideColorActive: g
        };
    }).filter(PB);
    if (r.length > 0) {
      for (let a = 0; a < 30; a++) {
        const l = r[a % r.length];
        e.addRule(`.monaco-editor .${o.getInlineClassNameOfLevel(a).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`);
      }
      e.addRule(".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }"), e.addRule(".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }"), e.addRule(".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }"), e.addRule(`.monaco-editor .vertical.${o.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`), e.addRule(`.monaco-editor .horizontal-top.${o.activeClassName} { border-top: 1px solid var(--guide-color-active); }`), e.addRule(`.monaco-editor .horizontal-bottom.${o.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`);
    }
  });
  class Pj {
    constructor() {
      this._currentVisibleRange = new D(1, 1, 1, 1);
    }
    getCurrentVisibleRange() {
      return this._currentVisibleRange;
    }
    setCurrentVisibleRange(e) {
      this._currentVisibleRange = e;
    }
  }
  class Fj {
    constructor(e, t, i, n, o, r, a) {
      this.minimalReveal = e, this.lineNumber = t, this.startColumn = i, this.endColumn = n, this.startScrollTop = o, this.stopScrollTop = r, this.scrollType = a, this.type = "range", this.minLineNumber = t, this.maxLineNumber = t;
    }
  }
  class Bj {
    constructor(e, t, i, n, o) {
      this.minimalReveal = e, this.selections = t, this.startScrollTop = i, this.stopScrollTop = n, this.scrollType = o, this.type = "selections";
      let r = t[0].startLineNumber, a = t[0].endLineNumber;
      for (let l = 1, c = t.length; l < c; l++) {
        const d = t[l];
        r = Math.min(r, d.startLineNumber), a = Math.max(a, d.endLineNumber);
      }
      this.minLineNumber = r, this.maxLineNumber = a;
    }
  }
  class dC extends Do {
    constructor(e, t) {
      super(e), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new q5(this), this.domNode = this._visibleLines.domNode;
      const i = this._context.configuration, n = this._context.configuration.options, o = n.get(44), r = n.get(132), a = n.get(131);
      this._lineHeight = n.get(59), this._typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this._isViewportWrapping = r.isViewportWrapping, this._revealHorizontalRightPadding = n.get(89), this._horizontalScrollbarHeight = a.horizontalScrollbarHeight, this._cursorSurroundingLines = n.get(25), this._cursorSurroundingLinesStyle = n.get(26), this._canUseLayerHinting = !n.get(28), this._viewLineOptions = new _T(i, this._context.theme.type), ha.write(this.domNode, 7), this.domNode.setClassName(`view-lines ${Ad}`), En(this.domNode, o), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new It(() => {
        this._updateLineWidthsSlow();
      }, 200), this._asyncCheckMonospaceFontAssumptions = new It(() => {
        this._checkMonospaceFontAssumptions();
      }, 2e3), this._lastRenderedData = new Pj(), this._horizontalRevealRequest = null;
    }
    dispose() {
      this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
    }
    getDomNode() {
      return this.domNode;
    }
    createVisibleLine() {
      return new qr(this._viewLineOptions);
    }
    onConfigurationChanged(e) {
      this._visibleLines.onConfigurationChanged(e), e.hasChanged(132) && (this._maxLineWidth = 0);
      const t = this._context.configuration.options, i = t.get(44), n = t.get(132), o = t.get(131);
      return this._lineHeight = t.get(59), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = n.isViewportWrapping, this._revealHorizontalRightPadding = t.get(89), this._horizontalScrollbarHeight = o.horizontalScrollbarHeight, this._cursorSurroundingLines = t.get(25), this._cursorSurroundingLinesStyle = t.get(26), this._canUseLayerHinting = !t.get(28), En(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(131) && (this._maxLineWidth = 0), !0;
    }
    _onOptionsMaybeChanged() {
      const e = this._context.configuration, t = new _T(e, this._context.theme.type);
      if (!this._viewLineOptions.equals(t)) {
        this._viewLineOptions = t;
        const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
        for (let o = i; o <= n; o++)
          this._visibleLines.getVisibleLine(o).onOptionsChanged(this._viewLineOptions);
        return !0;
      }
      return !1;
    }
    onCursorStateChanged(e) {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      let n = !1;
      for (let o = t; o <= i; o++)
        n = this._visibleLines.getVisibleLine(o).onSelectionChanged() || n;
      return n;
    }
    onDecorationsChanged(e) {
      {
        const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
        for (let n = t; n <= i; n++)
          this._visibleLines.getVisibleLine(n).onDecorationsChanged();
      }
      return !0;
    }
    onFlushed(e) {
      const t = this._visibleLines.onFlushed(e);
      return this._maxLineWidth = 0, t;
    }
    onLinesChanged(e) {
      return this._visibleLines.onLinesChanged(e);
    }
    onLinesDeleted(e) {
      return this._visibleLines.onLinesDeleted(e);
    }
    onLinesInserted(e) {
      return this._visibleLines.onLinesInserted(e);
    }
    onRevealRangeRequest(e) {
      const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
      if (t === -1)
        return !1;
      let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
      e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
        scrollTop: i.scrollTop,
        scrollLeft: 0
      } : e.range ? this._horizontalRevealRequest = new Fj(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new Bj(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
      const o = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
      return this._context.viewModel.viewLayout.setScrollPosition(i, o), !0;
    }
    onScrollChanged(e) {
      if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
        const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
        (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
      }
      return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
    }
    onTokensChanged(e) {
      return this._visibleLines.onTokensChanged(e);
    }
    onZonesChanged(e) {
      return this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
    }
    onThemeChanged(e) {
      return this._onOptionsMaybeChanged();
    }
    getPositionFromDOMInfo(e, t) {
      const i = this._getViewLineDomNode(e);
      if (i === null)
        return null;
      const n = this._getLineNumberFor(i);
      if (n === -1 || n < 1 || n > this._context.viewModel.getLineCount())
        return null;
      if (this._context.viewModel.getLineMaxColumn(n) === 1)
        return new V(n, 1);
      const o = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
      if (n < o || n > r)
        return null;
      let a = this._visibleLines.getVisibleLine(n).getColumnOfNodeOffset(n, e, t);
      const l = this._context.viewModel.getLineMinColumn(n);
      return a < l && (a = l), new V(n, a);
    }
    _getViewLineDomNode(e) {
      for (; e && e.nodeType === 1; ) {
        if (e.className === qr.CLASS_NAME)
          return e;
        e = e.parentElement;
      }
      return null;
    }
    _getLineNumberFor(e) {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let n = t; n <= i; n++) {
        const o = this._visibleLines.getVisibleLine(n);
        if (e === o.getDomNode())
          return n;
      }
      return -1;
    }
    getLineWidth(e) {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      return e < t || e > i ? -1 : this._visibleLines.getVisibleLine(e).getWidth();
    }
    linesVisibleRangesForRange(e, t) {
      if (this.shouldRender())
        return null;
      const i = e.endLineNumber, n = D.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
      if (!n)
        return null;
      let o = [], r = 0;
      const a = new pT(this.domNode.domNode, this._textRangeRestingSpot);
      let l = 0;
      t && (l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(n.startLineNumber, 1)).lineNumber);
      const c = this._visibleLines.getStartLineNumber(), d = this._visibleLines.getEndLineNumber();
      for (let h = n.startLineNumber; h <= n.endLineNumber; h++) {
        if (h < c || h > d)
          continue;
        const u = h === n.startLineNumber ? n.startColumn : 1, f = h === n.endLineNumber ? n.endColumn : this._context.viewModel.getLineMaxColumn(h), g = this._visibleLines.getVisibleLine(h).getVisibleRangesForRange(h, u, f, a);
        if (!!g) {
          if (t && h < i) {
            const _ = l;
            l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(h + 1, 1)).lineNumber, _ !== l && (g.ranges[g.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
          }
          o[r++] = new ZU(g.outsideRenderedLine, h, tC.from(g.ranges));
        }
      }
      return r === 0 ? null : o;
    }
    _visibleRangesForLineRange(e, t, i) {
      return this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber() ? null : this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(e, t, i, new pT(this.domNode.domNode, this._textRangeRestingSpot));
    }
    visibleRangeForPosition(e) {
      const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
      return t ? new YU(t.outsideRenderedLine, t.ranges[0].left) : null;
    }
    updateLineWidths() {
      this._updateLineWidths(!1);
    }
    _updateLineWidthsFast() {
      return this._updateLineWidths(!0);
    }
    _updateLineWidthsSlow() {
      this._updateLineWidths(!1);
    }
    _updateLineWidths(e) {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      let n = 1, o = !0;
      for (let r = t; r <= i; r++) {
        const a = this._visibleLines.getVisibleLine(r);
        if (e && !a.getWidthIsFast()) {
          o = !1;
          continue;
        }
        n = Math.max(n, a.getWidth());
      }
      return o && t === 1 && i === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(n), o;
    }
    _checkMonospaceFontAssumptions() {
      let e = -1, t = -1;
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= n; o++) {
        const r = this._visibleLines.getVisibleLine(o);
        if (r.needsMonospaceFontCheck()) {
          const a = r.getWidth();
          a > t && (t = a, e = o);
        }
      }
      if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
        for (let o = i; o <= n; o++)
          this._visibleLines.getVisibleLine(o).onMonospaceAssumptionsInvalidated();
    }
    prepareRender() {
      throw new Error("Not supported");
    }
    render() {
      throw new Error("Not supported");
    }
    renderText(e) {
      if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
        const i = this._horizontalRevealRequest;
        if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
          this._horizontalRevealRequest = null, this.onDidRender();
          const n = this._computeScrollLeftToReveal(i);
          n && (this._isViewportWrapping || this._ensureMaxLineWidth(n.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({
            scrollLeft: n.scrollLeft
          }, i.scrollType));
        }
      }
      if (this._updateLineWidthsFast() || this._asyncUpdateLineWidths.schedule(), Nn && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
        const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
        for (let o = i; o <= n; o++)
          if (this._visibleLines.getVisibleLine(o).needsMonospaceFontCheck()) {
            this._asyncCheckMonospaceFontAssumptions.schedule();
            break;
          }
      }
      this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
      const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
      this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
    }
    _ensureMaxLineWidth(e) {
      const t = Math.ceil(e);
      this._maxLineWidth < t && (this._maxLineWidth = t, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
    }
    _computeScrollTopToRevealRange(e, t, i, n, o, r) {
      const a = e.top, l = e.height, c = a + l;
      let d, h, u;
      if (o && o.length > 0) {
        let _ = o[0].startLineNumber, b = o[0].endLineNumber;
        for (let C = 1, v = o.length; C < v; C++) {
          const w = o[C];
          _ = Math.min(_, w.startLineNumber), b = Math.max(b, w.endLineNumber);
        }
        d = !1, h = this._context.viewLayout.getVerticalOffsetForLineNumber(_), u = this._context.viewLayout.getVerticalOffsetForLineNumber(b) + this._lineHeight;
      } else if (n)
        d = !0, h = this._context.viewLayout.getVerticalOffsetForLineNumber(n.startLineNumber), u = this._context.viewLayout.getVerticalOffsetForLineNumber(n.endLineNumber) + this._lineHeight;
      else
        return -1;
      if ((t === "mouse" || i) && this._cursorSurroundingLinesStyle === "default")
        i || (h -= this._lineHeight);
      else {
        const _ = Math.min(l / this._lineHeight / 2, this._cursorSurroundingLines);
        h -= _ * this._lineHeight, u += Math.max(0, _ - 1) * this._lineHeight;
      }
      (r === 0 || r === 4) && (u += i ? this._horizontalScrollbarHeight : this._lineHeight);
      let g;
      if (u - h > l) {
        if (!d)
          return -1;
        g = h;
      } else if (r === 5 || r === 6)
        if (r === 6 && a <= h && u <= c)
          g = a;
        else {
          const _ = Math.max(5 * this._lineHeight, l * 0.2), b = h - _, C = u - l;
          g = Math.max(C, b);
        }
      else if (r === 1 || r === 2)
        if (r === 2 && a <= h && u <= c)
          g = a;
        else {
          const _ = (h + u) / 2;
          g = Math.max(0, _ - l / 2);
        }
      else
        g = this._computeMinimumScrolling(a, c, h, u, r === 3, r === 4);
      return g;
    }
    _computeScrollLeftToReveal(e) {
      const t = this._context.viewLayout.getCurrentViewport(), i = t.left, n = i + t.width;
      let o = 1073741824, r = 0;
      if (e.type === "range") {
        const l = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
        if (!l)
          return null;
        for (const c of l.ranges)
          o = Math.min(o, Math.round(c.left)), r = Math.max(r, Math.round(c.left + c.width));
      } else
        for (const l of e.selections) {
          if (l.startLineNumber !== l.endLineNumber)
            return null;
          const c = this._visibleRangesForLineRange(l.startLineNumber, l.startColumn, l.endColumn);
          if (!c)
            return null;
          for (const d of c.ranges)
            o = Math.min(o, Math.round(d.left)), r = Math.max(r, Math.round(d.left + d.width));
        }
      return e.minimalReveal || (o = Math.max(0, o - dC.HORIZONTAL_EXTRA_PX), r += this._revealHorizontalRightPadding), e.type === "selections" && r - o > t.width ? null : {
        scrollLeft: this._computeMinimumScrolling(i, n, o, r),
        maxHorizontalOffset: r
      };
    }
    _computeMinimumScrolling(e, t, i, n, o, r) {
      e = e | 0, t = t | 0, i = i | 0, n = n | 0, o = !!o, r = !!r;
      const a = t - e;
      if (n - i < a) {
        if (o)
          return i;
        if (r)
          return Math.max(0, n - a);
        if (i < e)
          return i;
        if (n > t)
          return Math.max(0, n - a);
      } else
        return i;
      return e;
    }
  }
  dC.HORIZONTAL_EXTRA_PX = 30;
  class Wj extends fE {
    constructor(e) {
      super(), this._context = e;
      const i = this._context.configuration.options.get(131);
      this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
    }
    onConfigurationChanged(e) {
      const i = this._context.configuration.options.get(131);
      return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    _getDecorations(e) {
      const t = e.getDecorationsInViewport(), i = [];
      let n = 0;
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.options.linesDecorationsClassName;
        l && (i[n++] = new u1(a.range.startLineNumber, a.range.endLineNumber, l));
        const c = a.options.firstLineDecorationClassName;
        c && (i[n++] = new u1(a.range.startLineNumber, a.range.startLineNumber, c));
      }
      return i;
    }
    prepareRender(e) {
      const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = this._decorationsLeft.toString(), r = this._decorationsWidth.toString(), a = '" style="left:' + o + "px;width:" + r + 'px;"></div>', l = [];
      for (let c = t; c <= i; c++) {
        const d = c - t, h = n[d];
        let u = "";
        for (let f = 0, g = h.length; f < g; f++)
          u += '<div class="cldr ' + h[f] + a;
        l[d] = u;
      }
      this._renderResult = l;
    }
    render(e, t) {
      return this._renderResult ? this._renderResult[t - e] : "";
    }
  }
  class Vj extends fE {
    constructor(e) {
      super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
    }
    onConfigurationChanged(e) {
      return !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    _getDecorations(e) {
      const t = e.getDecorationsInViewport(), i = [];
      let n = 0;
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = a.options.marginClassName;
        l && (i[n++] = new u1(a.range.startLineNumber, a.range.endLineNumber, l));
      }
      return i;
    }
    prepareRender(e) {
      const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = [];
      for (let r = t; r <= i; r++) {
        const a = r - t, l = n[a];
        let c = "";
        for (let d = 0, h = l.length; d < h; d++)
          c += '<div class="cmdr ' + l[d] + '" style=""></div>';
        o[a] = c;
      }
      this._renderResult = o;
    }
    render(e, t) {
      return this._renderResult ? this._renderResult[t - e] : "";
    }
  }
  class fo {
    constructor(e, t, i, n) {
      this._rgba8Brand = void 0, this.r = fo._clamp(e), this.g = fo._clamp(t), this.b = fo._clamp(i), this.a = fo._clamp(n);
    }
    equals(e) {
      return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
    }
    static _clamp(e) {
      return e < 0 ? 0 : e > 255 ? 255 : e | 0;
    }
  }
  fo.Empty = new fo(0, 0, 0, 0);
  class f_ extends z {
    constructor() {
      super(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), this._register(Yt.onDidChange((e) => {
        e.changedColorMap && this._updateColorMap();
      }));
    }
    static getInstance() {
      return this._INSTANCE || (this._INSTANCE = new f_()), this._INSTANCE;
    }
    _updateColorMap() {
      const e = Yt.getColorMap();
      if (!e) {
        this._colors = [fo.Empty], this._backgroundIsLight = !0;
        return;
      }
      this._colors = [fo.Empty];
      for (let i = 1; i < e.length; i++) {
        const n = e[i].rgba;
        this._colors[i] = new fo(n.r, n.g, n.b, Math.round(n.a * 255));
      }
      const t = e[2].getRelativeLuminance();
      this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
    }
    getColor(e) {
      return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
    }
    backgroundIsLight() {
      return this._backgroundIsLight;
    }
  }
  f_._INSTANCE = null;
  class yT {
    constructor(e, t, i, n) {
      this._viewportBrand = void 0, this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = n | 0;
    }
  }
  class Hj {
    constructor(e, t) {
      this.tabSize = e, this.data = t;
    }
  }
  class gE {
    constructor(e, t, i, n, o, r, a) {
      this._viewLineDataBrand = void 0, this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = n, this.startVisibleColumn = o, this.tokens = r, this.inlineDecorations = a;
    }
  }
  class Js {
    constructor(e, t, i, n, o, r, a, l, c, d) {
      this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = n, this.isBasicASCII = Js.isBasicASCII(i, r), this.containsRTL = Js.containsRTL(i, this.isBasicASCII, o), this.tokens = a, this.inlineDecorations = l, this.tabSize = c, this.startVisibleColumn = d;
    }
    static isBasicASCII(e, t) {
      return t ? Rv(e) : !0;
    }
    static containsRTL(e, t, i) {
      return !t && i ? Av(e) : !1;
    }
  }
  class um {
    constructor(e, t, i) {
      this.range = e, this.inlineClassName = t, this.type = i;
    }
  }
  class zj {
    constructor(e, t, i, n) {
      this.startOffset = e, this.endOffset = t, this.inlineClassName = i, this.inlineClassNameAffectsLetterSpacing = n;
    }
    toInlineDecoration(e) {
      return new um(new D(e, this.startOffset + 1, e, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 : 0);
    }
  }
  class J5 {
    constructor(e, t) {
      this._viewModelDecorationBrand = void 0, this.range = e, this.options = t;
    }
  }
  class eF {
    constructor(e, t, i) {
      this.color = e, this.zIndex = t, this.data = i;
    }
    static cmp(e, t) {
      return e.zIndex === t.zIndex ? e.color < t.color ? -1 : e.color > t.color ? 1 : 0 : e.zIndex - t.zIndex;
    }
  }
  const Uj = (() => {
    const s = [];
    for (let e = 32; e <= 126; e++)
      s.push(e);
    return s.push(65533), s;
  })(), $j = (s, e) => (s -= 32, s < 0 || s > 96 ? e <= 2 ? (s + 96) % 96 : 96 - 1 : s);
  class ep {
    constructor(e, t) {
      this.scale = t, this._minimapCharRendererBrand = void 0, this.charDataNormal = ep.soften(e, 12 / 15), this.charDataLight = ep.soften(e, 50 / 60);
    }
    static soften(e, t) {
      const i = new Uint8ClampedArray(e.length);
      for (let n = 0, o = e.length; n < o; n++)
        i[n] = t1(e[n] * t);
      return i;
    }
    renderChar(e, t, i, n, o, r, a, l, c, d, h) {
      const u = 1 * this.scale, f = 2 * this.scale, g = h ? 1 : f;
      if (t + u > e.width || i + g > e.height) {
        console.warn("bad render request outside image data");
        return;
      }
      const _ = d ? this.charDataLight : this.charDataNormal, b = $j(n, c), C = e.width * 4, v = a.r, w = a.g, S = a.b, L = o.r - v, x = o.g - w, y = o.b - S, k = Math.max(r, l), I = e.data;
      let F = b * u * f, R = i * C + t * 4;
      for (let $ = 0; $ < g; $++) {
        let j = R;
        for (let le = 0; le < u; le++) {
          const he = _[F++] / 255 * (r / 255);
          I[j++] = v + L * he, I[j++] = w + x * he, I[j++] = S + y * he, I[j++] = k;
        }
        R += C;
      }
    }
    blockRenderChar(e, t, i, n, o, r, a, l) {
      const c = 1 * this.scale, d = 2 * this.scale, h = l ? 1 : d;
      if (t + c > e.width || i + h > e.height) {
        console.warn("bad render request outside image data");
        return;
      }
      const u = e.width * 4, f = 0.5 * (o / 255), g = r.r, _ = r.g, b = r.b, C = n.r - g, v = n.g - _, w = n.b - b, S = g + C * f, L = _ + v * f, x = b + w * f, y = Math.max(o, a), k = e.data;
      let I = i * u + t * 4;
      for (let F = 0; F < h; F++) {
        let R = I;
        for (let $ = 0; $ < c; $++)
          k[R++] = S, k[R++] = L, k[R++] = x, k[R++] = y;
        I += u;
      }
    }
  }
  const LT = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15
  }, kT = (s) => {
    const e = new Uint8ClampedArray(s.length / 2);
    for (let t = 0; t < s.length; t += 2)
      e[t >> 1] = LT[s[t]] << 4 | LT[s[t + 1]] & 15;
    return e;
  }, DT = {
    1: ul(() => kT("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
    2: ul(() => kT("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
  };
  class fm {
    static create(e, t) {
      if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
        return this.lastCreated;
      let i;
      return DT[e] ? i = new ep(DT[e](), e) : i = fm.createFromSampleData(fm.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
    }
    static createSampleData(e) {
      const t = document.createElement("canvas"), i = t.getContext("2d");
      t.style.height = `${16}px`, t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold ${16}px ${e}`, i.textBaseline = "middle";
      let n = 0;
      for (const o of Uj)
        i.fillText(String.fromCharCode(o), n, 16 / 2), n += 10;
      return i.getImageData(0, 0, 96 * 10, 16);
    }
    static createFromSampleData(e, t) {
      if (e.length !== 61440)
        throw new Error("Unexpected source in MinimapCharRenderer");
      const n = fm._downsample(e, t);
      return new ep(n, t);
    }
    static _downsampleChar(e, t, i, n, o) {
      const r = 1 * o, a = 2 * o;
      let l = n, c = 0;
      for (let d = 0; d < a; d++) {
        const h = d / a * 16, u = (d + 1) / a * 16;
        for (let f = 0; f < r; f++) {
          const g = f / r * 10, _ = (f + 1) / r * 10;
          let b = 0, C = 0;
          for (let w = h; w < u; w++) {
            const S = t + Math.floor(w) * 3840, L = 1 - (w - Math.floor(w));
            for (let x = g; x < _; x++) {
              const y = 1 - (x - Math.floor(x)), k = S + Math.floor(x) * 4, I = y * L;
              C += I, b += e[k] * e[k + 3] / 255 * I;
            }
          }
          const v = b / C;
          c = Math.max(c, v), i[l++] = t1(v);
        }
      }
      return c;
    }
    static _downsample(e, t) {
      const i = 2 * t * 1 * t, n = i * 96, o = new Uint8ClampedArray(n);
      let r = 0, a = 0, l = 0;
      for (let c = 0; c < 96; c++)
        l = Math.max(l, this._downsampleChar(e, a, o, r, t)), r += i, a += 10 * 4;
      if (l > 0) {
        const c = 255 / l;
        for (let d = 0; d < n; d++)
          o[d] *= c;
      }
      return o;
    }
  }
  var Lo;
  (function(s) {
    s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
  })(Lo || (Lo = {}));
  var _o;
  (function(s) {
    s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
  })(_o || (_o = {}));
  var Jr;
  (function(s) {
    s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
  })(Jr || (Jr = {}));
  class d0 {
    constructor(e) {
      this._textModelResolvedOptionsBrand = void 0, this.tabSize = Math.max(1, e.tabSize | 0), this.indentSize = e.tabSize | 0, this.insertSpaces = Boolean(e.insertSpaces), this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = Boolean(e.trimAutoWhitespace), this.bracketPairColorizationOptions = e.bracketPairColorizationOptions;
    }
    equals(e) {
      return this.tabSize === e.tabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace && po(this.bracketPairColorizationOptions, e.bracketPairColorizationOptions);
    }
    createChangeEvent(e) {
      return {
        tabSize: this.tabSize !== e.tabSize,
        indentSize: this.indentSize !== e.indentSize,
        insertSpaces: this.insertSpaces !== e.insertSpaces,
        trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
      };
    }
  }
  class tp {
    constructor(e, t) {
      this._findMatchBrand = void 0, this.range = e, this.matches = t;
    }
  }
  class Jw {
    constructor(e, t, i, n, o, r) {
      this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = n, this.isAutoWhitespaceEdit = o, this._isTracked = r;
    }
  }
  class jj {
    constructor(e, t, i) {
      this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
    }
  }
  class Kj {
    constructor(e, t, i) {
      this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
    }
  }
  function qj(s) {
    return !s.isTooLargeForSyncing() && !s.isForSimpleWidget;
  }
  const Gj = 140, Zj = 2;
  class ip {
    constructor(e, t, i) {
      const n = e.options, o = n.get(129), r = n.get(131), a = r.minimap, l = n.get(44), c = n.get(65);
      this.renderMinimap = a.renderMinimap, this.size = c.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = n.get(94), this.showSlider = c.showSlider, this.pixelRatio = o, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = n.get(59), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = r.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = r.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.charRenderer = ul(() => fm.create(this.fontScale, l.fontFamily)), this.defaultBackgroundColor = i.getColor(2), this.backgroundColor = ip._getMinimapBackground(t, this.defaultBackgroundColor), this.foregroundAlpha = ip._getMinimapForegroundOpacity(t);
    }
    static _getMinimapBackground(e, t) {
      const i = e.getColor(NU);
      return i ? new fo(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
    }
    static _getMinimapForegroundOpacity(e) {
      const t = e.getColor(TU);
      return t ? fo._clamp(Math.round(255 * t.rgba.a)) : 255;
    }
    equals(e) {
      return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.showSlider === e.showSlider && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(e.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor) && this.foregroundAlpha === e.foregroundAlpha;
    }
  }
  class gm {
    constructor(e, t, i, n, o, r, a, l) {
      this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = n, this.sliderTop = o, this.sliderHeight = r, this.startLineNumber = a, this.endLineNumber = l;
    }
    getDesiredScrollTopFromDelta(e) {
      return Math.round(this.scrollTop + e / this._computedSliderRatio);
    }
    getDesiredScrollTopFromTouchLocation(e) {
      return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
    }
    static create(e, t, i, n, o, r, a, l, c, d, h) {
      const u = e.pixelRatio, f = e.minimapLineHeight, g = Math.floor(e.canvasInnerHeight / f), _ = e.lineHeight;
      if (e.minimapHeightIsEditorHeight) {
        const L = l * e.lineHeight + (e.scrollBeyondLastLine ? o - e.lineHeight : 0), x = Math.max(1, Math.floor(o * o / L)), y = Math.max(0, e.minimapHeight - x), k = y / (d - o), I = c * k, F = y > 0, R = Math.floor(e.canvasInnerHeight / e.minimapLineHeight);
        return new gm(c, d, F, k, I, x, 1, Math.min(a, R));
      }
      let b;
      if (r && i !== a) {
        const L = i - t + 1;
        b = Math.floor(L * f / u);
      } else {
        const L = o / _;
        b = Math.floor(L * f / u);
      }
      let C;
      e.scrollBeyondLastLine ? C = (a - 1) * f / u : C = Math.max(0, a * f / u - b), C = Math.min(e.minimapHeight - b, C);
      const v = C / (d - o), w = c * v;
      let S = 0;
      if (e.scrollBeyondLastLine && (S = o / _ - 1), g >= a + S) {
        const x = a, y = C > 0;
        return new gm(c, d, y, v, w, b, 1, x);
      } else {
        let L = Math.max(1, Math.floor(t - w * u / f));
        h && h.scrollHeight === d && (h.scrollTop > c && (L = Math.min(L, h.startLineNumber)), h.scrollTop < c && (L = Math.max(L, h.startLineNumber)));
        const x = Math.min(a, L + g - 1), y = (c - n) / _, k = (t - L + y) * f / u;
        return new gm(c, d, !0, v, k, b, L, x);
      }
    }
  }
  class f1 {
    constructor(e) {
      this.dy = e;
    }
    onContentChanged() {
      this.dy = -1;
    }
    onTokensChanged() {
      this.dy = -1;
    }
  }
  f1.INVALID = new f1(-1);
  class xT {
    constructor(e, t, i) {
      this.renderedLayout = e, this._imageData = t, this._renderedLines = new K5(() => f1.INVALID), this._renderedLines._set(e.startLineNumber, i);
    }
    linesEquals(e) {
      if (!this.scrollEquals(e))
        return !1;
      const i = this._renderedLines._get().lines;
      for (let n = 0, o = i.length; n < o; n++)
        if (i[n].dy === -1)
          return !1;
      return !0;
    }
    scrollEquals(e) {
      return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
    }
    _get() {
      const e = this._renderedLines._get();
      return {
        imageData: this._imageData,
        rendLineNumberStart: e.rendLineNumberStart,
        lines: e.lines
      };
    }
    onLinesChanged(e, t) {
      return this._renderedLines.onLinesChanged(e, t);
    }
    onLinesDeleted(e, t) {
      this._renderedLines.onLinesDeleted(e, t);
    }
    onLinesInserted(e, t) {
      this._renderedLines.onLinesInserted(e, t);
    }
    onTokensChanged(e) {
      return this._renderedLines.onTokensChanged(e);
    }
  }
  class mE {
    constructor(e, t, i, n) {
      this._backgroundFillData = mE._createBackgroundFillData(t, i, n), this._buffers = [
        e.createImageData(t, i),
        e.createImageData(t, i)
      ], this._lastUsedBuffer = 0;
    }
    getBuffer() {
      this._lastUsedBuffer = 1 - this._lastUsedBuffer;
      const e = this._buffers[this._lastUsedBuffer];
      return e.data.set(this._backgroundFillData), e;
    }
    static _createBackgroundFillData(e, t, i) {
      const n = i.r, o = i.g, r = i.b, a = i.a, l = new Uint8ClampedArray(e * t * 4);
      let c = 0;
      for (let d = 0; d < t; d++)
        for (let h = 0; h < e; h++)
          l[c] = n, l[c + 1] = o, l[c + 2] = r, l[c + 3] = a, c += 4;
      return l;
    }
  }
  class np {
    constructor(e, t) {
      this.samplingRatio = e, this.minimapLines = t;
    }
    static compute(e, t, i) {
      if (e.renderMinimap === 0 || !e.isSampling)
        return [null, []];
      const n = e.pixelRatio, o = e.lineHeight, r = e.scrollBeyondLastLine, { minimapLineCount: a } = Ku.computeContainedMinimapLineCount({
        viewLineCount: t,
        scrollBeyondLastLine: r,
        height: e.editorHeight,
        lineHeight: o,
        pixelRatio: n
      }), l = t / a, c = l / 2;
      if (!i || i.minimapLines.length === 0) {
        const w = [];
        if (w[0] = 1, a > 1) {
          for (let S = 0, L = a - 1; S < L; S++)
            w[S] = Math.round(S * l + c);
          w[a - 1] = t;
        }
        return [new np(l, w), []];
      }
      const d = i.minimapLines, h = d.length, u = [];
      let f = 0, g = 0, _ = 1;
      const b = 10;
      let C = [], v = null;
      for (let w = 0; w < a; w++) {
        const S = Math.max(_, Math.round(w * l)), L = Math.max(S, Math.round((w + 1) * l));
        for (; f < h && d[f] < S; ) {
          if (C.length < b) {
            const y = f + 1 + g;
            v && v.type === "deleted" && v._oldIndex === f - 1 ? v.deleteToLineNumber++ : (v = { type: "deleted", _oldIndex: f, deleteFromLineNumber: y, deleteToLineNumber: y }, C.push(v)), g--;
          }
          f++;
        }
        let x;
        if (f < h && d[f] <= L)
          x = d[f], f++;
        else if (w === 0 ? x = 1 : w + 1 === a ? x = t : x = Math.round(w * l + c), C.length < b) {
          const y = f + 1 + g;
          v && v.type === "inserted" && v._i === w - 1 ? v.insertToLineNumber++ : (v = { type: "inserted", _i: w, insertFromLineNumber: y, insertToLineNumber: y }, C.push(v)), g++;
        }
        u[w] = x, _ = x;
      }
      if (C.length < b)
        for (; f < h; ) {
          const w = f + 1 + g;
          v && v.type === "deleted" && v._oldIndex === f - 1 ? v.deleteToLineNumber++ : (v = { type: "deleted", _oldIndex: f, deleteFromLineNumber: w, deleteToLineNumber: w }, C.push(v)), g--, f++;
        }
      else
        C = [{ type: "flush" }];
      return [new np(l, u), C];
    }
    modelLineToMinimapLine(e) {
      return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
    }
    modelLineRangeToMinimapLineRange(e, t) {
      let i = this.modelLineToMinimapLine(e) - 1;
      for (; i > 0 && this.minimapLines[i - 1] >= e; )
        i--;
      let n = this.modelLineToMinimapLine(t) - 1;
      for (; n + 1 < this.minimapLines.length && this.minimapLines[n + 1] <= t; )
        n++;
      if (i === n) {
        const o = this.minimapLines[i];
        if (o < e || o > t)
          return null;
      }
      return [i + 1, n + 1];
    }
    decorationLineRangeToMinimapLineRange(e, t) {
      let i = this.modelLineToMinimapLine(e), n = this.modelLineToMinimapLine(t);
      return e !== t && n === i && (n === this.minimapLines.length ? i > 1 && i-- : n++), [i, n];
    }
    onLinesDeleted(e) {
      const t = e.toLineNumber - e.fromLineNumber + 1;
      let i = this.minimapLines.length, n = 0;
      for (let o = this.minimapLines.length - 1; o >= 0 && !(this.minimapLines[o] < e.fromLineNumber); o--)
        this.minimapLines[o] <= e.toLineNumber ? (this.minimapLines[o] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, o), n = Math.max(n, o)) : this.minimapLines[o] -= t;
      return [i, n];
    }
    onLinesInserted(e) {
      const t = e.toLineNumber - e.fromLineNumber + 1;
      for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
        this.minimapLines[i] += t;
    }
  }
  class Yj extends Do {
    constructor(e) {
      super(e), this.tokensColorTracker = f_.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new ip(this._context.configuration, this._context.theme, this.tokensColorTracker);
      const [t] = np.compute(this.options, this._context.viewModel.getLineCount(), null);
      this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new g1(e.theme, this);
    }
    dispose() {
      this._actual.dispose(), super.dispose();
    }
    getDomNode() {
      return this._actual.getDomNode();
    }
    _onOptionsMaybeChanged() {
      const e = new ip(this._context.configuration, this._context.theme, this.tokensColorTracker);
      return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
    }
    onConfigurationChanged(e) {
      return this._onOptionsMaybeChanged();
    }
    onCursorStateChanged(e) {
      return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
    }
    onDecorationsChanged(e) {
      return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
    }
    onFlushed(e) {
      return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
    }
    onLinesChanged(e) {
      if (this._samplingState) {
        const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);
        return t ? this._actual.onLinesChanged(t[0], t[1]) : !1;
      } else
        return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);
    }
    onLinesDeleted(e) {
      if (this._samplingState) {
        const [t, i] = this._samplingState.onLinesDeleted(e);
        return t <= i && this._actual.onLinesChanged(t + 1, i + 1), this._shouldCheckSampling = !0, !0;
      } else
        return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    }
    onLinesInserted(e) {
      return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    }
    onScrollChanged(e) {
      return this._actual.onScrollChanged();
    }
    onThemeChanged(e) {
      return this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
    }
    onTokensChanged(e) {
      if (this._samplingState) {
        const t = [];
        for (const i of e.ranges) {
          const n = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
          n && t.push({ fromLineNumber: n[0], toLineNumber: n[1] });
        }
        return t.length ? this._actual.onTokensChanged(t) : !1;
      } else
        return this._actual.onTokensChanged(e.ranges);
    }
    onTokensColorsChanged(e) {
      return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
    }
    onZonesChanged(e) {
      return this._actual.onZonesChanged();
    }
    prepareRender(e) {
      this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
    }
    render(e) {
      let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
      this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
      const n = {
        viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
        scrollWidth: e.scrollWidth,
        scrollHeight: e.scrollHeight,
        viewportStartLineNumber: t,
        viewportEndLineNumber: i,
        viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
        scrollTop: e.scrollTop,
        scrollLeft: e.scrollLeft,
        viewportWidth: e.viewportWidth,
        viewportHeight: e.viewportHeight
      };
      this._actual.render(n);
    }
    _recreateLineSampling() {
      this._minimapSelections = null;
      const e = Boolean(this._samplingState), [t, i] = np.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
      if (this._samplingState = t, e && this._samplingState)
        for (const n of i)
          switch (n.type) {
            case "deleted":
              this._actual.onLinesDeleted(n.deleteFromLineNumber, n.deleteToLineNumber);
              break;
            case "inserted":
              this._actual.onLinesInserted(n.insertFromLineNumber, n.insertToLineNumber);
              break;
            case "flush":
              this._actual.onFlushed();
              break;
          }
    }
    getLineCount() {
      return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
    }
    getRealLineCount() {
      return this._context.viewModel.getLineCount();
    }
    getLineContent(e) {
      return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineContent(e);
    }
    getLineMaxColumn(e) {
      return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineMaxColumn(e);
    }
    getMinimapLinesRenderingData(e, t, i) {
      if (this._samplingState) {
        const n = [];
        for (let o = 0, r = t - e + 1; o < r; o++)
          i[o] ? n[o] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[e + o - 1]) : n[o] = null;
        return n;
      }
      return this._context.viewModel.getMinimapLinesRenderingData(e, t, i).data;
    }
    getSelections() {
      if (this._minimapSelections === null)
        if (this._samplingState) {
          this._minimapSelections = [];
          for (const e of this._selections) {
            const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
            this._minimapSelections.push(new ae(t, e.startColumn, i, e.endColumn));
          }
        } else
          this._minimapSelections = this._selections;
      return this._minimapSelections;
    }
    getMinimapDecorationsInViewport(e, t) {
      let i;
      if (this._samplingState) {
        const o = this._samplingState.minimapLines[e - 1], r = this._samplingState.minimapLines[t - 1];
        i = new D(o, 1, r, this._context.viewModel.getLineMaxColumn(r));
      } else
        i = new D(e, 1, t, this._context.viewModel.getLineMaxColumn(t));
      const n = this._context.viewModel.getDecorationsInViewport(i);
      if (this._samplingState) {
        const o = [];
        for (const r of n) {
          if (!r.options.minimap)
            continue;
          const a = r.range, l = this._samplingState.modelLineToMinimapLine(a.startLineNumber), c = this._samplingState.modelLineToMinimapLine(a.endLineNumber);
          o.push(new J5(new D(l, a.startColumn, c, a.endColumn), r.options));
        }
        return o;
      }
      return n;
    }
    getOptions() {
      return this._context.viewModel.model.getOptions();
    }
    revealLineNumber(e) {
      this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.viewModel.revealRange("mouse", !1, new D(e, 1, e, 1), 1, 0);
    }
    setScrollTop(e) {
      this._context.viewModel.viewLayout.setScrollPosition({
        scrollTop: e
      }, 1);
    }
  }
  class g1 extends z {
    constructor(e, t) {
      super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(uT), this._domNode = dt(document.createElement("div")), ha.write(this._domNode, 8), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = dt(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = dt(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = dt(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = dt(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = dt(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._mouseDownListener = on(this._domNode.domNode, "mousedown", (i) => {
        if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
          return;
        if (this._model.options.size !== "proportional") {
          if (i.leftButton && this._lastRenderData) {
            const c = mn(this._slider.domNode), d = c.top + c.height / 2;
            this._startSliderDragging(i.buttons, i.posx, d, i.posy, this._lastRenderData.renderedLayout);
          }
          return;
        }
        const o = this._model.options.minimapLineHeight, r = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.browserEvent.offsetY;
        let l = Math.floor(r / o) + this._lastRenderData.renderedLayout.startLineNumber;
        l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
      }), this._sliderMouseMoveMonitor = new Ah(), this._sliderMouseDownListener = on(this._slider.domNode, "mousedown", (i) => {
        i.preventDefault(), i.stopPropagation(), i.leftButton && this._lastRenderData && this._startSliderDragging(i.buttons, i.posx, i.posy, i.posy, this._lastRenderData.renderedLayout);
      }), this._gestureDisposable = kt.addTarget(this._domNode.domNode), this._sliderTouchStartListener = ee(this._domNode.domNode, Bt.Start, (i) => {
        i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
      }, { passive: !1 }), this._sliderTouchMoveListener = ee(this._domNode.domNode, Bt.Change, (i) => {
        i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
      }, { passive: !1 }), this._sliderTouchEndListener = on(this._domNode.domNode, Bt.End, (i) => {
        i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
      });
    }
    _startSliderDragging(e, t, i, n, o) {
      this._slider.toggleClassName("active", !0);
      const r = (a, l) => {
        const c = Math.abs(l - t);
        if (rn && c > Gj) {
          this._model.setScrollTop(o.scrollTop);
          return;
        }
        const d = a - i;
        this._model.setScrollTop(o.getDesiredScrollTopFromDelta(d));
      };
      n !== i && r(n, t), this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, e, ng, (a) => r(a.posy, a.posx), () => {
        this._slider.toggleClassName("active", !1);
      });
    }
    scrollDueToTouchEvent(e) {
      const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
      this._model.setScrollTop(i);
    }
    dispose() {
      this._mouseDownListener.dispose(), this._sliderMouseMoveMonitor.dispose(), this._sliderMouseDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
    }
    _getMinimapDomNodeClassName() {
      return this._model.options.showSlider === "always" ? "minimap slider-always" : "minimap slider-mouseover";
    }
    getDomNode() {
      return this._domNode;
    }
    _applyLayout() {
      this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
    }
    _getBuffer() {
      return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new mE(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
    }
    onDidChangeOptions() {
      this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
    }
    onSelectionChanged() {
      return this._renderDecorations = !0, !0;
    }
    onDecorationsChanged() {
      return this._renderDecorations = !0, !0;
    }
    onFlushed() {
      return this._lastRenderData = null, !0;
    }
    onLinesChanged(e, t) {
      return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
    }
    onLinesDeleted(e, t) {
      return this._lastRenderData && this._lastRenderData.onLinesDeleted(e, t), !0;
    }
    onLinesInserted(e, t) {
      return this._lastRenderData && this._lastRenderData.onLinesInserted(e, t), !0;
    }
    onScrollChanged() {
      return this._renderDecorations = !0, !0;
    }
    onThemeChanged() {
      return this._selectionColor = this._theme.getColor(uT), this._renderDecorations = !0, !0;
    }
    onTokensChanged(e) {
      return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
    }
    onTokensColorsChanged() {
      return this._lastRenderData = null, this._buffers = null, !0;
    }
    onZonesChanged() {
      return this._lastRenderData = null, !0;
    }
    render(e) {
      if (this._model.options.renderMinimap === 0) {
        this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
        return;
      }
      e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
      const i = gm.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
      this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
    }
    renderDecorations(e) {
      if (this._renderDecorations) {
        this._renderDecorations = !1;
        const t = this._model.getSelections();
        t.sort(D.compareRangesUsingStarts);
        const i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber);
        i.sort((u, f) => (u.options.zIndex || 0) - (f.options.zIndex || 0));
        const { canvasInnerWidth: n, canvasInnerHeight: o } = this._model.options, r = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, c = this._decorationsCanvas.domNode.getContext("2d");
        c.clearRect(0, 0, n, o);
        const d = new IT(e.startLineNumber, e.endLineNumber, !1);
        this._renderSelectionLineHighlights(c, t, d, e, r), this._renderDecorationsLineHighlights(c, i, d, e, r);
        const h = new IT(e.startLineNumber, e.endLineNumber, null);
        this._renderSelectionsHighlights(c, t, h, e, r, l, a, n), this._renderDecorationsHighlights(c, i, h, e, r, l, a, n);
      }
    }
    _renderSelectionLineHighlights(e, t, i, n, o) {
      if (!this._selectionColor || this._selectionColor.isTransparent())
        return;
      e.fillStyle = this._selectionColor.transparent(0.5).toString();
      let r = 0, a = 0;
      for (const l of t) {
        const c = Math.max(n.startLineNumber, l.startLineNumber), d = Math.min(n.endLineNumber, l.endLineNumber);
        if (c > d)
          continue;
        for (let f = c; f <= d; f++)
          i.set(f, !0);
        const h = (c - n.startLineNumber) * o, u = (d - n.startLineNumber) * o + o;
        a >= h || (a > r && e.fillRect(Rl, r, e.canvas.width, a - r), r = h), a = u;
      }
      a > r && e.fillRect(Rl, r, e.canvas.width, a - r);
    }
    _renderDecorationsLineHighlights(e, t, i, n, o) {
      const r = /* @__PURE__ */ new Map();
      for (let a = t.length - 1; a >= 0; a--) {
        const l = t[a], c = l.options.minimap;
        if (!c || c.position !== _o.Inline)
          continue;
        const d = Math.max(n.startLineNumber, l.range.startLineNumber), h = Math.min(n.endLineNumber, l.range.endLineNumber);
        if (d > h)
          continue;
        const u = c.getColor(this._theme.value);
        if (!u || u.isTransparent())
          continue;
        let f = r.get(u.toString());
        f || (f = u.transparent(0.5).toString(), r.set(u.toString(), f)), e.fillStyle = f;
        for (let g = d; g <= h; g++) {
          if (i.has(g))
            continue;
          i.set(g, !0);
          const _ = (d - n.startLineNumber) * o;
          e.fillRect(Rl, _, e.canvas.width, o);
        }
      }
    }
    _renderSelectionsHighlights(e, t, i, n, o, r, a, l) {
      if (!(!this._selectionColor || this._selectionColor.isTransparent()))
        for (const c of t) {
          const d = Math.max(n.startLineNumber, c.startLineNumber), h = Math.min(n.endLineNumber, c.endLineNumber);
          if (!(d > h))
            for (let u = d; u <= h; u++)
              this.renderDecorationOnLine(e, i, c, this._selectionColor, n, u, o, o, r, a, l);
        }
    }
    _renderDecorationsHighlights(e, t, i, n, o, r, a, l) {
      for (const c of t) {
        const d = c.options.minimap;
        if (!d)
          continue;
        const h = Math.max(n.startLineNumber, c.range.startLineNumber), u = Math.min(n.endLineNumber, c.range.endLineNumber);
        if (h > u)
          continue;
        const f = d.getColor(this._theme.value);
        if (!(!f || f.isTransparent()))
          for (let g = h; g <= u; g++)
            switch (d.position) {
              case _o.Inline:
                this.renderDecorationOnLine(e, i, c.range, f, n, g, o, o, r, a, l);
                continue;
              case _o.Gutter: {
                const _ = (g - n.startLineNumber) * o, b = 2;
                this.renderDecoration(e, f, b, _, Zj, o);
                continue;
              }
            }
      }
    }
    renderDecorationOnLine(e, t, i, n, o, r, a, l, c, d, h) {
      const u = (r - o.startLineNumber) * l;
      if (u + a < 0 || u > this._model.options.canvasInnerHeight)
        return;
      const { startLineNumber: f, endLineNumber: g } = i, _ = f === r ? i.startColumn : 1, b = g === r ? i.endColumn : this._model.getLineMaxColumn(r), C = this.getXOffsetForPosition(t, r, _, c, d, h), v = this.getXOffsetForPosition(t, r, b, c, d, h);
      this.renderDecoration(e, n, C, u, v - C, a);
    }
    getXOffsetForPosition(e, t, i, n, o, r) {
      if (i === 1)
        return Rl;
      if ((i - 1) * o >= r)
        return r;
      let l = e.get(t);
      if (!l) {
        const c = this._model.getLineContent(t);
        l = [Rl];
        let d = Rl;
        for (let h = 1; h < c.length + 1; h++) {
          const u = c.charCodeAt(h - 1), f = u === 9 ? n * o : _c(u) ? 2 * o : o, g = d + f;
          if (g >= r) {
            l[h] = r;
            break;
          }
          l[h] = g, d = g;
        }
        e.set(t, l);
      }
      return i - 1 < l.length ? l[i - 1] : r;
    }
    renderDecoration(e, t, i, n, o, r) {
      e.fillStyle = t && t.toString() || "", e.fillRect(i, n, o, r);
    }
    renderLines(e) {
      const t = e.startLineNumber, i = e.endLineNumber, n = this._model.options.minimapLineHeight;
      if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
        const he = this._lastRenderData._get();
        return new xT(e, he.imageData, he.lines);
      }
      const o = this._getBuffer();
      if (!o)
        return null;
      const [r, a, l] = g1._renderUntouchedLines(o, t, i, n, this._lastRenderData), c = this._model.getMinimapLinesRenderingData(t, i, l), d = this._model.getOptions().tabSize, h = this._model.options.defaultBackgroundColor, u = this._model.options.backgroundColor, f = this._model.options.foregroundAlpha, g = this._model.tokensColorTracker, _ = g.backgroundIsLight(), b = this._model.options.renderMinimap, C = this._model.options.charRenderer(), v = this._model.options.fontScale, w = this._model.options.minimapCharWidth, L = (b === 1 ? 2 : 2 + 1) * v, x = n > L ? Math.floor((n - L) / 2) : 0, y = u.a / 255, k = new fo(Math.round((u.r - h.r) * y + h.r), Math.round((u.g - h.g) * y + h.g), Math.round((u.b - h.b) * y + h.b), 255);
      let I = 0;
      const F = [];
      for (let he = 0, Ce = i - t + 1; he < Ce; he++)
        l[he] && g1._renderLine(o, k, u.a, _, b, w, g, f, C, I, x, d, c[he], v, n), F[he] = new f1(I), I += n;
      const R = r === -1 ? 0 : r, j = (a === -1 ? o.height : a) - R;
      return this._canvas.domNode.getContext("2d").putImageData(o, 0, 0, 0, R, o.width, j), new xT(e, o, F);
    }
    static _renderUntouchedLines(e, t, i, n, o) {
      const r = [];
      if (!o) {
        for (let k = 0, I = i - t + 1; k < I; k++)
          r[k] = !0;
        return [-1, -1, r];
      }
      const a = o._get(), l = a.imageData.data, c = a.rendLineNumberStart, d = a.lines, h = d.length, u = e.width, f = e.data, g = (i - t + 1) * n * u * 4;
      let _ = -1, b = -1, C = -1, v = -1, w = -1, S = -1, L = 0;
      for (let k = t; k <= i; k++) {
        const I = k - t, F = k - c, R = F >= 0 && F < h ? d[F].dy : -1;
        if (R === -1) {
          r[I] = !0, L += n;
          continue;
        }
        const $ = R * u * 4, j = (R + n) * u * 4, le = L * u * 4, he = (L + n) * u * 4;
        v === $ && S === le ? (v = j, S = he) : (C !== -1 && (f.set(l.subarray(C, v), w), _ === -1 && C === 0 && C === w && (_ = v), b === -1 && v === g && C === w && (b = C)), C = $, v = j, w = le, S = he), r[I] = !1, L += n;
      }
      C !== -1 && (f.set(l.subarray(C, v), w), _ === -1 && C === 0 && C === w && (_ = v), b === -1 && v === g && C === w && (b = C));
      const x = _ === -1 ? -1 : _ / (u * 4), y = b === -1 ? -1 : b / (u * 4);
      return [x, y, r];
    }
    static _renderLine(e, t, i, n, o, r, a, l, c, d, h, u, f, g, _) {
      const b = f.content, C = f.tokens, v = e.width - r, w = _ === 1;
      let S = Rl, L = 0, x = 0;
      for (let y = 0, k = C.getCount(); y < k; y++) {
        const I = C.getEndOffset(y), F = C.getForeground(y), R = a.getColor(F);
        for (; L < I; L++) {
          if (S > v)
            return;
          const $ = b.charCodeAt(L);
          if ($ === 9) {
            const j = u - (L + x) % u;
            x += j - 1, S += j * r;
          } else if ($ === 32)
            S += r;
          else {
            const j = _c($) ? 2 : 1;
            for (let le = 0; le < j; le++)
              if (o === 2 ? c.blockRenderChar(e, S, d + h, R, l, t, i, w) : c.renderChar(e, S, d + h, $, R, l, t, i, g, n, w), S += r, S > v)
                return;
          }
        }
      }
    }
  }
  class IT {
    constructor(e, t, i) {
      this._startLineNumber = e, this._endLineNumber = t, this._defaultValue = i, this._values = [];
      for (let n = 0, o = this._endLineNumber - this._startLineNumber + 1; n < o; n++)
        this._values[n] = i;
    }
    has(e) {
      return this.get(e) !== this._defaultValue;
    }
    set(e, t) {
      e < this._startLineNumber || e > this._endLineNumber || (this._values[e - this._startLineNumber] = t);
    }
    get(e) {
      return e < this._startLineNumber || e > this._endLineNumber ? this._defaultValue : this._values[e - this._startLineNumber];
    }
  }
  Vt((s, e) => {
    const t = s.getColor(MU);
    t && e.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${t}; }`);
    const i = s.getColor(AU);
    i && e.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${i}; }`);
    const n = s.getColor(RU);
    n && e.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${n}; }`);
    const o = s.getColor(sg);
    o && e.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${o} -6px 0 6px -6px inset; }`);
  });
  class Xj extends Do {
    constructor(e) {
      super(e);
      const i = this._context.configuration.options.get(131);
      this._widgets = {}, this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, this._domNode = dt(document.createElement("div")), ha.write(this._domNode, 4), this._domNode.setClassName("overlayWidgets");
    }
    dispose() {
      super.dispose(), this._widgets = {};
    }
    getDomNode() {
      return this._domNode;
    }
    onConfigurationChanged(e) {
      const i = this._context.configuration.options.get(131);
      return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
    }
    addWidget(e) {
      const t = dt(e.getDomNode());
      this._widgets[e.getId()] = {
        widget: e,
        preference: null,
        domNode: t
      }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), this._domNode.appendChild(t), this.setShouldRender();
    }
    setWidgetPosition(e, t) {
      const i = this._widgets[e.getId()];
      return i.preference === t ? !1 : (i.preference = t, this.setShouldRender(), !0);
    }
    removeWidget(e) {
      const t = e.getId();
      if (this._widgets.hasOwnProperty(t)) {
        const n = this._widgets[t].domNode.domNode;
        delete this._widgets[t], n.parentNode.removeChild(n), this.setShouldRender();
      }
    }
    _renderWidget(e) {
      const t = e.domNode;
      if (e.preference === null) {
        t.unsetTop();
        return;
      }
      if (e.preference === 0)
        t.setTop(0), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
      else if (e.preference === 1) {
        const i = t.domNode.clientHeight;
        t.setTop(this._editorHeight - i - 2 * this._horizontalScrollbarHeight), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
      } else
        e.preference === 2 && (t.setTop(0), t.domNode.style.right = "50%");
    }
    prepareRender(e) {
    }
    render(e) {
      this._domNode.setWidth(this._editorWidth);
      const t = Object.keys(this._widgets);
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i];
        this._renderWidget(this._widgets[o]);
      }
    }
  }
  class Qj {
    constructor(e, t) {
      const i = e.options;
      this.lineHeight = i.get(59), this.pixelRatio = i.get(129), this.overviewRulerLanes = i.get(74), this.renderBorder = i.get(73);
      const n = t.getColor(A$);
      this.borderColor = n ? n.toString() : null, this.hideCursor = i.get(52);
      const o = t.getColor(F5);
      this.cursorColor = o ? o.transparent(0.7).toString() : null, this.themeType = t.type;
      const r = i.get(65), a = r.enabled, l = r.side, c = a ? t.getColor(R$) || Yt.getDefaultBackground() : null;
      c === null || l === "left" ? this.backgroundColor = null : this.backgroundColor = H.Format.CSS.formatHex(c);
      const h = i.get(131).overviewRuler;
      this.top = h.top, this.right = h.right, this.domWidth = h.width, this.domHeight = h.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
      const [u, f] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
      this.x = u, this.w = f;
    }
    _initLanes(e, t, i) {
      const n = t - e;
      if (i >= 3) {
        const o = Math.floor(n / 3), r = Math.floor(n / 3), a = n - o - r, l = e, c = l + o, d = l + o + a;
        return [
          [
            0,
            l,
            c,
            l,
            d,
            l,
            c,
            l
          ],
          [
            0,
            o,
            a,
            o + a,
            r,
            o + a + r,
            a + r,
            o + a + r
          ]
        ];
      } else if (i === 2) {
        const o = Math.floor(n / 2), r = n - o, a = e, l = a + o;
        return [
          [
            0,
            a,
            a,
            a,
            l,
            a,
            a,
            a
          ],
          [
            0,
            o,
            o,
            o,
            r,
            o + r,
            o + r,
            o + r
          ]
        ];
      } else {
        const o = e, r = n;
        return [
          [
            0,
            o,
            o,
            o,
            o,
            o,
            o,
            o
          ],
          [
            0,
            r,
            r,
            r,
            r,
            r,
            r,
            r
          ]
        ];
      }
    }
    equals(e) {
      return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColor === e.cursorColor && this.themeType === e.themeType && this.backgroundColor === e.backgroundColor && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
    }
  }
  class Jj extends Do {
    constructor(e) {
      super(e), this._domNode = dt(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = Yt.onDidChange((t) => {
        t.changedColorMap && this._updateSettings(!0);
      }), this._cursorPositions = [];
    }
    dispose() {
      super.dispose(), this._tokensColorTrackerListener.dispose();
    }
    _updateSettings(e) {
      const t = new Qj(this._context.configuration, this._context.theme);
      return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
    }
    onConfigurationChanged(e) {
      return this._updateSettings(!1);
    }
    onCursorStateChanged(e) {
      this._cursorPositions = [];
      for (let t = 0, i = e.selections.length; t < i; t++)
        this._cursorPositions[t] = e.selections[t].getPosition();
      return this._cursorPositions.sort(V.compare), !0;
    }
    onDecorationsChanged(e) {
      return !!e.affectsOverviewRuler;
    }
    onFlushed(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollHeightChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    onThemeChanged(e) {
      return this._updateSettings(!1);
    }
    getDomNode() {
      return this._domNode.domNode;
    }
    prepareRender(e) {
    }
    render(e) {
      this._render();
    }
    _render() {
      if (this._settings.overviewRulerLanes === 0) {
        this._domNode.setBackgroundColor(this._settings.backgroundColor ? this._settings.backgroundColor : ""), this._domNode.setDisplay("none");
        return;
      }
      this._domNode.setDisplay("block");
      const e = this._settings.canvasWidth, t = this._settings.canvasHeight, i = this._settings.lineHeight, n = this._context.viewLayout, o = this._context.viewLayout.getScrollHeight(), r = t / o, a = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme), l = 6 * this._settings.pixelRatio | 0, c = l / 2 | 0, d = this._domNode.domNode.getContext("2d");
      this._settings.backgroundColor === null ? d.clearRect(0, 0, e, t) : (d.fillStyle = this._settings.backgroundColor, d.fillRect(0, 0, e, t));
      const h = this._settings.x, u = this._settings.w;
      a.sort(eF.cmp);
      for (const f of a) {
        const g = f.color, _ = f.data;
        d.fillStyle = g;
        let b = 0, C = 0, v = 0;
        for (let w = 0, S = _.length / 3; w < S; w++) {
          const L = _[3 * w], x = _[3 * w + 1], y = _[3 * w + 2];
          let k = n.getVerticalOffsetForLineNumber(x) * r | 0, I = (n.getVerticalOffsetForLineNumber(y) + i) * r | 0;
          if (I - k < l) {
            let R = (k + I) / 2 | 0;
            R < c ? R = c : R + c > t && (R = t - c), k = R - c, I = R + c;
          }
          k > v + 1 || L !== b ? (w !== 0 && d.fillRect(h[b], C, u[b], v - C), b = L, C = k, v = I) : I > v && (v = I);
        }
        d.fillRect(h[b], C, u[b], v - C);
      }
      if (!this._settings.hideCursor && this._settings.cursorColor) {
        const f = 2 * this._settings.pixelRatio | 0, g = f / 2 | 0, _ = this._settings.x[7], b = this._settings.w[7];
        d.fillStyle = this._settings.cursorColor;
        let C = -100, v = -100;
        for (let w = 0, S = this._cursorPositions.length; w < S; w++) {
          const L = this._cursorPositions[w];
          let x = n.getVerticalOffsetForLineNumber(L.lineNumber) * r | 0;
          x < g ? x = g : x + g > t && (x = t - g);
          const y = x - g, k = y + f;
          y > v + 1 ? (w !== 0 && d.fillRect(_, C, b, v - C), C = y, v = k) : k > v && (v = k);
        }
        d.fillRect(_, C, b, v - C);
      }
      this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (d.beginPath(), d.lineWidth = 1, d.strokeStyle = this._settings.borderColor, d.moveTo(0, 0), d.lineTo(0, t), d.stroke(), d.moveTo(0, 0), d.lineTo(e, 0), d.stroke());
    }
  }
  class ET {
    constructor(e, t, i) {
      this._colorZoneBrand = void 0, this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
    }
    static compare(e, t) {
      return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
    }
  }
  class sp {
    constructor(e, t, i, n) {
      this._overviewRulerZoneBrand = void 0, this.startLineNumber = e, this.endLineNumber = t, this.heightInLines = i, this.color = n, this._colorZone = null;
    }
    static compare(e, t) {
      return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.heightInLines === t.heightInLines ? e.endLineNumber - t.endLineNumber : e.heightInLines - t.heightInLines : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
    }
    setColorZone(e) {
      this._colorZone = e;
    }
    getColorZones() {
      return this._colorZone;
    }
  }
  class eK {
    constructor(e) {
      this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
    }
    getId2Color() {
      return this._id2Color;
    }
    setZones(e) {
      this._zones = e, this._zones.sort(sp.compare);
    }
    setLineHeight(e) {
      return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
    }
    setPixelRatio(e) {
      this._pixelRatio = e, this._colorZonesInvalid = !0;
    }
    getDOMWidth() {
      return this._domWidth;
    }
    getCanvasWidth() {
      return this._domWidth * this._pixelRatio;
    }
    setDOMWidth(e) {
      return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
    }
    getDOMHeight() {
      return this._domHeight;
    }
    getCanvasHeight() {
      return this._domHeight * this._pixelRatio;
    }
    setDOMHeight(e) {
      return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
    }
    getOuterHeight() {
      return this._outerHeight;
    }
    setOuterHeight(e) {
      return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
    }
    resolveColorZones() {
      const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), n = Math.floor(this._outerHeight), o = i / n, r = Math.floor(4 * this._pixelRatio / 2), a = [];
      for (let l = 0, c = this._zones.length; l < c; l++) {
        const d = this._zones[l];
        if (!e) {
          const S = d.getColorZones();
          if (S) {
            a.push(S);
            continue;
          }
        }
        const h = this._getVerticalOffsetForLine(d.startLineNumber), u = d.heightInLines === 0 ? this._getVerticalOffsetForLine(d.endLineNumber) + t : h + d.heightInLines * t, f = Math.floor(o * h), g = Math.floor(o * u);
        let _ = Math.floor((f + g) / 2), b = g - _;
        b < r && (b = r), _ - b < 0 && (_ = b), _ + b > i && (_ = i - b);
        const C = d.color;
        let v = this._color2Id[C];
        v || (v = ++this._lastAssignedId, this._color2Id[C] = v, this._id2Color[v] = C);
        const w = new ET(_ - b, _ + b, v);
        d.setColorZone(w), a.push(w);
      }
      return this._colorZonesInvalid = !1, a.sort(ET.compare), a;
    }
  }
  class tK extends d_ {
    constructor(e, t) {
      super(), this._context = e;
      const i = this._context.configuration.options;
      this._domNode = dt(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new eK((n) => this._context.viewLayout.getVerticalOffsetForLineNumber(n)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(59)), this._zoneManager.setPixelRatio(i.get(129)), this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), super.dispose();
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options;
      return e.hasChanged(59) && (this._zoneManager.setLineHeight(t.get(59)), this._render()), e.hasChanged(129) && (this._zoneManager.setPixelRatio(t.get(129)), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
    }
    onFlushed(e) {
      return this._render(), !0;
    }
    onScrollChanged(e) {
      return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
    }
    onZonesChanged(e) {
      return this._render(), !0;
    }
    getDomNode() {
      return this._domNode.domNode;
    }
    setLayout(e) {
      this._domNode.setTop(e.top), this._domNode.setRight(e.right);
      let t = !1;
      t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
    }
    setZones(e) {
      this._zoneManager.setZones(e), this._render();
    }
    _render() {
      if (this._zoneManager.getOuterHeight() === 0)
        return !1;
      const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), n = this._zoneManager.getId2Color(), o = this._domNode.domNode.getContext("2d");
      return o.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(o, i, n, e), !0;
    }
    _renderOneLane(e, t, i, n) {
      let o = 0, r = 0, a = 0;
      for (const l of t) {
        const c = l.colorId, d = l.from, h = l.to;
        c !== o ? (e.fillRect(0, r, n, a - r), o = c, e.fillStyle = i[o], r = d, a = h) : a >= d ? a = Math.max(a, h) : (e.fillRect(0, r, n, a - r), r = d, a = h);
      }
      e.fillRect(0, r, n, a - r);
    }
  }
  class iK extends Do {
    constructor(e) {
      super(e), this.domNode = dt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
      const t = this._context.configuration.options;
      this._rulers = t.get(91), this._typicalHalfwidthCharacterWidth = t.get(44).typicalHalfwidthCharacterWidth;
    }
    dispose() {
      super.dispose();
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options;
      return this._rulers = t.get(91), this._typicalHalfwidthCharacterWidth = t.get(44).typicalHalfwidthCharacterWidth, !0;
    }
    onScrollChanged(e) {
      return e.scrollHeightChanged;
    }
    prepareRender(e) {
    }
    _ensureRulersCount() {
      const e = this._renderedRulers.length, t = this._rulers.length;
      if (e === t)
        return;
      if (e < t) {
        const { tabSize: n } = this._context.viewModel.model.getOptions(), o = n;
        let r = t - e;
        for (; r > 0; ) {
          const a = dt(document.createElement("div"));
          a.setClassName("view-ruler"), a.setWidth(o), this.domNode.appendChild(a), this._renderedRulers.push(a), r--;
        }
        return;
      }
      let i = e - t;
      for (; i > 0; ) {
        const n = this._renderedRulers.pop();
        this.domNode.removeChild(n), i--;
      }
    }
    render(e) {
      this._ensureRulersCount();
      for (let t = 0, i = this._rulers.length; t < i; t++) {
        const n = this._renderedRulers[t], o = this._rulers[t];
        n.setBoxShadow(o.color ? `1px 0 0 0 ${o.color} inset` : ""), n.setHeight(Math.min(e.scrollHeight, 1e6)), n.setLeft(o.column * this._typicalHalfwidthCharacterWidth);
      }
    }
  }
  Vt((s, e) => {
    const t = s.getColor(T$);
    t && e.addRule(`.monaco-editor .view-ruler { box-shadow: 1px 0 0 0 ${t} inset; }`);
  });
  class nK extends Do {
    constructor(e) {
      super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
      const i = this._context.configuration.options.get(92);
      this._useShadows = i.useShadows, this._domNode = dt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
    }
    dispose() {
      super.dispose();
    }
    _updateShouldShow() {
      const e = this._useShadows && this._scrollTop > 0;
      return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
    }
    getDomNode() {
      return this._domNode;
    }
    _updateWidth() {
      const t = this._context.configuration.options.get(131);
      t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.minimap.minimapWidth - t.verticalScrollbarWidth;
    }
    onConfigurationChanged(e) {
      const i = this._context.configuration.options.get(92);
      return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
    }
    onScrollChanged(e) {
      return this._scrollTop = e.scrollTop, this._updateShouldShow();
    }
    prepareRender(e) {
    }
    render(e) {
      this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
    }
  }
  Vt((s, e) => {
    const t = s.getColor(sg);
    t && e.addRule(`.monaco-editor .scroll-decoration { box-shadow: ${t} 0 6px 6px -6px inset; }`);
  });
  class sK {
    constructor(e) {
      this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
    }
  }
  class oK {
    constructor(e, t) {
      this.lineNumber = e, this.ranges = t;
    }
  }
  function rK(s) {
    return new sK(s);
  }
  function aK(s) {
    return new oK(s.lineNumber, s.ranges.map(rK));
  }
  class oi extends rg {
    constructor(e) {
      super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
      const t = this._context.configuration.options;
      this._lineHeight = t.get(59), this._roundedSelection = t.get(90), this._typicalHalfwidthCharacterWidth = t.get(44).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
    }
    dispose() {
      this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options;
      return this._lineHeight = t.get(59), this._roundedSelection = t.get(90), this._typicalHalfwidthCharacterWidth = t.get(44).typicalHalfwidthCharacterWidth, !0;
    }
    onCursorStateChanged(e) {
      return this._selections = e.selections.slice(0), !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    _visibleRangesHaveGaps(e) {
      for (let t = 0, i = e.length; t < i; t++)
        if (e[t].ranges.length > 1)
          return !0;
      return !1;
    }
    _enrichVisibleRangesWithStyle(e, t, i) {
      const n = this._typicalHalfwidthCharacterWidth / 4;
      let o = null, r = null;
      if (i && i.length > 0 && t.length > 0) {
        const a = t[0].lineNumber;
        if (a === e.startLineNumber)
          for (let c = 0; !o && c < i.length; c++)
            i[c].lineNumber === a && (o = i[c].ranges[0]);
        const l = t[t.length - 1].lineNumber;
        if (l === e.endLineNumber)
          for (let c = i.length - 1; !r && c >= 0; c--)
            i[c].lineNumber === l && (r = i[c].ranges[0]);
        o && !o.startStyle && (o = null), r && !r.startStyle && (r = null);
      }
      for (let a = 0, l = t.length; a < l; a++) {
        const c = t[a].ranges[0], d = c.left, h = c.left + c.width, u = {
          top: 0,
          bottom: 0
        }, f = {
          top: 0,
          bottom: 0
        };
        if (a > 0) {
          const g = t[a - 1].ranges[0].left, _ = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
          Y_(d - g) < n ? u.top = 2 : d > g && (u.top = 1), Y_(h - _) < n ? f.top = 2 : g < h && h < _ && (f.top = 1);
        } else
          o && (u.top = o.startStyle.top, f.top = o.endStyle.top);
        if (a + 1 < l) {
          const g = t[a + 1].ranges[0].left, _ = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
          Y_(d - g) < n ? u.bottom = 2 : g < d && d < _ && (u.bottom = 1), Y_(h - _) < n ? f.bottom = 2 : h < _ && (f.bottom = 1);
        } else
          r && (u.bottom = r.startStyle.bottom, f.bottom = r.endStyle.bottom);
        c.startStyle = u, c.endStyle = f;
      }
    }
    _getVisibleRangesWithStyle(e, t, i) {
      const o = (t.linesVisibleRangesForRange(e, !0) || []).map(aK);
      return !this._visibleRangesHaveGaps(o) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, o, i), o;
    }
    _createSelectionPiece(e, t, i, n, o) {
      return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;left:" + n.toString() + "px;width:" + o.toString() + "px;height:" + t + 'px;"></div>';
    }
    _actualRenderOneSelection(e, t, i, n) {
      if (n.length === 0)
        return;
      const o = !!n[0].ranges[0].startStyle, r = this._lineHeight.toString(), a = (this._lineHeight - 1).toString(), l = n[0].lineNumber, c = n[n.length - 1].lineNumber;
      for (let d = 0, h = n.length; d < h; d++) {
        const u = n[d], f = u.lineNumber, g = f - t, _ = i && (f === c || f === l) ? a : r, b = i && f === l ? 1 : 0;
        let C = "", v = "";
        for (let w = 0, S = u.ranges.length; w < S; w++) {
          const L = u.ranges[w];
          if (o) {
            const y = L.startStyle, k = L.endStyle;
            if (y.top === 1 || y.bottom === 1) {
              C += this._createSelectionPiece(b, _, oi.SELECTION_CLASS_NAME, L.left - oi.ROUNDED_PIECE_WIDTH, oi.ROUNDED_PIECE_WIDTH);
              let I = oi.EDITOR_BACKGROUND_CLASS_NAME;
              y.top === 1 && (I += " " + oi.SELECTION_TOP_RIGHT), y.bottom === 1 && (I += " " + oi.SELECTION_BOTTOM_RIGHT), C += this._createSelectionPiece(b, _, I, L.left - oi.ROUNDED_PIECE_WIDTH, oi.ROUNDED_PIECE_WIDTH);
            }
            if (k.top === 1 || k.bottom === 1) {
              C += this._createSelectionPiece(b, _, oi.SELECTION_CLASS_NAME, L.left + L.width, oi.ROUNDED_PIECE_WIDTH);
              let I = oi.EDITOR_BACKGROUND_CLASS_NAME;
              k.top === 1 && (I += " " + oi.SELECTION_TOP_LEFT), k.bottom === 1 && (I += " " + oi.SELECTION_BOTTOM_LEFT), C += this._createSelectionPiece(b, _, I, L.left + L.width, oi.ROUNDED_PIECE_WIDTH);
            }
          }
          let x = oi.SELECTION_CLASS_NAME;
          if (o) {
            const y = L.startStyle, k = L.endStyle;
            y.top === 0 && (x += " " + oi.SELECTION_TOP_LEFT), y.bottom === 0 && (x += " " + oi.SELECTION_BOTTOM_LEFT), k.top === 0 && (x += " " + oi.SELECTION_TOP_RIGHT), k.bottom === 0 && (x += " " + oi.SELECTION_BOTTOM_RIGHT);
          }
          v += this._createSelectionPiece(b, _, x, L.left, L.width);
        }
        e[g][0] += C, e[g][1] += v;
      }
    }
    prepareRender(e) {
      const t = [], i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
      for (let r = i; r <= n; r++) {
        const a = r - i;
        t[a] = ["", ""];
      }
      const o = [];
      for (let r = 0, a = this._selections.length; r < a; r++) {
        const l = this._selections[r];
        if (l.isEmpty()) {
          o[r] = null;
          continue;
        }
        const c = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[r]);
        o[r] = c, this._actualRenderOneSelection(t, i, this._selections.length > 1, c);
      }
      this._previousFrameVisibleRangesWithStyle = o, this._renderResult = t.map(([r, a]) => r + a);
    }
    render(e, t) {
      if (!this._renderResult)
        return "";
      const i = t - e;
      return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
    }
  }
  oi.SELECTION_CLASS_NAME = "selected-text";
  oi.SELECTION_TOP_LEFT = "top-left-radius";
  oi.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
  oi.SELECTION_TOP_RIGHT = "top-right-radius";
  oi.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
  oi.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
  oi.ROUNDED_PIECE_WIDTH = 10;
  Vt((s, e) => {
    const t = s.getColor(sc);
    t && e.addRule(`.monaco-editor .focused .selected-text { background-color: ${t}; }`);
    const i = s.getColor(eE);
    i && e.addRule(`.monaco-editor .selected-text { background-color: ${i}; }`);
    const n = s.getColor(Rz);
    n && !n.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${n}; }`);
  });
  function Y_(s) {
    return s < 0 ? -s : s;
  }
  class NT {
    constructor(e, t, i, n, o, r) {
      this.top = e, this.left = t, this.width = i, this.height = n, this.textContent = o, this.textContentClassName = r;
    }
  }
  class TT {
    constructor(e) {
      this._context = e;
      const t = this._context.configuration.options, i = t.get(44);
      this._cursorStyle = t.get(24), this._lineHeight = t.get(59), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(27), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = dt(document.createElement("div")), this._domNode.setClassName(`cursor ${Ad}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), En(this._domNode, i), this._domNode.setDisplay("none"), this._position = new V(1, 1), this._lastRenderedContent = "", this._renderData = null;
    }
    getDomNode() {
      return this._domNode;
    }
    getPosition() {
      return this._position;
    }
    show() {
      this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
    }
    hide() {
      this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options, i = t.get(44);
      return this._cursorStyle = t.get(24), this._lineHeight = t.get(59), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(27), this._typicalHalfwidthCharacterWidth), En(this._domNode, i), !0;
    }
    onCursorPositionChanged(e) {
      return this._position = e, !0;
    }
    _getGraphemeAwarePosition() {
      const { lineNumber: e, column: t } = this._position, i = this._context.viewModel.getLineContent(e), [n, o] = ZW(i, t - 1);
      return [new V(e, n + 1), i.substring(n, o)];
    }
    _prepareRender(e) {
      let t = "";
      const [i, n] = this._getGraphemeAwarePosition();
      if (this._cursorStyle === sn.Line || this._cursorStyle === sn.LineThin) {
        const u = e.visibleRangeForPosition(i);
        if (!u || u.outsideRenderedLine)
          return null;
        let f;
        this._cursorStyle === sn.Line ? (f = P2(this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), f > 2 && (t = n)) : f = P2(1);
        let g = u.left;
        f >= 2 && g >= 1 && (g -= 1);
        const _ = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.bigNumbersDelta;
        return new NT(_, g, f, this._lineHeight, t, "");
      }
      const o = e.linesVisibleRangesForRange(new D(i.lineNumber, i.column, i.lineNumber, i.column + n.length), !1);
      if (!o || o.length === 0)
        return null;
      const r = o[0];
      if (r.outsideRenderedLine || r.ranges.length === 0)
        return null;
      const a = r.ranges[0], l = a.width < 1 ? this._typicalHalfwidthCharacterWidth : a.width;
      let c = "";
      if (this._cursorStyle === sn.Block) {
        const u = this._context.viewModel.getViewLineData(i.lineNumber);
        t = n;
        const f = u.tokens.findTokenIndexAtOffset(i.column - 1);
        c = u.tokens.getClassName(f);
      }
      let d = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.bigNumbersDelta, h = this._lineHeight;
      return (this._cursorStyle === sn.Underline || this._cursorStyle === sn.UnderlineThin) && (d += this._lineHeight - 2, h = 2), new NT(d, a.left, l, h, t, c);
    }
    prepareRender(e) {
      this._renderData = this._prepareRender(e);
    }
    render(e) {
      return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${Ad} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
        domNode: this._domNode.domNode,
        position: this._position,
        contentLeft: this._renderData.left,
        height: this._renderData.height,
        width: 2
      }) : (this._domNode.setDisplay("none"), null);
    }
  }
  class op extends Do {
    constructor(e) {
      super(e);
      const t = this._context.configuration.options;
      this._readOnly = t.get(81), this._cursorBlinking = t.get(22), this._cursorStyle = t.get(24), this._cursorSmoothCaretAnimation = t.get(23), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new TT(this._context), this._secondaryCursors = [], this._renderData = [], this._domNode = dt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new Ns(), this._cursorFlatBlinkInterval = new o_(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
    }
    dispose() {
      super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
    }
    getDomNode() {
      return this._domNode;
    }
    onCompositionStart(e) {
      return this._isComposingInput = !0, this._updateBlinking(), !0;
    }
    onCompositionEnd(e) {
      return this._isComposingInput = !1, this._updateBlinking(), !0;
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options;
      this._readOnly = t.get(81), this._cursorBlinking = t.get(22), this._cursorStyle = t.get(24), this._cursorSmoothCaretAnimation = t.get(23), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
      for (let i = 0, n = this._secondaryCursors.length; i < n; i++)
        this._secondaryCursors[i].onConfigurationChanged(e);
      return !0;
    }
    _onCursorPositionChanged(e, t) {
      if (this._primaryCursor.onCursorPositionChanged(e), this._updateBlinking(), this._secondaryCursors.length < t.length) {
        const i = t.length - this._secondaryCursors.length;
        for (let n = 0; n < i; n++) {
          const o = new TT(this._context);
          this._domNode.domNode.insertBefore(o.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(o);
        }
      } else if (this._secondaryCursors.length > t.length) {
        const i = this._secondaryCursors.length - t.length;
        for (let n = 0; n < i; n++)
          this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
      }
      for (let i = 0; i < t.length; i++)
        this._secondaryCursors[i].onCursorPositionChanged(t[i]);
    }
    onCursorStateChanged(e) {
      const t = [];
      for (let n = 0, o = e.selections.length; n < o; n++)
        t[n] = e.selections[n].getPosition();
      this._onCursorPositionChanged(t[0], t.slice(1));
      const i = e.selections[0].isEmpty();
      return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
    }
    onDecorationsChanged(e) {
      return !0;
    }
    onFlushed(e) {
      return !0;
    }
    onFocusChanged(e) {
      return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
    }
    onLinesChanged(e) {
      return !0;
    }
    onLinesDeleted(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return !0;
    }
    onTokensChanged(e) {
      const t = (i) => {
        for (let n = 0, o = e.ranges.length; n < o; n++)
          if (e.ranges[n].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[n].toLineNumber)
            return !0;
        return !1;
      };
      if (t(this._primaryCursor.getPosition()))
        return !0;
      for (const i of this._secondaryCursors)
        if (t(i.getPosition()))
          return !0;
      return !1;
    }
    onZonesChanged(e) {
      return !0;
    }
    _getCursorBlinking() {
      return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
    }
    _updateBlinking() {
      this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
      const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
      t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
        this._isVisible ? this._hide() : this._show();
      }, op.BLINK_INTERVAL) : this._startCursorBlinkAnimation.setIfNotSet(() => {
        this._blinkingEnabled = !0, this._updateDomClassName();
      }, op.BLINK_INTERVAL));
    }
    _updateDomClassName() {
      this._domNode.setClassName(this._getClassName());
    }
    _getClassName() {
      let e = "cursors-layer";
      switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
        case sn.Line:
          e += " cursor-line-style";
          break;
        case sn.Block:
          e += " cursor-block-style";
          break;
        case sn.Underline:
          e += " cursor-underline-style";
          break;
        case sn.LineThin:
          e += " cursor-line-thin-style";
          break;
        case sn.BlockOutline:
          e += " cursor-block-outline-style";
          break;
        case sn.UnderlineThin:
          e += " cursor-underline-thin-style";
          break;
        default:
          e += " cursor-line-style";
      }
      if (this._blinkingEnabled)
        switch (this._getCursorBlinking()) {
          case 1:
            e += " cursor-blink";
            break;
          case 2:
            e += " cursor-smooth";
            break;
          case 3:
            e += " cursor-phase";
            break;
          case 4:
            e += " cursor-expand";
            break;
          case 5:
            e += " cursor-solid";
            break;
          default:
            e += " cursor-solid";
        }
      else
        e += " cursor-solid";
      return this._cursorSmoothCaretAnimation && (e += " cursor-smooth-caret-animation"), e;
    }
    _show() {
      this._primaryCursor.show();
      for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
        this._secondaryCursors[e].show();
      this._isVisible = !0;
    }
    _hide() {
      this._primaryCursor.hide();
      for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
        this._secondaryCursors[e].hide();
      this._isVisible = !1;
    }
    prepareRender(e) {
      this._primaryCursor.prepareRender(e);
      for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
        this._secondaryCursors[t].prepareRender(e);
    }
    render(e) {
      const t = [];
      let i = 0;
      const n = this._primaryCursor.render(e);
      n && (t[i++] = n);
      for (let o = 0, r = this._secondaryCursors.length; o < r; o++) {
        const a = this._secondaryCursors[o].render(e);
        a && (t[i++] = a);
      }
      this._renderData = t;
    }
    getLastRenderData() {
      return this._renderData;
    }
  }
  op.BLINK_INTERVAL = 500;
  Vt((s, e) => {
    const t = s.getColor(F5);
    if (t) {
      let i = s.getColor(E$);
      i || (i = t.opposite()), e.addRule(`.monaco-editor .inputarea.ime-input { caret-color: ${t}; }`), e.addRule(`.monaco-editor .cursors-layer .cursor { background-color: ${t}; border-color: ${t}; color: ${i}; }`), s.type === "hc" && e.addRule(`.monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid ${i}; border-right: 1px solid ${i}; }`);
    }
  });
  const eS = () => {
    throw new Error("Invalid change accessor");
  };
  class lK extends Do {
    constructor(e) {
      super(e);
      const t = this._context.configuration.options, i = t.get(131);
      this._lineHeight = t.get(59), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = dt(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = dt(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
    }
    dispose() {
      super.dispose(), this._zones = {};
    }
    _recomputeWhitespacesProps() {
      const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
      for (const n of e)
        t.set(n.id, n);
      let i = !1;
      return this._context.viewModel.changeWhitespace((n) => {
        const o = Object.keys(this._zones);
        for (let r = 0, a = o.length; r < a; r++) {
          const l = o[r], c = this._zones[l], d = this._computeWhitespaceProps(c.delegate);
          c.isInHiddenArea = d.isInHiddenArea;
          const h = t.get(l);
          h && (h.afterLineNumber !== d.afterViewLineNumber || h.height !== d.heightInPx) && (n.changeOneWhitespace(l, d.afterViewLineNumber, d.heightInPx), this._safeCallOnComputedHeight(c.delegate, d.heightInPx), i = !0);
        }
      }), i;
    }
    onConfigurationChanged(e) {
      const t = this._context.configuration.options, i = t.get(131);
      return this._lineHeight = t.get(59), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(59) && this._recomputeWhitespacesProps(), !0;
    }
    onLineMappingChanged(e) {
      return this._recomputeWhitespacesProps();
    }
    onLinesDeleted(e) {
      return !0;
    }
    onScrollChanged(e) {
      return e.scrollTopChanged || e.scrollWidthChanged;
    }
    onZonesChanged(e) {
      return !0;
    }
    onLinesInserted(e) {
      return !0;
    }
    _getZoneOrdinal(e) {
      return typeof e.afterColumn < "u" ? e.afterColumn : 1e4;
    }
    _computeWhitespaceProps(e) {
      if (e.afterLineNumber === 0)
        return {
          isInHiddenArea: !1,
          afterViewLineNumber: 0,
          heightInPx: this._heightInPixels(e),
          minWidthInPx: this._minWidthInPixels(e)
        };
      let t;
      if (typeof e.afterColumn < "u")
        t = this._context.viewModel.model.validatePosition({
          lineNumber: e.afterLineNumber,
          column: e.afterColumn
        });
      else {
        const r = this._context.viewModel.model.validatePosition({
          lineNumber: e.afterLineNumber,
          column: 1
        }).lineNumber;
        t = new V(r, this._context.viewModel.model.getLineMaxColumn(r));
      }
      let i;
      t.column === this._context.viewModel.model.getLineMaxColumn(t.lineNumber) ? i = this._context.viewModel.model.validatePosition({
        lineNumber: t.lineNumber + 1,
        column: 1
      }) : i = this._context.viewModel.model.validatePosition({
        lineNumber: t.lineNumber,
        column: t.column + 1
      });
      const n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t, e.afterColumnAffinity), o = this._context.viewModel.coordinatesConverter.modelPositionIsVisible(i);
      return {
        isInHiddenArea: !o,
        afterViewLineNumber: n.lineNumber,
        heightInPx: o ? this._heightInPixels(e) : 0,
        minWidthInPx: this._minWidthInPixels(e)
      };
    }
    changeViewZones(e) {
      let t = !1;
      return this._context.viewModel.changeWhitespace((i) => {
        const n = {
          addZone: (o) => (t = !0, this._addZone(i, o)),
          removeZone: (o) => {
            !o || (t = this._removeZone(i, o) || t);
          },
          layoutZone: (o) => {
            !o || (t = this._layoutZone(i, o) || t);
          }
        };
        cK(e, n), n.addZone = eS, n.removeZone = eS, n.layoutZone = eS;
      }), t;
    }
    _addZone(e, t) {
      const i = this._computeWhitespaceProps(t), o = {
        whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
        delegate: t,
        isInHiddenArea: i.isInHiddenArea,
        isVisible: !1,
        domNode: dt(t.domNode),
        marginDomNode: t.marginDomNode ? dt(t.marginDomNode) : null
      };
      return this._safeCallOnComputedHeight(o.delegate, i.heightInPx), o.domNode.setPosition("absolute"), o.domNode.domNode.style.width = "100%", o.domNode.setDisplay("none"), o.domNode.setAttribute("monaco-view-zone", o.whitespaceId), this.domNode.appendChild(o.domNode), o.marginDomNode && (o.marginDomNode.setPosition("absolute"), o.marginDomNode.domNode.style.width = "100%", o.marginDomNode.setDisplay("none"), o.marginDomNode.setAttribute("monaco-view-zone", o.whitespaceId), this.marginDomNode.appendChild(o.marginDomNode)), this._zones[o.whitespaceId] = o, this.setShouldRender(), o.whitespaceId;
    }
    _removeZone(e, t) {
      if (this._zones.hasOwnProperty(t)) {
        const i = this._zones[t];
        return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.parentNode.removeChild(i.domNode.domNode), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.parentNode.removeChild(i.marginDomNode.domNode)), this.setShouldRender(), !0;
      }
      return !1;
    }
    _layoutZone(e, t) {
      if (this._zones.hasOwnProperty(t)) {
        const i = this._zones[t], n = this._computeWhitespaceProps(i.delegate);
        return i.isInHiddenArea = n.isInHiddenArea, e.changeOneWhitespace(i.whitespaceId, n.afterViewLineNumber, n.heightInPx), this._safeCallOnComputedHeight(i.delegate, n.heightInPx), this.setShouldRender(), !0;
      }
      return !1;
    }
    shouldSuppressMouseDownOnViewZone(e) {
      if (this._zones.hasOwnProperty(e)) {
        const t = this._zones[e];
        return Boolean(t.delegate.suppressMouseDown);
      }
      return !1;
    }
    _heightInPixels(e) {
      return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
    }
    _minWidthInPixels(e) {
      return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
    }
    _safeCallOnComputedHeight(e, t) {
      if (typeof e.onComputedHeight == "function")
        try {
          e.onComputedHeight(t);
        } catch (i) {
          We(i);
        }
    }
    _safeCallOnDomNodeTop(e, t) {
      if (typeof e.onDomNodeTop == "function")
        try {
          e.onDomNodeTop(t);
        } catch (i) {
          We(i);
        }
    }
    prepareRender(e) {
    }
    render(e) {
      const t = e.viewportData.whitespaceViewportData, i = {};
      let n = !1;
      for (const r of t)
        this._zones[r.id].isInHiddenArea || (i[r.id] = r, n = !0);
      const o = Object.keys(this._zones);
      for (let r = 0, a = o.length; r < a; r++) {
        const l = o[r], c = this._zones[l];
        let d = 0, h = 0, u = "none";
        i.hasOwnProperty(l) ? (d = i[l].verticalOffset - e.bigNumbersDelta, h = i[l].height, u = "block", c.isVisible || (c.domNode.setAttribute("monaco-visible-view-zone", "true"), c.isVisible = !0), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (c.isVisible && (c.domNode.removeAttribute("monaco-visible-view-zone"), c.isVisible = !1), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), c.domNode.setTop(d), c.domNode.setHeight(h), c.domNode.setDisplay(u), c.marginDomNode && (c.marginDomNode.setTop(d), c.marginDomNode.setHeight(h), c.marginDomNode.setDisplay(u));
      }
      n && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
    }
  }
  function cK(s, e) {
    try {
      return s(e);
    } catch (t) {
      We(t);
    }
  }
  class dK {
    constructor(e) {
      this._theme = e;
    }
    get type() {
      return this._theme.type;
    }
    get value() {
      return this._theme;
    }
    update(e) {
      this._theme = e;
    }
    getColor(e) {
      return this._theme.getColor(e);
    }
  }
  class hK {
    constructor(e, t, i) {
      this.configuration = e, this.theme = new dK(t), this.viewModel = i, this.viewLayout = i.viewLayout;
    }
    addEventHandler(e) {
      this.viewModel.addViewEventHandler(e);
    }
    removeEventHandler(e) {
      this.viewModel.removeViewEventHandler(e);
    }
  }
  class uK {
    constructor(e, t, i, n) {
      this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.whitespaceViewportData = i, this._model = n, this.visibleRange = new D(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
    }
    getViewLineRenderingData(e) {
      return this._model.getViewLineRenderingData(this.visibleRange, e);
    }
    getDecorationsInViewport() {
      return this._model.getDecorationsInViewport(this.visibleRange);
    }
  }
  class fK extends d_ {
    constructor(e, t, i, n, o, r) {
      super(), this._selections = [new ae(1, 1, 1, 1)], this._renderAnimationFrame = null;
      const a = new dj(t, n, o, e);
      this._context = new hK(t, i, n), this._context.addEventHandler(this), this._viewParts = [], this._textAreaHandler = new lj(this._context, a, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = dt(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = dt(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = dt(document.createElement("div")), ha.write(this._overflowGuardContainer, 3), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new Tj(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new dC(this._context, this._linesContent), this._viewZones = new lK(this._context), this._viewParts.push(this._viewZones);
      const l = new Jj(this._context);
      this._viewParts.push(l);
      const c = new nK(this._context);
      this._viewParts.push(c);
      const d = new uj(this._context);
      this._viewParts.push(d), d.addDynamicOverlay(new pj(this._context)), d.addDynamicOverlay(new oi(this._context)), d.addDynamicOverlay(new Oj(this._context)), d.addDynamicOverlay(new bj(this._context));
      const h = new fj(this._context);
      this._viewParts.push(h), h.addDynamicOverlay(new _j(this._context)), h.addDynamicOverlay(new Mj(this._context)), h.addDynamicOverlay(new Vj(this._context)), h.addDynamicOverlay(new Wj(this._context)), h.addDynamicOverlay(new wf(this._context));
      const u = new Jd(this._context);
      u.getDomNode().appendChild(this._viewZones.marginDomNode), u.getDomNode().appendChild(h.getDomNode()), this._viewParts.push(u), this._contentWidgets = new gj(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new op(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new Xj(this._context), this._viewParts.push(this._overlayWidgets);
      const f = new iK(this._context);
      this._viewParts.push(f);
      const g = new Yj(this._context);
      if (this._viewParts.push(g), l) {
        const _ = this._scrollbar.getOverviewRulerLayoutInfo();
        _.parent.insertBefore(l.getDomNode(), _.insertBefore);
      }
      this._linesContent.appendChild(d.getDomNode()), this._linesContent.appendChild(f.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(u.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(c.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(g.getDomNode()), this.domNode.appendChild(this._overflowGuardContainer), r ? r.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode) : this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this._applyLayout(), this._pointerHandler = this._register(new y$(this._context, a, this._createPointerHandlerHelper()));
    }
    _flushAccumulatedAndRenderNow() {
      this._renderNow();
    }
    _createPointerHandlerHelper() {
      return {
        viewDomNode: this.domNode.domNode,
        linesContentDomNode: this._linesContent.domNode,
        focusTextArea: () => {
          this.focus();
        },
        dispatchTextAreaEvent: (e) => {
          this._textAreaHandler.textArea.domNode.dispatchEvent(e);
        },
        getLastRenderData: () => {
          const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
          return new g$(e, t);
        },
        shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
        shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
        getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
        visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new V(e, t))),
        getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
      };
    }
    _createTextAreaHandlerHelper() {
      return {
        visibleRangeForPosition: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(e))
      };
    }
    _applyLayout() {
      const t = this._context.configuration.options.get(131);
      this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(1e6), this._linesContent.setHeight(1e6);
    }
    _getEditorClassName() {
      const e = this._textAreaHandler.isFocused() ? " focused" : "";
      return this._context.configuration.options.get(128) + " " + X0(this._context.theme.type) + e;
    }
    handleEvents(e) {
      super.handleEvents(e), this._scheduleRender();
    }
    onConfigurationChanged(e) {
      return this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
    }
    onCursorStateChanged(e) {
      return this._selections = e.selections, !1;
    }
    onFocusChanged(e) {
      return this.domNode.setClassName(this._getEditorClassName()), !1;
    }
    onThemeChanged(e) {
      return this._context.theme.update(e.theme), this.domNode.setClassName(this._getEditorClassName()), !1;
    }
    dispose() {
      this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
      for (const e of this._viewParts)
        e.dispose();
      super.dispose();
    }
    _scheduleRender() {
      this._renderAnimationFrame === null && (this._renderAnimationFrame = gP(this._onRenderScheduled.bind(this), 100));
    }
    _onRenderScheduled() {
      this._renderAnimationFrame = null, this._flushAccumulatedAndRenderNow();
    }
    _renderNow() {
      gK(() => this._actualRender());
    }
    _getViewPartsToRender() {
      const e = [];
      let t = 0;
      for (const i of this._viewParts)
        i.shouldRender() && (e[t++] = i);
      return e;
    }
    _actualRender() {
      if (!yI(this.domNode.domNode))
        return;
      let e = this._getViewPartsToRender();
      if (!this._viewLines.shouldRender() && e.length === 0)
        return;
      const t = this._context.viewLayout.getLinesViewportData();
      this._context.viewModel.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
      const i = new uK(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.viewModel);
      this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender());
      const n = new GU(this._context.viewLayout, i, this._viewLines);
      for (const o of e)
        o.prepareRender(n);
      for (const o of e)
        o.render(n), o.onDidRender();
    }
    delegateVerticalScrollbarMouseDown(e) {
      this._scrollbar.delegateVerticalScrollbarMouseDown(e);
    }
    restoreState(e) {
      this._context.viewModel.viewLayout.setScrollPosition({ scrollTop: e.scrollTop }, 1), this._context.viewModel.tokenizeViewport(), this._renderNow(), this._viewLines.updateLineWidths(), this._context.viewModel.viewLayout.setScrollPosition({ scrollLeft: e.scrollLeft }, 1);
    }
    getOffsetForColumn(e, t) {
      const i = this._context.viewModel.model.validatePosition({
        lineNumber: e,
        column: t
      }), n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i);
      this._flushAccumulatedAndRenderNow();
      const o = this._viewLines.visibleRangeForPosition(new V(n.lineNumber, n.column));
      return o ? o.left : -1;
    }
    getTargetAtClientPoint(e, t) {
      const i = this._pointerHandler.getTargetAtClientPoint(e, t);
      return i ? lC.convertViewToModelMouseTarget(i, this._context.viewModel.coordinatesConverter) : null;
    }
    createOverviewRuler(e) {
      return new tK(this._context, e);
    }
    change(e) {
      this._viewZones.changeViewZones(e), this._scheduleRender();
    }
    render(e, t) {
      if (t) {
        this._viewLines.forceShouldRender();
        for (const i of this._viewParts)
          i.forceShouldRender();
      }
      e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
    }
    focus() {
      this._textAreaHandler.focusTextArea();
    }
    isFocused() {
      return this._textAreaHandler.isFocused();
    }
    setAriaOptions(e) {
      this._textAreaHandler.setAriaOptions(e);
    }
    addContentWidget(e) {
      this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
    }
    layoutContentWidget(e) {
      let t = e.position && e.position.range || null;
      if (t === null) {
        const n = e.position ? e.position.position : null;
        n !== null && (t = new D(n.lineNumber, n.column, n.lineNumber, n.column));
      }
      const i = e.position ? e.position.preference : null;
      this._contentWidgets.setWidgetPosition(e.widget, t, i), this._scheduleRender();
    }
    removeContentWidget(e) {
      this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
    }
    addOverlayWidget(e) {
      this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
    }
    layoutOverlayWidget(e) {
      const t = e.position ? e.position.preference : null;
      this._overlayWidgets.setWidgetPosition(e.widget, t) && this._scheduleRender();
    }
    removeOverlayWidget(e) {
      this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
    }
  }
  function gK(s) {
    try {
      return s();
    } catch (e) {
      We(e);
    }
  }
  class m1 {
    constructor(e) {
      this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new nn(new D(1, 1, 1, 1), 0, new V(1, 1), 0), new nn(new D(1, 1, 1, 1), 0, new V(1, 1), 0));
    }
    dispose(e) {
      this._removeTrackedRange(e);
    }
    startTrackingSelection(e) {
      this._trackSelection = !0, this._updateTrackedRange(e);
    }
    stopTrackingSelection(e) {
      this._trackSelection = !1, this._removeTrackedRange(e);
    }
    _updateTrackedRange(e) {
      !this._trackSelection || (this._selTrackedRange = e.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0));
    }
    _removeTrackedRange(e) {
      this._selTrackedRange = e.model._setTrackedRange(this._selTrackedRange, null, 0);
    }
    asCursorState() {
      return new Ze(this.modelState, this.viewState);
    }
    readSelectionFromMarkers(e) {
      const t = e.model._getTrackedRange(this._selTrackedRange);
      return ae.fromRange(t, this.modelState.selection.getDirection());
    }
    ensureValidState(e) {
      this._setState(e, this.modelState, this.viewState);
    }
    setState(e, t, i) {
      this._setState(e, t, i);
    }
    static _validatePositionWithCache(e, t, i, n) {
      return t.equals(i) ? n : e.normalizePosition(t, 2);
    }
    static _validateViewState(e, t) {
      const i = t.position, n = t.selectionStart.getStartPosition(), o = t.selectionStart.getEndPosition(), r = e.normalizePosition(i, 2), a = this._validatePositionWithCache(e, n, i, r), l = this._validatePositionWithCache(e, o, n, a);
      return i.equals(r) && n.equals(a) && o.equals(l) ? t : new nn(D.fromPositions(a, l), t.selectionStartLeftoverVisibleColumns + n.column - a.column, r, t.leftoverVisibleColumns + i.column - r.column);
    }
    _setState(e, t, i) {
      if (i && (i = m1._validateViewState(e.viewModel, i)), t) {
        const n = e.model.validateRange(t.selectionStart), o = t.selectionStart.equalsRange(n) ? t.selectionStartLeftoverVisibleColumns : 0, r = e.model.validatePosition(t.position), a = t.position.equals(r) ? t.leftoverVisibleColumns : 0;
        t = new nn(n, o, r, a);
      } else {
        if (!i)
          return;
        const n = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), o = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
        t = new nn(n, i.selectionStartLeftoverVisibleColumns, o, i.leftoverVisibleColumns);
      }
      if (i) {
        const n = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), o = e.coordinatesConverter.validateViewPosition(i.position, t.position);
        i = new nn(n, t.selectionStartLeftoverVisibleColumns, o, t.leftoverVisibleColumns);
      } else {
        const n = e.coordinatesConverter.convertModelPositionToViewPosition(new V(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), o = e.coordinatesConverter.convertModelPositionToViewPosition(new V(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), r = new D(n.lineNumber, n.column, o.lineNumber, o.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
        i = new nn(r, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
      }
      this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
    }
  }
  class MT {
    constructor(e) {
      this.context = e, this.cursors = [new m1(e)], this.lastAddedCursorIndex = 0;
    }
    dispose() {
      for (const e of this.cursors)
        e.dispose(this.context);
    }
    startTrackingSelections() {
      for (const e of this.cursors)
        e.startTrackingSelection(this.context);
    }
    stopTrackingSelections() {
      for (const e of this.cursors)
        e.stopTrackingSelection(this.context);
    }
    updateContext(e) {
      this.context = e;
    }
    ensureValidState() {
      for (const e of this.cursors)
        e.ensureValidState(this.context);
    }
    readSelectionFromMarkers() {
      return this.cursors.map((e) => e.readSelectionFromMarkers(this.context));
    }
    getAll() {
      return this.cursors.map((e) => e.asCursorState());
    }
    getViewPositions() {
      return this.cursors.map((e) => e.viewState.position);
    }
    getTopMostViewPosition() {
      return WV(this.cursors, o0((e) => e.viewState.position, V.compare)).viewState.position;
    }
    getBottomMostViewPosition() {
      return BV(this.cursors, o0((e) => e.viewState.position, V.compare)).viewState.position;
    }
    getSelections() {
      return this.cursors.map((e) => e.modelState.selection);
    }
    getViewSelections() {
      return this.cursors.map((e) => e.viewState.selection);
    }
    setSelections(e) {
      this.setStates(Ze.fromModelSelections(e));
    }
    getPrimaryCursor() {
      return this.cursors[0].asCursorState();
    }
    setStates(e) {
      e !== null && (this.cursors[0].setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
    }
    _setSecondaryStates(e) {
      const t = this.cursors.length - 1, i = e.length;
      if (t < i) {
        const n = i - t;
        for (let o = 0; o < n; o++)
          this._addSecondaryCursor();
      } else if (t > i) {
        const n = t - i;
        for (let o = 0; o < n; o++)
          this._removeSecondaryCursor(this.cursors.length - 2);
      }
      for (let n = 0; n < i; n++)
        this.cursors[n + 1].setState(this.context, e[n].modelState, e[n].viewState);
    }
    killSecondaryCursors() {
      this._setSecondaryStates([]);
    }
    _addSecondaryCursor() {
      this.cursors.push(new m1(this.context)), this.lastAddedCursorIndex = this.cursors.length - 1;
    }
    getLastAddedCursorIndex() {
      return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
    }
    _removeSecondaryCursor(e) {
      this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.cursors[e + 1].dispose(this.context), this.cursors.splice(e + 1, 1);
    }
    normalize() {
      if (this.cursors.length === 1)
        return;
      const e = this.cursors.slice(0), t = [];
      for (let i = 0, n = e.length; i < n; i++)
        t.push({
          index: i,
          selection: e[i].modelState.selection
        });
      t.sort(o0((i) => i.selection, D.compareRangesUsingStarts));
      for (let i = 0; i < t.length - 1; i++) {
        const n = t[i], o = t[i + 1], r = n.selection, a = o.selection;
        if (!this.context.cursorConfig.multiCursorMergeOverlapping)
          continue;
        let l;
        if (a.isEmpty() || r.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(r.getEndPosition()) : l = a.getStartPosition().isBefore(r.getEndPosition()), l) {
          const c = n.index < o.index ? i : i + 1, d = n.index < o.index ? i + 1 : i, h = t[d].index, u = t[c].index, f = t[d].selection, g = t[c].selection;
          if (!f.equalsSelection(g)) {
            const _ = f.plusRange(g), b = f.selectionStartLineNumber === f.startLineNumber && f.selectionStartColumn === f.startColumn, C = g.selectionStartLineNumber === g.startLineNumber && g.selectionStartColumn === g.startColumn;
            let v;
            h === this.lastAddedCursorIndex ? (v = b, this.lastAddedCursorIndex = u) : v = C;
            let w;
            v ? w = new ae(_.startLineNumber, _.startColumn, _.endLineNumber, _.endColumn) : w = new ae(_.endLineNumber, _.endColumn, _.startLineNumber, _.startColumn), t[c].selection = w;
            const S = Ze.fromModelSelection(w);
            e[u].setState(this.context, S.modelState, S.viewState);
          }
          for (const _ of t)
            _.index > h && _.index--;
          e.splice(h, 1), t.splice(d, 1), this._removeSecondaryCursor(h - 1), i--;
        }
      }
    }
  }
  class AT {
    constructor(e, t, i, n) {
      this._cursorContextBrand = void 0, this.model = e, this.viewModel = t, this.coordinatesConverter = i, this.cursorConfig = n;
    }
  }
  class mK {
    constructor() {
      this.changeType = 1;
    }
  }
  class vr {
    constructor(e, t, i, n, o) {
      this.ownerId = e, this.lineNumber = t, this.column = i, this.options = n, this.order = o;
    }
    static applyInjectedText(e, t) {
      if (!t || t.length === 0)
        return e;
      let i = "", n = 0;
      for (const o of t)
        i += e.substring(n, o.column - 1), n = o.column - 1, i += o.options.content;
      return i += e.substring(n), i;
    }
    static fromDecorations(e) {
      const t = [];
      for (const i of e)
        i.options.before && i.options.before.content.length > 0 && t.push(new vr(i.ownerId, i.range.startLineNumber, i.range.startColumn, i.options.before, 0)), i.options.after && i.options.after.content.length > 0 && t.push(new vr(i.ownerId, i.range.endLineNumber, i.range.endColumn, i.options.after, 1));
      return t.sort((i, n) => i.lineNumber === n.lineNumber ? i.column === n.column ? i.order - n.order : i.column - n.column : i.lineNumber - n.lineNumber), t;
    }
  }
  class RT {
    constructor(e, t, i) {
      this.changeType = 2, this.lineNumber = e, this.detail = t, this.injectedText = i;
    }
  }
  class pK {
    constructor(e, t) {
      this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
    }
  }
  class _K {
    constructor(e, t, i, n) {
      this.changeType = 4, this.injectedTexts = n, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
    }
  }
  class bK {
    constructor() {
      this.changeType = 5;
    }
  }
  class Od {
    constructor(e, t, i, n) {
      this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = n, this.resultingSelection = null;
    }
    containsEvent(e) {
      for (let t = 0, i = this.changes.length; t < i; t++)
        if (this.changes[t].changeType === e)
          return !0;
      return !1;
    }
    static merge(e, t) {
      const i = [].concat(e.changes).concat(t.changes), n = t.versionId, o = e.isUndoing || t.isUndoing, r = e.isRedoing || t.isRedoing;
      return new Od(i, n, o, r);
    }
  }
  class tF {
    constructor(e) {
      this.changes = e;
    }
  }
  class p1 {
    constructor(e, t) {
      this.rawContentChangedEvent = e, this.contentChangedEvent = t;
    }
    merge(e) {
      const t = Od.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = p1._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
      return new p1(t, i);
    }
    static _mergeChangeEvents(e, t) {
      const i = [].concat(e.changes).concat(t.changes), n = t.eol, o = t.versionId, r = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush;
      return {
        changes: i,
        eol: n,
        versionId: o,
        isUndoing: r,
        isRedoing: a,
        isFlush: l
      };
    }
  }
  class vK {
    constructor() {
      this.type = 0;
    }
  }
  class CK {
    constructor() {
      this.type = 1;
    }
  }
  class wK {
    constructor(e) {
      this.type = 2, this._source = e;
    }
    hasChanged(e) {
      return this._source.hasChanged(e);
    }
  }
  class SK {
    constructor(e, t) {
      this.type = 3, this.selections = e, this.modelSelections = t;
    }
  }
  class Jh {
    constructor(e) {
      this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0);
    }
  }
  class X_ {
    constructor() {
      this.type = 5;
    }
  }
  class yK {
    constructor(e) {
      this.type = 6, this.isFocused = e;
    }
  }
  class LK {
    constructor() {
      this.type = 7;
    }
  }
  class Q_ {
    constructor() {
      this.type = 8;
    }
  }
  class iF {
    constructor(e, t) {
      this.type = 9, this.fromLineNumber = e, this.toLineNumber = t;
    }
  }
  class xL {
    constructor(e, t) {
      this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
    }
  }
  class IL {
    constructor(e, t) {
      this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
    }
  }
  class h0 {
    constructor(e, t, i, n, o, r, a) {
      this.source = e, this.minimalReveal = t, this.range = i, this.selections = n, this.verticalType = o, this.revealHorizontal = r, this.scrollType = a, this.type = 12;
    }
  }
  class kK {
    constructor(e) {
      this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
    }
  }
  class DK {
    constructor(e) {
      this.theme = e, this.type = 14;
    }
  }
  class xK {
    constructor(e) {
      this.type = 15, this.ranges = e;
    }
  }
  class IK {
    constructor() {
      this.type = 16;
    }
  }
  class EK {
    constructor() {
      this.type = 17;
    }
  }
  class NK extends z {
    constructor() {
      super(), this._onEvent = this._register(new B()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
    }
    emitOutgoingEvent(e) {
      this._addOutgoingEvent(e), this._emitOutgoingEvents();
    }
    _addOutgoingEvent(e) {
      for (let t = 0, i = this._outgoingEvents.length; t < i; t++)
        if (this._outgoingEvents[t].kind === e.kind) {
          this._outgoingEvents[t] = this._outgoingEvents[t].merge(e);
          return;
        }
      this._outgoingEvents.push(e);
    }
    _emitOutgoingEvents() {
      for (; this._outgoingEvents.length > 0; ) {
        if (this._collector || this._isConsumingViewEventQueue)
          return;
        const e = this._outgoingEvents.shift();
        e.isNoOp() || this._onEvent.fire(e);
      }
    }
    addViewEventHandler(e) {
      for (let t = 0, i = this._eventHandlers.length; t < i; t++)
        this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
      this._eventHandlers.push(e);
    }
    removeViewEventHandler(e) {
      for (let t = 0; t < this._eventHandlers.length; t++)
        if (this._eventHandlers[t] === e) {
          this._eventHandlers.splice(t, 1);
          break;
        }
    }
    beginEmitViewEvents() {
      return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new TK()), this._collector;
    }
    endEmitViewEvents() {
      if (this._collectorCnt--, this._collectorCnt === 0) {
        const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
        this._collector = null;
        for (const i of e)
          this._addOutgoingEvent(i);
        t.length > 0 && this._emitMany(t);
      }
      this._emitOutgoingEvents();
    }
    emitSingleViewEvent(e) {
      try {
        this.beginEmitViewEvents().emitViewEvent(e);
      } finally {
        this.endEmitViewEvents();
      }
    }
    _emitMany(e) {
      this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
    }
    _consumeViewEventQueue() {
      try {
        this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
      } finally {
        this._isConsumingViewEventQueue = !1;
      }
    }
    _doConsumeQueue() {
      for (; this._viewEventQueue; ) {
        const e = this._viewEventQueue;
        this._viewEventQueue = null;
        const t = this._eventHandlers.slice(0);
        for (const i of t)
          i.handleEvents(e);
      }
    }
  }
  class TK {
    constructor() {
      this.viewEvents = [], this.outgoingEvents = [];
    }
    emitViewEvent(e) {
      this.viewEvents.push(e);
    }
    emitOutgoingEvent(e) {
      this.outgoingEvents.push(e);
    }
  }
  class pE {
    constructor(e, t, i, n) {
      this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = n, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
    }
    isNoOp() {
      return !this.contentWidthChanged && !this.contentHeightChanged;
    }
    merge(e) {
      return e.kind !== 0 ? this : new pE(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
    }
  }
  class _E {
    constructor(e, t) {
      this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
    }
    isNoOp() {
      return this.oldHasFocus === this.hasFocus;
    }
    merge(e) {
      return e.kind !== 1 ? this : new _E(this.oldHasFocus, e.hasFocus);
    }
  }
  class bE {
    constructor(e, t, i, n, o, r, a, l) {
      this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = n, this.scrollWidth = o, this.scrollLeft = r, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
    }
    isNoOp() {
      return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
    }
    merge(e) {
      return e.kind !== 2 ? this : new bE(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
    }
  }
  class OT {
    constructor() {
      this.kind = 3;
    }
    isNoOp() {
      return !1;
    }
    merge(e) {
      return this;
    }
  }
  class _1 {
    constructor(e, t, i, n, o, r, a) {
      this.kind = 6, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = n, this.source = o, this.reason = r, this.reachedMaxCursorCount = a;
    }
    static _selectionsAreEqual(e, t) {
      if (!e && !t)
        return !0;
      if (!e || !t)
        return !1;
      const i = e.length, n = t.length;
      if (i !== n)
        return !1;
      for (let o = 0; o < i; o++)
        if (!e[o].equalsSelection(t[o]))
          return !1;
      return !0;
    }
    isNoOp() {
      return _1._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
    }
    merge(e) {
      return e.kind !== 6 ? this : new _1(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
    }
  }
  class MK {
    constructor() {
      this.kind = 5;
    }
    isNoOp() {
      return !1;
    }
    merge(e) {
      return this;
    }
  }
  class yf extends z {
    constructor(e, t, i, n) {
      super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new AT(this._model, this._viewModel, this._coordinatesConverter, n), this._cursors = new MT(this.context), this._hasFocus = !1, this._isHandling = !1, this._isDoingComposition = !1, this._selectionsWhenCompositionStarted = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
    }
    dispose() {
      this._cursors.dispose(), this._autoClosedActions = at(this._autoClosedActions), super.dispose();
    }
    updateConfiguration(e) {
      this.context = new AT(this._model, this._viewModel, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
    }
    onLineMappingChanged(e) {
      this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
    }
    setHasFocus(e) {
      this._hasFocus = e;
    }
    _validateAutoClosedActions() {
      if (this._autoClosedActions.length > 0) {
        const e = this._cursors.getSelections();
        for (let t = 0; t < this._autoClosedActions.length; t++) {
          const i = this._autoClosedActions[t];
          i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
        }
      }
    }
    getPrimaryCursorState() {
      return this._cursors.getPrimaryCursor();
    }
    getLastAddedCursorIndex() {
      return this._cursors.getLastAddedCursorIndex();
    }
    getCursorStates() {
      return this._cursors.getAll();
    }
    setStates(e, t, i, n) {
      let o = !1;
      n !== null && n.length > yf.MAX_CURSOR_COUNT && (n = n.slice(0, yf.MAX_CURSOR_COUNT), o = !0);
      const r = mm.from(this._model, this);
      return this._cursors.setStates(n), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, r, o);
    }
    setCursorColumnSelectData(e) {
      this._columnSelectData = e;
    }
    revealPrimary(e, t, i, n, o, r) {
      const a = this._cursors.getViewPositions();
      let l = null, c = null;
      a.length > 1 ? c = this._cursors.getViewSelections() : l = D.fromPositions(a[0], a[0]), e.emitViewEvent(new h0(t, i, l, c, n, o, r));
    }
    saveState() {
      const e = [], t = this._cursors.getSelections();
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i];
        e.push({
          inSelectionMode: !o.isEmpty(),
          selectionStart: {
            lineNumber: o.selectionStartLineNumber,
            column: o.selectionStartColumn
          },
          position: {
            lineNumber: o.positionLineNumber,
            column: o.positionColumn
          }
        });
      }
      return e;
    }
    restoreState(e, t) {
      const i = [];
      for (let n = 0, o = t.length; n < o; n++) {
        const r = t[n];
        let a = 1, l = 1;
        r.position && r.position.lineNumber && (a = r.position.lineNumber), r.position && r.position.column && (l = r.position.column);
        let c = a, d = l;
        r.selectionStart && r.selectionStart.lineNumber && (c = r.selectionStart.lineNumber), r.selectionStart && r.selectionStart.column && (d = r.selectionStart.column), i.push({
          selectionStartLineNumber: c,
          selectionStartColumn: d,
          positionLineNumber: a,
          positionColumn: l
        });
      }
      this.setStates(e, "restoreState", 0, Ze.fromModelSelections(i)), this.revealPrimary(e, "restoreState", !1, 0, !0, 1);
    }
    onModelContentChanged(e, t) {
      if (t instanceof tF) {
        if (this._isHandling)
          return;
        this._isHandling = !0;
        try {
          this.setStates(e, "modelChange", 0, this.getCursorStates());
        } finally {
          this._isHandling = !1;
        }
      } else {
        if (this._knownModelVersionId = t.versionId, this._isHandling)
          return;
        const i = t.containsEvent(1);
        if (this._prevEditOperationType = 0, i)
          this._cursors.dispose(), this._cursors = new MT(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
        else if (this._hasFocus && t.resultingSelection && t.resultingSelection.length > 0) {
          const n = Ze.fromModelSelections(t.resultingSelection);
          this.setStates(e, "modelChange", t.isUndoing ? 5 : t.isRedoing ? 6 : 2, n) && this.revealPrimary(e, "modelChange", !1, 0, !0, 0);
        } else {
          const n = this._cursors.readSelectionFromMarkers();
          this.setStates(e, "modelChange", 2, Ze.fromModelSelections(n));
        }
      }
    }
    getSelection() {
      return this._cursors.getPrimaryCursor().modelState.selection;
    }
    getTopMostViewPosition() {
      return this._cursors.getTopMostViewPosition();
    }
    getBottomMostViewPosition() {
      return this._cursors.getBottomMostViewPosition();
    }
    getCursorColumnSelectData() {
      if (this._columnSelectData)
        return this._columnSelectData;
      const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
      return {
        isReal: !1,
        fromViewLineNumber: t.lineNumber,
        fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, t),
        toViewLineNumber: i.lineNumber,
        toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, i)
      };
    }
    getSelections() {
      return this._cursors.getSelections();
    }
    setSelections(e, t, i, n) {
      this.setStates(e, t, n, Ze.fromModelSelections(i));
    }
    getPrevEditOperationType() {
      return this._prevEditOperationType;
    }
    setPrevEditOperationType(e) {
      this._prevEditOperationType = e;
    }
    _pushAutoClosedAction(e, t) {
      const i = [], n = [];
      for (let a = 0, l = e.length; a < l; a++)
        i.push({
          range: e[a],
          options: {
            description: "auto-closed-character",
            inlineClassName: "auto-closed-character",
            stickiness: 1
          }
        }), n.push({
          range: t[a],
          options: {
            description: "auto-closed-enclosing",
            stickiness: 1
          }
        });
      const o = this._model.deltaDecorations([], i), r = this._model.deltaDecorations([], n);
      this._autoClosedActions.push(new PT(this._model, o, r));
    }
    _executeEditOperation(e) {
      if (!e)
        return;
      e.shouldPushStackElementBefore && this._model.pushStackElement();
      const t = AK.executeCommands(this._model, this._cursors.getSelections(), e.commands);
      if (t) {
        this._interpretCommandResult(t);
        const i = [], n = [];
        for (let o = 0; o < e.commands.length; o++) {
          const r = e.commands[o];
          r instanceof r5 && r.enclosingRange && r.closeCharacterRange && (i.push(r.closeCharacterRange), n.push(r.enclosingRange));
        }
        i.length > 0 && this._pushAutoClosedAction(i, n), this._prevEditOperationType = e.type;
      }
      e.shouldPushStackElementAfter && this._model.pushStackElement();
    }
    _interpretCommandResult(e) {
      (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
    }
    _emitStateChangedIfNecessary(e, t, i, n, o) {
      const r = mm.from(this._model, this);
      if (r.equals(n))
        return !1;
      const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
      if (e.emitViewEvent(new SK(l, a)), !n || n.cursorState.length !== r.cursorState.length || r.cursorState.some((c, d) => !c.modelState.equals(n.cursorState[d].modelState))) {
        const c = n ? n.cursorState.map((h) => h.modelState.selection) : null, d = n ? n.modelVersionId : 0;
        e.emitOutgoingEvent(new _1(c, a, d, r.modelVersionId, t || "keyboard", i, o));
      }
      return !0;
    }
    _findAutoClosingPairs(e) {
      if (!e.length)
        return null;
      const t = [];
      for (let i = 0, n = e.length; i < n; i++) {
        const o = e[i];
        if (!o.text || o.text.indexOf(`
`) >= 0)
          return null;
        const r = o.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
        if (!r)
          return null;
        const a = r[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
        if (!l || l.length !== 1)
          return null;
        const c = l[0].open, d = o.text.length - r[2].length - 1, h = o.text.lastIndexOf(c, d - 1);
        if (h === -1)
          return null;
        t.push([h, d]);
      }
      return t;
    }
    executeEdits(e, t, i, n) {
      let o = null;
      t === "snippet" && (o = this._findAutoClosingPairs(i)), o && (i[0]._isTracked = !0);
      const r = [], a = [], l = this._model.pushEditOperations(this.getSelections(), i, (c) => {
        if (o)
          for (let h = 0, u = o.length; h < u; h++) {
            const [f, g] = o[h], _ = c[h], b = _.range.startLineNumber, C = _.range.startColumn - 1 + f, v = _.range.startColumn - 1 + g;
            r.push(new D(b, v + 1, b, v + 2)), a.push(new D(b, C + 1, b, v + 2));
          }
        const d = n(c);
        return d && (this._isHandling = !0), d;
      });
      l && (this._isHandling = !1, this.setSelections(e, t, l, 0)), r.length > 0 && this._pushAutoClosedAction(r, a);
    }
    _executeEdit(e, t, i, n = 0) {
      if (this.context.cursorConfig.readOnly)
        return;
      const o = mm.from(this._model, this);
      this._cursors.stopTrackingSelections(), this._isHandling = !0;
      try {
        this._cursors.ensureValidState(), e();
      } catch (r) {
        We(r);
      }
      this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, n, o, !1) && this.revealPrimary(t, i, !1, 0, !0, 0);
    }
    setIsDoingComposition(e) {
      this._isDoingComposition = e;
    }
    getAutoClosedCharacters() {
      return PT.getAllAutoClosedCharacters(this._autoClosedActions);
    }
    startComposition(e) {
      this._selectionsWhenCompositionStarted = this.getSelections().slice(0);
    }
    endComposition(e, t) {
      this._executeEdit(() => {
        t === "keyboard" && (this._executeEditOperation(Gt.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters())), this._selectionsWhenCompositionStarted = null);
      }, e, t);
    }
    type(e, t, i) {
      this._executeEdit(() => {
        if (i === "keyboard") {
          const n = t.length;
          let o = 0;
          for (; o < n; ) {
            const r = RI(t, o), a = t.substr(o, r);
            this._executeEditOperation(Gt.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), o += r;
          }
        } else
          this._executeEditOperation(Gt.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
      }, e, i);
    }
    compositionType(e, t, i, n, o, r) {
      if (t.length === 0 && i === 0 && n === 0) {
        if (o !== 0) {
          const a = this.getSelections().map((l) => {
            const c = l.getPosition();
            return new ae(c.lineNumber, c.column + o, c.lineNumber, c.column + o);
          });
          this.setSelections(e, r, a, 0);
        }
        return;
      }
      this._executeEdit(() => {
        this._executeEditOperation(Gt.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, n, o));
      }, e, r);
    }
    paste(e, t, i, n, o) {
      this._executeEdit(() => {
        this._executeEditOperation(Gt.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, n || []));
      }, e, o, 4);
    }
    cut(e, t) {
      this._executeEdit(() => {
        this._executeEditOperation(Gd.cut(this.context.cursorConfig, this._model, this.getSelections()));
      }, e, t);
    }
    executeCommand(e, t, i) {
      this._executeEdit(() => {
        this._cursors.killSecondaryCursors(), this._executeEditOperation(new _s(0, [t], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !1
        }));
      }, e, i);
    }
    executeCommands(e, t, i) {
      this._executeEdit(() => {
        this._executeEditOperation(new _s(0, t, {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !1
        }));
      }, e, i);
    }
  }
  yf.MAX_CURSOR_COUNT = 1e4;
  class mm {
    constructor(e, t) {
      this.modelVersionId = e, this.cursorState = t;
    }
    static from(e, t) {
      return new mm(e.getVersionId(), t.getCursorStates());
    }
    equals(e) {
      if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
        return !1;
      for (let t = 0, i = this.cursorState.length; t < i; t++)
        if (!this.cursorState[t].equals(e.cursorState[t]))
          return !1;
      return !0;
    }
  }
  class PT {
    constructor(e, t, i) {
      this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
    }
    static getAllAutoClosedCharacters(e) {
      let t = [];
      for (const i of e)
        t = t.concat(i.getAutoClosedCharactersRanges());
      return t;
    }
    dispose() {
      this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
    }
    getAutoClosedCharactersRanges() {
      const e = [];
      for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
        const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
        i && e.push(i);
      }
      return e;
    }
    isValid(e) {
      const t = [];
      for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
        const n = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
        if (n && (t.push(n), n.startLineNumber !== n.endLineNumber))
          return !1;
      }
      t.sort(D.compareRangesUsingStarts), e.sort(D.compareRangesUsingStarts);
      for (let i = 0; i < e.length; i++)
        if (i >= t.length || !t[i].strictContainsRange(e[i]))
          return !1;
      return !0;
    }
  }
  class AK {
    static executeCommands(e, t, i) {
      const n = {
        model: e,
        selectionsBefore: t,
        trackedRanges: [],
        trackedRangesDirection: []
      }, o = this._innerExecuteCommands(n, i);
      for (let r = 0, a = n.trackedRanges.length; r < a; r++)
        n.model._setTrackedRange(n.trackedRanges[r], null, 0);
      return o;
    }
    static _innerExecuteCommands(e, t) {
      if (this._arrayIsEmpty(t))
        return null;
      const i = this._getEditOperations(e, t);
      if (i.operations.length === 0)
        return null;
      const n = i.operations, o = this._getLoserCursorMap(n);
      if (o.hasOwnProperty("0"))
        return console.warn("Ignoring commands"), null;
      const r = [];
      for (let c = 0, d = n.length; c < d; c++)
        o.hasOwnProperty(n[c].identifier.major.toString()) || r.push(n[c]);
      i.hadTrackedEditOperation && r.length > 0 && (r[0]._isTracked = !0);
      let a = e.model.pushEditOperations(e.selectionsBefore, r, (c) => {
        const d = [];
        for (let f = 0; f < e.selectionsBefore.length; f++)
          d[f] = [];
        for (const f of c)
          !f.identifier || d[f.identifier.major].push(f);
        const h = (f, g) => f.identifier.minor - g.identifier.minor, u = [];
        for (let f = 0; f < e.selectionsBefore.length; f++)
          d[f].length > 0 ? (d[f].sort(h), u[f] = t[f].computeCursorState(e.model, {
            getInverseEditOperations: () => d[f],
            getTrackedSelection: (g) => {
              const _ = parseInt(g, 10), b = e.model._getTrackedRange(e.trackedRanges[_]);
              return e.trackedRangesDirection[_] === 0 ? new ae(b.startLineNumber, b.startColumn, b.endLineNumber, b.endColumn) : new ae(b.endLineNumber, b.endColumn, b.startLineNumber, b.startColumn);
            }
          })) : u[f] = e.selectionsBefore[f];
        return u;
      });
      a || (a = e.selectionsBefore);
      const l = [];
      for (let c in o)
        o.hasOwnProperty(c) && l.push(parseInt(c, 10));
      l.sort((c, d) => d - c);
      for (const c of l)
        a.splice(c, 1);
      return a;
    }
    static _arrayIsEmpty(e) {
      for (let t = 0, i = e.length; t < i; t++)
        if (e[t])
          return !1;
      return !0;
    }
    static _getEditOperations(e, t) {
      let i = [], n = !1;
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o];
        if (a) {
          const l = this._getEditOperationsFromCommand(e, o, a);
          i = i.concat(l.operations), n = n || l.hadTrackedEditOperation;
        }
      }
      return {
        operations: i,
        hadTrackedEditOperation: n
      };
    }
    static _getEditOperationsFromCommand(e, t, i) {
      const n = [];
      let o = 0;
      const r = (h, u, f = !1) => {
        D.isEmpty(h) && u === "" || n.push({
          identifier: {
            major: t,
            minor: o++
          },
          range: h,
          text: u,
          forceMoveMarkers: f,
          isAutoWhitespaceEdit: i.insertsAutoWhitespace
        });
      };
      let a = !1;
      const d = {
        addEditOperation: r,
        addTrackedEditOperation: (h, u, f) => {
          a = !0, r(h, u, f);
        },
        trackSelection: (h, u) => {
          const f = ae.liftSelection(h);
          let g;
          if (f.isEmpty())
            if (typeof u == "boolean")
              u ? g = 2 : g = 3;
            else {
              const C = e.model.getLineMaxColumn(f.startLineNumber);
              f.startColumn === C ? g = 2 : g = 3;
            }
          else
            g = 1;
          const _ = e.trackedRanges.length, b = e.model._setTrackedRange(null, f, g);
          return e.trackedRanges[_] = b, e.trackedRangesDirection[_] = f.getDirection(), _.toString();
        }
      };
      try {
        i.getEditOperations(e.model, d);
      } catch (h) {
        return We(h), {
          operations: [],
          hadTrackedEditOperation: !1
        };
      }
      return {
        operations: n,
        hadTrackedEditOperation: a
      };
    }
    static _getLoserCursorMap(e) {
      e = e.slice(0), e.sort((i, n) => -D.compareRangesUsingEnds(i.range, n.range));
      const t = {};
      for (let i = 1; i < e.length; i++) {
        const n = e[i - 1], o = e[i];
        if (D.getStartPosition(n.range).isBefore(D.getEndPosition(o.range))) {
          let r;
          n.identifier.major > o.identifier.major ? r = n.identifier.major : r = o.identifier.major, t[r.toString()] = !0;
          for (let a = 0; a < e.length; a++)
            e[a].identifier.major === r && (e.splice(a, 1), a < i && i--, a--);
          i > 0 && i--;
        }
      }
      return t;
    }
  }
  class nF {
    constructor(e, t, i, n, o, r) {
      this.id = e, this.label = t, this.alias = i, this._precondition = n, this._run = o, this._contextKeyService = r;
    }
    isSupported() {
      return this._contextKeyService.contextMatchesRules(this._precondition);
    }
    run() {
      return this.isSupported() ? this._run() : Promise.resolve(void 0);
    }
  }
  const g_ = {
    ICodeEditor: "vs.editor.ICodeEditor",
    IDiffEditor: "vs.editor.IDiffEditor"
  }, Oh = {
    Configuration: "base.contributions.configuration"
  }, Sg = "vscode://schemas/settings/resourceLanguage", FT = Si.as(Zv.JSONContribution);
  class RK {
    constructor() {
      this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new B(), this._onDidUpdateConfiguration = new B(), this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
        id: "defaultOverrides",
        title: m("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
        properties: {}
      }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: !1, errorMessage: "Unknown editor configuration setting", allowTrailingCommas: !0, allowComments: !0 }, this.configurationProperties = {}, this.excludedConfigurationProperties = {}, FT.registerSchema(Sg, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
    }
    registerConfiguration(e, t = !0) {
      this.registerConfigurations([e], t);
    }
    registerConfigurations(e, t = !0) {
      const i = this.doRegisterConfigurations(e, t);
      FT.registerSchema(Sg, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i });
    }
    registerDefaultConfigurations(e) {
      var t;
      const i = [], n = [];
      for (const { overrides: o, source: r } of e)
        for (const a in o)
          if (i.push(a), rp.test(a)) {
            const l = Object.assign(Object.assign({}, ((t = this.configurationDefaultsOverrides.get(a)) === null || t === void 0 ? void 0 : t.value) || {}), o[a]);
            this.configurationDefaultsOverrides.set(a, { source: r, value: l });
            const c = {
              type: "object",
              default: l,
              description: m("defaultLanguageConfiguration.description", "Configure settings to be overridden for {0} language.", a),
              $ref: Sg,
              defaultDefaultValue: l,
              source: vo(r) ? void 0 : r
            };
            n.push(...oF(a)), this.configurationProperties[a] = c, this.defaultLanguageConfigurationOverridesNode.properties[a] = c;
          } else {
            this.configurationDefaultsOverrides.set(a, { value: o[a], source: r });
            const l = this.configurationProperties[a];
            l && (this.updatePropertyDefaultValue(a, l), this.updateSchema(a, l));
          }
      this.registerOverrideIdentifiers(n), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i, defaultsOverrides: !0 });
    }
    registerOverrideIdentifiers(e) {
      for (const t of e)
        this.overrideIdentifiers.add(t);
      this.updateOverridePropertyPatternKey();
    }
    doRegisterConfigurations(e, t) {
      const i = [];
      return e.forEach((n) => {
        i.push(...this.validateAndRegisterProperties(n, t, n.extensionInfo, n.restrictedProperties)), this.configurationContributors.push(n), this.registerJSONConfiguration(n);
      }), i;
    }
    validateAndRegisterProperties(e, t = !0, i, n, o = 3) {
      o = Ws(e.scope) ? o : e.scope;
      let r = [], a = e.properties;
      if (a)
        for (let c in a) {
          if (t && FK(c)) {
            delete a[c];
            continue;
          }
          const d = a[c];
          if (d.source = i, d.defaultDefaultValue = a[c].default, this.updatePropertyDefaultValue(c, d), rp.test(c) ? d.scope = void 0 : (d.scope = Ws(d.scope) ? o : d.scope, d.restricted = Ws(d.restricted) ? !!n?.includes(c) : d.restricted), a[c].hasOwnProperty("included") && !a[c].included) {
            this.excludedConfigurationProperties[c] = a[c], delete a[c];
            continue;
          } else
            this.configurationProperties[c] = a[c];
          !a[c].deprecationMessage && a[c].markdownDeprecationMessage && (a[c].deprecationMessage = a[c].markdownDeprecationMessage), r.push(c);
        }
      let l = e.allOf;
      if (l)
        for (let c of l)
          r.push(...this.validateAndRegisterProperties(c, t, i, n, o));
      return r;
    }
    getConfigurationProperties() {
      return this.configurationProperties;
    }
    registerJSONConfiguration(e) {
      const t = (i) => {
        let n = i.properties;
        if (n)
          for (const r in n)
            this.updateSchema(r, n[r]);
        let o = i.allOf;
        o && o.forEach(t);
      };
      t(e);
    }
    updateSchema(e, t) {
      switch (t.scope) {
        case 1:
          break;
        case 2:
          break;
        case 6:
          break;
        case 3:
          break;
        case 4:
          break;
        case 5:
          this.resourceLanguageSettingsSchema.properties[e] = t;
          break;
      }
    }
    updateOverridePropertyPatternKey() {
      for (const e of this.overrideIdentifiers.values()) {
        const t = `[${e}]`, i = {
          type: "object",
          description: m("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
          errorMessage: m("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
          $ref: Sg
        };
        this.updatePropertyDefaultValue(t, i);
      }
      this._onDidSchemaChange.fire();
    }
    registerOverridePropertyPatternKey() {
      m("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."), m("overrideSettings.errorMessage", "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
    }
    updatePropertyDefaultValue(e, t) {
      const i = this.configurationDefaultsOverrides.get(e);
      let n = i?.value, o = i?.source;
      Ss(n) && (n = t.defaultDefaultValue, o = void 0), Ss(n) && (n = PK(t.type)), t.default = n, t.defaultValueSource = o;
    }
  }
  const sF = "\\[([^\\]]+)\\]", BT = new RegExp(sF, "g"), OK = `^(${sF})+$`, rp = new RegExp(OK);
  function oF(s) {
    const e = [];
    if (rp.test(s)) {
      let t = BT.exec(s);
      for (; t?.length; ) {
        const i = t[1].trim();
        i && e.push(i), t = BT.exec(s);
      }
    }
    return Cc(e);
  }
  function PK(s) {
    switch (Array.isArray(s) ? s[0] : s) {
      case "boolean":
        return !1;
      case "integer":
      case "number":
        return 0;
      case "string":
        return "";
      case "array":
        return [];
      case "object":
        return {};
      default:
        return null;
    }
  }
  const rF = new RK();
  Si.add(Oh.Configuration, rF);
  function FK(s) {
    return s.trim() ? rp.test(s) ? m("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", s) : rF.getConfigurationProperties()[s] !== void 0 ? m("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", s) : null : m("config.property.empty", "Cannot register an empty property");
  }
  const BK = {
    ModesRegistry: "editor.modesRegistry"
  };
  class WK {
    constructor() {
      this._onDidChangeLanguages = new B(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
    }
    registerLanguage(e) {
      return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
        dispose: () => {
          for (let t = 0, i = this._languages.length; t < i; t++)
            if (this._languages[t] === e) {
              this._languages.splice(t, 1);
              return;
            }
        }
      };
    }
    getLanguages() {
      return this._languages;
    }
  }
  const Lf = new WK();
  Si.add(BK.ModesRegistry, Lf);
  const ya = "plaintext", VK = ".txt";
  Lf.registerLanguage({
    id: ya,
    extensions: [VK],
    aliases: [m("plainText.alias", "Plain Text"), "text"],
    mimetypes: [cr.text]
  });
  Di.register(ya, {
    brackets: [
      ["(", ")"],
      ["[", "]"],
      ["{", "}"]
    ],
    surroundingPairs: [
      { open: "{", close: "}" },
      { open: "[", close: "]" },
      { open: "(", close: ")" },
      { open: "<", close: ">" },
      { open: '"', close: '"' },
      { open: "'", close: "'" },
      { open: "`", close: "`" }
    ],
    colorizedBracketPairs: [],
    folding: {
      offSide: !0
    }
  }, 0);
  Si.as(Oh.Configuration).registerDefaultConfigurations([{
    overrides: {
      "[plaintext]": {
        "editor.unicodeHighlight.ambiguousCharacters": !1,
        "editor.unicodeHighlight.invisibleCharacters": !1
      }
    }
  }]);
  class Fi {
    constructor(e, t, i) {
      this._lineTokensBrand = void 0, this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t, this._languageIdCodec = i;
    }
    static createEmpty(e, t) {
      const i = Fi.defaultTokenMetadata, n = new Uint32Array(2);
      return n[0] = e.length, n[1] = i, new Fi(n, e, t);
    }
    equals(e) {
      return e instanceof Fi ? this.slicedEquals(e, 0, this._tokensCount) : !1;
    }
    slicedEquals(e, t, i) {
      if (this._text !== e._text || this._tokensCount !== e._tokensCount)
        return !1;
      const n = t << 1, o = n + (i << 1);
      for (let r = n; r < o; r++)
        if (this._tokens[r] !== e._tokens[r])
          return !1;
      return !0;
    }
    getLineContent() {
      return this._text;
    }
    getCount() {
      return this._tokensCount;
    }
    getStartOffset(e) {
      return e > 0 ? this._tokens[e - 1 << 1] : 0;
    }
    getMetadata(e) {
      return this._tokens[(e << 1) + 1];
    }
    getLanguageId(e) {
      const t = this._tokens[(e << 1) + 1], i = In.getLanguageId(t);
      return this._languageIdCodec.decodeLanguageId(i);
    }
    getStandardTokenType(e) {
      const t = this._tokens[(e << 1) + 1];
      return In.getTokenType(t);
    }
    getForeground(e) {
      const t = this._tokens[(e << 1) + 1];
      return In.getForeground(t);
    }
    getClassName(e) {
      const t = this._tokens[(e << 1) + 1];
      return In.getClassNameFromMetadata(t);
    }
    getInlineStyle(e, t) {
      const i = this._tokens[(e << 1) + 1];
      return In.getInlineStyleFromMetadata(i, t);
    }
    getPresentation(e) {
      const t = this._tokens[(e << 1) + 1];
      return In.getPresentationFromMetadata(t);
    }
    getEndOffset(e) {
      return this._tokens[e << 1];
    }
    findTokenIndexAtOffset(e) {
      return Fi.findIndexInTokensArray(this._tokens, e);
    }
    inflate() {
      return this;
    }
    sliceAndInflate(e, t, i) {
      return new vE(this, e, t, i);
    }
    static convertToEndOffset(e, t) {
      const n = (e.length >>> 1) - 1;
      for (let o = 0; o < n; o++)
        e[o << 1] = e[o + 1 << 1];
      e[n << 1] = t;
    }
    static findIndexInTokensArray(e, t) {
      if (e.length <= 2)
        return 0;
      let i = 0, n = (e.length >>> 1) - 1;
      for (; i < n; ) {
        const o = i + Math.floor((n - i) / 2), r = e[o << 1];
        if (r === t)
          return o + 1;
        r < t ? i = o + 1 : r > t && (n = o);
      }
      return i;
    }
    withInserted(e) {
      if (e.length === 0)
        return this;
      let t = 0, i = 0, n = "";
      const o = new Array();
      let r = 0;
      for (; ; ) {
        const a = t < this._tokensCount ? this._tokens[t << 1] : -1, l = i < e.length ? e[i] : null;
        if (a !== -1 && (l === null || a <= l.offset)) {
          n += this._text.substring(r, a);
          const c = this._tokens[(t << 1) + 1];
          o.push(n.length, c), t++, r = a;
        } else if (l) {
          if (l.offset > r) {
            n += this._text.substring(r, l.offset);
            const c = this._tokens[(t << 1) + 1];
            o.push(n.length, c), r = l.offset;
          }
          n += l.text, o.push(n.length, l.tokenMetadata), i++;
        } else
          break;
      }
      return new Fi(new Uint32Array(o), n, this._languageIdCodec);
    }
  }
  Fi.defaultTokenMetadata = (0 << 10 | 1 << 14 | 2 << 23) >>> 0;
  class vE {
    constructor(e, t, i, n) {
      this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = n, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this._tokensCount = 0;
      for (let o = this._firstTokenIndex, r = e.getCount(); o < r && !(e.getStartOffset(o) >= i); o++)
        this._tokensCount++;
    }
    getMetadata(e) {
      return this._source.getMetadata(this._firstTokenIndex + e);
    }
    getLanguageId(e) {
      return this._source.getLanguageId(this._firstTokenIndex + e);
    }
    getLineContent() {
      return this._source.getLineContent().substring(this._startOffset, this._endOffset);
    }
    equals(e) {
      return e instanceof vE ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
    }
    getCount() {
      return this._tokensCount;
    }
    getForeground(e) {
      return this._source.getForeground(this._firstTokenIndex + e);
    }
    getEndOffset(e) {
      const t = this._source.getEndOffset(this._firstTokenIndex + e);
      return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
    }
    getClassName(e) {
      return this._source.getClassName(this._firstTokenIndex + e);
    }
    getInlineStyle(e, t) {
      return this._source.getInlineStyle(this._firstTokenIndex + e, t);
    }
    getPresentation(e) {
      return this._source.getPresentation(this._firstTokenIndex + e);
    }
    findTokenIndexAtOffset(e) {
      return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
    }
  }
  const kf = new class {
    clone() {
      return this;
    }
    equals(s) {
      return this === s;
    }
  }();
  function aF(s, e) {
    return new dE([new Zm(0, "", s)], e);
  }
  function CE(s, e) {
    const t = new Uint32Array(2);
    return t[0] = 0, t[1] = (s << 0 | 0 << 8 | 0 << 10 | 1 << 14 | 2 << 23) >>> 0, new aC(t, e === null ? kf : e);
  }
  var HK = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const WT = {
    getInitialState: () => kf,
    tokenizeEncoded: (s, e, t) => CE(0, t)
  };
  function zK(s, e, t) {
    return HK(this, void 0, void 0, function* () {
      if (!t)
        return VT(e, s.languageIdCodec, WT);
      const i = yield Yt.getOrCreate(t);
      return VT(e, s.languageIdCodec, i || WT);
    });
  }
  function UK(s, e, t, i, n, o, r) {
    let a = "<div>", l = i, c = 0, d = !0;
    for (let h = 0, u = e.getCount(); h < u; h++) {
      const f = e.getEndOffset(h);
      if (f <= i)
        continue;
      let g = "";
      for (; l < f && l < n; l++) {
        const _ = s.charCodeAt(l);
        switch (_) {
          case 9: {
            let b = o - (l + c) % o;
            for (c += b - 1; b > 0; )
              r && d ? (g += "&#160;", d = !1) : (g += " ", d = !0), b--;
            break;
          }
          case 60:
            g += "&lt;", d = !1;
            break;
          case 62:
            g += "&gt;", d = !1;
            break;
          case 38:
            g += "&amp;", d = !1;
            break;
          case 0:
            g += "&#00;", d = !1;
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            g += "\uFFFD", d = !1;
            break;
          case 13:
            g += "&#8203", d = !1;
            break;
          case 32:
            r && d ? (g += "&#160;", d = !1) : (g += " ", d = !0);
            break;
          default:
            g += String.fromCharCode(_), d = !1;
        }
      }
      if (a += `<span style="${e.getInlineStyle(h, t)}">${g}</span>`, f > n || l >= n)
        break;
    }
    return a += "</div>", a;
  }
  function VT(s, e, t) {
    let i = '<div class="monaco-tokenized-source">';
    const n = da(s);
    let o = t.getInitialState();
    for (let r = 0, a = n.length; r < a; r++) {
      const l = n[r];
      r > 0 && (i += "<br/>");
      const c = t.tokenizeEncoded(l, !0, o);
      Fi.convertToEndOffset(c.tokens, l.length);
      const h = new Fi(c.tokens, l, e).inflate();
      let u = 0;
      for (let f = 0, g = h.getCount(); f < g; f++) {
        const _ = h.getClassName(f), b = h.getEndOffset(f);
        i += `<span class="${_}">${II(l.substring(u, b))}</span>`, u = b;
      }
      o = c.endState;
    }
    return i += "</div>", i;
  }
  class $K {
    constructor() {
      this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
    }
    insert(e) {
      this._hasPending = !0, this._inserts.push(e);
    }
    change(e) {
      this._hasPending = !0, this._changes.push(e);
    }
    remove(e) {
      this._hasPending = !0, this._removes.push(e);
    }
    mustCommit() {
      return this._hasPending;
    }
    commit(e) {
      if (!this._hasPending)
        return;
      const t = this._inserts, i = this._changes, n = this._removes;
      this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, n);
    }
  }
  class jK {
    constructor(e, t, i, n, o) {
      this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = n, this.minWidth = o, this.prefixSum = 0;
    }
  }
  class ap {
    constructor(e, t, i, n) {
      this._instanceId = EP(++ap.INSTANCE_COUNT), this._pendingChanges = new $K(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = n;
    }
    static findInsertionIndex(e, t, i) {
      let n = 0, o = e.length;
      for (; n < o; ) {
        const r = n + o >>> 1;
        t === e[r].afterLineNumber ? i < e[r].ordinal ? o = r : n = r + 1 : t < e[r].afterLineNumber ? o = r : n = r + 1;
      }
      return n;
    }
    setLineHeight(e) {
      this._checkPendingChanges(), this._lineHeight = e;
    }
    setPadding(e, t) {
      this._paddingTop = e, this._paddingBottom = t;
    }
    onFlushed(e) {
      this._checkPendingChanges(), this._lineCount = e;
    }
    changeWhitespace(e) {
      let t = !1;
      try {
        e({
          insertWhitespace: (n, o, r, a) => {
            t = !0, n = n | 0, o = o | 0, r = r | 0, a = a | 0;
            const l = this._instanceId + ++this._lastWhitespaceId;
            return this._pendingChanges.insert(new jK(l, n, o, r, a)), l;
          },
          changeOneWhitespace: (n, o, r) => {
            t = !0, o = o | 0, r = r | 0, this._pendingChanges.change({ id: n, newAfterLineNumber: o, newHeight: r });
          },
          removeWhitespace: (n) => {
            t = !0, this._pendingChanges.remove({ id: n });
          }
        });
      } finally {
        this._pendingChanges.commit(this);
      }
      return t;
    }
    _commitPendingChanges(e, t, i) {
      if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
        for (const l of e)
          this._insertWhitespace(l);
        for (const l of t)
          this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
        for (const l of i) {
          const c = this._findWhitespaceIndex(l.id);
          c !== -1 && this._removeWhitespace(c);
        }
        return;
      }
      const n = /* @__PURE__ */ new Set();
      for (const l of i)
        n.add(l.id);
      const o = /* @__PURE__ */ new Map();
      for (const l of t)
        o.set(l.id, l);
      const r = (l) => {
        const c = [];
        for (const d of l)
          if (!n.has(d.id)) {
            if (o.has(d.id)) {
              const h = o.get(d.id);
              d.afterLineNumber = h.newAfterLineNumber, d.height = h.newHeight;
            }
            c.push(d);
          }
        return c;
      }, a = r(this._arr).concat(r(e));
      a.sort((l, c) => l.afterLineNumber === c.afterLineNumber ? l.ordinal - c.ordinal : l.afterLineNumber - c.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
    }
    _checkPendingChanges() {
      this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
    }
    _insertWhitespace(e) {
      const t = ap.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
      this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
    }
    _findWhitespaceIndex(e) {
      const t = this._arr;
      for (let i = 0, n = t.length; i < n; i++)
        if (t[i].id === e)
          return i;
      return -1;
    }
    _changeOneWhitespace(e, t, i) {
      const n = this._findWhitespaceIndex(e);
      if (n !== -1 && (this._arr[n].height !== i && (this._arr[n].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, n - 1)), this._arr[n].afterLineNumber !== t)) {
        const o = this._arr[n];
        this._removeWhitespace(n), o.afterLineNumber = t, this._insertWhitespace(o);
      }
    }
    _removeWhitespace(e) {
      this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
    }
    onLinesDeleted(e, t) {
      this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
      for (let i = 0, n = this._arr.length; i < n; i++) {
        const o = this._arr[i].afterLineNumber;
        e <= o && o <= t ? this._arr[i].afterLineNumber = e - 1 : o > t && (this._arr[i].afterLineNumber -= t - e + 1);
      }
    }
    onLinesInserted(e, t) {
      this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
      for (let i = 0, n = this._arr.length; i < n; i++) {
        const o = this._arr[i].afterLineNumber;
        e <= o && (this._arr[i].afterLineNumber += t - e + 1);
      }
    }
    getWhitespacesTotalHeight() {
      return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
    }
    getWhitespacesAccumulatedHeight(e) {
      this._checkPendingChanges(), e = e | 0;
      let t = Math.max(0, this._prefixSumValidIndex + 1);
      t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
      for (let i = t; i <= e; i++)
        this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
      return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
    }
    getLinesTotalHeight() {
      this._checkPendingChanges();
      const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
      return e + t + this._paddingTop + this._paddingBottom;
    }
    getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
      this._checkPendingChanges(), e = e | 0;
      const t = this._findLastWhitespaceBeforeLineNumber(e);
      return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
    }
    _findLastWhitespaceBeforeLineNumber(e) {
      e = e | 0;
      const t = this._arr;
      let i = 0, n = t.length - 1;
      for (; i <= n; ) {
        const r = (n - i | 0) / 2 | 0, a = i + r | 0;
        if (t[a].afterLineNumber < e) {
          if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
            return a;
          i = a + 1 | 0;
        } else
          n = a - 1 | 0;
      }
      return -1;
    }
    _findFirstWhitespaceAfterLineNumber(e) {
      e = e | 0;
      const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
      return i < this._arr.length ? i : -1;
    }
    getFirstWhitespaceIndexAfterLineNumber(e) {
      return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
    }
    getVerticalOffsetForLineNumber(e) {
      this._checkPendingChanges(), e = e | 0;
      let t;
      e > 1 ? t = this._lineHeight * (e - 1) : t = 0;
      const i = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e);
      return t + i + this._paddingTop;
    }
    getWhitespaceMinWidth() {
      if (this._checkPendingChanges(), this._minWidth === -1) {
        let e = 0;
        for (let t = 0, i = this._arr.length; t < i; t++)
          e = Math.max(e, this._arr[t].minWidth);
        this._minWidth = e;
      }
      return this._minWidth;
    }
    isAfterLines(e) {
      this._checkPendingChanges();
      const t = this.getLinesTotalHeight();
      return e > t;
    }
    isInTopPadding(e) {
      return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
    }
    isInBottomPadding(e) {
      if (this._paddingBottom === 0)
        return !1;
      this._checkPendingChanges();
      const t = this.getLinesTotalHeight();
      return e >= t - this._paddingBottom;
    }
    getLineNumberAtOrAfterVerticalOffset(e) {
      if (this._checkPendingChanges(), e = e | 0, e < 0)
        return 1;
      const t = this._lineCount | 0, i = this._lineHeight;
      let n = 1, o = t;
      for (; n < o; ) {
        const r = (n + o) / 2 | 0, a = this.getVerticalOffsetForLineNumber(r) | 0;
        if (e >= a + i)
          n = r + 1;
        else {
          if (e >= a)
            return r;
          o = r;
        }
      }
      return n > t ? t : n;
    }
    getLinesViewportData(e, t) {
      this._checkPendingChanges(), e = e | 0, t = t | 0;
      const i = this._lineHeight, n = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, o = this.getVerticalOffsetForLineNumber(n) | 0;
      let r = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(n) | 0;
      const l = this.getWhitespacesCount() | 0;
      let c, d;
      a === -1 ? (a = l, d = r + 1, c = 0) : (d = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
      let h = o, u = h;
      const f = 5e5;
      let g = 0;
      o >= f && (g = Math.floor(o / f) * f, g = Math.floor(g / i) * i, u -= g);
      const _ = [], b = e + (t - e) / 2;
      let C = -1;
      for (let L = n; L <= r; L++) {
        if (C === -1) {
          const x = h, y = h + i;
          (x <= b && b < y || x > b) && (C = L);
        }
        for (h += i, _[L - n] = u, u += i; d === L; )
          u += c, h += c, a++, a >= l ? d = r + 1 : (d = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
        if (h >= t) {
          r = L;
          break;
        }
      }
      C === -1 && (C = r);
      const v = this.getVerticalOffsetForLineNumber(r) | 0;
      let w = n, S = r;
      return w < S && o < e && w++, w < S && v + i > t && S--, {
        bigNumbersDelta: g,
        startLineNumber: n,
        endLineNumber: r,
        relativeVerticalOffset: _,
        centeredLineNumber: C,
        completelyVisibleStartLineNumber: w,
        completelyVisibleEndLineNumber: S
      };
    }
    getVerticalOffsetForWhitespaceIndex(e) {
      this._checkPendingChanges(), e = e | 0;
      const t = this.getAfterLineNumberForWhitespaceIndex(e);
      let i;
      t >= 1 ? i = this._lineHeight * t : i = 0;
      let n;
      return e > 0 ? n = this.getWhitespacesAccumulatedHeight(e - 1) : n = 0, i + n + this._paddingTop;
    }
    getWhitespaceIndexAtOrAfterVerticallOffset(e) {
      this._checkPendingChanges(), e = e | 0;
      let t = 0, i = this.getWhitespacesCount() - 1;
      if (i < 0)
        return -1;
      const n = this.getVerticalOffsetForWhitespaceIndex(i), o = this.getHeightForWhitespaceIndex(i);
      if (e >= n + o)
        return -1;
      for (; t < i; ) {
        const r = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
        if (e >= a + l)
          t = r + 1;
        else {
          if (e >= a)
            return r;
          i = r;
        }
      }
      return t;
    }
    getWhitespaceAtVerticalOffset(e) {
      this._checkPendingChanges(), e = e | 0;
      const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
      if (t < 0 || t >= this.getWhitespacesCount())
        return null;
      const i = this.getVerticalOffsetForWhitespaceIndex(t);
      if (i > e)
        return null;
      const n = this.getHeightForWhitespaceIndex(t), o = this.getIdForWhitespaceIndex(t), r = this.getAfterLineNumberForWhitespaceIndex(t);
      return {
        id: o,
        afterLineNumber: r,
        verticalOffset: i,
        height: n
      };
    }
    getWhitespaceViewportData(e, t) {
      this._checkPendingChanges(), e = e | 0, t = t | 0;
      const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), n = this.getWhitespacesCount() - 1;
      if (i < 0)
        return [];
      const o = [];
      for (let r = i; r <= n; r++) {
        const a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
        if (a >= t)
          break;
        o.push({
          id: this.getIdForWhitespaceIndex(r),
          afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(r),
          verticalOffset: a,
          height: l
        });
      }
      return o;
    }
    getWhitespaces() {
      return this._checkPendingChanges(), this._arr.slice(0);
    }
    getWhitespacesCount() {
      return this._checkPendingChanges(), this._arr.length;
    }
    getIdForWhitespaceIndex(e) {
      return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
    }
    getAfterLineNumberForWhitespaceIndex(e) {
      return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
    }
    getHeightForWhitespaceIndex(e) {
      return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
    }
  }
  ap.INSTANCE_COUNT = 0;
  const KK = 125;
  class qg {
    constructor(e, t, i, n) {
      e = e | 0, t = t | 0, i = i | 0, n = n | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), n < 0 && (n = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = n, this.scrollHeight = Math.max(i, n);
    }
    equals(e) {
      return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
    }
  }
  class qK extends z {
    constructor(e, t) {
      super(), this._onDidContentSizeChange = this._register(new B()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new qg(0, 0, 0, 0), this._scrollable = this._register(new h_({
        forceIntegerValues: !0,
        smoothScrollDuration: e,
        scheduleAtNextAnimationFrame: t
      })), this.onDidScroll = this._scrollable.onScroll;
    }
    getScrollable() {
      return this._scrollable;
    }
    setSmoothScrollDuration(e) {
      this._scrollable.setSmoothScrollDuration(e);
    }
    validateScrollPosition(e) {
      return this._scrollable.validateScrollPosition(e);
    }
    getScrollDimensions() {
      return this._dimensions;
    }
    setScrollDimensions(e) {
      if (this._dimensions.equals(e))
        return;
      const t = this._dimensions;
      this._dimensions = e, this._scrollable.setScrollDimensions({
        width: e.width,
        scrollWidth: e.scrollWidth,
        height: e.height,
        scrollHeight: e.scrollHeight
      }, !0);
      const i = t.contentWidth !== e.contentWidth, n = t.contentHeight !== e.contentHeight;
      (i || n) && this._onDidContentSizeChange.fire(new pE(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
    }
    getFutureScrollPosition() {
      return this._scrollable.getFutureScrollPosition();
    }
    getCurrentScrollPosition() {
      return this._scrollable.getCurrentScrollPosition();
    }
    setScrollPositionNow(e) {
      this._scrollable.setScrollPositionNow(e);
    }
    setScrollPositionSmooth(e) {
      this._scrollable.setScrollPositionSmooth(e);
    }
  }
  class GK extends z {
    constructor(e, t, i) {
      super(), this._configuration = e;
      const n = this._configuration.options, o = n.get(131), r = n.get(75);
      this._linesLayout = new ap(t, n.get(59), r.top, r.bottom), this._scrollable = this._register(new qK(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new qg(o.contentWidth, 0, o.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
    }
    dispose() {
      super.dispose();
    }
    getScrollable() {
      return this._scrollable.getScrollable();
    }
    onHeightMaybeChanged() {
      this._updateHeight();
    }
    _configureSmoothScrollDuration() {
      this._scrollable.setSmoothScrollDuration(this._configuration.options.get(103) ? KK : 0);
    }
    onConfigurationChanged(e) {
      const t = this._configuration.options;
      if (e.hasChanged(59) && this._linesLayout.setLineHeight(t.get(59)), e.hasChanged(75)) {
        const i = t.get(75);
        this._linesLayout.setPadding(i.top, i.bottom);
      }
      if (e.hasChanged(131)) {
        const i = t.get(131), n = i.contentWidth, o = i.height, r = this._scrollable.getScrollDimensions(), a = r.contentWidth;
        this._scrollable.setScrollDimensions(new qg(n, r.contentWidth, o, this._getContentHeight(n, o, a)));
      } else
        this._updateHeight();
      e.hasChanged(103) && this._configureSmoothScrollDuration();
    }
    onFlushed(e) {
      this._linesLayout.onFlushed(e);
    }
    onLinesDeleted(e, t) {
      this._linesLayout.onLinesDeleted(e, t);
    }
    onLinesInserted(e, t) {
      this._linesLayout.onLinesInserted(e, t);
    }
    _getHorizontalScrollbarHeight(e, t) {
      const n = this._configuration.options.get(92);
      return n.horizontal === 2 || e >= t ? 0 : n.horizontalScrollbarSize;
    }
    _getContentHeight(e, t, i) {
      const n = this._configuration.options;
      let o = this._linesLayout.getLinesTotalHeight();
      return n.get(94) ? o += Math.max(0, t - n.get(59) - n.get(75).bottom) : o += this._getHorizontalScrollbarHeight(e, i), o;
    }
    _updateHeight() {
      const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, n = e.contentWidth;
      this._scrollable.setScrollDimensions(new qg(t, e.contentWidth, i, this._getContentHeight(t, i, n)));
    }
    getCurrentViewport() {
      const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
      return new yT(t.scrollTop, t.scrollLeft, e.width, e.height);
    }
    getFutureViewport() {
      const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
      return new yT(t.scrollTop, t.scrollLeft, e.width, e.height);
    }
    _computeContentWidth(e) {
      const t = this._configuration.options, i = t.get(132), n = t.get(44);
      if (i.isViewportWrapping) {
        const o = t.get(131), r = t.get(65);
        return e > o.contentWidth + n.typicalHalfwidthCharacterWidth && r.enabled && r.side === "right" ? e + o.verticalScrollbarWidth : e;
      } else {
        const o = t.get(93) * n.typicalHalfwidthCharacterWidth, r = this._linesLayout.getWhitespaceMinWidth();
        return Math.max(e + o, r);
      }
    }
    setMaxLineWidth(e) {
      const t = this._scrollable.getScrollDimensions();
      this._scrollable.setScrollDimensions(new qg(t.width, this._computeContentWidth(e), t.height, t.contentHeight)), this._updateHeight();
    }
    saveState() {
      const e = this._scrollable.getFutureScrollPosition(), t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), n = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
      return {
        scrollTop: t,
        scrollTopWithoutViewZones: t - n,
        scrollLeft: e.scrollLeft
      };
    }
    changeWhitespace(e) {
      const t = this._linesLayout.changeWhitespace(e);
      return t && this.onHeightMaybeChanged(), t;
    }
    getVerticalOffsetForLineNumber(e) {
      return this._linesLayout.getVerticalOffsetForLineNumber(e);
    }
    isAfterLines(e) {
      return this._linesLayout.isAfterLines(e);
    }
    isInTopPadding(e) {
      return this._linesLayout.isInTopPadding(e);
    }
    isInBottomPadding(e) {
      return this._linesLayout.isInBottomPadding(e);
    }
    getLineNumberAtVerticalOffset(e) {
      return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
    }
    getWhitespaceAtVerticalOffset(e) {
      return this._linesLayout.getWhitespaceAtVerticalOffset(e);
    }
    getLinesViewportData() {
      const e = this.getCurrentViewport();
      return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
    }
    getLinesViewportDataAtScrollTop(e) {
      const t = this._scrollable.getScrollDimensions();
      return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
    }
    getWhitespaceViewportData() {
      const e = this.getCurrentViewport();
      return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
    }
    getWhitespaces() {
      return this._linesLayout.getWhitespaces();
    }
    getContentWidth() {
      return this._scrollable.getScrollDimensions().contentWidth;
    }
    getScrollWidth() {
      return this._scrollable.getScrollDimensions().scrollWidth;
    }
    getContentHeight() {
      return this._scrollable.getScrollDimensions().contentHeight;
    }
    getScrollHeight() {
      return this._scrollable.getScrollDimensions().scrollHeight;
    }
    getCurrentScrollLeft() {
      return this._scrollable.getCurrentScrollPosition().scrollLeft;
    }
    getCurrentScrollTop() {
      return this._scrollable.getCurrentScrollPosition().scrollTop;
    }
    validateScrollPosition(e) {
      return this._scrollable.validateScrollPosition(e);
    }
    setScrollPosition(e, t) {
      t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
    }
    deltaScrollNow(e, t) {
      const i = this._scrollable.getCurrentScrollPosition();
      this._scrollable.setScrollPositionNow({
        scrollLeft: i.scrollLeft + e,
        scrollTop: i.scrollTop + t
      });
    }
  }
  class ZK {
    constructor(e, t, i, n, o) {
      this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = n, this._coordinatesConverter = o, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
    }
    _clearCachedModelDecorationsResolver() {
      this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
    }
    dispose() {
      this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
    }
    reset() {
      this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
    }
    onModelDecorationsChanged() {
      this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
    }
    onLineMappingChanged() {
      this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
    }
    _getOrCreateViewModelDecoration(e) {
      const t = e.id;
      let i = this._decorationsCache[t];
      if (!i) {
        const n = e.range, o = e.options;
        let r;
        if (o.isWholeLine) {
          const a = this._coordinatesConverter.convertModelPositionToViewPosition(new V(n.startLineNumber, 1), 0), l = this._coordinatesConverter.convertModelPositionToViewPosition(new V(n.endLineNumber, this.model.getLineMaxColumn(n.endLineNumber)), 1);
          r = new D(a.lineNumber, a.column, l.lineNumber, l.column);
        } else
          r = this._coordinatesConverter.convertModelRangeToViewRange(n, 1);
        i = new J5(r, o), this._decorationsCache[t] = i;
      }
      return i;
    }
    getDecorationsViewportData(e) {
      let t = this._cachedModelDecorationsResolver !== null;
      return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsViewportData(e), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
    }
    _getDecorationsViewportData(e) {
      const t = this._linesCollection.getDecorationsInRange(e, this.editorId, o1(this.configuration.options)), i = e.startLineNumber, n = e.endLineNumber, o = [];
      let r = 0;
      const a = [];
      for (let l = i; l <= n; l++)
        a[l - i] = [];
      for (let l = 0, c = t.length; l < c; l++) {
        const d = t[l], h = d.options;
        if (!wE(this.model, d))
          continue;
        const u = this._getOrCreateViewModelDecoration(d), f = u.range;
        if (o[r++] = u, h.inlineClassName) {
          const g = new um(f, h.inlineClassName, h.inlineClassNameAffectsLetterSpacing ? 3 : 0), _ = Math.max(i, f.startLineNumber), b = Math.min(n, f.endLineNumber);
          for (let C = _; C <= b; C++)
            a[C - i].push(g);
        }
        if (h.beforeContentClassName && i <= f.startLineNumber && f.startLineNumber <= n) {
          const g = new um(new D(f.startLineNumber, f.startColumn, f.startLineNumber, f.startColumn), h.beforeContentClassName, 1);
          a[f.startLineNumber - i].push(g);
        }
        if (h.afterContentClassName && i <= f.endLineNumber && f.endLineNumber <= n) {
          const g = new um(new D(f.endLineNumber, f.endColumn, f.endLineNumber, f.endColumn), h.afterContentClassName, 2);
          a[f.endLineNumber - i].push(g);
        }
      }
      return {
        decorations: o,
        inlineDecorations: a
      };
    }
  }
  function wE(s, e) {
    return !(e.options.hideInCommentTokens && SE(s, e) || e.options.hideInStringTokens && yE(s, e));
  }
  function SE(s, e) {
    return lF(s, e.range, (t) => t === 1);
  }
  function yE(s, e) {
    return lF(s, e.range, (t) => t === 2);
  }
  function lF(s, e, t) {
    for (let i = e.startLineNumber; i <= e.endLineNumber; i++) {
      const n = s.getLineTokens(i), o = i === e.startLineNumber, r = i === e.endLineNumber;
      let a = o ? n.findTokenIndexAtOffset(e.startColumn - 1) : 0;
      for (; a < n.getCount() && !(r && n.getStartOffset(a) > e.endColumn - 1); ) {
        if (!t(n.getStandardTokenType(a)))
          return !1;
        a++;
      }
    }
    return !0;
  }
  class J_ {
    constructor(e, t, i) {
      this.range = e, this.nestingLevel = t, this.isInvalid = i;
    }
  }
  class YK {
    constructor(e, t, i, n) {
      this.range = e, this.openingBracketRange = t, this.closingBracketRange = i, this.nestingLevel = n;
    }
  }
  class XK extends YK {
    constructor(e, t, i, n, o) {
      super(e, t, i, n), this.minVisibleColumnIndentation = o;
    }
  }
  class EL {
    constructor(e, t) {
      this.lineCount = e, this.columnCount = t;
    }
    toString() {
      return `${this.lineCount},${this.columnCount}`;
    }
  }
  EL.zero = new EL(0, 0);
  function QK(s, e, t, i) {
    return s !== t ? fi(t - s, i) : fi(0, i - e);
  }
  const ua = 0;
  function JK(s) {
    return s === 0;
  }
  const Ks = Math.pow(2, 26);
  function fi(s, e) {
    return s * Ks + e;
  }
  function lc(s) {
    const e = s, t = Math.floor(e / Ks), i = e - t * Ks;
    return new EL(t, i);
  }
  function eq(s) {
    return Math.floor(s / Ks);
  }
  function Ii(s, e) {
    return e < Ks ? s + e : s - s % Ks + e;
  }
  function tq(s, e) {
    const t = s, i = e;
    if (i - t <= 0)
      return ua;
    const o = Math.floor(t / Ks), r = Math.floor(i / Ks), a = i - r * Ks;
    if (o === r) {
      const l = t - o * Ks;
      return fi(0, a - l);
    } else
      return fi(r - o, a);
  }
  function u0(s, e) {
    return s < e;
  }
  function wd(s, e) {
    return s <= e;
  }
  function eb(s, e) {
    return s >= e;
  }
  function tb(s) {
    return fi(s.lineNumber - 1, s.column - 1);
  }
  function Sd(s, e) {
    const t = s, i = Math.floor(t / Ks), n = t - i * Ks, o = e, r = Math.floor(o / Ks), a = o - r * Ks;
    return new D(i + 1, n + 1, r + 1, a + 1);
  }
  function iq(s) {
    const e = da(s);
    return fi(e.length - 1, e[e.length - 1].length);
  }
  class HT {
    constructor(e, t, i) {
      this.startOffset = e, this.endOffset = t, this.newLength = i;
    }
  }
  class nq {
    constructor(e, t) {
      this.documentLength = t, this.nextEditIdx = 0, this.deltaOldToNewLineCount = 0, this.deltaOldToNewColumnCount = 0, this.deltaLineIdxInOld = -1, this.edits = e.map((i) => LE.from(i));
    }
    getOffsetBeforeChange(e) {
      return this.adjustNextEdit(e), this.translateCurToOld(e);
    }
    getDistanceToNextChange(e) {
      this.adjustNextEdit(e);
      const t = this.edits[this.nextEditIdx], i = t ? this.translateOldToCur(t.offsetObj) : this.documentLength;
      return tq(e, i);
    }
    translateOldToCur(e) {
      return e.lineCount === this.deltaLineIdxInOld ? fi(e.lineCount + this.deltaOldToNewLineCount, e.columnCount + this.deltaOldToNewColumnCount) : fi(e.lineCount + this.deltaOldToNewLineCount, e.columnCount);
    }
    translateCurToOld(e) {
      const t = lc(e);
      return t.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld ? fi(t.lineCount - this.deltaOldToNewLineCount, t.columnCount - this.deltaOldToNewColumnCount) : fi(t.lineCount - this.deltaOldToNewLineCount, t.columnCount);
    }
    adjustNextEdit(e) {
      for (; this.nextEditIdx < this.edits.length; ) {
        const t = this.edits[this.nextEditIdx], i = this.translateOldToCur(t.endOffsetAfterObj);
        if (wd(i, e)) {
          this.nextEditIdx++;
          const n = lc(i), o = lc(this.translateOldToCur(t.endOffsetBeforeObj)), r = n.lineCount - o.lineCount;
          this.deltaOldToNewLineCount += r;
          const a = this.deltaLineIdxInOld === t.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0, l = n.columnCount - o.columnCount;
          this.deltaOldToNewColumnCount = a + l, this.deltaLineIdxInOld = t.endOffsetBeforeObj.lineCount;
        } else
          break;
      }
    }
  }
  class LE {
    constructor(e, t, i) {
      this.endOffsetBeforeObj = lc(t), this.endOffsetAfterObj = lc(Ii(e, i)), this.offsetObj = lc(e);
    }
    static from(e) {
      return new LE(e.startOffset, e.endOffset, e.newLength);
    }
  }
  const f0 = new Array();
  class xi {
    constructor(e, t) {
      this.items = e, this.additionalItems = t;
    }
    static create(e, t) {
      if (e <= 128 && t.length === 0) {
        let i = xi.cache[e];
        return i || (i = new xi(e, t), xi.cache[e] = i), i;
      }
      return new xi(e, t);
    }
    static getEmpty() {
      return this.empty;
    }
    add(e, t) {
      const i = t.getKey(e);
      let n = i >> 5;
      if (n === 0) {
        const r = 1 << i | this.items;
        return r === this.items ? this : xi.create(r, this.additionalItems);
      }
      n--;
      const o = this.additionalItems.slice(0);
      for (; o.length < n; )
        o.push(0);
      return o[n] |= 1 << (i & 31), xi.create(this.items, o);
    }
    merge(e) {
      const t = this.items | e.items;
      if (this.additionalItems === f0 && e.additionalItems === f0)
        return t === this.items ? this : t === e.items ? e : xi.create(t, f0);
      const i = new Array();
      for (let n = 0; n < Math.max(this.additionalItems.length, e.additionalItems.length); n++) {
        const o = this.additionalItems[n] || 0, r = e.additionalItems[n] || 0;
        i.push(o | r);
      }
      return xi.create(t, i);
    }
    intersects(e) {
      if ((this.items & e.items) !== 0)
        return !0;
      for (let t = 0; t < Math.min(this.additionalItems.length, e.additionalItems.length); t++)
        if ((this.additionalItems[t] & e.additionalItems[t]) !== 0)
          return !0;
      return !1;
    }
  }
  xi.cache = new Array(129);
  xi.empty = xi.create(0, f0);
  const zT = {
    getKey(s) {
      return s;
    }
  };
  class cF {
    constructor() {
      this.items = /* @__PURE__ */ new Map();
    }
    getKey(e) {
      let t = this.items.get(e);
      return t === void 0 && (t = this.items.size, this.items.set(e, t)), t;
    }
  }
  class kE {
    constructor(e) {
      this._length = e;
    }
    get length() {
      return this._length;
    }
  }
  class lp extends kE {
    constructor(e, t, i, n, o) {
      super(e), this.openingBracket = t, this.child = i, this.closingBracket = n, this.missingOpeningBracketIds = o;
    }
    static create(e, t, i) {
      let n = e.length;
      return t && (n = Ii(n, t.length)), i && (n = Ii(n, i.length)), new lp(n, e, t, i, t ? t.missingOpeningBracketIds : xi.getEmpty());
    }
    get kind() {
      return 2;
    }
    get listHeight() {
      return 0;
    }
    get childrenLength() {
      return 3;
    }
    getChild(e) {
      switch (e) {
        case 0:
          return this.openingBracket;
        case 1:
          return this.child;
        case 2:
          return this.closingBracket;
      }
      throw new Error("Invalid child index");
    }
    get children() {
      const e = new Array();
      return e.push(this.openingBracket), this.child && e.push(this.child), this.closingBracket && e.push(this.closingBracket), e;
    }
    canBeReused(e) {
      return !(this.closingBracket === null || e.intersects(this.missingOpeningBracketIds));
    }
    deepClone() {
      return new lp(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
    }
    computeMinIndentation(e, t) {
      return this.child ? this.child.computeMinIndentation(Ii(e, this.openingBracket.length), t) : Number.MAX_SAFE_INTEGER;
    }
  }
  class fa extends kE {
    constructor(e, t, i) {
      super(e), this.listHeight = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
    }
    static create23(e, t, i, n = !1) {
      let o = e.length, r = e.missingOpeningBracketIds;
      if (e.listHeight !== t.listHeight)
        throw new Error("Invalid list heights");
      if (o = Ii(o, t.length), r = r.merge(t.missingOpeningBracketIds), i) {
        if (e.listHeight !== i.listHeight)
          throw new Error("Invalid list heights");
        o = Ii(o, i.length), r = r.merge(i.missingOpeningBracketIds);
      }
      return n ? new sq(o, e.listHeight + 1, e, t, i, r) : new cp(o, e.listHeight + 1, e, t, i, r);
    }
    static getEmpty() {
      return new oq(ua, 0, [], xi.getEmpty());
    }
    get kind() {
      return 4;
    }
    get missingOpeningBracketIds() {
      return this._missingOpeningBracketIds;
    }
    throwIfImmutable() {
    }
    makeLastElementMutable() {
      this.throwIfImmutable();
      const e = this.childrenLength;
      if (e === 0)
        return;
      const t = this.getChild(e - 1), i = t.kind === 4 ? t.toMutable() : t;
      return t !== i && this.setChild(e - 1, i), i;
    }
    makeFirstElementMutable() {
      if (this.throwIfImmutable(), this.childrenLength === 0)
        return;
      const t = this.getChild(0), i = t.kind === 4 ? t.toMutable() : t;
      return t !== i && this.setChild(0, i), i;
    }
    canBeReused(e) {
      if (e.intersects(this.missingOpeningBracketIds))
        return !1;
      let t = this, i;
      for (; t.kind === 4 && (i = t.childrenLength) > 0; )
        t = t.getChild(i - 1);
      return t.canBeReused(e);
    }
    handleChildrenChanged() {
      this.throwIfImmutable();
      const e = this.childrenLength;
      let t = this.getChild(0).length, i = this.getChild(0).missingOpeningBracketIds;
      for (let n = 1; n < e; n++) {
        const o = this.getChild(n);
        t = Ii(t, o.length), i = i.merge(o.missingOpeningBracketIds);
      }
      this._length = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
    }
    computeMinIndentation(e, t) {
      if (this.cachedMinIndentation !== -1)
        return this.cachedMinIndentation;
      let i = Number.MAX_SAFE_INTEGER, n = e;
      for (let o = 0; o < this.childrenLength; o++) {
        const r = this.getChild(o);
        r && (i = Math.min(i, r.computeMinIndentation(n, t)), n = Ii(n, r.length));
      }
      return this.cachedMinIndentation = i, i;
    }
  }
  class cp extends fa {
    constructor(e, t, i, n, o, r) {
      super(e, t, r), this._item1 = i, this._item2 = n, this._item3 = o;
    }
    get childrenLength() {
      return this._item3 !== null ? 3 : 2;
    }
    getChild(e) {
      switch (e) {
        case 0:
          return this._item1;
        case 1:
          return this._item2;
        case 2:
          return this._item3;
      }
      throw new Error("Invalid child index");
    }
    setChild(e, t) {
      switch (e) {
        case 0:
          this._item1 = t;
          return;
        case 1:
          this._item2 = t;
          return;
        case 2:
          this._item3 = t;
          return;
      }
      throw new Error("Invalid child index");
    }
    get children() {
      return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
    }
    get item1() {
      return this._item1;
    }
    get item2() {
      return this._item2;
    }
    get item3() {
      return this._item3;
    }
    deepClone() {
      return new cp(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
    }
    appendChildOfSameHeight(e) {
      if (this._item3)
        throw new Error("Cannot append to a full (2,3) tree node");
      this.throwIfImmutable(), this._item3 = e, this.handleChildrenChanged();
    }
    unappendChild() {
      if (!this._item3)
        throw new Error("Cannot remove from a non-full (2,3) tree node");
      this.throwIfImmutable();
      const e = this._item3;
      return this._item3 = null, this.handleChildrenChanged(), e;
    }
    prependChildOfSameHeight(e) {
      if (this._item3)
        throw new Error("Cannot prepend to a full (2,3) tree node");
      this.throwIfImmutable(), this._item3 = this._item2, this._item2 = this._item1, this._item1 = e, this.handleChildrenChanged();
    }
    unprependChild() {
      if (!this._item3)
        throw new Error("Cannot remove from a non-full (2,3) tree node");
      this.throwIfImmutable();
      const e = this._item1;
      return this._item1 = this._item2, this._item2 = this._item3, this._item3 = null, this.handleChildrenChanged(), e;
    }
    toMutable() {
      return this;
    }
  }
  class sq extends cp {
    toMutable() {
      return new cp(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
    }
    throwIfImmutable() {
      throw new Error("this instance is immutable");
    }
  }
  class b1 extends fa {
    constructor(e, t, i, n) {
      super(e, t, n), this._children = i;
    }
    get childrenLength() {
      return this._children.length;
    }
    getChild(e) {
      return this._children[e];
    }
    setChild(e, t) {
      this._children[e] = t;
    }
    get children() {
      return this._children;
    }
    deepClone() {
      const e = new Array(this._children.length);
      for (let t = 0; t < this._children.length; t++)
        e[t] = this._children[t].deepClone();
      return new b1(this.length, this.listHeight, e, this.missingOpeningBracketIds);
    }
    appendChildOfSameHeight(e) {
      this.throwIfImmutable(), this._children.push(e), this.handleChildrenChanged();
    }
    unappendChild() {
      this.throwIfImmutable();
      const e = this._children.pop();
      return this.handleChildrenChanged(), e;
    }
    prependChildOfSameHeight(e) {
      this.throwIfImmutable(), this._children.unshift(e), this.handleChildrenChanged();
    }
    unprependChild() {
      this.throwIfImmutable();
      const e = this._children.shift();
      return this.handleChildrenChanged(), e;
    }
    toMutable() {
      return this;
    }
  }
  class oq extends b1 {
    toMutable() {
      return new b1(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
    }
    throwIfImmutable() {
      throw new Error("this instance is immutable");
    }
  }
  const rq = [];
  class DE extends kE {
    get listHeight() {
      return 0;
    }
    get childrenLength() {
      return 0;
    }
    getChild(e) {
      return null;
    }
    get children() {
      return rq;
    }
    deepClone() {
      return this;
    }
  }
  class _u extends DE {
    get kind() {
      return 0;
    }
    get missingOpeningBracketIds() {
      return xi.getEmpty();
    }
    canBeReused(e) {
      return !0;
    }
    computeMinIndentation(e, t) {
      const i = lc(e), n = (i.columnCount === 0 ? i.lineCount : i.lineCount + 1) + 1, o = eq(Ii(e, this.length)) + 1;
      let r = Number.MAX_SAFE_INTEGER;
      for (let a = n; a <= o; a++) {
        const l = t.getLineFirstNonWhitespaceColumn(a), c = t.getLineContent(a);
        if (l === 0)
          continue;
        const d = Oi.visibleColumnFromColumn(c, l, t.getOptions().tabSize);
        r = Math.min(r, d);
      }
      return r;
    }
  }
  class v1 extends DE {
    constructor(e, t, i) {
      super(e), this.languageId = t, this.bracketIds = i;
    }
    static create(e, t, i) {
      return new v1(e, t, i);
    }
    get kind() {
      return 1;
    }
    get missingOpeningBracketIds() {
      return xi.getEmpty();
    }
    canBeReused(e) {
      return !1;
    }
    computeMinIndentation(e, t) {
      return Number.MAX_SAFE_INTEGER;
    }
  }
  class aq extends DE {
    constructor(e, t) {
      super(t), this.missingOpeningBracketIds = e;
    }
    get kind() {
      return 3;
    }
    canBeReused(e) {
      return !e.intersects(this.missingOpeningBracketIds);
    }
    computeMinIndentation(e, t) {
      return Number.MAX_SAFE_INTEGER;
    }
  }
  class zl {
    constructor(e, t, i, n, o) {
      this.length = e, this.kind = t, this.bracketId = i, this.bracketIds = n, this.astNode = o;
    }
  }
  class dF {
    constructor(e, t) {
      this.textModel = e, this.bracketTokens = t, this.reader = new lq(this.textModel, this.bracketTokens), this._offset = ua, this.didPeek = !1, this.peeked = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
    }
    get offset() {
      return this._offset;
    }
    get length() {
      return fi(this.textBufferLineCount, this.textBufferLastLineLength);
    }
    skip(e) {
      this.didPeek = !1, this._offset = Ii(this._offset, e);
      const t = lc(this._offset);
      this.reader.setPosition(t.lineCount, t.columnCount);
    }
    read() {
      let e;
      return this.peeked ? (this.didPeek = !1, e = this.peeked) : e = this.reader.read(), e && (this._offset = Ii(this._offset, e.length)), e;
    }
    peek() {
      return this.didPeek || (this.peeked = this.reader.read(), this.didPeek = !0), this.peeked;
    }
  }
  class lq {
    constructor(e, t) {
      this.textModel = e, this.bracketTokens = t, this.lineIdx = 0, this.line = null, this.lineCharOffset = 0, this.lineTokens = null, this.lineTokenOffset = 0, this.peekedToken = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
    }
    setPosition(e, t) {
      e === this.lineIdx ? (this.lineCharOffset = t, this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset)) : (this.lineIdx = e, this.lineCharOffset = t, this.line = null), this.peekedToken = null;
    }
    read() {
      if (this.peekedToken) {
        const o = this.peekedToken;
        return this.peekedToken = null, this.lineCharOffset += o.length, o;
      }
      if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)
        return null;
      this.line === null && (this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
      const e = this.lineIdx, t = this.lineCharOffset;
      let i = 0;
      for (; ; ) {
        const o = this.lineTokens, r = o.getCount();
        let a = null;
        if (this.lineTokenOffset < r) {
          const l = o.getMetadata(this.lineTokenOffset);
          for (; this.lineTokenOffset + 1 < r && l === o.getMetadata(this.lineTokenOffset + 1); )
            this.lineTokenOffset++;
          const c = In.getTokenType(l) === 0, d = o.getEndOffset(this.lineTokenOffset);
          if (c && d !== this.lineCharOffset) {
            const h = o.getLanguageId(this.lineTokenOffset), u = this.line.substring(this.lineCharOffset, d), f = this.bracketTokens.getSingleLanguageBracketTokens(h), g = f.regExpGlobal;
            if (g) {
              g.lastIndex = 0;
              const _ = g.exec(u);
              _ && (a = f.getToken(_[0]), a && (this.lineCharOffset += _.index));
            }
          }
          if (i += d - this.lineCharOffset, a)
            if (e !== this.lineIdx || t !== this.lineCharOffset) {
              this.peekedToken = a;
              break;
            } else
              return this.lineCharOffset += a.length, a;
          else
            this.lineTokenOffset++, this.lineCharOffset = d;
        } else if (this.lineIdx === this.textBufferLineCount - 1 || (this.lineIdx++, this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1), this.lineTokenOffset = 0, this.line = this.lineTokens.getLineContent(), this.lineCharOffset = 0, i += 33, i > 1e3))
          break;
        if (i > 1500)
          break;
      }
      const n = QK(e, t, this.lineIdx, this.lineCharOffset);
      return new zl(n, 0, -1, xi.getEmpty(), new _u(n));
    }
  }
  class cq {
    constructor(e, t) {
      this.text = e, this._offset = ua, this.idx = 0;
      const n = t.getRegExpStr() ? new RegExp(t.getRegExpStr() + `|
`, "g") : null, o = [];
      let r, a = 0, l = 0, c = 0, d = 0;
      const h = new Array();
      for (let g = 0; g < 60; g++)
        h.push(new zl(fi(0, g), 0, -1, xi.getEmpty(), new _u(fi(0, g))));
      const u = new Array();
      for (let g = 0; g < 60; g++)
        u.push(new zl(fi(1, g), 0, -1, xi.getEmpty(), new _u(fi(1, g))));
      if (n)
        for (n.lastIndex = 0; (r = n.exec(e)) !== null; ) {
          const g = r.index, _ = r[0];
          if (_ === `
`)
            a++, l = g + 1;
          else {
            if (c !== g) {
              let b;
              if (d === a) {
                const C = g - c;
                if (C < h.length)
                  b = h[C];
                else {
                  const v = fi(0, C);
                  b = new zl(v, 0, -1, xi.getEmpty(), new _u(v));
                }
              } else {
                const C = a - d, v = g - l;
                if (C === 1 && v < u.length)
                  b = u[v];
                else {
                  const w = fi(C, v);
                  b = new zl(w, 0, -1, xi.getEmpty(), new _u(w));
                }
              }
              o.push(b);
            }
            o.push(t.getToken(_)), c = g + _.length, d = a;
          }
        }
      const f = e.length;
      if (c !== f) {
        const g = d === a ? fi(0, f - c) : fi(a - d, f - l);
        o.push(new zl(g, 0, -1, xi.getEmpty(), new _u(g)));
      }
      this.length = fi(a, f - l), this.tokens = o;
    }
    get offset() {
      return this._offset;
    }
    read() {
      return this.tokens[this.idx++] || null;
    }
    peek() {
      return this.tokens[this.idx] || null;
    }
    skip(e) {
      throw new pB();
    }
  }
  class C1 {
    constructor(e) {
      this.map = e, this.hasRegExp = !1, this._regExpGlobal = null;
    }
    static createFromLanguage(e, t) {
      function i(l, c) {
        return t.getKey(`${l}:::${c}`);
      }
      const n = e.characterPair.getColorizedBrackets(), o = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
      for (const [l, c] of n) {
        r.add(l);
        let d = o.get(c);
        const h = i(e.languageId, l);
        d || (d = { openingBrackets: xi.getEmpty(), first: h }, o.set(c, d)), d.openingBrackets = d.openingBrackets.add(h, zT);
      }
      const a = /* @__PURE__ */ new Map();
      for (const [l, c] of o) {
        const d = fi(0, l.length);
        a.set(l, new zl(d, 2, c.first, c.openingBrackets, v1.create(d, e.languageId, c.openingBrackets)));
      }
      for (const l of r) {
        const c = fi(0, l.length), d = i(e.languageId, l), h = xi.getEmpty().add(d, zT);
        a.set(l, new zl(c, 1, d, h, v1.create(c, e.languageId, h)));
      }
      return new C1(a);
    }
    getRegExpStr() {
      if (this.isEmpty)
        return null;
      {
        const e = [...this.map.keys()];
        return e.sort(), e.reverse(), e.map((t) => dq(t)).join("|");
      }
    }
    get regExpGlobal() {
      if (!this.hasRegExp) {
        const e = this.getRegExpStr();
        this._regExpGlobal = e ? new RegExp(e, "g") : null, this.hasRegExp = !0;
      }
      return this._regExpGlobal;
    }
    getToken(e) {
      return this.map.get(e);
    }
    findClosingTokenText(e) {
      for (const [t, i] of this.map)
        if (i.bracketIds.intersects(e))
          return t;
    }
    get isEmpty() {
      return this.map.size === 0;
    }
  }
  function dq(s) {
    const e = wo(s);
    return /^[\w ]+$/.test(s) ? `\\b${e}\\b` : e;
  }
  class hF {
    constructor(e, t) {
      this.denseKeyProvider = e, this.getLanguageConfiguration = t, this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
    }
    didLanguageChange(e) {
      const t = this.languageIdToBracketTokens.get(e);
      if (!t)
        return !1;
      const i = C1.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider).getRegExpStr();
      return t.getRegExpStr() !== i;
    }
    getSingleLanguageBracketTokens(e) {
      let t = this.languageIdToBracketTokens.get(e);
      return t || (t = C1.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider), this.languageIdToBracketTokens.set(e, t)), t;
    }
  }
  function hq(s) {
    if (s.length === 0)
      return null;
    if (s.length === 1)
      return s[0];
    let e = 0;
    function t() {
      if (e >= s.length)
        return null;
      const r = e, a = s[r].listHeight;
      for (e++; e < s.length && s[e].listHeight === a; )
        e++;
      return e - r >= 2 ? uF(r === 0 && e === s.length ? s : s.slice(r, e), !1) : s[r];
    }
    let i = t(), n = t();
    if (!n)
      return i;
    for (let r = t(); r; r = t())
      UT(i, n) <= UT(n, r) ? (i = tS(i, n), n = r) : n = tS(n, r);
    return tS(i, n);
  }
  function uF(s, e = !1) {
    if (s.length === 0)
      return null;
    if (s.length === 1)
      return s[0];
    let t = s.length;
    for (; t > 3; ) {
      const i = t >> 1;
      for (let n = 0; n < i; n++) {
        const o = n << 1;
        s[n] = fa.create23(s[o], s[o + 1], o + 3 === t ? s[o + 2] : null, e);
      }
      t = i;
    }
    return fa.create23(s[0], s[1], t >= 3 ? s[2] : null, e);
  }
  function UT(s, e) {
    return Math.abs(s.listHeight - e.listHeight);
  }
  function tS(s, e) {
    return s.listHeight === e.listHeight ? fa.create23(s, e, null, !1) : s.listHeight > e.listHeight ? uq(s, e) : fq(e, s);
  }
  function uq(s, e) {
    s = s.toMutable();
    let t = s;
    const i = new Array();
    let n;
    for (; ; ) {
      if (e.listHeight === t.listHeight) {
        n = e;
        break;
      }
      if (t.kind !== 4)
        throw new Error("unexpected");
      i.push(t), t = t.makeLastElementMutable();
    }
    for (let o = i.length - 1; o >= 0; o--) {
      const r = i[o];
      n ? r.childrenLength >= 3 ? n = fa.create23(r.unappendChild(), n, null, !1) : (r.appendChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
    }
    return n ? fa.create23(s, n, null, !1) : s;
  }
  function fq(s, e) {
    s = s.toMutable();
    let t = s;
    const i = new Array();
    for (; e.listHeight !== t.listHeight; ) {
      if (t.kind !== 4)
        throw new Error("unexpected");
      i.push(t), t = t.makeFirstElementMutable();
    }
    let n = e;
    for (let o = i.length - 1; o >= 0; o--) {
      const r = i[o];
      n ? r.childrenLength >= 3 ? n = fa.create23(n, r.unprependChild(), null, !1) : (r.prependChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
    }
    return n ? fa.create23(n, s, null, !1) : s;
  }
  class gq {
    constructor(e) {
      this.lastOffset = ua, this.nextNodes = [e], this.offsets = [ua], this.idxs = [];
    }
    readLongestNodeAt(e, t) {
      if (u0(e, this.lastOffset))
        throw new Error("Invalid offset");
      for (this.lastOffset = e; ; ) {
        const i = yg(this.nextNodes);
        if (!i)
          return;
        const n = yg(this.offsets);
        if (u0(e, n))
          return;
        if (u0(n, e))
          if (Ii(n, i.length) <= e)
            this.nextNodeAfterCurrent();
          else {
            const o = iS(i);
            o !== -1 ? (this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o)) : this.nextNodeAfterCurrent();
          }
        else {
          if (t(i))
            return this.nextNodeAfterCurrent(), i;
          {
            const o = iS(i);
            if (o === -1) {
              this.nextNodeAfterCurrent();
              return;
            } else
              this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o);
          }
        }
      }
    }
    nextNodeAfterCurrent() {
      for (; ; ) {
        const e = yg(this.offsets), t = yg(this.nextNodes);
        if (this.nextNodes.pop(), this.offsets.pop(), this.idxs.length === 0)
          break;
        const i = yg(this.nextNodes), n = iS(i, this.idxs[this.idxs.length - 1]);
        if (n !== -1) {
          this.nextNodes.push(i.getChild(n)), this.offsets.push(Ii(e, t.length)), this.idxs[this.idxs.length - 1] = n;
          break;
        } else
          this.idxs.pop();
      }
    }
  }
  function iS(s, e = -1) {
    for (; ; ) {
      if (e++, e >= s.childrenLength)
        return -1;
      if (s.getChild(e))
        return e;
    }
  }
  function yg(s) {
    return s.length > 0 ? s[s.length - 1] : void 0;
  }
  function NL(s, e, t, i) {
    return new mq(s, e, t, i).parseDocument();
  }
  class mq {
    constructor(e, t, i, n) {
      if (this.tokenizer = e, this.createImmutableLists = n, this._itemsConstructed = 0, this._itemsFromCache = 0, i && n)
        throw new Error("Not supported");
      this.oldNodeReader = i ? new gq(i) : void 0, this.positionMapper = new nq(t, e.length);
    }
    parseDocument() {
      this._itemsConstructed = 0, this._itemsFromCache = 0;
      let e = this.parseList(xi.getEmpty());
      return e || (e = fa.getEmpty()), e;
    }
    parseList(e) {
      const t = new Array();
      for (; ; ) {
        const n = this.tokenizer.peek();
        if (!n || n.kind === 2 && n.bracketIds.intersects(e))
          break;
        const o = this.parseChild(e);
        o.kind === 4 && o.childrenLength === 0 || t.push(o);
      }
      return this.oldNodeReader ? hq(t) : uF(t, this.createImmutableLists);
    }
    parseChild(e) {
      if (this.oldNodeReader) {
        const i = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
        if (!JK(i)) {
          const n = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (o) => u0(o.length, i) ? o.canBeReused(e) : !1);
          if (n)
            return this._itemsFromCache++, this.tokenizer.skip(n.length), n;
        }
      }
      this._itemsConstructed++;
      const t = this.tokenizer.read();
      switch (t.kind) {
        case 2:
          return new aq(t.bracketIds, t.length);
        case 0:
          return t.astNode;
        case 1: {
          const i = e.merge(t.bracketIds), n = this.parseList(i), o = this.tokenizer.peek();
          return o && o.kind === 2 && (o.bracketId === t.bracketId || o.bracketIds.intersects(t.bracketIds)) ? (this.tokenizer.read(), lp.create(t.astNode, n, o.astNode)) : lp.create(t.astNode, n, null);
        }
        default:
          throw new Error("unexpected");
      }
    }
  }
  class pq extends z {
    constructor(e, t) {
      if (super(), this.textModel = e, this.getLanguageConfiguration = t, this.didChangeEmitter = new B(), this.denseKeyProvider = new cF(), this.brackets = new hF(this.denseKeyProvider, this.getLanguageConfiguration), this.onDidChange = this.didChangeEmitter.event, e.backgroundTokenizationState === 0) {
        const i = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), n = new cq(this.textModel.getValue(), i);
        this.initialAstWithoutTokens = NL(n, [], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens;
      } else
        e.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, !1)) : e.backgroundTokenizationState === 1 && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens);
    }
    didLanguageChange(e) {
      return this.brackets.didLanguageChange(e);
    }
    handleDidChangeBackgroundTokenizationState() {
      if (this.textModel.backgroundTokenizationState === 2) {
        const e = this.initialAstWithoutTokens === void 0;
        this.initialAstWithoutTokens = void 0, e || this.didChangeEmitter.fire();
      }
    }
    handleDidChangeTokens({ ranges: e }) {
      const t = e.map((i) => new HT(fi(i.fromLineNumber - 1, 0), fi(i.toLineNumber, 0), fi(i.toLineNumber - i.fromLineNumber + 1, 0)));
      this.astWithTokens = this.parseDocumentFromTextBuffer(t, this.astWithTokens, !1), this.initialAstWithoutTokens || this.didChangeEmitter.fire();
    }
    handleContentChanged(e) {
      const t = e.changes.map((i) => {
        const n = D.lift(i.range);
        return new HT(tb(n.getStartPosition()), tb(n.getEndPosition()), iq(i.text));
      }).reverse();
      this.astWithTokens = this.parseDocumentFromTextBuffer(t, this.astWithTokens, !1), this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(t, this.initialAstWithoutTokens, !1));
    }
    parseDocumentFromTextBuffer(e, t, i) {
      const n = t, o = new dF(this.textModel, this.brackets);
      return NL(o, e, n, i);
    }
    getBracketsInRange(e) {
      const t = fi(e.startLineNumber - 1, e.startColumn - 1), i = fi(e.endLineNumber - 1, e.endColumn - 1), n = new Array(), o = this.initialAstWithoutTokens || this.astWithTokens;
      return TL(o, ua, o.length, t, i, n), n;
    }
    getBracketPairsInRange(e, t) {
      const i = new Array(), n = tb(e.getStartPosition()), o = tb(e.getEndPosition()), r = this.initialAstWithoutTokens || this.astWithTokens, a = new _q(i, t, this.textModel);
      return fF(r, ua, r.length, n, o, a), i;
    }
  }
  function TL(s, e, t, i, n, o, r = 0) {
    if (s.kind === 4)
      for (const a of s.children)
        t = Ii(e, a.length), wd(e, n) && eb(t, i) && TL(a, e, t, i, n, o, r), e = t;
    else if (s.kind === 2) {
      r++;
      {
        const a = s.openingBracket;
        if (t = Ii(e, a.length), wd(e, n) && eb(t, i)) {
          const l = Sd(e, t);
          o.push(new J_(l, r - 1, !s.closingBracket));
        }
        e = t;
      }
      if (s.child) {
        const a = s.child;
        t = Ii(e, a.length), wd(e, n) && eb(t, i) && TL(a, e, t, i, n, o, r), e = t;
      }
      if (s.closingBracket) {
        const a = s.closingBracket;
        if (t = Ii(e, a.length), wd(e, n) && eb(t, i)) {
          const l = Sd(e, t);
          o.push(new J_(l, r - 1, !1));
        }
        e = t;
      }
    } else if (s.kind === 3) {
      const a = Sd(e, t);
      o.push(new J_(a, r - 1, !0));
    } else if (s.kind === 1) {
      const a = Sd(e, t);
      o.push(new J_(a, r - 1, !1));
    }
  }
  class _q {
    constructor(e, t, i) {
      this.result = e, this.includeMinIndentation = t, this.textModel = i;
    }
  }
  function fF(s, e, t, i, n, o, r = 0) {
    var a;
    if (s.kind === 2) {
      const c = Ii(e, s.openingBracket.length);
      let d = -1;
      o.includeMinIndentation && (d = s.computeMinIndentation(e, o.textModel)), o.result.push(new XK(Sd(e, t), Sd(e, c), s.closingBracket ? Sd(Ii(c, ((a = s.child) === null || a === void 0 ? void 0 : a.length) || ua), t) : void 0, r, d)), r++;
    }
    let l = e;
    for (const c of s.children) {
      const d = l;
      l = Ii(l, c.length), wd(d, n) && wd(i, l) && fF(c, d, l, i, n, o, r);
    }
  }
  class bq extends z {
    constructor(e, t) {
      super(), this.textModel = e, this.languageConfigurationService = t, this.bracketPairsTree = this._register(new Gn()), this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.bracketsRequested = !1, this._register(this.languageConfigurationService.onDidChange((i) => {
        var n;
        (!i.languageId || ((n = this.bracketPairsTree.value) === null || n === void 0 ? void 0 : n.object.didLanguageChange(i.languageId))) && (this.bracketPairsTree.clear(), this.updateBracketPairsTree());
      }));
    }
    get isDocumentSupported() {
      return this.textModel.getValueLength() <= 5e6;
    }
    handleDidChangeOptions(e) {
      this.bracketPairsTree.clear(), this.updateBracketPairsTree();
    }
    handleDidChangeLanguage(e) {
      this.bracketPairsTree.clear(), this.updateBracketPairsTree();
    }
    handleDidChangeContent(e) {
      var t;
      (t = this.bracketPairsTree.value) === null || t === void 0 || t.object.handleContentChanged(e);
    }
    handleDidChangeBackgroundTokenizationState() {
      var e;
      (e = this.bracketPairsTree.value) === null || e === void 0 || e.object.handleDidChangeBackgroundTokenizationState();
    }
    handleDidChangeTokens(e) {
      var t;
      (t = this.bracketPairsTree.value) === null || t === void 0 || t.object.handleDidChangeTokens(e);
    }
    updateBracketPairsTree() {
      if (this.bracketsRequested && this.isDocumentSupported) {
        if (!this.bracketPairsTree.value) {
          const e = new te();
          this.bracketPairsTree.value = vq(e.add(new pq(this.textModel, (t) => this.languageConfigurationService.getLanguageConfiguration(t))), e), e.add(this.bracketPairsTree.value.object.onDidChange((t) => this.onDidChangeEmitter.fire(t))), this.onDidChangeEmitter.fire();
        }
      } else
        this.bracketPairsTree.value && (this.bracketPairsTree.clear(), this.onDidChangeEmitter.fire());
    }
    getBracketPairsInRange(e) {
      var t;
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketPairsInRange(e, !1)) || [];
    }
    getBracketPairsInRangeWithMinIndentation(e) {
      var t;
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketPairsInRange(e, !0)) || [];
    }
    getBracketsInRange(e) {
      var t;
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketsInRange(e)) || [];
    }
    findMatchingBracketUp(e, t, i) {
      const n = e.toLowerCase(), o = this.textModel.validatePosition(t), r = this.textModel.getLanguageIdAtPosition(o.lineNumber, o.column), a = this.languageConfigurationService.getLanguageConfiguration(r).brackets;
      if (!a)
        return null;
      const l = a.textIsBracket[n];
      return l ? ib(this._findMatchingBracketUp(l, o, nS(i))) : null;
    }
    matchBracket(e, t) {
      const i = nS(t);
      return this._matchBracket(this.textModel.validatePosition(e), i);
    }
    _establishBracketSearchOffsets(e, t, i, n) {
      const o = t.getCount(), r = t.getLanguageId(n);
      let a = Math.max(0, e.column - 1 - i.maxBracketLength);
      for (let c = n - 1; c >= 0; c--) {
        const d = t.getEndOffset(c);
        if (d <= a)
          break;
        if (Mr(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
          a = d;
          break;
        }
      }
      let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
      for (let c = n + 1; c < o; c++) {
        const d = t.getStartOffset(c);
        if (d >= l)
          break;
        if (Mr(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
          l = d;
          break;
        }
      }
      return { searchStartOffset: a, searchEndOffset: l };
    }
    _matchBracket(e, t) {
      const i = e.lineNumber, n = this.textModel.getLineTokens(i), o = this.textModel.getLineContent(i), r = n.findTokenIndexAtOffset(e.column - 1);
      if (r < 0)
        return null;
      const a = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(r)).brackets;
      if (a && !Mr(n.getStandardTokenType(r))) {
        let { searchStartOffset: l, searchEndOffset: c } = this._establishBracketSearchOffsets(e, n, a, r), d = null;
        for (; ; ) {
          const h = Fo.findNextBracketInRange(a.forwardRegex, i, o, l, c);
          if (!h)
            break;
          if (h.startColumn <= e.column && e.column <= h.endColumn) {
            const u = o.substring(h.startColumn - 1, h.endColumn - 1).toLowerCase(), f = this._matchFoundBracket(h, a.textIsBracket[u], a.textIsOpenBracket[u], t);
            if (f) {
              if (f instanceof Ka)
                return null;
              d = f;
            }
          }
          l = h.endColumn - 1;
        }
        if (d)
          return d;
      }
      if (r > 0 && n.getStartOffset(r) === e.column - 1) {
        const l = r - 1, c = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(l)).brackets;
        if (c && !Mr(n.getStandardTokenType(l))) {
          const { searchStartOffset: d, searchEndOffset: h } = this._establishBracketSearchOffsets(e, n, c, l), u = Fo.findPrevBracketInRange(c.reversedRegex, i, o, d, h);
          if (u && u.startColumn <= e.column && e.column <= u.endColumn) {
            const f = o.substring(u.startColumn - 1, u.endColumn - 1).toLowerCase(), g = this._matchFoundBracket(u, c.textIsBracket[f], c.textIsOpenBracket[f], t);
            if (g)
              return g instanceof Ka ? null : g;
          }
        }
      }
      return null;
    }
    _matchFoundBracket(e, t, i, n) {
      if (!t)
        return null;
      const o = i ? this._findMatchingBracketDown(t, e.getEndPosition(), n) : this._findMatchingBracketUp(t, e.getStartPosition(), n);
      return o ? o instanceof Ka ? o : [e, o] : null;
    }
    _findMatchingBracketUp(e, t, i) {
      const n = e.languageId, o = e.reversedRegex;
      let r = -1, a = 0;
      const l = (c, d, h, u) => {
        for (; ; ) {
          if (i && ++a % 100 === 0 && !i())
            return Ka.INSTANCE;
          const f = Fo.findPrevBracketInRange(o, c, d, h, u);
          if (!f)
            break;
          const g = d.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase();
          if (e.isOpen(g) ? r++ : e.isClose(g) && r--, r === 0)
            return f;
          u = f.startColumn - 1;
        }
        return null;
      };
      for (let c = t.lineNumber; c >= 1; c--) {
        const d = this.textModel.getLineTokens(c), h = d.getCount(), u = this.textModel.getLineContent(c);
        let f = h - 1, g = u.length, _ = u.length;
        c === t.lineNumber && (f = d.findTokenIndexAtOffset(t.column - 1), g = t.column - 1, _ = t.column - 1);
        let b = !0;
        for (; f >= 0; f--) {
          const C = d.getLanguageId(f) === n && !Mr(d.getStandardTokenType(f));
          if (C)
            b ? g = d.getStartOffset(f) : (g = d.getStartOffset(f), _ = d.getEndOffset(f));
          else if (b && g !== _) {
            const v = l(c, u, g, _);
            if (v)
              return v;
          }
          b = C;
        }
        if (b && g !== _) {
          const C = l(c, u, g, _);
          if (C)
            return C;
        }
      }
      return null;
    }
    _findMatchingBracketDown(e, t, i) {
      const n = e.languageId, o = e.forwardRegex;
      let r = 1, a = 0;
      const l = (d, h, u, f) => {
        for (; ; ) {
          if (i && ++a % 100 === 0 && !i())
            return Ka.INSTANCE;
          const g = Fo.findNextBracketInRange(o, d, h, u, f);
          if (!g)
            break;
          const _ = h.substring(g.startColumn - 1, g.endColumn - 1).toLowerCase();
          if (e.isOpen(_) ? r++ : e.isClose(_) && r--, r === 0)
            return g;
          u = g.endColumn - 1;
        }
        return null;
      }, c = this.textModel.getLineCount();
      for (let d = t.lineNumber; d <= c; d++) {
        const h = this.textModel.getLineTokens(d), u = h.getCount(), f = this.textModel.getLineContent(d);
        let g = 0, _ = 0, b = 0;
        d === t.lineNumber && (g = h.findTokenIndexAtOffset(t.column - 1), _ = t.column - 1, b = t.column - 1);
        let C = !0;
        for (; g < u; g++) {
          const v = h.getLanguageId(g) === n && !Mr(h.getStandardTokenType(g));
          if (v)
            C || (_ = h.getStartOffset(g)), b = h.getEndOffset(g);
          else if (C && _ !== b) {
            const w = l(d, f, _, b);
            if (w)
              return w;
          }
          C = v;
        }
        if (C && _ !== b) {
          const v = l(d, f, _, b);
          if (v)
            return v;
        }
      }
      return null;
    }
    findPrevBracket(e) {
      const t = this.textModel.validatePosition(e);
      let i = null, n = null;
      for (let o = t.lineNumber; o >= 1; o--) {
        const r = this.textModel.getLineTokens(o), a = r.getCount(), l = this.textModel.getLineContent(o);
        let c = a - 1, d = l.length, h = l.length;
        if (o === t.lineNumber) {
          c = r.findTokenIndexAtOffset(t.column - 1), d = t.column - 1, h = t.column - 1;
          const f = r.getLanguageId(c);
          i !== f && (i = f, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets);
        }
        let u = !0;
        for (; c >= 0; c--) {
          const f = r.getLanguageId(c);
          if (i !== f) {
            if (n && u && d !== h) {
              const _ = Fo.findPrevBracketInRange(n.reversedRegex, o, l, d, h);
              if (_)
                return this._toFoundBracket(n, _);
              u = !1;
            }
            i = f, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets;
          }
          const g = !!n && !Mr(r.getStandardTokenType(c));
          if (g)
            u ? d = r.getStartOffset(c) : (d = r.getStartOffset(c), h = r.getEndOffset(c));
          else if (n && u && d !== h) {
            const _ = Fo.findPrevBracketInRange(n.reversedRegex, o, l, d, h);
            if (_)
              return this._toFoundBracket(n, _);
          }
          u = g;
        }
        if (n && u && d !== h) {
          const f = Fo.findPrevBracketInRange(n.reversedRegex, o, l, d, h);
          if (f)
            return this._toFoundBracket(n, f);
        }
      }
      return null;
    }
    findNextBracket(e) {
      const t = this.textModel.validatePosition(e), i = this.textModel.getLineCount();
      let n = null, o = null;
      for (let r = t.lineNumber; r <= i; r++) {
        const a = this.textModel.getLineTokens(r), l = a.getCount(), c = this.textModel.getLineContent(r);
        let d = 0, h = 0, u = 0;
        if (r === t.lineNumber) {
          d = a.findTokenIndexAtOffset(t.column - 1), h = t.column - 1, u = t.column - 1;
          const g = a.getLanguageId(d);
          n !== g && (n = g, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets);
        }
        let f = !0;
        for (; d < l; d++) {
          const g = a.getLanguageId(d);
          if (n !== g) {
            if (o && f && h !== u) {
              const b = Fo.findNextBracketInRange(o.forwardRegex, r, c, h, u);
              if (b)
                return this._toFoundBracket(o, b);
              f = !1;
            }
            n = g, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets;
          }
          const _ = !!o && !Mr(a.getStandardTokenType(d));
          if (_)
            f || (h = a.getStartOffset(d)), u = a.getEndOffset(d);
          else if (o && f && h !== u) {
            const b = Fo.findNextBracketInRange(o.forwardRegex, r, c, h, u);
            if (b)
              return this._toFoundBracket(o, b);
          }
          f = _;
        }
        if (o && f && h !== u) {
          const g = Fo.findNextBracketInRange(o.forwardRegex, r, c, h, u);
          if (g)
            return this._toFoundBracket(o, g);
        }
      }
      return null;
    }
    findEnclosingBrackets(e, t) {
      const i = nS(t), n = this.textModel.validatePosition(e), o = this.textModel.getLineCount(), r = /* @__PURE__ */ new Map();
      let a = [];
      const l = (f, g) => {
        if (!r.has(f)) {
          const _ = [];
          for (let b = 0, C = g ? g.brackets.length : 0; b < C; b++)
            _[b] = 0;
          r.set(f, _);
        }
        a = r.get(f);
      };
      let c = 0;
      const d = (f, g, _, b, C) => {
        for (; ; ) {
          if (i && ++c % 100 === 0 && !i())
            return Ka.INSTANCE;
          const v = Fo.findNextBracketInRange(f.forwardRegex, g, _, b, C);
          if (!v)
            break;
          const w = _.substring(v.startColumn - 1, v.endColumn - 1).toLowerCase(), S = f.textIsBracket[w];
          if (S && (S.isOpen(w) ? a[S.index]++ : S.isClose(w) && a[S.index]--, a[S.index] === -1))
            return this._matchFoundBracket(v, S, !1, i);
          b = v.endColumn - 1;
        }
        return null;
      };
      let h = null, u = null;
      for (let f = n.lineNumber; f <= o; f++) {
        const g = this.textModel.getLineTokens(f), _ = g.getCount(), b = this.textModel.getLineContent(f);
        let C = 0, v = 0, w = 0;
        if (f === n.lineNumber) {
          C = g.findTokenIndexAtOffset(n.column - 1), v = n.column - 1, w = n.column - 1;
          const L = g.getLanguageId(C);
          h !== L && (h = L, u = this.languageConfigurationService.getLanguageConfiguration(h).brackets, l(h, u));
        }
        let S = !0;
        for (; C < _; C++) {
          const L = g.getLanguageId(C);
          if (h !== L) {
            if (u && S && v !== w) {
              const y = d(u, f, b, v, w);
              if (y)
                return ib(y);
              S = !1;
            }
            h = L, u = this.languageConfigurationService.getLanguageConfiguration(h).brackets, l(h, u);
          }
          const x = !!u && !Mr(g.getStandardTokenType(C));
          if (x)
            S || (v = g.getStartOffset(C)), w = g.getEndOffset(C);
          else if (u && S && v !== w) {
            const y = d(u, f, b, v, w);
            if (y)
              return ib(y);
          }
          S = x;
        }
        if (u && S && v !== w) {
          const L = d(u, f, b, v, w);
          if (L)
            return ib(L);
        }
      }
      return null;
    }
    _toFoundBracket(e, t) {
      if (!t)
        return null;
      let i = this.textModel.getValueInRange(t);
      i = i.toLowerCase();
      const n = e.textIsBracket[i];
      return n ? {
        range: t,
        open: n.open,
        close: n.close,
        isOpen: e.textIsOpenBracket[i]
      } : null;
    }
  }
  function vq(s, e) {
    return {
      object: s,
      dispose: () => e?.dispose()
    };
  }
  function nS(s) {
    if (typeof s > "u")
      return () => !0;
    {
      const e = Date.now();
      return () => Date.now() - e <= s;
    }
  }
  class Ka {
    constructor() {
      this._searchCanceledBrand = void 0;
    }
  }
  Ka.INSTANCE = new Ka();
  function ib(s) {
    return s instanceof Ka ? null : s;
  }
  class Cq extends z {
    constructor(e) {
      super(), this.textModel = e, this.colorProvider = new gF(), this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.colorizationOptions = e.getOptions().bracketPairColorizationOptions, this._register(e.bracketPairs.onDidChange((t) => {
        this.onDidChangeEmitter.fire();
      }));
    }
    handleDidChangeOptions(e) {
      this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
    }
    getDecorationsInRange(e, t, i) {
      if (t === void 0)
        return [];
      if (!this.colorizationOptions.enabled)
        return [];
      const n = new Array(), o = this.textModel.bracketPairs.getBracketsInRange(e);
      for (const r of o)
        n.push({
          id: `bracket${r.range.toString()}-${r.nestingLevel}`,
          options: { description: "BracketPairColorization", inlineClassName: this.colorProvider.getInlineClassName(r) },
          ownerId: 0,
          range: r.range
        });
      return n;
    }
    getAllDecorations(e, t) {
      return e === void 0 ? [] : this.colorizationOptions.enabled ? this.getDecorationsInRange(new D(1, 1, this.textModel.getLineCount(), 1), e, t) : [];
    }
  }
  class gF {
    constructor() {
      this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
    }
    getInlineClassName(e) {
      return e.isInvalid ? this.unexpectedClosingBracketClassName : this.getInlineClassNameOfLevel(e.nestingLevel);
    }
    getInlineClassNameOfLevel(e) {
      return `bracket-highlighting-${e % 30}`;
    }
  }
  Vt((s, e) => {
    const t = [
      V5,
      H5,
      z5,
      U5,
      $5,
      j5
    ], i = new gF();
    e.addRule(`.monaco-editor .${i.unexpectedClosingBracketClassName} { color: ${s.getColor(j$)}; }`);
    const n = t.map((o) => s.getColor(o)).filter((o) => !!o).filter((o) => !o.isTransparent());
    for (let o = 0; o < 30; o++) {
      const r = n[o % n.length];
      e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(o)} { color: ${r}; }`);
    }
  });
  function nb(s) {
    return s.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
  }
  class gn {
    constructor(e, t, i, n) {
      this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = n;
    }
    get oldLength() {
      return this.oldText.length;
    }
    get oldEnd() {
      return this.oldPosition + this.oldText.length;
    }
    get newLength() {
      return this.newText.length;
    }
    get newEnd() {
      return this.newPosition + this.newText.length;
    }
    toString() {
      return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${nb(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${nb(this.oldText)}")` : `(replace@${this.oldPosition} "${nb(this.oldText)}" with "${nb(this.newText)}")`;
    }
    static _writeStringSize(e) {
      return 4 + 2 * e.length;
    }
    static _writeString(e, t, i) {
      const n = t.length;
      nr(e, n, i), i += 4;
      for (let o = 0; o < n; o++)
        HV(e, t.charCodeAt(o), i), i += 2;
      return i;
    }
    static _readString(e, t) {
      const i = ir(e, t);
      return t += 4, nL(e, t, i);
    }
    writeSize() {
      return 4 + 4 + gn._writeStringSize(this.oldText) + gn._writeStringSize(this.newText);
    }
    write(e, t) {
      return nr(e, this.oldPosition, t), t += 4, nr(e, this.newPosition, t), t += 4, t = gn._writeString(e, this.oldText, t), t = gn._writeString(e, this.newText, t), t;
    }
    static read(e, t, i) {
      const n = ir(e, t);
      t += 4;
      const o = ir(e, t);
      t += 4;
      const r = gn._readString(e, t);
      t += gn._writeStringSize(r);
      const a = gn._readString(e, t);
      return t += gn._writeStringSize(a), i.push(new gn(n, r, o, a)), t;
    }
  }
  function wq(s, e) {
    return s === null || s.length === 0 ? e : new Or(s, e).compress();
  }
  class Or {
    constructor(e, t) {
      this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
    }
    compress() {
      let e = 0, t = 0, i = this._getPrev(e), n = this._getCurr(t);
      for (; e < this._prevLen || t < this._currLen; ) {
        if (i === null) {
          this._acceptCurr(n), n = this._getCurr(++t);
          continue;
        }
        if (n === null) {
          this._acceptPrev(i), i = this._getPrev(++e);
          continue;
        }
        if (n.oldEnd <= i.newPosition) {
          this._acceptCurr(n), n = this._getCurr(++t);
          continue;
        }
        if (i.newEnd <= n.oldPosition) {
          this._acceptPrev(i), i = this._getPrev(++e);
          continue;
        }
        if (n.oldPosition < i.newPosition) {
          const [c, d] = Or._splitCurr(n, i.newPosition - n.oldPosition);
          this._acceptCurr(c), n = d;
          continue;
        }
        if (i.newPosition < n.oldPosition) {
          const [c, d] = Or._splitPrev(i, n.oldPosition - i.newPosition);
          this._acceptPrev(c), i = d;
          continue;
        }
        let a, l;
        if (n.oldEnd === i.newEnd)
          a = i, l = n, i = this._getPrev(++e), n = this._getCurr(++t);
        else if (n.oldEnd < i.newEnd) {
          const [c, d] = Or._splitPrev(i, n.oldLength);
          a = c, l = n, i = d, n = this._getCurr(++t);
        } else {
          const [c, d] = Or._splitCurr(n, i.newLength);
          a = i, l = c, i = this._getPrev(++e), n = d;
        }
        this._result[this._resultLen++] = new gn(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
      }
      const o = Or._merge(this._result);
      return Or._removeNoOps(o);
    }
    _acceptCurr(e) {
      this._result[this._resultLen++] = Or._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
    }
    _getCurr(e) {
      return e < this._currLen ? this._currEdits[e] : null;
    }
    _acceptPrev(e) {
      this._result[this._resultLen++] = Or._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
    }
    _getPrev(e) {
      return e < this._prevLen ? this._prevEdits[e] : null;
    }
    static _rebaseCurr(e, t) {
      return new gn(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
    }
    static _rebasePrev(e, t) {
      return new gn(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
    }
    static _splitPrev(e, t) {
      const i = e.newText.substr(0, t), n = e.newText.substr(t);
      return [
        new gn(e.oldPosition, e.oldText, e.newPosition, i),
        new gn(e.oldEnd, "", e.newPosition + t, n)
      ];
    }
    static _splitCurr(e, t) {
      const i = e.oldText.substr(0, t), n = e.oldText.substr(t);
      return [
        new gn(e.oldPosition, i, e.newPosition, e.newText),
        new gn(e.oldPosition + t, n, e.newEnd, "")
      ];
    }
    static _merge(e) {
      if (e.length === 0)
        return e;
      const t = [];
      let i = 0, n = e[0];
      for (let o = 1; o < e.length; o++) {
        const r = e[o];
        n.oldEnd === r.oldPosition ? n = new gn(n.oldPosition, n.oldText + r.oldText, n.newPosition, n.newText + r.newText) : (t[i++] = n, n = r);
      }
      return t[i++] = n, t;
    }
    static _removeNoOps(e) {
      if (e.length === 0)
        return e;
      const t = [];
      let i = 0;
      for (let n = 0; n < e.length; n++) {
        const o = e[n];
        o.oldText !== o.newText && (t[i++] = o);
      }
      return t;
    }
  }
  function Il(s) {
    return s === 47 || s === 92;
  }
  function mF(s) {
    return s.replace(/[\\/]/g, Ci.sep);
  }
  function Sq(s) {
    return s.indexOf("/") === -1 && (s = mF(s)), /^[a-zA-Z]:(\/|$)/.test(s) && (s = "/" + s), s;
  }
  function $T(s, e = Ci.sep) {
    if (!s)
      return "";
    const t = s.length, i = s.charCodeAt(0);
    if (Il(i)) {
      if (Il(s.charCodeAt(1)) && !Il(s.charCodeAt(2))) {
        let o = 3;
        const r = o;
        for (; o < t && !Il(s.charCodeAt(o)); o++)
          ;
        if (r !== o && !Il(s.charCodeAt(o + 1))) {
          for (o += 1; o < t; o++)
            if (Il(s.charCodeAt(o)))
              return s.slice(0, o + 1).replace(/[\\/]/g, e);
        }
      }
      return e;
    } else if (pF(i) && s.charCodeAt(1) === 58)
      return Il(s.charCodeAt(2)) ? s.slice(0, 2) + e : s.slice(0, 2);
    let n = s.indexOf("://");
    if (n !== -1) {
      for (n += 3; n < t; n++)
        if (Il(s.charCodeAt(n)))
          return s.slice(0, n + 1);
    }
    return "";
  }
  function ML(s, e, t, i = ta) {
    if (s === e)
      return !0;
    if (!s || !e || e.length > s.length)
      return !1;
    if (t) {
      if (!TI(s, e))
        return !1;
      if (e.length === s.length)
        return !0;
      let o = e.length;
      return e.charAt(e.length - 1) === i && o--, s.charAt(o) === i;
    }
    return e.charAt(e.length - 1) !== i && (e += i), s.indexOf(e) === 0;
  }
  function pF(s) {
    return s >= 65 && s <= 90 || s >= 97 && s <= 122;
  }
  function yq(s) {
    const e = SI(s);
    return rn ? s.length > 3 ? !1 : _F(e) && (s.length === 2 || e.charCodeAt(2) === 92) : e === Ci.sep;
  }
  function _F(s, e) {
    return (e !== void 0 ? e : rn) ? pF(s.charCodeAt(0)) && s.charCodeAt(1) === 58 : !1;
  }
  function Ar(s) {
    return H0(s, !0);
  }
  class xE {
    constructor(e) {
      this._ignorePathCasing = e;
    }
    compare(e, t, i = !1) {
      return e === t ? 0 : zm(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
    }
    isEqual(e, t, i = !1) {
      return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
    }
    getComparisonKey(e, t = !1) {
      return e.with({
        path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
        fragment: t ? null : void 0
      }).toString();
    }
    isEqualOrParent(e, t, i = !1) {
      if (e.scheme === t.scheme) {
        if (e.scheme === ze.file)
          return ML(Ar(e), Ar(t), this._ignorePathCasing(e)) && e.query === t.query && (i || e.fragment === t.fragment);
        if (KT(e.authority, t.authority))
          return ML(e.path, t.path, this._ignorePathCasing(e), "/") && e.query === t.query && (i || e.fragment === t.fragment);
      }
      return !1;
    }
    joinPath(e, ...t) {
      return Ee.joinPath(e, ...t);
    }
    basenameOrAuthority(e) {
      return ko(e) || e.authority;
    }
    basename(e) {
      return Ci.basename(e.path);
    }
    extname(e) {
      return Ci.extname(e.path);
    }
    dirname(e) {
      if (e.path.length === 0)
        return e;
      let t;
      return e.scheme === ze.file ? t = Ee.file(oP(Ar(e))).path : (t = Ci.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
        path: t
      });
    }
    normalizePath(e) {
      if (!e.path.length)
        return e;
      let t;
      return e.scheme === ze.file ? t = Ee.file(SI(Ar(e))).path : t = Ci.normalize(e.path), e.with({
        path: t
      });
    }
    relativePath(e, t) {
      if (e.scheme !== t.scheme || !KT(e.authority, t.authority))
        return;
      if (e.scheme === ze.file) {
        const o = hW(Ar(e), Ar(t));
        return rn ? mF(o) : o;
      }
      let i = e.path || "/", n = t.path || "/";
      if (this._ignorePathCasing(e)) {
        let o = 0;
        for (const r = Math.min(i.length, n.length); o < r && !(i.charCodeAt(o) !== n.charCodeAt(o) && i.charAt(o).toLowerCase() !== n.charAt(o).toLowerCase()); o++)
          ;
        i = n.substr(0, o) + i.substr(o);
      }
      return Ci.relative(i, n);
    }
    resolvePath(e, t) {
      if (e.scheme === ze.file) {
        const i = Ee.file(dW(Ar(e), t));
        return e.with({
          authority: i.authority,
          path: i.path
        });
      }
      return t = Sq(t), e.with({
        path: Ci.resolve(e.path, t)
      });
    }
    isAbsolutePath(e) {
      return !!e.path && e.path[0] === "/";
    }
    isEqualAuthority(e, t) {
      return e === t || e !== void 0 && t !== void 0 && Su(e, t);
    }
    hasTrailingPathSeparator(e, t = ta) {
      if (e.scheme === ze.file) {
        const i = Ar(e);
        return i.length > $T(i).length && i[i.length - 1] === t;
      } else {
        const i = e.path;
        return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
      }
    }
    removeTrailingPathSeparator(e, t = ta) {
      return qT(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e;
    }
    addTrailingPathSeparator(e, t = ta) {
      let i = !1;
      if (e.scheme === ze.file) {
        const n = Ar(e);
        i = n !== void 0 && n.length === $T(n).length && n[n.length - 1] === t;
      } else {
        t = "/";
        const n = e.path;
        i = n.length === 1 && n.charCodeAt(n.length - 1) === 47;
      }
      return !i && !qT(e, t) ? e.with({ path: e.path + "/" }) : e;
    }
  }
  const Wt = new xE(() => !1);
  new xE((s) => s.scheme === ze.file ? !Nn : !0);
  new xE((s) => !0);
  const bF = Wt.isEqual.bind(Wt);
  Wt.isEqualOrParent.bind(Wt);
  Wt.getComparisonKey.bind(Wt);
  const Lq = Wt.basenameOrAuthority.bind(Wt), ko = Wt.basename.bind(Wt), kq = Wt.extname.bind(Wt), hC = Wt.dirname.bind(Wt), Dq = Wt.joinPath.bind(Wt), xq = Wt.normalizePath.bind(Wt);
  Wt.relativePath.bind(Wt);
  const jT = Wt.resolvePath.bind(Wt);
  Wt.isAbsolutePath.bind(Wt);
  const KT = Wt.isEqualAuthority.bind(Wt), qT = Wt.hasTrailingPathSeparator.bind(Wt);
  Wt.removeTrailingPathSeparator.bind(Wt);
  Wt.addTrailingPathSeparator.bind(Wt);
  var yc;
  (function(s) {
    s.META_DATA_LABEL = "label", s.META_DATA_DESCRIPTION = "description", s.META_DATA_SIZE = "size", s.META_DATA_MIME = "mime";
    function e(t) {
      const i = /* @__PURE__ */ new Map();
      t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((r) => {
        const [a, l] = r.split(":");
        a && l && i.set(a, l);
      });
      const o = t.path.substring(0, t.path.indexOf(";"));
      return o && i.set(s.META_DATA_MIME, o), i;
    }
    s.parseMetaData = e;
  })(yc || (yc = {}));
  function eu(s) {
    return s.toString();
  }
  class $i {
    constructor(e, t, i, n, o, r, a) {
      this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = n, this.beforeCursorState = o, this.afterCursorState = r, this.changes = a;
    }
    static create(e, t) {
      const i = e.getAlternativeVersionId(), n = AL(e);
      return new $i(i, i, n, n, t, t, []);
    }
    append(e, t, i, n, o) {
      t.length > 0 && (this.changes = wq(this.changes, t)), this.afterEOL = i, this.afterVersionId = n, this.afterCursorState = o;
    }
    static _writeSelectionsSize(e) {
      return 4 + 4 * 4 * (e ? e.length : 0);
    }
    static _writeSelections(e, t, i) {
      if (nr(e, t ? t.length : 0, i), i += 4, t)
        for (const n of t)
          nr(e, n.selectionStartLineNumber, i), i += 4, nr(e, n.selectionStartColumn, i), i += 4, nr(e, n.positionLineNumber, i), i += 4, nr(e, n.positionColumn, i), i += 4;
      return i;
    }
    static _readSelections(e, t, i) {
      const n = ir(e, t);
      t += 4;
      for (let o = 0; o < n; o++) {
        const r = ir(e, t);
        t += 4;
        const a = ir(e, t);
        t += 4;
        const l = ir(e, t);
        t += 4;
        const c = ir(e, t);
        t += 4, i.push(new ae(r, a, l, c));
      }
      return t;
    }
    serialize() {
      let e = 10 + $i._writeSelectionsSize(this.beforeCursorState) + $i._writeSelectionsSize(this.afterCursorState) + 4;
      for (const n of this.changes)
        e += n.writeSize();
      const t = new Uint8Array(e);
      let i = 0;
      nr(t, this.beforeVersionId, i), i += 4, nr(t, this.afterVersionId, i), i += 4, K2(t, this.beforeEOL, i), i += 1, K2(t, this.afterEOL, i), i += 1, i = $i._writeSelections(t, this.beforeCursorState, i), i = $i._writeSelections(t, this.afterCursorState, i), nr(t, this.changes.length, i), i += 4;
      for (const n of this.changes)
        i = n.write(t, i);
      return t.buffer;
    }
    static deserialize(e) {
      const t = new Uint8Array(e);
      let i = 0;
      const n = ir(t, i);
      i += 4;
      const o = ir(t, i);
      i += 4;
      const r = j2(t, i);
      i += 1;
      const a = j2(t, i);
      i += 1;
      const l = [];
      i = $i._readSelections(t, i, l);
      const c = [];
      i = $i._readSelections(t, i, c);
      const d = ir(t, i);
      i += 4;
      const h = [];
      for (let u = 0; u < d; u++)
        i = gn.read(t, i, h);
      return new $i(n, o, r, a, l, c, h);
    }
  }
  class vF {
    constructor(e, t) {
      this.model = e, this._data = $i.create(e, t);
    }
    get type() {
      return 0;
    }
    get resource() {
      return Ee.isUri(this.model) ? this.model : this.model.uri;
    }
    get label() {
      return m("edit", "Typing");
    }
    toString() {
      return (this._data instanceof $i ? this._data : $i.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
    }
    matchesResource(e) {
      return (Ee.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
    }
    setModel(e) {
      this.model = e;
    }
    canAppend(e) {
      return this.model === e && this._data instanceof $i;
    }
    append(e, t, i, n, o) {
      this._data instanceof $i && this._data.append(e, t, i, n, o);
    }
    close() {
      this._data instanceof $i && (this._data = this._data.serialize());
    }
    open() {
      this._data instanceof $i || (this._data = $i.deserialize(this._data));
    }
    undo() {
      if (Ee.isUri(this.model))
        throw new Error("Invalid SingleModelEditStackElement");
      this._data instanceof $i && (this._data = this._data.serialize());
      const e = $i.deserialize(this._data);
      this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
    }
    redo() {
      if (Ee.isUri(this.model))
        throw new Error("Invalid SingleModelEditStackElement");
      this._data instanceof $i && (this._data = this._data.serialize());
      const e = $i.deserialize(this._data);
      this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
    }
    heapSize() {
      return this._data instanceof $i && (this._data = this._data.serialize()), this._data.byteLength + 168;
    }
  }
  class Iq {
    constructor(e, t) {
      this.type = 1, this.label = e, this._isOpen = !0, this._editStackElementsArr = t.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
      for (const i of this._editStackElementsArr) {
        const n = eu(i.resource);
        this._editStackElementsMap.set(n, i);
      }
      this._delegate = null;
    }
    get resources() {
      return this._editStackElementsArr.map((e) => e.resource);
    }
    prepareUndoRedo() {
      if (this._delegate)
        return this._delegate.prepareUndoRedo(this);
    }
    matchesResource(e) {
      const t = eu(e);
      return this._editStackElementsMap.has(t);
    }
    setModel(e) {
      const t = eu(Ee.isUri(e) ? e : e.uri);
      this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
    }
    canAppend(e) {
      if (!this._isOpen)
        return !1;
      const t = eu(e.uri);
      return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
    }
    append(e, t, i, n, o) {
      const r = eu(e.uri);
      this._editStackElementsMap.get(r).append(e, t, i, n, o);
    }
    close() {
      this._isOpen = !1;
    }
    open() {
    }
    undo() {
      this._isOpen = !1;
      for (const e of this._editStackElementsArr)
        e.undo();
    }
    redo() {
      for (const e of this._editStackElementsArr)
        e.redo();
    }
    heapSize(e) {
      const t = eu(e);
      return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
    }
    split() {
      return this._editStackElementsArr;
    }
    toString() {
      let e = [];
      for (const t of this._editStackElementsArr)
        e.push(`${ko(t.resource)}: ${t}`);
      return `{${e.join(", ")}}`;
    }
  }
  function AL(s) {
    return s.getEOL() === `
` ? 0 : 1;
  }
  function qa(s) {
    return s ? s instanceof vF || s instanceof Iq : !1;
  }
  class IE {
    constructor(e, t) {
      this._model = e, this._undoRedoService = t;
    }
    pushStackElement() {
      const e = this._undoRedoService.getLastElement(this._model.uri);
      qa(e) && e.close();
    }
    popStackElement() {
      const e = this._undoRedoService.getLastElement(this._model.uri);
      qa(e) && e.open();
    }
    clear() {
      this._undoRedoService.removeElements(this._model.uri);
    }
    _getOrCreateEditStackElement(e) {
      const t = this._undoRedoService.getLastElement(this._model.uri);
      if (qa(t) && t.canAppend(this._model))
        return t;
      const i = new vF(this._model, e);
      return this._undoRedoService.pushElement(i), i;
    }
    pushEOL(e) {
      const t = this._getOrCreateEditStackElement(null);
      this._model.setEOL(e), t.append(this._model, [], AL(this._model), this._model.getAlternativeVersionId(), null);
    }
    pushEditOperation(e, t, i) {
      const n = this._getOrCreateEditStackElement(e), o = this._model.applyEdits(t, !0), r = IE._computeCursorState(i, o), a = o.map((l, c) => ({ index: c, textChange: l.textChange }));
      return a.sort((l, c) => l.textChange.oldPosition === c.textChange.oldPosition ? l.index - c.index : l.textChange.oldPosition - c.textChange.oldPosition), n.append(this._model, a.map((l) => l.textChange), AL(this._model), this._model.getAlternativeVersionId(), r), r;
    }
    static _computeCursorState(e, t) {
      try {
        return e ? e(t) : null;
      } catch (i) {
        return We(i), null;
      }
    }
  }
  class Eq {
    constructor() {
      this.spacesDiff = 0, this.looksLikeAlignment = !1;
    }
  }
  function Nq(s, e, t, i, n) {
    n.spacesDiff = 0, n.looksLikeAlignment = !1;
    let o;
    for (o = 0; o < e && o < i; o++) {
      const u = s.charCodeAt(o), f = t.charCodeAt(o);
      if (u !== f)
        break;
    }
    let r = 0, a = 0;
    for (let u = o; u < e; u++)
      s.charCodeAt(u) === 32 ? r++ : a++;
    let l = 0, c = 0;
    for (let u = o; u < i; u++)
      t.charCodeAt(u) === 32 ? l++ : c++;
    if (r > 0 && a > 0 || l > 0 && c > 0)
      return;
    const d = Math.abs(a - c), h = Math.abs(r - l);
    if (d === 0) {
      n.spacesDiff = h, h > 0 && 0 <= l - 1 && l - 1 < s.length && l < t.length && t.charCodeAt(l) !== 32 && s.charCodeAt(l - 1) === 32 && s.charCodeAt(s.length - 1) === 44 && (n.looksLikeAlignment = !0);
      return;
    }
    if (h % d === 0) {
      n.spacesDiff = h / d;
      return;
    }
  }
  function GT(s, e, t) {
    const i = Math.min(s.getLineCount(), 1e4);
    let n = 0, o = 0, r = "", a = 0;
    const l = [2, 4, 6, 8, 3, 5, 7], c = 8, d = [0, 0, 0, 0, 0, 0, 0, 0, 0], h = new Eq();
    for (let g = 1; g <= i; g++) {
      const _ = s.getLineLength(g), b = s.getLineContent(g), C = _ <= 65536;
      let v = !1, w = 0, S = 0, L = 0;
      for (let y = 0, k = _; y < k; y++) {
        const I = C ? b.charCodeAt(y) : s.getLineCharCode(g, y);
        if (I === 9)
          L++;
        else if (I === 32)
          S++;
        else {
          v = !0, w = y;
          break;
        }
      }
      if (!v || (L > 0 ? n++ : S > 1 && o++, Nq(r, a, b, w, h), h.looksLikeAlignment && !(t && e === h.spacesDiff)))
        continue;
      const x = h.spacesDiff;
      x <= c && d[x]++, r = b, a = w;
    }
    let u = t;
    n !== o && (u = n < o);
    let f = e;
    if (u) {
      let g = u ? 0 : 0.1 * i;
      l.forEach((_) => {
        const b = d[_];
        b > g && (g = b, f = _);
      }), f === 4 && d[4] > 0 && d[2] > 0 && d[2] >= d[4] / 2 && (f = 2);
    }
    return {
      insertSpaces: u,
      tabSize: f
    };
  }
  function ts(s) {
    return (s.metadata & 1) >>> 0;
  }
  function Ot(s, e) {
    s.metadata = s.metadata & 254 | e << 0;
  }
  function _n(s) {
    return (s.metadata & 2) >>> 1 === 1;
  }
  function Rt(s, e) {
    s.metadata = s.metadata & 253 | (e ? 1 : 0) << 1;
  }
  function CF(s) {
    return (s.metadata & 4) >>> 2 === 1;
  }
  function ZT(s, e) {
    s.metadata = s.metadata & 251 | (e ? 1 : 0) << 2;
  }
  function Tq(s) {
    return (s.metadata & 24) >>> 3;
  }
  function YT(s, e) {
    s.metadata = s.metadata & 231 | e << 3;
  }
  function Mq(s) {
    return (s.metadata & 32) >>> 5 === 1;
  }
  function XT(s, e) {
    s.metadata = s.metadata & 223 | (e ? 1 : 0) << 5;
  }
  class wF {
    constructor(e, t, i) {
      this.metadata = 0, this.parent = this, this.left = this, this.right = this, Ot(this, 1), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, ZT(this, !1), YT(this, 1), XT(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, Rt(this, !1);
    }
    reset(e, t, i, n) {
      this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = n;
    }
    setOptions(e) {
      this.options = e;
      const t = this.options.className;
      ZT(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), YT(this, this.options.stickiness), XT(this, this.options.collapseOnReplaceEdit);
    }
    setCachedOffsets(e, t, i) {
      this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
    }
    detach() {
      this.parent = null, this.left = null, this.right = null;
    }
  }
  const Ue = new wF(null, 0, 0);
  Ue.parent = Ue;
  Ue.left = Ue;
  Ue.right = Ue;
  Ot(Ue, 0);
  class sS {
    constructor() {
      this.root = Ue, this.requestNormalizeDelta = !1;
    }
    intervalSearch(e, t, i, n, o) {
      return this.root === Ue ? [] : Vq(this, e, t, i, n, o);
    }
    search(e, t, i) {
      return this.root === Ue ? [] : Wq(this, e, t, i);
    }
    collectNodesFromOwner(e) {
      return Fq(this, e);
    }
    collectNodesPostOrder() {
      return Bq(this);
    }
    insert(e) {
      QT(this, e), this._normalizeDeltaIfNecessary();
    }
    delete(e) {
      JT(this, e), this._normalizeDeltaIfNecessary();
    }
    resolveNode(e, t) {
      const i = e;
      let n = 0;
      for (; e !== this.root; )
        e === e.parent.right && (n += e.parent.delta), e = e.parent;
      const o = i.start + n, r = i.end + n;
      i.setCachedOffsets(o, r, t);
    }
    acceptReplace(e, t, i, n) {
      const o = Oq(this, e, e + t);
      for (let r = 0, a = o.length; r < a; r++) {
        const l = o[r];
        JT(this, l);
      }
      this._normalizeDeltaIfNecessary(), Pq(this, e, e + t, i), this._normalizeDeltaIfNecessary();
      for (let r = 0, a = o.length; r < a; r++) {
        const l = o[r];
        l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, Rq(l, e, e + t, i, n), l.maxEnd = l.end, QT(this, l);
      }
      this._normalizeDeltaIfNecessary();
    }
    _normalizeDeltaIfNecessary() {
      !this.requestNormalizeDelta || (this.requestNormalizeDelta = !1, Aq(this));
    }
  }
  function Aq(s) {
    let e = s.root, t = 0;
    for (; e !== Ue; ) {
      if (e.left !== Ue && !_n(e.left)) {
        e = e.left;
        continue;
      }
      if (e.right !== Ue && !_n(e.right)) {
        t += e.delta, e = e.right;
        continue;
      }
      e.start = t + e.start, e.end = t + e.end, e.delta = 0, Lc(e), Rt(e, !0), Rt(e.left, !1), Rt(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
    }
    Rt(s.root, !1);
  }
  function tu(s, e, t, i) {
    return s < t ? !0 : s > t || i === 1 ? !1 : i === 2 ? !0 : e;
  }
  function Rq(s, e, t, i, n) {
    const o = Tq(s), r = o === 0 || o === 2, a = o === 1 || o === 2, l = t - e, c = i, d = Math.min(l, c), h = s.start;
    let u = !1;
    const f = s.end;
    let g = !1;
    e <= h && f <= t && Mq(s) && (s.start = e, u = !0, s.end = e, g = !0);
    {
      const b = n ? 1 : l > 0 ? 2 : 0;
      !u && tu(h, r, e, b) && (u = !0), !g && tu(f, a, e, b) && (g = !0);
    }
    if (d > 0 && !n) {
      const b = l > c ? 2 : 0;
      !u && tu(h, r, e + d, b) && (u = !0), !g && tu(f, a, e + d, b) && (g = !0);
    }
    {
      const b = n ? 1 : 0;
      !u && tu(h, r, t, b) && (s.start = e + c, u = !0), !g && tu(f, a, t, b) && (s.end = e + c, g = !0);
    }
    const _ = c - l;
    u || (s.start = Math.max(0, h + _)), g || (s.end = Math.max(0, f + _)), s.start > s.end && (s.end = s.start);
  }
  function Oq(s, e, t) {
    let i = s.root, n = 0, o = 0, r = 0, a = 0;
    const l = [];
    let c = 0;
    for (; i !== Ue; ) {
      if (_n(i)) {
        Rt(i.left, !1), Rt(i.right, !1), i === i.parent.right && (n -= i.parent.delta), i = i.parent;
        continue;
      }
      if (!_n(i.left)) {
        if (o = n + i.maxEnd, o < e) {
          Rt(i, !0);
          continue;
        }
        if (i.left !== Ue) {
          i = i.left;
          continue;
        }
      }
      if (r = n + i.start, r > t) {
        Rt(i, !0);
        continue;
      }
      if (a = n + i.end, a >= e && (i.setCachedOffsets(r, a, 0), l[c++] = i), Rt(i, !0), i.right !== Ue && !_n(i.right)) {
        n += i.delta, i = i.right;
        continue;
      }
    }
    return Rt(s.root, !1), l;
  }
  function Pq(s, e, t, i) {
    let n = s.root, o = 0, r = 0, a = 0;
    const l = i - (t - e);
    for (; n !== Ue; ) {
      if (_n(n)) {
        Rt(n.left, !1), Rt(n.right, !1), n === n.parent.right && (o -= n.parent.delta), Lc(n), n = n.parent;
        continue;
      }
      if (!_n(n.left)) {
        if (r = o + n.maxEnd, r < e) {
          Rt(n, !0);
          continue;
        }
        if (n.left !== Ue) {
          n = n.left;
          continue;
        }
      }
      if (a = o + n.start, a > t) {
        n.start += l, n.end += l, n.delta += l, (n.delta < -1073741824 || n.delta > 1073741824) && (s.requestNormalizeDelta = !0), Rt(n, !0);
        continue;
      }
      if (Rt(n, !0), n.right !== Ue && !_n(n.right)) {
        o += n.delta, n = n.right;
        continue;
      }
    }
    Rt(s.root, !1);
  }
  function Fq(s, e) {
    let t = s.root;
    const i = [];
    let n = 0;
    for (; t !== Ue; ) {
      if (_n(t)) {
        Rt(t.left, !1), Rt(t.right, !1), t = t.parent;
        continue;
      }
      if (t.left !== Ue && !_n(t.left)) {
        t = t.left;
        continue;
      }
      if (t.ownerId === e && (i[n++] = t), Rt(t, !0), t.right !== Ue && !_n(t.right)) {
        t = t.right;
        continue;
      }
    }
    return Rt(s.root, !1), i;
  }
  function Bq(s) {
    let e = s.root;
    const t = [];
    let i = 0;
    for (; e !== Ue; ) {
      if (_n(e)) {
        Rt(e.left, !1), Rt(e.right, !1), e = e.parent;
        continue;
      }
      if (e.left !== Ue && !_n(e.left)) {
        e = e.left;
        continue;
      }
      if (e.right !== Ue && !_n(e.right)) {
        e = e.right;
        continue;
      }
      t[i++] = e, Rt(e, !0);
    }
    return Rt(s.root, !1), t;
  }
  function Wq(s, e, t, i) {
    let n = s.root, o = 0, r = 0, a = 0;
    const l = [];
    let c = 0;
    for (; n !== Ue; ) {
      if (_n(n)) {
        Rt(n.left, !1), Rt(n.right, !1), n === n.parent.right && (o -= n.parent.delta), n = n.parent;
        continue;
      }
      if (n.left !== Ue && !_n(n.left)) {
        n = n.left;
        continue;
      }
      r = o + n.start, a = o + n.end, n.setCachedOffsets(r, a, i);
      let d = !0;
      if (e && n.ownerId && n.ownerId !== e && (d = !1), t && CF(n) && (d = !1), d && (l[c++] = n), Rt(n, !0), n.right !== Ue && !_n(n.right)) {
        o += n.delta, n = n.right;
        continue;
      }
    }
    return Rt(s.root, !1), l;
  }
  function Vq(s, e, t, i, n, o) {
    let r = s.root, a = 0, l = 0, c = 0, d = 0;
    const h = [];
    let u = 0;
    for (; r !== Ue; ) {
      if (_n(r)) {
        Rt(r.left, !1), Rt(r.right, !1), r === r.parent.right && (a -= r.parent.delta), r = r.parent;
        continue;
      }
      if (!_n(r.left)) {
        if (l = a + r.maxEnd, l < e) {
          Rt(r, !0);
          continue;
        }
        if (r.left !== Ue) {
          r = r.left;
          continue;
        }
      }
      if (c = a + r.start, c > t) {
        Rt(r, !0);
        continue;
      }
      if (d = a + r.end, d >= e) {
        r.setCachedOffsets(c, d, o);
        let f = !0;
        i && r.ownerId && r.ownerId !== i && (f = !1), n && CF(r) && (f = !1), f && (h[u++] = r);
      }
      if (Rt(r, !0), r.right !== Ue && !_n(r.right)) {
        a += r.delta, r = r.right;
        continue;
      }
    }
    return Rt(s.root, !1), h;
  }
  function QT(s, e) {
    if (s.root === Ue)
      return e.parent = Ue, e.left = Ue, e.right = Ue, Ot(e, 0), s.root = e, s.root;
    Hq(s, e), Pl(e.parent);
    let t = e;
    for (; t !== s.root && ts(t.parent) === 1; )
      if (t.parent === t.parent.parent.left) {
        const i = t.parent.parent.right;
        ts(i) === 1 ? (Ot(t.parent, 0), Ot(i, 0), Ot(t.parent.parent, 1), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, pm(s, t)), Ot(t.parent, 0), Ot(t.parent.parent, 1), _m(s, t.parent.parent));
      } else {
        const i = t.parent.parent.left;
        ts(i) === 1 ? (Ot(t.parent, 0), Ot(i, 0), Ot(t.parent.parent, 1), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, _m(s, t)), Ot(t.parent, 0), Ot(t.parent.parent, 1), pm(s, t.parent.parent));
      }
    return Ot(s.root, 0), e;
  }
  function Hq(s, e) {
    let t = 0, i = s.root;
    const n = e.start, o = e.end;
    for (; ; )
      if (Uq(n, o, i.start + t, i.end + t) < 0)
        if (i.left === Ue) {
          e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
          break;
        } else
          i = i.left;
      else if (i.right === Ue) {
        e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
        break;
      } else
        t += i.delta, i = i.right;
    e.parent = i, e.left = Ue, e.right = Ue, Ot(e, 1);
  }
  function JT(s, e) {
    let t, i;
    if (e.left === Ue ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === Ue ? (t = e.left, i = e) : (i = zq(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (s.requestNormalizeDelta = !0)), i === s.root) {
      s.root = t, Ot(t, 0), e.detach(), oS(), Lc(t), s.root.parent = Ue;
      return;
    }
    const n = ts(i) === 1;
    if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, Ot(i, ts(e)), e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Ue && (i.left.parent = i), i.right !== Ue && (i.right.parent = i)), e.detach(), n) {
      Pl(t.parent), i !== e && (Pl(i), Pl(i.parent)), oS();
      return;
    }
    Pl(t), Pl(t.parent), i !== e && (Pl(i), Pl(i.parent));
    let o;
    for (; t !== s.root && ts(t) === 0; )
      t === t.parent.left ? (o = t.parent.right, ts(o) === 1 && (Ot(o, 0), Ot(t.parent, 1), pm(s, t.parent), o = t.parent.right), ts(o.left) === 0 && ts(o.right) === 0 ? (Ot(o, 1), t = t.parent) : (ts(o.right) === 0 && (Ot(o.left, 0), Ot(o, 1), _m(s, o), o = t.parent.right), Ot(o, ts(t.parent)), Ot(t.parent, 0), Ot(o.right, 0), pm(s, t.parent), t = s.root)) : (o = t.parent.left, ts(o) === 1 && (Ot(o, 0), Ot(t.parent, 1), _m(s, t.parent), o = t.parent.left), ts(o.left) === 0 && ts(o.right) === 0 ? (Ot(o, 1), t = t.parent) : (ts(o.left) === 0 && (Ot(o.right, 0), Ot(o, 1), pm(s, o), o = t.parent.left), Ot(o, ts(t.parent)), Ot(t.parent, 0), Ot(o.left, 0), _m(s, t.parent), t = s.root));
    Ot(t, 0), oS();
  }
  function zq(s) {
    for (; s.left !== Ue; )
      s = s.left;
    return s;
  }
  function oS() {
    Ue.parent = Ue, Ue.delta = 0, Ue.start = 0, Ue.end = 0;
  }
  function pm(s, e) {
    const t = e.right;
    t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== Ue && (t.left.parent = e), t.parent = e.parent, e.parent === Ue ? s.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, Lc(e), Lc(t);
  }
  function _m(s, e) {
    const t = e.left;
    e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (s.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== Ue && (t.right.parent = e), t.parent = e.parent, e.parent === Ue ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, Lc(e), Lc(t);
  }
  function SF(s) {
    let e = s.end;
    if (s.left !== Ue) {
      const t = s.left.maxEnd;
      t > e && (e = t);
    }
    if (s.right !== Ue) {
      const t = s.right.maxEnd + s.delta;
      t > e && (e = t);
    }
    return e;
  }
  function Lc(s) {
    s.maxEnd = SF(s);
  }
  function Pl(s) {
    for (; s !== Ue; ) {
      const e = SF(s);
      if (s.maxEnd === e)
        return;
      s.maxEnd = e, s = s.parent;
    }
  }
  function Uq(s, e, t, i) {
    return s === t ? e - i : s - t;
  }
  class RL {
    constructor(e, t) {
      this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
    }
    next() {
      if (this.right !== Pe)
        return EE(this.right);
      let e = this;
      for (; e.parent !== Pe && e.parent.left !== e; )
        e = e.parent;
      return e.parent === Pe ? Pe : e.parent;
    }
    prev() {
      if (this.left !== Pe)
        return yF(this.left);
      let e = this;
      for (; e.parent !== Pe && e.parent.right !== e; )
        e = e.parent;
      return e.parent === Pe ? Pe : e.parent;
    }
    detach() {
      this.parent = null, this.left = null, this.right = null;
    }
  }
  const Pe = new RL(null, 0);
  Pe.parent = Pe;
  Pe.left = Pe;
  Pe.right = Pe;
  Pe.color = 0;
  function EE(s) {
    for (; s.left !== Pe; )
      s = s.left;
    return s;
  }
  function yF(s) {
    for (; s.right !== Pe; )
      s = s.right;
    return s;
  }
  function NE(s) {
    return s === Pe ? 0 : s.size_left + s.piece.length + NE(s.right);
  }
  function TE(s) {
    return s === Pe ? 0 : s.lf_left + s.piece.lineFeedCnt + TE(s.right);
  }
  function rS() {
    Pe.parent = Pe;
  }
  function bm(s, e) {
    const t = e.right;
    t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== Pe && (t.left.parent = e), t.parent = e.parent, e.parent === Pe ? s.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
  }
  function vm(s, e) {
    const t = e.left;
    e.left = t.right, t.right !== Pe && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === Pe ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
  }
  function sb(s, e) {
    let t, i;
    if (e.left === Pe ? (i = e, t = i.right) : e.right === Pe ? (i = e, t = i.left) : (i = EE(e.right), t = i.right), i === s.root) {
      s.root = t, t.color = 0, e.detach(), rS(), s.root.parent = Pe;
      return;
    }
    const n = i.color === 1;
    if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, Gg(s, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, Gg(s, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Pe && (i.left.parent = i), i.right !== Pe && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, Gg(s, i)), e.detach(), t.parent.left === t) {
      const r = NE(t), a = TE(t);
      if (r !== t.parent.size_left || a !== t.parent.lf_left) {
        const l = r - t.parent.size_left, c = a - t.parent.lf_left;
        t.parent.size_left = r, t.parent.lf_left = a, Ba(s, t.parent, l, c);
      }
    }
    if (Gg(s, t.parent), n) {
      rS();
      return;
    }
    let o;
    for (; t !== s.root && t.color === 0; )
      t === t.parent.left ? (o = t.parent.right, o.color === 1 && (o.color = 0, t.parent.color = 1, bm(s, t.parent), o = t.parent.right), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.right.color === 0 && (o.left.color = 0, o.color = 1, vm(s, o), o = t.parent.right), o.color = t.parent.color, t.parent.color = 0, o.right.color = 0, bm(s, t.parent), t = s.root)) : (o = t.parent.left, o.color === 1 && (o.color = 0, t.parent.color = 1, vm(s, t.parent), o = t.parent.left), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.left.color === 0 && (o.right.color = 0, o.color = 1, bm(s, o), o = t.parent.left), o.color = t.parent.color, t.parent.color = 0, o.left.color = 0, vm(s, t.parent), t = s.root));
    t.color = 0, rS();
  }
  function eM(s, e) {
    for (Gg(s, e); e !== s.root && e.parent.color === 1; )
      if (e.parent === e.parent.parent.left) {
        const t = e.parent.parent.right;
        t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, bm(s, e)), e.parent.color = 0, e.parent.parent.color = 1, vm(s, e.parent.parent));
      } else {
        const t = e.parent.parent.left;
        t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, vm(s, e)), e.parent.color = 0, e.parent.parent.color = 1, bm(s, e.parent.parent));
      }
    s.root.color = 0;
  }
  function Ba(s, e, t, i) {
    for (; e !== s.root && e !== Pe; )
      e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
  function Gg(s, e) {
    let t = 0, i = 0;
    if (e !== s.root) {
      for (; e !== s.root && e === e.parent.right; )
        e = e.parent;
      if (e !== s.root)
        for (e = e.parent, t = NE(e.left) - e.size_left, i = TE(e.left) - e.lf_left, e.size_left += t, e.lf_left += i; e !== s.root && (t !== 0 || i !== 0); )
          e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
    }
  }
  const $q = 999;
  class td {
    constructor(e, t, i, n) {
      this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = n;
    }
    parseSearchRequest() {
      if (this.searchString === "")
        return null;
      let e;
      this.isRegex ? e = jq(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
      let t = null;
      try {
        t = kP(this.searchString, this.isRegex, {
          matchCase: this.matchCase,
          wholeWord: !1,
          multiline: e,
          global: !0,
          unicode: !0
        });
      } catch {
        return null;
      }
      if (!t)
        return null;
      let i = !this.isRegex && !e;
      return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new jj(t, this.wordSeparators ? yo(this.wordSeparators) : null, i ? this.searchString : null);
    }
  }
  function jq(s) {
    if (!s || s.length === 0)
      return !1;
    for (let e = 0, t = s.length; e < t; e++)
      if (s.charCodeAt(e) === 92) {
        if (e++, e >= t)
          break;
        const n = s.charCodeAt(e);
        if (n === 110 || n === 114 || n === 87)
          return !0;
      }
    return !1;
  }
  function cd(s, e, t) {
    if (!t)
      return new tp(s, null);
    const i = [];
    for (let n = 0, o = e.length; n < o; n++)
      i[n] = e[n];
    return new tp(s, i);
  }
  class tM {
    constructor(e) {
      const t = [];
      let i = 0;
      for (let n = 0, o = e.length; n < o; n++)
        e.charCodeAt(n) === 10 && (t[i++] = n);
      this._lineFeedsOffsets = t;
    }
    findLineFeedCountBeforeOffset(e) {
      const t = this._lineFeedsOffsets;
      let i = 0, n = t.length - 1;
      if (n === -1 || e <= t[0])
        return 0;
      for (; i < n; ) {
        const o = i + ((n - i) / 2 >> 0);
        t[o] >= e ? n = o - 1 : t[o + 1] >= e ? (i = o, n = o) : i = o + 1;
      }
      return i + 1;
    }
  }
  class ob {
    static findMatches(e, t, i, n, o) {
      const r = t.parseSearchRequest();
      return r ? r.regex.multiline ? this._doFindMatchesMultiline(e, i, new Nu(r.wordSeparators, r.regex), n, o) : this._doFindMatchesLineByLine(e, i, r, n, o) : [];
    }
    static _getMultilineMatchRange(e, t, i, n, o, r) {
      let a, l = 0;
      n ? (l = n.findLineFeedCountBeforeOffset(o), a = t + o + l) : a = t + o;
      let c;
      if (n) {
        const f = n.findLineFeedCountBeforeOffset(o + r.length) - l;
        c = a + r.length + f;
      } else
        c = a + r.length;
      const d = e.getPositionAt(a), h = e.getPositionAt(c);
      return new D(d.lineNumber, d.column, h.lineNumber, h.column);
    }
    static _doFindMatchesMultiline(e, t, i, n, o) {
      const r = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(t, 1), l = e.getEOL() === `\r
` ? new tM(a) : null, c = [];
      let d = 0, h;
      for (i.reset(0); h = i.next(a); )
        if (c[d++] = cd(this._getMultilineMatchRange(e, r, a, l, h.index, h[0]), h, n), d >= o)
          return c;
      return c;
    }
    static _doFindMatchesLineByLine(e, t, i, n, o) {
      const r = [];
      let a = 0;
      if (t.startLineNumber === t.endLineNumber) {
        const c = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
        return a = this._findMatchesInLine(i, c, t.startLineNumber, t.startColumn - 1, a, r, n, o), r;
      }
      const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
      a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, r, n, o);
      for (let c = t.startLineNumber + 1; c < t.endLineNumber && a < o; c++)
        a = this._findMatchesInLine(i, e.getLineContent(c), c, 0, a, r, n, o);
      if (a < o) {
        const c = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
        a = this._findMatchesInLine(i, c, t.endLineNumber, 0, a, r, n, o);
      }
      return r;
    }
    static _findMatchesInLine(e, t, i, n, o, r, a, l) {
      const c = e.wordSeparators;
      if (!a && e.simpleSearch) {
        const u = e.simpleSearch, f = u.length, g = t.length;
        let _ = -f;
        for (; (_ = t.indexOf(u, _ + f)) !== -1; )
          if ((!c || ME(c, t, g, _, f)) && (r[o++] = new tp(new D(i, _ + 1 + n, i, _ + 1 + f + n), null), o >= l))
            return o;
        return o;
      }
      const d = new Nu(e.wordSeparators, e.regex);
      let h;
      d.reset(0);
      do
        if (h = d.next(t), h && (r[o++] = cd(new D(i, h.index + 1 + n, i, h.index + 1 + h[0].length + n), h, a), o >= l))
          return o;
      while (h);
      return o;
    }
    static findNextMatch(e, t, i, n) {
      const o = t.parseSearchRequest();
      if (!o)
        return null;
      const r = new Nu(o.wordSeparators, o.regex);
      return o.regex.multiline ? this._doFindNextMatchMultiline(e, i, r, n) : this._doFindNextMatchLineByLine(e, i, r, n);
    }
    static _doFindNextMatchMultiline(e, t, i, n) {
      const o = new V(t.lineNumber, 1), r = e.getOffsetAt(o), a = e.getLineCount(), l = e.getValueInRange(new D(o.lineNumber, o.column, a, e.getLineMaxColumn(a)), 1), c = e.getEOL() === `\r
` ? new tM(l) : null;
      i.reset(t.column - 1);
      let d = i.next(l);
      return d ? cd(this._getMultilineMatchRange(e, r, l, c, d.index, d[0]), d, n) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new V(1, 1), i, n) : null;
    }
    static _doFindNextMatchLineByLine(e, t, i, n) {
      const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r), l = this._findFirstMatchInLine(i, a, r, t.column, n);
      if (l)
        return l;
      for (let c = 1; c <= o; c++) {
        const d = (r + c - 1) % o, h = e.getLineContent(d + 1), u = this._findFirstMatchInLine(i, h, d + 1, 1, n);
        if (u)
          return u;
      }
      return null;
    }
    static _findFirstMatchInLine(e, t, i, n, o) {
      e.reset(n - 1);
      const r = e.next(t);
      return r ? cd(new D(i, r.index + 1, i, r.index + 1 + r[0].length), r, o) : null;
    }
    static findPreviousMatch(e, t, i, n) {
      const o = t.parseSearchRequest();
      if (!o)
        return null;
      const r = new Nu(o.wordSeparators, o.regex);
      return o.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, r, n) : this._doFindPreviousMatchLineByLine(e, i, r, n);
    }
    static _doFindPreviousMatchMultiline(e, t, i, n) {
      const o = this._doFindMatchesMultiline(e, new D(1, 1, t.lineNumber, t.column), i, n, 10 * $q);
      if (o.length > 0)
        return o[o.length - 1];
      const r = e.getLineCount();
      return t.lineNumber !== r || t.column !== e.getLineMaxColumn(r) ? this._doFindPreviousMatchMultiline(e, new V(r, e.getLineMaxColumn(r)), i, n) : null;
    }
    static _doFindPreviousMatchLineByLine(e, t, i, n) {
      const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, r, n);
      if (l)
        return l;
      for (let c = 1; c <= o; c++) {
        const d = (o + r - c - 1) % o, h = e.getLineContent(d + 1), u = this._findLastMatchInLine(i, h, d + 1, n);
        if (u)
          return u;
      }
      return null;
    }
    static _findLastMatchInLine(e, t, i, n) {
      let o = null, r;
      for (e.reset(0); r = e.next(t); )
        o = cd(new D(i, r.index + 1, i, r.index + 1 + r[0].length), r, n);
      return o;
    }
  }
  function Kq(s, e, t, i, n) {
    if (i === 0)
      return !0;
    const o = e.charCodeAt(i - 1);
    if (s.get(o) !== 0 || o === 13 || o === 10)
      return !0;
    if (n > 0) {
      const r = e.charCodeAt(i);
      if (s.get(r) !== 0)
        return !0;
    }
    return !1;
  }
  function qq(s, e, t, i, n) {
    if (i + n === t)
      return !0;
    const o = e.charCodeAt(i + n);
    if (s.get(o) !== 0 || o === 13 || o === 10)
      return !0;
    if (n > 0) {
      const r = e.charCodeAt(i + n - 1);
      if (s.get(r) !== 0)
        return !0;
    }
    return !1;
  }
  function ME(s, e, t, i, n) {
    return Kq(s, e, t, i, n) && qq(s, e, t, i, n);
  }
  class Nu {
    constructor(e, t) {
      this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
    }
    reset(e) {
      this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
    }
    next(e) {
      const t = e.length;
      let i;
      do {
        if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i))
          return null;
        const n = i.index, o = i[0].length;
        if (n === this._prevMatchStartIndex && o === this._prevMatchLength) {
          if (o === 0) {
            q0(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
            continue;
          }
          return null;
        }
        if (this._prevMatchStartIndex = n, this._prevMatchLength = o, !this._wordSeparators || ME(this._wordSeparators, e, t, n, o))
          return i;
      } while (i);
      return null;
    }
  }
  const Ta = 65535;
  function LF(s) {
    let e;
    return s[s.length - 1] < 65536 ? e = new Uint16Array(s.length) : e = new Uint32Array(s.length), e.set(s, 0), e;
  }
  class Gq {
    constructor(e, t, i, n, o) {
      this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = n, this.isBasicASCII = o;
    }
  }
  function Va(s, e = !0) {
    const t = [0];
    let i = 1;
    for (let n = 0, o = s.length; n < o; n++) {
      const r = s.charCodeAt(n);
      r === 13 ? n + 1 < o && s.charCodeAt(n + 1) === 10 ? (t[i++] = n + 2, n++) : t[i++] = n + 1 : r === 10 && (t[i++] = n + 1);
    }
    return e ? LF(t) : t;
  }
  function Zq(s, e) {
    s.length = 0, s[0] = 0;
    let t = 1, i = 0, n = 0, o = 0, r = !0;
    for (let l = 0, c = e.length; l < c; l++) {
      const d = e.charCodeAt(l);
      d === 13 ? l + 1 < c && e.charCodeAt(l + 1) === 10 ? (o++, s[t++] = l + 2, l++) : (i++, s[t++] = l + 1) : d === 10 ? (n++, s[t++] = l + 1) : r && d !== 9 && (d < 32 || d > 126) && (r = !1);
    }
    const a = new Gq(LF(s), i, n, o, r);
    return s.length = 0, a;
  }
  class ps {
    constructor(e, t, i, n, o) {
      this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = n, this.length = o;
    }
  }
  class dd {
    constructor(e, t) {
      this.buffer = e, this.lineStarts = t;
    }
  }
  class Yq {
    constructor(e, t) {
      this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== Pe && e.iterate(e.root, (i) => (i !== Pe && this._pieces.push(i.piece), !0));
    }
    read() {
      return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
    }
  }
  class Xq {
    constructor(e) {
      this._limit = e, this._cache = [];
    }
    get(e) {
      for (let t = this._cache.length - 1; t >= 0; t--) {
        const i = this._cache[t];
        if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
          return i;
      }
      return null;
    }
    get2(e) {
      for (let t = this._cache.length - 1; t >= 0; t--) {
        const i = this._cache[t];
        if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
          return i;
      }
      return null;
    }
    set(e) {
      this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
    }
    validate(e) {
      let t = !1;
      const i = this._cache;
      for (let n = 0; n < i.length; n++) {
        const o = i[n];
        if (o.node.parent === null || o.nodeStartOffset >= e) {
          i[n] = null, t = !0;
          continue;
        }
      }
      if (t) {
        const n = [];
        for (const o of i)
          o !== null && n.push(o);
        this._cache = n;
      }
    }
  }
  class Qq {
    constructor(e, t, i) {
      this.create(e, t, i);
    }
    create(e, t, i) {
      this._buffers = [
        new dd("", [0])
      ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = Pe, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
      let n = null;
      for (let o = 0, r = e.length; o < r; o++)
        if (e[o].buffer.length > 0) {
          e[o].lineStarts || (e[o].lineStarts = Va(e[o].buffer));
          const a = new ps(o + 1, { line: 0, column: 0 }, { line: e[o].lineStarts.length - 1, column: e[o].buffer.length - e[o].lineStarts[e[o].lineStarts.length - 1] }, e[o].lineStarts.length - 1, e[o].buffer.length);
          this._buffers.push(e[o]), n = this.rbInsertRight(n, a);
        }
      this._searchCache = new Xq(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
    }
    normalizeEOL(e) {
      const t = Ta, i = t - Math.floor(t / 3), n = i * 2;
      let o = "", r = 0;
      const a = [];
      if (this.iterate(this.root, (l) => {
        const c = this.getNodeContent(l), d = c.length;
        if (r <= i || r + d < n)
          return o += c, r += d, !0;
        const h = o.replace(/\r\n|\r|\n/g, e);
        return a.push(new dd(h, Va(h))), o = c, r = d, !0;
      }), r > 0) {
        const l = o.replace(/\r\n|\r|\n/g, e);
        a.push(new dd(l, Va(l)));
      }
      this.create(a, e, !0);
    }
    getEOL() {
      return this._EOL;
    }
    setEOL(e) {
      this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
    }
    createSnapshot(e) {
      return new Yq(this, e);
    }
    getOffsetAt(e, t) {
      let i = 0, n = this.root;
      for (; n !== Pe; )
        if (n.left !== Pe && n.lf_left + 1 >= e)
          n = n.left;
        else {
          if (n.lf_left + n.piece.lineFeedCnt + 1 >= e)
            return i += n.size_left, i += this.getAccumulatedValue(n, e - n.lf_left - 2) + t - 1;
          e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right;
        }
      return i;
    }
    getPositionAt(e) {
      e = Math.floor(e), e = Math.max(0, e);
      let t = this.root, i = 0;
      const n = e;
      for (; t !== Pe; )
        if (t.size_left !== 0 && t.size_left >= e)
          t = t.left;
        else if (t.size_left + t.piece.length >= e) {
          const o = this.getIndexOf(t, e - t.size_left);
          if (i += t.lf_left + o.index, o.index === 0) {
            const r = this.getOffsetAt(i + 1, 1), a = n - r;
            return new V(i + 1, a + 1);
          }
          return new V(i + 1, o.remainder + 1);
        } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === Pe) {
          const o = this.getOffsetAt(i + 1, 1), r = n - e - o;
          return new V(i + 1, r + 1);
        } else
          t = t.right;
      return new V(1, 1);
    }
    getValueInRange(e, t) {
      if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
        return "";
      const i = this.nodeAt2(e.startLineNumber, e.startColumn), n = this.nodeAt2(e.endLineNumber, e.endColumn), o = this.getValueInRange2(i, n);
      return t ? t !== this._EOL || !this._EOLNormalized ? o.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? o : o.replace(/\r\n|\r|\n/g, t) : o;
    }
    getValueInRange2(e, t) {
      if (e.node === t.node) {
        const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, c = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
        return l.substring(c + e.remainder, c + t.remainder);
      }
      let i = e.node;
      const n = this._buffers[i.piece.bufferIndex].buffer, o = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      let r = n.substring(o + e.remainder, o + i.piece.length);
      for (i = i.next(); i !== Pe; ) {
        const a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        if (i === t.node) {
          r += a.substring(l, l + t.remainder);
          break;
        } else
          r += a.substr(l, i.piece.length);
        i = i.next();
      }
      return r;
    }
    getLinesContent() {
      const e = [];
      let t = 0, i = "", n = !1;
      return this.iterate(this.root, (o) => {
        if (o === Pe)
          return !0;
        const r = o.piece;
        let a = r.length;
        if (a === 0)
          return !0;
        const l = this._buffers[r.bufferIndex].buffer, c = this._buffers[r.bufferIndex].lineStarts, d = r.start.line, h = r.end.line;
        let u = c[d] + r.start.column;
        if (n && (l.charCodeAt(u) === 10 && (u++, a--), e[t++] = i, i = "", n = !1, a === 0))
          return !0;
        if (d === h)
          return !this._EOLNormalized && l.charCodeAt(u + a - 1) === 13 ? (n = !0, i += l.substr(u, a - 1)) : i += l.substr(u, a), !0;
        i += this._EOLNormalized ? l.substring(u, Math.max(u, c[d + 1] - this._EOLLength)) : l.substring(u, c[d + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
        for (let f = d + 1; f < h; f++)
          i = this._EOLNormalized ? l.substring(c[f], c[f + 1] - this._EOLLength) : l.substring(c[f], c[f + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
        return !this._EOLNormalized && l.charCodeAt(c[h] + r.end.column - 1) === 13 ? (n = !0, r.end.column === 0 ? t-- : i = l.substr(c[h], r.end.column - 1)) : i = l.substr(c[h], r.end.column), !0;
      }), n && (e[t++] = i, i = ""), e[t++] = i, e;
    }
    getLength() {
      return this._length;
    }
    getLineCount() {
      return this._lineCnt;
    }
    getLineContent(e) {
      return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
    }
    _getCharCode(e) {
      if (e.remainder === e.node.piece.length) {
        const t = e.node.next();
        if (!t)
          return 0;
        const i = this._buffers[t.piece.bufferIndex], n = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
        return i.buffer.charCodeAt(n);
      } else {
        const t = this._buffers[e.node.piece.bufferIndex], n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
        return t.buffer.charCodeAt(n);
      }
    }
    getLineCharCode(e, t) {
      const i = this.nodeAt2(e, t + 1);
      return this._getCharCode(i);
    }
    getLineLength(e) {
      if (e === this.getLineCount()) {
        const t = this.getOffsetAt(e, 1);
        return this.getLength() - t;
      }
      return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
    }
    findMatchesInNode(e, t, i, n, o, r, a, l, c, d, h) {
      const u = this._buffers[e.piece.bufferIndex], f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), g = this.offsetInBuffer(e.piece.bufferIndex, o), _ = this.offsetInBuffer(e.piece.bufferIndex, r);
      let b;
      const C = { line: 0, column: 0 };
      let v, w;
      t._wordSeparators ? (v = u.buffer.substring(g, _), w = (S) => S + g, t.reset(0)) : (v = u.buffer, w = (S) => S, t.reset(g));
      do
        if (b = t.next(v), b) {
          if (w(b.index) >= _)
            return d;
          this.positionInBuffer(e, w(b.index) - f, C);
          const S = this.getLineFeedCnt(e.piece.bufferIndex, o, C), L = C.line === o.line ? C.column - o.column + n : C.column + 1, x = L + b[0].length;
          if (h[d++] = cd(new D(i + S, L, i + S, x), b, l), w(b.index) + b[0].length >= _ || d >= c)
            return d;
        }
      while (b);
      return d;
    }
    findMatchesLineByLine(e, t, i, n) {
      const o = [];
      let r = 0;
      const a = new Nu(t.wordSeparators, t.regex);
      let l = this.nodeAt2(e.startLineNumber, e.startColumn);
      if (l === null)
        return [];
      const c = this.nodeAt2(e.endLineNumber, e.endColumn);
      if (c === null)
        return [];
      let d = this.positionInBuffer(l.node, l.remainder);
      const h = this.positionInBuffer(c.node, c.remainder);
      if (l.node === c.node)
        return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, d, h, t, i, n, r, o), o;
      let u = e.startLineNumber, f = l.node;
      for (; f !== c.node; ) {
        const _ = this.getLineFeedCnt(f.piece.bufferIndex, d, f.piece.end);
        if (_ >= 1) {
          const C = this._buffers[f.piece.bufferIndex].lineStarts, v = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start), w = C[d.line + _], S = u === e.startLineNumber ? e.startColumn : 1;
          if (r = this.findMatchesInNode(f, a, u, S, d, this.positionInBuffer(f, w - v), t, i, n, r, o), r >= n)
            return o;
          u += _;
        }
        const b = u === e.startLineNumber ? e.startColumn - 1 : 0;
        if (u === e.endLineNumber) {
          const C = this.getLineContent(u).substring(b, e.endColumn - 1);
          return r = this._findMatchesInLine(t, a, C, e.endLineNumber, b, r, o, i, n), o;
        }
        if (r = this._findMatchesInLine(t, a, this.getLineContent(u).substr(b), u, b, r, o, i, n), r >= n)
          return o;
        u++, l = this.nodeAt2(u, 1), f = l.node, d = this.positionInBuffer(l.node, l.remainder);
      }
      if (u === e.endLineNumber) {
        const _ = u === e.startLineNumber ? e.startColumn - 1 : 0, b = this.getLineContent(u).substring(_, e.endColumn - 1);
        return r = this._findMatchesInLine(t, a, b, e.endLineNumber, _, r, o, i, n), o;
      }
      const g = u === e.startLineNumber ? e.startColumn : 1;
      return r = this.findMatchesInNode(c.node, a, u, g, d, h, t, i, n, r, o), o;
    }
    _findMatchesInLine(e, t, i, n, o, r, a, l, c) {
      const d = e.wordSeparators;
      if (!l && e.simpleSearch) {
        const u = e.simpleSearch, f = u.length, g = i.length;
        let _ = -f;
        for (; (_ = i.indexOf(u, _ + f)) !== -1; )
          if ((!d || ME(d, i, g, _, f)) && (a[r++] = new tp(new D(n, _ + 1 + o, n, _ + 1 + f + o), null), r >= c))
            return r;
        return r;
      }
      let h;
      t.reset(0);
      do
        if (h = t.next(i), h && (a[r++] = cd(new D(n, h.index + 1 + o, n, h.index + 1 + h[0].length + o), h, l), r >= c))
          return r;
      while (h);
      return r;
    }
    insert(e, t, i = !1) {
      if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== Pe) {
        const { node: n, remainder: o, nodeStartOffset: r } = this.nodeAt(e), a = n.piece, l = a.bufferIndex, c = this.positionInBuffer(n, o);
        if (n.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && r + a.length === e && t.length < Ta) {
          this.appendToNode(n, t), this.computeBufferMetadata();
          return;
        }
        if (r === e)
          this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
        else if (r + n.piece.length > e) {
          const d = [];
          let h = new ps(a.bufferIndex, c, a.end, this.getLineFeedCnt(a.bufferIndex, c, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, c));
          if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(n, o) === 10) {
            const _ = { line: h.start.line + 1, column: 0 };
            h = new ps(h.bufferIndex, _, h.end, this.getLineFeedCnt(h.bufferIndex, _, h.end), h.length - 1), t += `
`;
          }
          if (this.shouldCheckCRLF() && this.startWithLF(t))
            if (this.nodeCharCodeAt(n, o - 1) === 13) {
              const _ = this.positionInBuffer(n, o - 1);
              this.deleteNodeTail(n, _), t = "\r" + t, n.piece.length === 0 && d.push(n);
            } else
              this.deleteNodeTail(n, c);
          else
            this.deleteNodeTail(n, c);
          const u = this.createNewPieces(t);
          h.length > 0 && this.rbInsertRight(n, h);
          let f = n;
          for (let g = 0; g < u.length; g++)
            f = this.rbInsertRight(f, u[g]);
          this.deleteNodes(d);
        } else
          this.insertContentToNodeRight(t, n);
      } else {
        const n = this.createNewPieces(t);
        let o = this.rbInsertLeft(null, n[0]);
        for (let r = 1; r < n.length; r++)
          o = this.rbInsertRight(o, n[r]);
      }
      this.computeBufferMetadata();
    }
    delete(e, t) {
      if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === Pe)
        return;
      const i = this.nodeAt(e), n = this.nodeAt(e + t), o = i.node, r = n.node;
      if (o === r) {
        const u = this.positionInBuffer(o, i.remainder), f = this.positionInBuffer(o, n.remainder);
        if (i.nodeStartOffset === e) {
          if (t === o.piece.length) {
            const g = o.next();
            sb(this, o), this.validateCRLFWithPrevNode(g), this.computeBufferMetadata();
            return;
          }
          this.deleteNodeHead(o, f), this._searchCache.validate(e), this.validateCRLFWithPrevNode(o), this.computeBufferMetadata();
          return;
        }
        if (i.nodeStartOffset + o.piece.length === e + t) {
          this.deleteNodeTail(o, u), this.validateCRLFWithNextNode(o), this.computeBufferMetadata();
          return;
        }
        this.shrinkNode(o, u, f), this.computeBufferMetadata();
        return;
      }
      const a = [], l = this.positionInBuffer(o, i.remainder);
      this.deleteNodeTail(o, l), this._searchCache.validate(e), o.piece.length === 0 && a.push(o);
      const c = this.positionInBuffer(r, n.remainder);
      this.deleteNodeHead(r, c), r.piece.length === 0 && a.push(r);
      const d = o.next();
      for (let u = d; u !== Pe && u !== r; u = u.next())
        a.push(u);
      const h = o.piece.length === 0 ? o.prev() : o;
      this.deleteNodes(a), this.validateCRLFWithNextNode(h), this.computeBufferMetadata();
    }
    insertContentToNodeLeft(e, t) {
      const i = [];
      if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
        const r = t.piece, a = { line: r.start.line + 1, column: 0 }, l = new ps(r.bufferIndex, a, r.end, this.getLineFeedCnt(r.bufferIndex, a, r.end), r.length - 1);
        t.piece = l, e += `
`, Ba(this, t, -1, -1), t.piece.length === 0 && i.push(t);
      }
      const n = this.createNewPieces(e);
      let o = this.rbInsertLeft(t, n[n.length - 1]);
      for (let r = n.length - 2; r >= 0; r--)
        o = this.rbInsertLeft(o, n[r]);
      this.validateCRLFWithPrevNode(o), this.deleteNodes(i);
    }
    insertContentToNodeRight(e, t) {
      this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
      const i = this.createNewPieces(e), n = this.rbInsertRight(t, i[0]);
      let o = n;
      for (let r = 1; r < i.length; r++)
        o = this.rbInsertRight(o, i[r]);
      this.validateCRLFWithPrevNode(n);
    }
    positionInBuffer(e, t, i) {
      const n = e.piece, o = e.piece.bufferIndex, r = this._buffers[o].lineStarts, l = r[n.start.line] + n.start.column + t;
      let c = n.start.line, d = n.end.line, h = 0, u = 0, f = 0;
      for (; c <= d && (h = c + (d - c) / 2 | 0, f = r[h], h !== d); )
        if (u = r[h + 1], l < f)
          d = h - 1;
        else if (l >= u)
          c = h + 1;
        else
          break;
      return i ? (i.line = h, i.column = l - f, null) : {
        line: h,
        column: l - f
      };
    }
    getLineFeedCnt(e, t, i) {
      if (i.column === 0)
        return i.line - t.line;
      const n = this._buffers[e].lineStarts;
      if (i.line === n.length - 1)
        return i.line - t.line;
      const o = n[i.line + 1], r = n[i.line] + i.column;
      if (o > r + 1)
        return i.line - t.line;
      const a = r - 1;
      return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
    }
    offsetInBuffer(e, t) {
      return this._buffers[e].lineStarts[t.line] + t.column;
    }
    deleteNodes(e) {
      for (let t = 0; t < e.length; t++)
        sb(this, e[t]);
    }
    createNewPieces(e) {
      if (e.length > Ta) {
        const d = [];
        for (; e.length > Ta; ) {
          const u = e.charCodeAt(Ta - 1);
          let f;
          u === 13 || u >= 55296 && u <= 56319 ? (f = e.substring(0, Ta - 1), e = e.substring(Ta - 1)) : (f = e.substring(0, Ta), e = e.substring(Ta));
          const g = Va(f);
          d.push(new ps(this._buffers.length, { line: 0, column: 0 }, { line: g.length - 1, column: f.length - g[g.length - 1] }, g.length - 1, f.length)), this._buffers.push(new dd(f, g));
        }
        const h = Va(e);
        return d.push(new ps(this._buffers.length, { line: 0, column: 0 }, { line: h.length - 1, column: e.length - h[h.length - 1] }, h.length - 1, e.length)), this._buffers.push(new dd(e, h)), d;
      }
      let t = this._buffers[0].buffer.length;
      const i = Va(e, !1);
      let n = this._lastChangeBufferPos;
      if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
        this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, n = this._lastChangeBufferPos;
        for (let d = 0; d < i.length; d++)
          i[d] += t + 1;
        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
      } else {
        if (t !== 0)
          for (let d = 0; d < i.length; d++)
            i[d] += t;
        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
      }
      const o = this._buffers[0].buffer.length, r = this._buffers[0].lineStarts.length - 1, a = o - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = new ps(0, n, l, this.getLineFeedCnt(0, n, l), o - t);
      return this._lastChangeBufferPos = l, [c];
    }
    getLineRawContent(e, t = 0) {
      let i = this.root, n = "";
      const o = this._searchCache.get2(e);
      if (o) {
        i = o.node;
        const r = this.getAccumulatedValue(i, e - o.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        if (o.nodeStartLineNumber + i.piece.lineFeedCnt === e)
          n = a.substring(l + r, l + i.piece.length);
        else {
          const c = this.getAccumulatedValue(i, e - o.nodeStartLineNumber);
          return a.substring(l + r, l + c - t);
        }
      } else {
        let r = 0;
        const a = e;
        for (; i !== Pe; )
          if (i.left !== Pe && i.lf_left >= e - 1)
            i = i.left;
          else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
            const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this.getAccumulatedValue(i, e - i.lf_left - 1), d = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
            return r += i.size_left, this._searchCache.set({
              node: i,
              nodeStartOffset: r,
              nodeStartLineNumber: a - (e - 1 - i.lf_left)
            }), d.substring(h + l, h + c - t);
          } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
            const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this._buffers[i.piece.bufferIndex].buffer, d = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
            n = c.substring(d + l, d + i.piece.length);
            break;
          } else
            e -= i.lf_left + i.piece.lineFeedCnt, r += i.size_left + i.piece.length, i = i.right;
      }
      for (i = i.next(); i !== Pe; ) {
        const r = this._buffers[i.piece.bufferIndex].buffer;
        if (i.piece.lineFeedCnt > 0) {
          const a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return n += r.substring(l, l + a - t), n;
        } else {
          const a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          n += r.substr(a, i.piece.length);
        }
        i = i.next();
      }
      return n;
    }
    computeBufferMetadata() {
      let e = this.root, t = 1, i = 0;
      for (; e !== Pe; )
        t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
      this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
    }
    getIndexOf(e, t) {
      const i = e.piece, n = this.positionInBuffer(e, t), o = n.line - i.start.line;
      if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
        const r = this.getLineFeedCnt(e.piece.bufferIndex, i.start, n);
        if (r !== o)
          return { index: r, remainder: 0 };
      }
      return { index: o, remainder: n.column };
    }
    getAccumulatedValue(e, t) {
      if (t < 0)
        return 0;
      const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, o = i.start.line + t + 1;
      return o > i.end.line ? n[i.end.line] + i.end.column - n[i.start.line] - i.start.column : n[o] - n[i.start.line] - i.start.column;
    }
    deleteNodeTail(e, t) {
      const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.end), r = t, a = this.offsetInBuffer(i.bufferIndex, r), l = this.getLineFeedCnt(i.bufferIndex, i.start, r), c = l - n, d = a - o, h = i.length + d;
      e.piece = new ps(i.bufferIndex, i.start, r, l, h), Ba(this, e, d, c);
    }
    deleteNodeHead(e, t) {
      const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.start), r = t, a = this.getLineFeedCnt(i.bufferIndex, r, i.end), l = this.offsetInBuffer(i.bufferIndex, r), c = a - n, d = o - l, h = i.length + d;
      e.piece = new ps(i.bufferIndex, r, i.end, a, h), Ba(this, e, d, c);
    }
    shrinkNode(e, t, i) {
      const n = e.piece, o = n.start, r = n.end, a = n.length, l = n.lineFeedCnt, c = t, d = this.getLineFeedCnt(n.bufferIndex, n.start, c), h = this.offsetInBuffer(n.bufferIndex, t) - this.offsetInBuffer(n.bufferIndex, o);
      e.piece = new ps(n.bufferIndex, n.start, c, d, h), Ba(this, e, h - a, d - l);
      const u = new ps(n.bufferIndex, i, r, this.getLineFeedCnt(n.bufferIndex, i, r), this.offsetInBuffer(n.bufferIndex, r) - this.offsetInBuffer(n.bufferIndex, i)), f = this.rbInsertRight(e, u);
      this.validateCRLFWithPrevNode(f);
    }
    appendToNode(e, t) {
      this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
      const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), n = this._buffers[0].buffer.length;
      this._buffers[0].buffer += t;
      const o = Va(t, !1);
      for (let f = 0; f < o.length; f++)
        o[f] += n;
      if (i) {
        const f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
        this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: n - f };
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(o.slice(1));
      const r = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = e.piece.length + t.length, d = e.piece.lineFeedCnt, h = this.getLineFeedCnt(0, e.piece.start, l), u = h - d;
      e.piece = new ps(e.piece.bufferIndex, e.piece.start, l, h, c), this._lastChangeBufferPos = l, Ba(this, e, t.length, u);
    }
    nodeAt(e) {
      let t = this.root;
      const i = this._searchCache.get(e);
      if (i)
        return {
          node: i.node,
          nodeStartOffset: i.nodeStartOffset,
          remainder: e - i.nodeStartOffset
        };
      let n = 0;
      for (; t !== Pe; )
        if (t.size_left > e)
          t = t.left;
        else if (t.size_left + t.piece.length >= e) {
          n += t.size_left;
          const o = {
            node: t,
            remainder: e - t.size_left,
            nodeStartOffset: n
          };
          return this._searchCache.set(o), o;
        } else
          e -= t.size_left + t.piece.length, n += t.size_left + t.piece.length, t = t.right;
      return null;
    }
    nodeAt2(e, t) {
      let i = this.root, n = 0;
      for (; i !== Pe; )
        if (i.left !== Pe && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          const o = this.getAccumulatedValue(i, e - i.lf_left - 2), r = this.getAccumulatedValue(i, e - i.lf_left - 1);
          return n += i.size_left, {
            node: i,
            remainder: Math.min(o + t - 1, r),
            nodeStartOffset: n
          };
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          const o = this.getAccumulatedValue(i, e - i.lf_left - 2);
          if (o + t - 1 <= i.piece.length)
            return {
              node: i,
              remainder: o + t - 1,
              nodeStartOffset: n
            };
          t -= i.piece.length - o;
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right;
      for (i = i.next(); i !== Pe; ) {
        if (i.piece.lineFeedCnt > 0) {
          const o = this.getAccumulatedValue(i, 0), r = this.offsetOfNode(i);
          return {
            node: i,
            remainder: Math.min(t - 1, o),
            nodeStartOffset: r
          };
        } else if (i.piece.length >= t - 1) {
          const o = this.offsetOfNode(i);
          return {
            node: i,
            remainder: t - 1,
            nodeStartOffset: o
          };
        } else
          t -= i.piece.length;
        i = i.next();
      }
      return null;
    }
    nodeCharCodeAt(e, t) {
      if (e.piece.lineFeedCnt < 1)
        return -1;
      const i = this._buffers[e.piece.bufferIndex], n = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
      return i.buffer.charCodeAt(n);
    }
    offsetOfNode(e) {
      if (!e)
        return 0;
      let t = e.size_left;
      for (; e !== this.root; )
        e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
      return t;
    }
    shouldCheckCRLF() {
      return !(this._EOLNormalized && this._EOL === `
`);
    }
    startWithLF(e) {
      if (typeof e == "string")
        return e.charCodeAt(0) === 10;
      if (e === Pe || e.piece.lineFeedCnt === 0)
        return !1;
      const t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, n = t.start.line, o = i[n] + t.start.column;
      return n === i.length - 1 || i[n + 1] > o + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(o) === 10;
    }
    endWithCR(e) {
      return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === Pe || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
    }
    validateCRLFWithPrevNode(e) {
      if (this.shouldCheckCRLF() && this.startWithLF(e)) {
        const t = e.prev();
        this.endWithCR(t) && this.fixCRLF(t, e);
      }
    }
    validateCRLFWithNextNode(e) {
      if (this.shouldCheckCRLF() && this.endWithCR(e)) {
        const t = e.next();
        this.startWithLF(t) && this.fixCRLF(e, t);
      }
    }
    fixCRLF(e, t) {
      const i = [], n = this._buffers[e.piece.bufferIndex].lineStarts;
      let o;
      e.piece.end.column === 0 ? o = { line: e.piece.end.line - 1, column: n[e.piece.end.line] - n[e.piece.end.line - 1] - 1 } : o = { line: e.piece.end.line, column: e.piece.end.column - 1 };
      const r = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
      e.piece = new ps(e.piece.bufferIndex, e.piece.start, o, a, r), Ba(this, e, -1, -1), e.piece.length === 0 && i.push(e);
      const l = { line: t.piece.start.line + 1, column: 0 }, c = t.piece.length - 1, d = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
      t.piece = new ps(t.piece.bufferIndex, l, t.piece.end, d, c), Ba(this, t, -1, -1), t.piece.length === 0 && i.push(t);
      const h = this.createNewPieces(`\r
`);
      this.rbInsertRight(e, h[0]);
      for (let u = 0; u < i.length; u++)
        sb(this, i[u]);
    }
    adjustCarriageReturnFromNext(e, t) {
      if (this.shouldCheckCRLF() && this.endWithCR(e)) {
        const i = t.next();
        if (this.startWithLF(i)) {
          if (e += `
`, i.piece.length === 1)
            sb(this, i);
          else {
            const n = i.piece, o = { line: n.start.line + 1, column: 0 }, r = n.length - 1, a = this.getLineFeedCnt(n.bufferIndex, o, n.end);
            i.piece = new ps(n.bufferIndex, o, n.end, a, r), Ba(this, i, -1, -1);
          }
          return !0;
        }
      }
      return !1;
    }
    iterate(e, t) {
      if (e === Pe)
        return t(Pe);
      const i = this.iterate(e.left, t);
      return i && t(e) && this.iterate(e.right, t);
    }
    getNodeContent(e) {
      if (e === Pe)
        return "";
      const t = this._buffers[e.piece.bufferIndex];
      let i;
      const n = e.piece, o = this.offsetInBuffer(n.bufferIndex, n.start), r = this.offsetInBuffer(n.bufferIndex, n.end);
      return i = t.buffer.substring(o, r), i;
    }
    getPieceContent(e) {
      const t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), n = this.offsetInBuffer(e.bufferIndex, e.end);
      return t.buffer.substring(i, n);
    }
    rbInsertRight(e, t) {
      const i = new RL(t, 1);
      if (i.left = Pe, i.right = Pe, i.parent = Pe, i.size_left = 0, i.lf_left = 0, this.root === Pe)
        this.root = i, i.color = 0;
      else if (e.right === Pe)
        e.right = i, i.parent = e;
      else {
        const o = EE(e.right);
        o.left = i, i.parent = o;
      }
      return eM(this, i), i;
    }
    rbInsertLeft(e, t) {
      const i = new RL(t, 1);
      if (i.left = Pe, i.right = Pe, i.parent = Pe, i.size_left = 0, i.lf_left = 0, this.root === Pe)
        this.root = i, i.color = 0;
      else if (e.left === Pe)
        e.left = i, i.parent = e;
      else {
        const n = yF(e.left);
        n.right = i, i.parent = n;
      }
      return eM(this, i), i;
    }
  }
  function eh(s) {
    let e = 0, t = 0, i = 0, n = 0;
    for (let o = 0, r = s.length; o < r; o++) {
      const a = s.charCodeAt(o);
      a === 13 ? (e === 0 && (t = o), e++, o + 1 < r && s.charCodeAt(o + 1) === 10 ? (n |= 2, o++) : n |= 3, i = o + 1) : a === 10 && (n |= 1, e === 0 && (t = o), e++, i = o + 1);
    }
    return e === 0 && (t = s.length), [e, t, s.length - i, n];
  }
  class Ju extends z {
    constructor(e, t, i, n, o, r, a) {
      super(), this._onDidChangeContent = this._register(new B()), this._BOM = t, this._mightContainNonBasicASCII = !r, this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._pieceTree = new Qq(e, i, a);
    }
    mightContainRTL() {
      return this._mightContainRTL;
    }
    mightContainUnusualLineTerminators() {
      return this._mightContainUnusualLineTerminators;
    }
    resetMightContainUnusualLineTerminators() {
      this._mightContainUnusualLineTerminators = !1;
    }
    mightContainNonBasicASCII() {
      return this._mightContainNonBasicASCII;
    }
    getBOM() {
      return this._BOM;
    }
    getEOL() {
      return this._pieceTree.getEOL();
    }
    createSnapshot(e) {
      return this._pieceTree.createSnapshot(e ? this._BOM : "");
    }
    getOffsetAt(e, t) {
      return this._pieceTree.getOffsetAt(e, t);
    }
    getPositionAt(e) {
      return this._pieceTree.getPositionAt(e);
    }
    getRangeAt(e, t) {
      const i = e + t, n = this.getPositionAt(e), o = this.getPositionAt(i);
      return new D(n.lineNumber, n.column, o.lineNumber, o.column);
    }
    getValueInRange(e, t = 0) {
      if (e.isEmpty())
        return "";
      const i = this._getEndOfLine(t);
      return this._pieceTree.getValueInRange(e, i);
    }
    getValueLengthInRange(e, t = 0) {
      if (e.isEmpty())
        return 0;
      if (e.startLineNumber === e.endLineNumber)
        return e.endColumn - e.startColumn;
      const i = this.getOffsetAt(e.startLineNumber, e.startColumn);
      return this.getOffsetAt(e.endLineNumber, e.endColumn) - i;
    }
    getCharacterCountInRange(e, t = 0) {
      if (this._mightContainNonBasicASCII) {
        let i = 0;
        const n = e.startLineNumber, o = e.endLineNumber;
        for (let r = n; r <= o; r++) {
          const a = this.getLineContent(r), l = r === n ? e.startColumn - 1 : 0, c = r === o ? e.endColumn - 1 : a.length;
          for (let d = l; d < c; d++)
            Pi(a.charCodeAt(d)) ? (i = i + 1, d = d + 1) : i = i + 1;
        }
        return i += this._getEndOfLine(t).length * (o - n), i;
      }
      return this.getValueLengthInRange(e, t);
    }
    getLength() {
      return this._pieceTree.getLength();
    }
    getLineCount() {
      return this._pieceTree.getLineCount();
    }
    getLinesContent() {
      return this._pieceTree.getLinesContent();
    }
    getLineContent(e) {
      return this._pieceTree.getLineContent(e);
    }
    getLineCharCode(e, t) {
      return this._pieceTree.getLineCharCode(e, t);
    }
    getLineLength(e) {
      return this._pieceTree.getLineLength(e);
    }
    getLineFirstNonWhitespaceColumn(e) {
      const t = jn(this.getLineContent(e));
      return t === -1 ? 0 : t + 1;
    }
    getLineLastNonWhitespaceColumn(e) {
      const t = ia(this.getLineContent(e));
      return t === -1 ? 0 : t + 2;
    }
    _getEndOfLine(e) {
      switch (e) {
        case 1:
          return `
`;
        case 2:
          return `\r
`;
        case 0:
          return this.getEOL();
        default:
          throw new Error("Unknown EOL preference");
      }
    }
    setEOL(e) {
      this._pieceTree.setEOL(e);
    }
    applyEdits(e, t, i) {
      let n = this._mightContainRTL, o = this._mightContainUnusualLineTerminators, r = this._mightContainNonBasicASCII, a = !0, l = [];
      for (let _ = 0; _ < e.length; _++) {
        const b = e[_];
        a && b._isTracked && (a = !1);
        const C = b.range;
        if (b.text) {
          let x = !0;
          r || (x = !Rv(b.text), r = x), !n && x && (n = Av(b.text)), !o && x && (o = IP(b.text));
        }
        let v = "", w = 0, S = 0, L = 0;
        if (b.text) {
          let x;
          [w, S, L, x] = eh(b.text);
          const y = this.getEOL();
          x === 0 || x === (y === `\r
` ? 2 : 1) ? v = b.text : v = b.text.replace(/\r\n|\r|\n/g, y);
        }
        l[_] = {
          sortIndex: _,
          identifier: b.identifier || null,
          range: C,
          rangeOffset: this.getOffsetAt(C.startLineNumber, C.startColumn),
          rangeLength: this.getValueLengthInRange(C),
          text: v,
          eolCount: w,
          firstLineLength: S,
          lastLineLength: L,
          forceMoveMarkers: Boolean(b.forceMoveMarkers),
          isAutoWhitespaceEdit: b.isAutoWhitespaceEdit || !1
        };
      }
      l.sort(Ju._sortOpsAscending);
      let c = !1;
      for (let _ = 0, b = l.length - 1; _ < b; _++) {
        const C = l[_].range.getEndPosition(), v = l[_ + 1].range.getStartPosition();
        if (v.isBeforeOrEqual(C)) {
          if (v.isBefore(C))
            throw new Error("Overlapping ranges are not allowed!");
          c = !0;
        }
      }
      a && (l = this._reduceOperations(l));
      const d = i || t ? Ju._getInverseEditRanges(l) : [], h = [];
      if (t)
        for (let _ = 0; _ < l.length; _++) {
          const b = l[_], C = d[_];
          if (b.isAutoWhitespaceEdit && b.range.isEmpty())
            for (let v = C.startLineNumber; v <= C.endLineNumber; v++) {
              let w = "";
              v === C.startLineNumber && (w = this.getLineContent(b.range.startLineNumber), jn(w) !== -1) || h.push({ lineNumber: v, oldContent: w });
            }
        }
      let u = null;
      if (i) {
        let _ = 0;
        u = [];
        for (let b = 0; b < l.length; b++) {
          const C = l[b], v = d[b], w = this.getValueInRange(C.range), S = C.rangeOffset + _;
          _ += C.text.length - w.length, u[b] = {
            sortIndex: C.sortIndex,
            identifier: C.identifier,
            range: v,
            text: w,
            textChange: new gn(C.rangeOffset, w, S, C.text)
          };
        }
        c || u.sort((b, C) => b.sortIndex - C.sortIndex);
      }
      this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._mightContainNonBasicASCII = r;
      const f = this._doApplyEdits(l);
      let g = null;
      if (t && h.length > 0) {
        h.sort((_, b) => b.lineNumber - _.lineNumber), g = [];
        for (let _ = 0, b = h.length; _ < b; _++) {
          const C = h[_].lineNumber;
          if (_ > 0 && h[_ - 1].lineNumber === C)
            continue;
          const v = h[_].oldContent, w = this.getLineContent(C);
          w.length === 0 || w === v || jn(w) !== -1 || g.push(C);
        }
      }
      return this._onDidChangeContent.fire(), new Kj(u, f, g);
    }
    _reduceOperations(e) {
      return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
    }
    _toSingleEditOperation(e) {
      let t = !1;
      const i = e[0].range, n = e[e.length - 1].range, o = new D(i.startLineNumber, i.startColumn, n.endLineNumber, n.endColumn);
      let r = i.startLineNumber, a = i.startColumn;
      const l = [];
      for (let f = 0, g = e.length; f < g; f++) {
        const _ = e[f], b = _.range;
        t = t || _.forceMoveMarkers, l.push(this.getValueInRange(new D(r, a, b.startLineNumber, b.startColumn))), _.text.length > 0 && l.push(_.text), r = b.endLineNumber, a = b.endColumn;
      }
      const c = l.join(""), [d, h, u] = eh(c);
      return {
        sortIndex: 0,
        identifier: e[0].identifier,
        range: o,
        rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
        rangeLength: this.getValueLengthInRange(o, 0),
        text: c,
        eolCount: d,
        firstLineLength: h,
        lastLineLength: u,
        forceMoveMarkers: t,
        isAutoWhitespaceEdit: !1
      };
    }
    _doApplyEdits(e) {
      e.sort(Ju._sortOpsDescending);
      const t = [];
      for (let i = 0; i < e.length; i++) {
        const n = e[i], o = n.range.startLineNumber, r = n.range.startColumn, a = n.range.endLineNumber, l = n.range.endColumn;
        if (o === a && r === l && n.text.length === 0)
          continue;
        n.text ? (this._pieceTree.delete(n.rangeOffset, n.rangeLength), this._pieceTree.insert(n.rangeOffset, n.text, !0)) : this._pieceTree.delete(n.rangeOffset, n.rangeLength);
        const c = new D(o, r, a, l);
        t.push({
          range: c,
          rangeLength: n.rangeLength,
          text: n.text,
          rangeOffset: n.rangeOffset,
          forceMoveMarkers: n.forceMoveMarkers
        });
      }
      return t;
    }
    findMatchesLineByLine(e, t, i, n) {
      return this._pieceTree.findMatchesLineByLine(e, t, i, n);
    }
    static _getInverseEditRanges(e) {
      const t = [];
      let i = 0, n = 0, o = null;
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r];
        let c, d;
        o ? o.range.endLineNumber === l.range.startLineNumber ? (c = i, d = n + (l.range.startColumn - o.range.endColumn)) : (c = i + (l.range.startLineNumber - o.range.endLineNumber), d = l.range.startColumn) : (c = l.range.startLineNumber, d = l.range.startColumn);
        let h;
        if (l.text.length > 0) {
          const u = l.eolCount + 1;
          u === 1 ? h = new D(c, d, c, d + l.firstLineLength) : h = new D(c, d, c + u - 1, l.lastLineLength + 1);
        } else
          h = new D(c, d, c, d);
        i = h.endLineNumber, n = h.endColumn, t.push(h), o = l;
      }
      return t;
    }
    static _sortOpsAscending(e, t) {
      const i = D.compareRangesUsingEnds(e.range, t.range);
      return i === 0 ? e.sortIndex - t.sortIndex : i;
    }
    static _sortOpsDescending(e, t) {
      const i = D.compareRangesUsingEnds(e.range, t.range);
      return i === 0 ? t.sortIndex - e.sortIndex : -i;
    }
  }
  class Jq {
    constructor(e, t, i, n, o, r, a, l, c) {
      this._chunks = e, this._bom = t, this._cr = i, this._lf = n, this._crlf = o, this._containsRTL = r, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = c;
    }
    _getEOL(e) {
      const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
      return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
    }
    create(e) {
      const t = this._getEOL(e), i = this._chunks;
      if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
        for (let o = 0, r = i.length; o < r; o++) {
          const a = i[o].buffer.replace(/\r\n|\r|\n/g, t), l = Va(a);
          i[o] = new dd(a, l);
        }
      const n = new Ju(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
      return { textBuffer: n, disposable: n };
    }
  }
  class eG {
    constructor() {
      this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
    }
    acceptChunk(e) {
      if (e.length === 0)
        return;
      this.chunks.length === 0 && PI(e) && (this.BOM = QW, e = e.substr(1));
      const t = e.charCodeAt(e.length - 1);
      t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
    }
    _acceptChunk1(e, t) {
      !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
    }
    _acceptChunk2(e) {
      const t = Zq(this._tmpLineStarts, e);
      this.chunks.push(new dd(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, this.isBasicASCII && (this.isBasicASCII = t.isBasicASCII), !this.isBasicASCII && !this.containsRTL && (this.containsRTL = Av(e)), !this.isBasicASCII && !this.containsUnusualLineTerminators && (this.containsUnusualLineTerminators = IP(e));
    }
    finish(e = !0) {
      return this._finish(), new Jq(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
    }
    _finish() {
      if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
        this._hasPreviousChar = !1;
        const e = this.chunks[this.chunks.length - 1];
        e.buffer += String.fromCharCode(this._previousChar);
        const t = Va(e.buffer);
        e.lineStarts = t, this._previousChar === 13 && this.cr++;
      }
    }
  }
  class tG {
    constructor(e, t) {
      this._startLineNumber = e, this._tokens = t;
    }
    get startLineNumber() {
      return this._startLineNumber;
    }
    get endLineNumber() {
      return this._startLineNumber + this._tokens.length - 1;
    }
    getLineTokens(e) {
      return this._tokens[e - this._startLineNumber];
    }
    appendLineTokens(e) {
      this._tokens.push(e);
    }
  }
  class aS {
    constructor() {
      this._tokens = [];
    }
    add(e, t) {
      if (this._tokens.length > 0) {
        const i = this._tokens[this._tokens.length - 1];
        if (i.endLineNumber + 1 === e) {
          i.appendLineTokens(t);
          return;
        }
      }
      this._tokens.push(new tG(e, [t]));
    }
    finalize() {
      return this._tokens;
    }
  }
  class iM {
    constructor(e) {
      this._default = e, this._store = [];
    }
    get(e) {
      return e < this._store.length ? this._store[e] : this._default;
    }
    set(e, t) {
      for (; e >= this._store.length; )
        this._store[this._store.length] = this._default;
      this._store[e] = t;
    }
    delete(e, t) {
      t === 0 || e >= this._store.length || this._store.splice(e, t);
    }
    insert(e, t) {
      if (t === 0 || e >= this._store.length)
        return;
      const i = [];
      for (let n = 0; n < t; n++)
        i[n] = this._default;
      this._store = $v(this._store, e, i);
    }
  }
  class iG {
    constructor(e, t) {
      this.tokenizationSupport = e, this.initialState = t, this._lineBeginState = new iM(null), this._lineNeedsTokenization = new iM(!0), this._firstLineNeedsTokenization = 0, this._lineBeginState.set(0, this.initialState);
    }
    get invalidLineStartIndex() {
      return this._firstLineNeedsTokenization;
    }
    markMustBeTokenized(e) {
      this._lineNeedsTokenization.set(e, !0), this._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, e);
    }
    getBeginState(e) {
      return this._lineBeginState.get(e);
    }
    setEndState(e, t, i) {
      if (this._lineNeedsTokenization.set(t, !1), this._firstLineNeedsTokenization = t + 1, t === e - 1)
        return;
      const n = this._lineBeginState.get(t + 1);
      if (n === null || !i.equals(n)) {
        this._lineBeginState.set(t + 1, i), this.markMustBeTokenized(t + 1);
        return;
      }
      let o = t + 1;
      for (; o < e && !this._lineNeedsTokenization.get(o); )
        o++;
      this._firstLineNeedsTokenization = o;
    }
    applyEdits(e, t) {
      this.markMustBeTokenized(e.startLineNumber - 1), this._lineBeginState.delete(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineNeedsTokenization.delete(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineBeginState.insert(e.startLineNumber, t), this._lineNeedsTokenization.insert(e.startLineNumber, t);
    }
  }
  class nG extends z {
    constructor(e, t) {
      super(), this._textModel = e, this._languageIdCodec = t, this._isScheduled = !1, this._isDisposed = !1, this._tokenizationStateStore = null, this._register(Yt.onDidChange((i) => {
        const n = this._textModel.getLanguageId();
        i.changedLanguages.indexOf(n) !== -1 && (this._resetTokenizationState(), this._textModel.clearTokens());
      })), this._resetTokenizationState();
    }
    dispose() {
      this._isDisposed = !0, super.dispose();
    }
    handleDidChangeContent(e) {
      if (e.isFlush) {
        this._resetTokenizationState();
        return;
      }
      if (this._tokenizationStateStore)
        for (let t = 0, i = e.changes.length; t < i; t++) {
          const n = e.changes[t], [o] = eh(n.text);
          this._tokenizationStateStore.applyEdits(n.range, o);
        }
      this._beginBackgroundTokenization();
    }
    handleDidChangeAttached() {
      this._beginBackgroundTokenization();
    }
    handleDidChangeLanguage(e) {
      this._resetTokenizationState(), this._textModel.clearTokens();
    }
    _resetTokenizationState() {
      const [e, t] = sG(this._textModel);
      e && t ? this._tokenizationStateStore = new iG(e, t) : this._tokenizationStateStore = null, this._beginBackgroundTokenization();
    }
    _beginBackgroundTokenization() {
      this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._isScheduled = !0, Bm((e) => {
        this._isScheduled = !1, this._backgroundTokenizeWithDeadline(e);
      }));
    }
    _backgroundTokenizeWithDeadline(e) {
      const t = Date.now() + e.timeRemaining(), i = () => {
        this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._backgroundTokenizeForAtLeast1ms(), Date.now() < t ? K4(i) : this._beginBackgroundTokenization());
      };
      i();
    }
    _backgroundTokenizeForAtLeast1ms() {
      const e = this._textModel.getLineCount(), t = new aS(), i = hs.create(!1);
      do
        if (i.elapsed() > 1 || this._tokenizeOneInvalidLine(t) >= e)
          break;
      while (this._hasLinesToTokenize());
      this._textModel.setTokens(t.finalize(), !this._hasLinesToTokenize());
    }
    tokenizeViewport(e, t) {
      const i = new aS();
      this._tokenizeViewport(i, e, t), this._textModel.setTokens(i.finalize(), !this._hasLinesToTokenize());
    }
    reset() {
      this._resetTokenizationState(), this._textModel.clearTokens();
    }
    forceTokenization(e) {
      const t = new aS();
      this._updateTokensUntilLine(t, e), this._textModel.setTokens(t.finalize(), !this._hasLinesToTokenize());
    }
    getTokenTypeIfInsertingCharacter(e, t) {
      if (!this._tokenizationStateStore)
        return 0;
      this.forceTokenization(e.lineNumber);
      const i = this._tokenizationStateStore.getBeginState(e.lineNumber - 1);
      if (!i)
        return 0;
      const n = this._textModel.getLanguageId(), o = this._textModel.getLineContent(e.lineNumber), r = o.substring(0, e.column - 1) + t + o.substring(e.column - 1), a = Lg(this._languageIdCodec, n, this._tokenizationStateStore.tokenizationSupport, r, !0, i), l = new Fi(a.tokens, r, this._languageIdCodec);
      if (l.getCount() === 0)
        return 0;
      const c = l.findTokenIndexAtOffset(e.column - 1);
      return l.getStandardTokenType(c);
    }
    tokenizeLineWithEdit(e, t, i) {
      const n = e.lineNumber, o = e.column;
      if (!this._tokenizationStateStore)
        return null;
      this.forceTokenization(n);
      const r = this._tokenizationStateStore.getBeginState(n - 1);
      if (!r)
        return null;
      const a = this._textModel.getLineContent(n), l = a.substring(0, o - 1) + i + a.substring(o - 1 + t), c = this._textModel.getLanguageIdAtPosition(n, 0), d = Lg(this._languageIdCodec, c, this._tokenizationStateStore.tokenizationSupport, l, !0, r);
      return new Fi(d.tokens, l, this._languageIdCodec);
    }
    isCheapToTokenize(e) {
      if (!this._tokenizationStateStore)
        return !0;
      const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
      return e > t ? !1 : e < t || this._textModel.getLineLength(e) < 2048;
    }
    _hasLinesToTokenize() {
      return this._tokenizationStateStore ? this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount() : !1;
    }
    _tokenizeOneInvalidLine(e) {
      if (!this._tokenizationStateStore || !this._hasLinesToTokenize())
        return this._textModel.getLineCount() + 1;
      const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
      return this._updateTokensUntilLine(e, t), t;
    }
    _updateTokensUntilLine(e, t) {
      if (!this._tokenizationStateStore)
        return;
      const i = this._textModel.getLanguageId(), n = this._textModel.getLineCount(), o = t - 1;
      for (let r = this._tokenizationStateStore.invalidLineStartIndex; r <= o; r++) {
        const a = this._textModel.getLineContent(r + 1), l = this._tokenizationStateStore.getBeginState(r), c = Lg(this._languageIdCodec, i, this._tokenizationStateStore.tokenizationSupport, a, !0, l);
        e.add(r + 1, c.tokens), this._tokenizationStateStore.setEndState(n, r, c.endState), r = this._tokenizationStateStore.invalidLineStartIndex - 1;
      }
    }
    _tokenizeViewport(e, t, i) {
      if (!this._tokenizationStateStore || i <= this._tokenizationStateStore.invalidLineStartIndex)
        return;
      if (t <= this._tokenizationStateStore.invalidLineStartIndex) {
        this._updateTokensUntilLine(e, i);
        return;
      }
      let n = this._textModel.getLineFirstNonWhitespaceColumn(t);
      const o = [];
      let r = null;
      for (let c = t - 1; n > 1 && c >= 1; c--) {
        const d = this._textModel.getLineFirstNonWhitespaceColumn(c);
        if (d !== 0 && d < n) {
          if (r = this._tokenizationStateStore.getBeginState(c - 1), r)
            break;
          o.push(this._textModel.getLineContent(c)), n = d;
        }
      }
      r || (r = this._tokenizationStateStore.initialState);
      const a = this._textModel.getLanguageId();
      let l = r;
      for (let c = o.length - 1; c >= 0; c--)
        l = Lg(this._languageIdCodec, a, this._tokenizationStateStore.tokenizationSupport, o[c], !1, l).endState;
      for (let c = t; c <= i; c++) {
        const d = this._textModel.getLineContent(c), h = Lg(this._languageIdCodec, a, this._tokenizationStateStore.tokenizationSupport, d, !0, l);
        e.add(c, h.tokens), this._tokenizationStateStore.markMustBeTokenized(c - 1), l = h.endState;
      }
    }
  }
  function sG(s) {
    if (s.isTooLargeForTokenization())
      return [null, null];
    const e = Yt.get(s.getLanguageId());
    if (!e)
      return [null, null];
    let t;
    try {
      t = e.getInitialState();
    } catch (i) {
      return We(i), [null, null];
    }
    return [e, t];
  }
  function Lg(s, e, t, i, n, o) {
    let r = null;
    if (t)
      try {
        r = t.tokenizeEncoded(i, n, o.clone());
      } catch (a) {
        We(a);
      }
    return r || (r = CE(s.encodeLanguageId(e), o)), Fi.convertToEndOffset(r.tokens, i.length), r;
  }
  const Ha = new Uint32Array(0).buffer;
  class Pr {
    static deleteBeginning(e, t) {
      return e === null || e === Ha ? e : Pr.delete(e, 0, t);
    }
    static deleteEnding(e, t) {
      if (e === null || e === Ha)
        return e;
      const i = Qa(e), n = i[i.length - 2];
      return Pr.delete(e, t, n);
    }
    static delete(e, t, i) {
      if (e === null || e === Ha || t === i)
        return e;
      const n = Qa(e), o = n.length >>> 1;
      if (t === 0 && n[n.length - 2] === i)
        return Ha;
      const r = Fi.findIndexInTokensArray(n, t), a = r > 0 ? n[r - 1 << 1] : 0, l = n[r << 1];
      if (i < l) {
        const f = i - t;
        for (let g = r; g < o; g++)
          n[g << 1] -= f;
        return e;
      }
      let c, d;
      a !== t ? (n[r << 1] = t, c = r + 1 << 1, d = t) : (c = r << 1, d = a);
      const h = i - t;
      for (let f = r + 1; f < o; f++) {
        const g = n[f << 1] - h;
        g > d && (n[c++] = g, n[c++] = n[(f << 1) + 1], d = g);
      }
      if (c === n.length)
        return e;
      const u = new Uint32Array(c);
      return u.set(n.subarray(0, c), 0), u.buffer;
    }
    static append(e, t) {
      if (t === Ha)
        return e;
      if (e === Ha)
        return t;
      if (e === null)
        return e;
      if (t === null)
        return null;
      const i = Qa(e), n = Qa(t), o = n.length >>> 1, r = new Uint32Array(i.length + n.length);
      r.set(i, 0);
      let a = i.length;
      const l = i[i.length - 2];
      for (let c = 0; c < o; c++)
        r[a++] = n[c << 1] + l, r[a++] = n[(c << 1) + 1];
      return r.buffer;
    }
    static insert(e, t, i) {
      if (e === null || e === Ha)
        return e;
      const n = Qa(e), o = n.length >>> 1;
      let r = Fi.findIndexInTokensArray(n, t);
      r > 0 && n[r - 1 << 1] === t && r--;
      for (let a = r; a < o; a++)
        n[a << 1] += i;
      return e;
    }
  }
  function Qa(s) {
    return s instanceof Uint32Array ? s : new Uint32Array(s);
  }
  class w1 {
    constructor(e) {
      this._lineTokens = [], this._len = 0, this._languageIdCodec = e;
    }
    flush() {
      this._lineTokens = [], this._len = 0;
    }
    getTokens(e, t, i) {
      let n = null;
      if (t < this._len && (n = this._lineTokens[t]), n !== null && n !== Ha)
        return new Fi(Qa(n), i, this._languageIdCodec);
      const o = new Uint32Array(2);
      return o[0] = i.length, o[1] = nM(this._languageIdCodec.encodeLanguageId(e)), new Fi(o, i, this._languageIdCodec);
    }
    static _massageTokens(e, t, i) {
      const n = i ? Qa(i) : null;
      if (t === 0) {
        let o = !1;
        if (n && n.length > 1 && (o = In.getLanguageId(n[1]) !== e), !o)
          return Ha;
      }
      if (!n || n.length === 0) {
        const o = new Uint32Array(2);
        return o[0] = t, o[1] = nM(e), o.buffer;
      }
      return n[n.length - 2] = t, n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n;
    }
    _ensureLine(e) {
      for (; e >= this._len; )
        this._lineTokens[this._len] = null, this._len++;
    }
    _deleteLines(e, t) {
      t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
    }
    _insertLines(e, t) {
      if (t === 0)
        return;
      const i = [];
      for (let n = 0; n < t; n++)
        i[n] = null;
      this._lineTokens = $v(this._lineTokens, e, i), this._len += t;
    }
    setTokens(e, t, i, n, o) {
      const r = w1._massageTokens(this._languageIdCodec.encodeLanguageId(e), i, n);
      this._ensureLine(t);
      const a = this._lineTokens[t];
      return this._lineTokens[t] = r, o ? !w1._equals(a, r) : !1;
    }
    static _equals(e, t) {
      if (!e || !t)
        return !e && !t;
      const i = Qa(e), n = Qa(t);
      if (i.length !== n.length)
        return !1;
      for (let o = 0, r = i.length; o < r; o++)
        if (i[o] !== n[o])
          return !1;
      return !0;
    }
    acceptEdit(e, t, i) {
      this._acceptDeleteRange(e), this._acceptInsertText(new V(e.startLineNumber, e.startColumn), t, i);
    }
    _acceptDeleteRange(e) {
      const t = e.startLineNumber - 1;
      if (t >= this._len)
        return;
      if (e.startLineNumber === e.endLineNumber) {
        if (e.startColumn === e.endColumn)
          return;
        this._lineTokens[t] = Pr.delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
        return;
      }
      this._lineTokens[t] = Pr.deleteEnding(this._lineTokens[t], e.startColumn - 1);
      const i = e.endLineNumber - 1;
      let n = null;
      i < this._len && (n = Pr.deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = Pr.append(this._lineTokens[t], n), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
    }
    _acceptInsertText(e, t, i) {
      if (t === 0 && i === 0)
        return;
      const n = e.lineNumber - 1;
      if (!(n >= this._len)) {
        if (t === 0) {
          this._lineTokens[n] = Pr.insert(this._lineTokens[n], e.column - 1, i);
          return;
        }
        this._lineTokens[n] = Pr.deleteEnding(this._lineTokens[n], e.column - 1), this._lineTokens[n] = Pr.insert(this._lineTokens[n], e.column - 1, i), this._insertLines(e.lineNumber, t);
      }
    }
  }
  function nM(s) {
    return (s << 0 | 0 << 8 | 0 << 10 | 1 << 14 | 2 << 23) >>> 0;
  }
  class AE {
    constructor(e) {
      this._pieces = [], this._isComplete = !1, this._languageIdCodec = e;
    }
    flush() {
      this._pieces = [], this._isComplete = !1;
    }
    isEmpty() {
      return this._pieces.length === 0;
    }
    set(e, t) {
      this._pieces = e || [], this._isComplete = t;
    }
    setPartial(e, t) {
      let i = e;
      if (t.length > 0) {
        const o = t[0].getRange(), r = t[t.length - 1].getRange();
        if (!o || !r)
          return e;
        i = e.plusRange(o).plusRange(r);
      }
      let n = null;
      for (let o = 0, r = this._pieces.length; o < r; o++) {
        const a = this._pieces[o];
        if (a.endLineNumber < i.startLineNumber)
          continue;
        if (a.startLineNumber > i.endLineNumber) {
          n = n || { index: o };
          break;
        }
        if (a.removeTokens(i), a.isEmpty()) {
          this._pieces.splice(o, 1), o--, r--;
          continue;
        }
        if (a.endLineNumber < i.startLineNumber)
          continue;
        if (a.startLineNumber > i.endLineNumber) {
          n = n || { index: o };
          continue;
        }
        const [l, c] = a.split(i);
        if (l.isEmpty()) {
          n = n || { index: o };
          continue;
        }
        c.isEmpty() || (this._pieces.splice(o, 1, l, c), o++, r++, n = n || { index: o });
      }
      return n = n || { index: this._pieces.length }, t.length > 0 && (this._pieces = $v(this._pieces, n.index, t)), i;
    }
    isComplete() {
      return this._isComplete;
    }
    addSparseTokens(e, t) {
      const i = this._pieces;
      if (i.length === 0)
        return t;
      const n = AE._findFirstPieceWithLine(i, e), o = i[n].getLineTokens(e);
      if (!o)
        return t;
      const r = t.getCount(), a = o.getCount();
      let l = 0;
      const c = [];
      let d = 0, h = 0;
      const u = (f, g) => {
        f !== h && (h = f, c[d++] = f, c[d++] = g);
      };
      for (let f = 0; f < a; f++) {
        const g = o.getStartCharacter(f), _ = o.getEndCharacter(f), b = o.getMetadata(f), C = ((b & 1 ? 1024 : 0) | (b & 2 ? 2048 : 0) | (b & 4 ? 4096 : 0) | (b & 8 ? 8192 : 0) | (b & 16 ? 8372224 : 0) | (b & 32 ? 4286578688 : 0)) >>> 0, v = ~C >>> 0;
        for (; l < r && t.getEndOffset(l) <= g; )
          u(t.getEndOffset(l), t.getMetadata(l)), l++;
        for (l < r && t.getStartOffset(l) < g && u(g, t.getMetadata(l)); l < r && t.getEndOffset(l) < _; )
          u(t.getEndOffset(l), t.getMetadata(l) & v | b & C), l++;
        if (l < r)
          u(_, t.getMetadata(l) & v | b & C), t.getEndOffset(l) === _ && l++;
        else {
          const w = Math.min(Math.max(0, l - 1), r - 1);
          u(_, t.getMetadata(w) & v | b & C);
        }
      }
      for (; l < r; )
        u(t.getEndOffset(l), t.getMetadata(l)), l++;
      return new Fi(new Uint32Array(c), t.getLineContent(), this._languageIdCodec);
    }
    static _findFirstPieceWithLine(e, t) {
      let i = 0, n = e.length - 1;
      for (; i < n; ) {
        let o = i + Math.floor((n - i) / 2);
        if (e[o].endLineNumber < t)
          i = o + 1;
        else if (e[o].startLineNumber > t)
          n = o - 1;
        else {
          for (; o > i && e[o - 1].startLineNumber <= t && t <= e[o - 1].endLineNumber; )
            o--;
          return o;
        }
      }
      return i;
    }
    acceptEdit(e, t, i, n, o) {
      for (const r of this._pieces)
        r.acceptEdit(e, t, i, n, o);
    }
  }
  const uC = st("undoRedoService");
  class kF {
    constructor(e, t) {
      this.resource = e, this.elements = t;
    }
  }
  class Df {
    constructor() {
      this.id = Df._ID++, this.order = 1;
    }
    nextOrder() {
      return this.id === 0 ? 0 : this.order++;
    }
  }
  Df._ID = 0;
  Df.None = new Df();
  class Gr {
    constructor() {
      this.id = Gr._ID++, this.order = 1;
    }
    nextOrder() {
      return this.id === 0 ? 0 : this.order++;
    }
  }
  Gr._ID = 0;
  Gr.None = new Gr();
  var oG = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, lS = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  function rG() {
    return new eG();
  }
  function aG(s) {
    const e = rG();
    return e.acceptChunk(s), e.finish();
  }
  function sM(s, e) {
    return (typeof s == "string" ? aG(s) : s).create(e);
  }
  let rb = 0;
  const lG = 999, cG = 1e4;
  class dG {
    constructor(e) {
      this._source = e, this._eos = !1;
    }
    read() {
      if (this._eos)
        return null;
      const e = [];
      let t = 0, i = 0;
      do {
        const n = this._source.read();
        if (n === null)
          return this._eos = !0, t === 0 ? null : e.join("");
        if (n.length > 0 && (e[t++] = n, i += n.length), i >= 64 * 1024)
          return e.join("");
      } while (!0);
    }
  }
  const kg = () => {
    throw new Error("Invalid change accessor");
  };
  let gl = class id extends z {
    constructor(e, t, i, n = null, o, r, a) {
      super(), this._undoRedoService = o, this._languageService = r, this._languageConfigurationService = a, this._onWillDispose = this._register(new B()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new gG((u) => this.handleBeforeFireDecorationsChangedEvent(u))), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeLanguage = this._register(new B()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new B()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new B()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._onDidChangeOptions = this._register(new B()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new B()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._onDidChangeInjectedText = this._register(new B()), this._eventEmitter = this._register(new mG()), this._backgroundTokenizationState = 0, this._onBackgroundTokenizationStateChanged = this._register(new B()), rb++, this.id = "$model" + rb, this.isForSimpleWidget = i.isForSimpleWidget, typeof n > "u" || n === null ? this._associatedResource = Ee.parse("inmemory://model/" + rb) : this._associatedResource = n, this._attachedEditorCount = 0;
      const { textBuffer: l, disposable: c } = sM(e, i.defaultEOL);
      this._buffer = l, this._bufferDisposable = c, this._options = id.resolveOptions(this._buffer, i);
      const d = this._buffer.getLineCount(), h = this._buffer.getValueLengthInRange(new D(1, 1, d, this._buffer.getLineLength(d) + 1), 0);
      i.largeFileOptimizations ? this._isTooLargeForTokenization = h > id.LARGE_FILE_SIZE_THRESHOLD || d > id.LARGE_FILE_LINE_COUNT_THRESHOLD : this._isTooLargeForTokenization = !1, this._isTooLargeForSyncing = h > id.MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this._isDisposing = !1, this._languageId = t, this._languageRegistryListener = this._languageConfigurationService.onDidChange((u) => {
        u.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
      }), this._instanceId = EP(rb), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new oM(), this._commandManager = new IE(this, this._undoRedoService), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._tokens = new w1(this._languageService.languageIdCodec), this._semanticTokens = new AE(this._languageService.languageIdCodec), this._tokenization = new nG(this, this._languageService.languageIdCodec), this._bracketPairColorizer = this._register(new bq(this, this._languageConfigurationService)), this._guidesTextModelPart = this._register(new Rj(this, this._languageConfigurationService)), this._decorationProvider = this._register(new Cq(this)), this._register(this._decorationProvider.onDidChange(() => {
        this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._onDidChangeDecorations.endDeferredEmit();
      }));
    }
    static resolveOptions(e, t) {
      if (t.detectIndentation) {
        const i = GT(e, t.tabSize, t.insertSpaces);
        return new d0({
          tabSize: i.tabSize,
          indentSize: i.tabSize,
          insertSpaces: i.insertSpaces,
          trimAutoWhitespace: t.trimAutoWhitespace,
          defaultEOL: t.defaultEOL,
          bracketPairColorizationOptions: t.bracketPairColorizationOptions
        });
      }
      return new d0({
        tabSize: t.tabSize,
        indentSize: t.indentSize,
        insertSpaces: t.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL,
        bracketPairColorizationOptions: t.bracketPairColorizationOptions
      });
    }
    onDidChangeContent(e) {
      return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
    }
    onDidChangeContentOrInjectedText(e) {
      return ol(this._eventEmitter.fastEvent((t) => e(t.rawContentChangedEvent)), this._onDidChangeInjectedText.event((t) => e(t)));
    }
    get bracketPairs() {
      return this._bracketPairColorizer;
    }
    get guides() {
      return this._guidesTextModelPart;
    }
    get backgroundTokenizationState() {
      return this._backgroundTokenizationState;
    }
    handleTokenizationProgress(e) {
      if (this._backgroundTokenizationState === 2)
        return;
      const t = e ? 2 : 1;
      this._backgroundTokenizationState !== t && (this._backgroundTokenizationState = t, this._bracketPairColorizer.handleDidChangeBackgroundTokenizationState(), this._onBackgroundTokenizationStateChanged.fire());
    }
    dispose() {
      this._isDisposing = !0, this._onWillDispose.fire(), this._languageRegistryListener.dispose(), this._tokenization.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this._isDisposing = !1;
      const e = new Ju([], "", `
`, !1, !1, !0, !0);
      e.dispose(), this._buffer = e, this._bufferDisposable = z.None;
    }
    _assertNotDisposed() {
      if (this._isDisposed)
        throw new Error("Model is disposed!");
    }
    _emitContentChangedEvent(e, t) {
      this._isDisposing || (this._bracketPairColorizer.handleDidChangeContent(t), this._tokenization.handleDidChangeContent(t), this._eventEmitter.fire(new p1(e, t)));
    }
    setValue(e) {
      if (this._assertNotDisposed(), e === null)
        return;
      const { textBuffer: t, disposable: i } = sM(e, this._options.defaultEOL);
      this._setValueFromTextBuffer(t, i);
    }
    _createContentChanged2(e, t, i, n, o, r, a) {
      return {
        changes: [{
          range: e,
          rangeOffset: t,
          rangeLength: i,
          text: n
        }],
        eol: this._buffer.getEOL(),
        versionId: this.getVersionId(),
        isUndoing: o,
        isRedoing: r,
        isFlush: a
      };
    }
    _setValueFromTextBuffer(e, t) {
      this._assertNotDisposed();
      const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
      this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._tokens.flush(), this._semanticTokens.flush(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new oM(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new Od([
        new mK()
      ], this._versionId, !1, !1), this._createContentChanged2(new D(1, 1, o, r), 0, n, this.getValue(), !1, !1, !0));
    }
    setEOL(e) {
      this._assertNotDisposed();
      const t = e === 1 ? `\r
` : `
`;
      if (this._buffer.getEOL() === t)
        return;
      const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
      this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new Od([
        new bK()
      ], this._versionId, !1, !1), this._createContentChanged2(new D(1, 1, o, r), 0, n, this.getValue(), !1, !1, !1));
    }
    _onBeforeEOLChange() {
      this._decorationsTree.ensureAllNodesHaveRanges(this);
    }
    _onAfterEOLChange() {
      const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i], r = o.range, a = o.cachedAbsoluteStart - o.start, l = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), c = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
        o.cachedAbsoluteStart = l, o.cachedAbsoluteEnd = c, o.cachedVersionId = e, o.start = l - a, o.end = c - a, Lc(o);
      }
    }
    onBeforeAttached() {
      this._attachedEditorCount++, this._attachedEditorCount === 1 && (this._tokenization.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0));
    }
    onBeforeDetached() {
      this._attachedEditorCount--, this._attachedEditorCount === 0 && (this._tokenization.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0));
    }
    isAttachedToEditor() {
      return this._attachedEditorCount > 0;
    }
    getAttachedEditorCount() {
      return this._attachedEditorCount;
    }
    isTooLargeForSyncing() {
      return this._isTooLargeForSyncing;
    }
    isTooLargeForTokenization() {
      return this._isTooLargeForTokenization;
    }
    isDisposed() {
      return this._isDisposed;
    }
    isDominatedByLongLines() {
      if (this._assertNotDisposed(), this.isTooLargeForTokenization())
        return !1;
      let e = 0, t = 0;
      const i = this._buffer.getLineCount();
      for (let n = 1; n <= i; n++) {
        const o = this._buffer.getLineLength(n);
        o >= cG ? t += o : e += o;
      }
      return t > e;
    }
    get uri() {
      return this._associatedResource;
    }
    getOptions() {
      return this._assertNotDisposed(), this._options;
    }
    getFormattingOptions() {
      return {
        tabSize: this._options.indentSize,
        insertSpaces: this._options.insertSpaces
      };
    }
    updateOptions(e) {
      this._assertNotDisposed();
      const t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.indentSize, n = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, o = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, r = typeof e.bracketColorizationOptions < "u" ? e.bracketColorizationOptions : this._options.bracketPairColorizationOptions, a = new d0({
        tabSize: t,
        indentSize: i,
        insertSpaces: n,
        defaultEOL: this._options.defaultEOL,
        trimAutoWhitespace: o,
        bracketPairColorizationOptions: r
      });
      if (this._options.equals(a))
        return;
      const l = this._options.createChangeEvent(a);
      this._options = a, this._bracketPairColorizer.handleDidChangeOptions(l), this._decorationProvider.handleDidChangeOptions(l), this._onDidChangeOptions.fire(l);
    }
    detectIndentation(e, t) {
      this._assertNotDisposed();
      const i = GT(this._buffer, t, e);
      this.updateOptions({
        insertSpaces: i.insertSpaces,
        tabSize: i.tabSize,
        indentSize: i.tabSize
      });
    }
    normalizeIndentation(e) {
      return this._assertNotDisposed(), e1(e, this._options.indentSize, this._options.insertSpaces);
    }
    getVersionId() {
      return this._assertNotDisposed(), this._versionId;
    }
    mightContainRTL() {
      return this._buffer.mightContainRTL();
    }
    mightContainUnusualLineTerminators() {
      return this._buffer.mightContainUnusualLineTerminators();
    }
    removeUnusualLineTerminators(e = null) {
      const t = this.findMatches(xP.source, !1, !0, !1, null, !1, 1073741824);
      this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
    }
    mightContainNonBasicASCII() {
      return this._buffer.mightContainNonBasicASCII();
    }
    getAlternativeVersionId() {
      return this._assertNotDisposed(), this._alternativeVersionId;
    }
    getInitialUndoRedoSnapshot() {
      return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
    }
    getOffsetAt(e) {
      this._assertNotDisposed();
      const t = this._validatePosition(e.lineNumber, e.column, 0);
      return this._buffer.getOffsetAt(t.lineNumber, t.column);
    }
    getPositionAt(e) {
      this._assertNotDisposed();
      const t = Math.min(this._buffer.getLength(), Math.max(0, e));
      return this._buffer.getPositionAt(t);
    }
    _increaseVersionId() {
      this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
    }
    _overwriteVersionId(e) {
      this._versionId = e;
    }
    _overwriteAlternativeVersionId(e) {
      this._alternativeVersionId = e;
    }
    _overwriteInitialUndoRedoSnapshot(e) {
      this._initialUndoRedoSnapshot = e;
    }
    getValue(e, t = !1) {
      this._assertNotDisposed();
      const i = this.getFullModelRange(), n = this.getValueInRange(i, e);
      return t ? this._buffer.getBOM() + n : n;
    }
    createSnapshot(e = !1) {
      return new dG(this._buffer.createSnapshot(e));
    }
    getValueLength(e, t = !1) {
      this._assertNotDisposed();
      const i = this.getFullModelRange(), n = this.getValueLengthInRange(i, e);
      return t ? this._buffer.getBOM().length + n : n;
    }
    getValueInRange(e, t = 0) {
      return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
    }
    getValueLengthInRange(e, t = 0) {
      return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
    }
    getCharacterCountInRange(e, t = 0) {
      return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
    }
    getLineCount() {
      return this._assertNotDisposed(), this._buffer.getLineCount();
    }
    getLineContent(e) {
      if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
        throw new Error("Illegal value for lineNumber");
      return this._buffer.getLineContent(e);
    }
    getLineLength(e) {
      if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
        throw new Error("Illegal value for lineNumber");
      return this._buffer.getLineLength(e);
    }
    getLinesContent() {
      return this._assertNotDisposed(), this._buffer.getLinesContent();
    }
    getEOL() {
      return this._assertNotDisposed(), this._buffer.getEOL();
    }
    getEndOfLineSequence() {
      return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
    }
    getLineMinColumn(e) {
      return this._assertNotDisposed(), 1;
    }
    getLineMaxColumn(e) {
      if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
        throw new Error("Illegal value for lineNumber");
      return this._buffer.getLineLength(e) + 1;
    }
    getLineFirstNonWhitespaceColumn(e) {
      if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
        throw new Error("Illegal value for lineNumber");
      return this._buffer.getLineFirstNonWhitespaceColumn(e);
    }
    getLineLastNonWhitespaceColumn(e) {
      if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
        throw new Error("Illegal value for lineNumber");
      return this._buffer.getLineLastNonWhitespaceColumn(e);
    }
    _validateRangeRelaxedNoAllocations(e) {
      const t = this._buffer.getLineCount(), i = e.startLineNumber, n = e.startColumn;
      let o = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), r = Math.floor(typeof n == "number" && !isNaN(n) ? n : 1);
      if (o < 1)
        o = 1, r = 1;
      else if (o > t)
        o = t, r = this.getLineMaxColumn(o);
      else if (r <= 1)
        r = 1;
      else {
        const h = this.getLineMaxColumn(o);
        r >= h && (r = h);
      }
      const a = e.endLineNumber, l = e.endColumn;
      let c = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), d = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
      if (c < 1)
        c = 1, d = 1;
      else if (c > t)
        c = t, d = this.getLineMaxColumn(c);
      else if (d <= 1)
        d = 1;
      else {
        const h = this.getLineMaxColumn(c);
        d >= h && (d = h);
      }
      return i === o && n === r && a === c && l === d && e instanceof D && !(e instanceof ae) ? e : new D(o, r, c, d);
    }
    _isValidPosition(e, t, i) {
      if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
        return !1;
      const n = this._buffer.getLineCount();
      if (e > n)
        return !1;
      if (t === 1)
        return !0;
      const o = this.getLineMaxColumn(e);
      if (t > o)
        return !1;
      if (i === 1) {
        const r = this._buffer.getLineCharCode(e, t - 2);
        if (Pi(r))
          return !1;
      }
      return !0;
    }
    _validatePosition(e, t, i) {
      const n = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), o = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), r = this._buffer.getLineCount();
      if (n < 1)
        return new V(1, 1);
      if (n > r)
        return new V(r, this.getLineMaxColumn(r));
      if (o <= 1)
        return new V(n, 1);
      const a = this.getLineMaxColumn(n);
      if (o >= a)
        return new V(n, a);
      if (i === 1) {
        const l = this._buffer.getLineCharCode(n, o - 2);
        if (Pi(l))
          return new V(n, o - 1);
      }
      return new V(n, o);
    }
    validatePosition(e) {
      return this._assertNotDisposed(), e instanceof V && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
    }
    _isValidRange(e, t) {
      const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
      if (!this._isValidPosition(i, n, 0) || !this._isValidPosition(o, r, 0))
        return !1;
      if (t === 1) {
        const a = n > 1 ? this._buffer.getLineCharCode(i, n - 2) : 0, l = r > 1 && r <= this._buffer.getLineLength(o) ? this._buffer.getLineCharCode(o, r - 2) : 0, c = Pi(a), d = Pi(l);
        return !c && !d;
      }
      return !0;
    }
    validateRange(e) {
      if (this._assertNotDisposed(), e instanceof D && !(e instanceof ae) && this._isValidRange(e, 1))
        return e;
      const i = this._validatePosition(e.startLineNumber, e.startColumn, 0), n = this._validatePosition(e.endLineNumber, e.endColumn, 0), o = i.lineNumber, r = i.column, a = n.lineNumber, l = n.column;
      {
        const c = r > 1 ? this._buffer.getLineCharCode(o, r - 2) : 0, d = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, h = Pi(c), u = Pi(d);
        return !h && !u ? new D(o, r, a, l) : o === a && r === l ? new D(o, r - 1, a, l - 1) : h && u ? new D(o, r - 1, a, l + 1) : h ? new D(o, r - 1, a, l) : new D(o, r, a, l + 1);
      }
    }
    modifyPosition(e, t) {
      this._assertNotDisposed();
      const i = this.getOffsetAt(e) + t;
      return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
    }
    getFullModelRange() {
      this._assertNotDisposed();
      const e = this.getLineCount();
      return new D(1, 1, e, this.getLineMaxColumn(e));
    }
    findMatchesLineByLine(e, t, i, n) {
      return this._buffer.findMatchesLineByLine(e, t, i, n);
    }
    findMatches(e, t, i, n, o, r, a = lG) {
      this._assertNotDisposed();
      let l = null;
      t !== null && (Array.isArray(t) || (t = [t]), t.every((h) => D.isIRange(h)) && (l = t.map((h) => this.validateRange(h)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((h, u) => h.startLineNumber - u.startLineNumber || h.startColumn - u.startColumn);
      const c = [];
      c.push(l.reduce((h, u) => D.areIntersecting(h, u) ? h.plusRange(u) : (c.push(h), u)));
      let d;
      if (!i && e.indexOf(`
`) < 0) {
        const u = new td(e, i, n, o).parseSearchRequest();
        if (!u)
          return [];
        d = (f) => this.findMatchesLineByLine(f, u, r, a);
      } else
        d = (h) => ob.findMatches(this, new td(e, i, n, o), h, r, a);
      return c.map(d).reduce((h, u) => h.concat(u), []);
    }
    findNextMatch(e, t, i, n, o, r) {
      this._assertNotDisposed();
      const a = this.validatePosition(t);
      if (!i && e.indexOf(`
`) < 0) {
        const c = new td(e, i, n, o).parseSearchRequest();
        if (!c)
          return null;
        const d = this.getLineCount();
        let h = new D(a.lineNumber, a.column, d, this.getLineMaxColumn(d)), u = this.findMatchesLineByLine(h, c, r, 1);
        return ob.findNextMatch(this, new td(e, i, n, o), a, r), u.length > 0 || (h = new D(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), u = this.findMatchesLineByLine(h, c, r, 1), u.length > 0) ? u[0] : null;
      }
      return ob.findNextMatch(this, new td(e, i, n, o), a, r);
    }
    findPreviousMatch(e, t, i, n, o, r) {
      this._assertNotDisposed();
      const a = this.validatePosition(t);
      return ob.findPreviousMatch(this, new td(e, i, n, o), a, r);
    }
    pushStackElement() {
      this._commandManager.pushStackElement();
    }
    popStackElement() {
      this._commandManager.popStackElement();
    }
    pushEOL(e) {
      if ((this.getEOL() === `
` ? 0 : 1) !== e)
        try {
          this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
        } finally {
          this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
        }
    }
    _validateEditOperation(e) {
      return e instanceof Jw ? e : new Jw(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
    }
    _validateEditOperations(e) {
      const t = [];
      for (let i = 0, n = e.length; i < n; i++)
        t[i] = this._validateEditOperation(e[i]);
      return t;
    }
    pushEditOperations(e, t, i) {
      try {
        return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    _pushEditOperations(e, t, i) {
      if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
        const n = t.map((r) => ({
          range: this.validateRange(r.range),
          text: r.text
        }));
        let o = !0;
        if (e)
          for (let r = 0, a = e.length; r < a; r++) {
            const l = e[r];
            let c = !1;
            for (let d = 0, h = n.length; d < h; d++) {
              const u = n[d].range, f = u.startLineNumber > l.endLineNumber, g = l.startLineNumber > u.endLineNumber;
              if (!f && !g) {
                c = !0;
                break;
              }
            }
            if (!c) {
              o = !1;
              break;
            }
          }
        if (o)
          for (let r = 0, a = this._trimAutoWhitespaceLines.length; r < a; r++) {
            const l = this._trimAutoWhitespaceLines[r], c = this.getLineMaxColumn(l);
            let d = !0;
            for (let h = 0, u = n.length; h < u; h++) {
              const f = n[h].range, g = n[h].text;
              if (!(l < f.startLineNumber || l > f.endLineNumber) && !(l === f.startLineNumber && f.startColumn === c && f.isEmpty() && g && g.length > 0 && g.charAt(0) === `
`) && !(l === f.startLineNumber && f.startColumn === 1 && f.isEmpty() && g && g.length > 0 && g.charAt(g.length - 1) === `
`)) {
                d = !1;
                break;
              }
            }
            if (d) {
              const h = new D(l, 1, l, c);
              t.push(new Jw(null, h, null, !1, !1, !1));
            }
          }
        this._trimAutoWhitespaceLines = null;
      }
      return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i);
    }
    _applyUndo(e, t, i, n) {
      const o = e.map((r) => {
        const a = this.getPositionAt(r.newPosition), l = this.getPositionAt(r.newEnd);
        return {
          range: new D(a.lineNumber, a.column, l.lineNumber, l.column),
          text: r.oldText
        };
      });
      this._applyUndoRedoEdits(o, t, !0, !1, i, n);
    }
    _applyRedo(e, t, i, n) {
      const o = e.map((r) => {
        const a = this.getPositionAt(r.oldPosition), l = this.getPositionAt(r.oldEnd);
        return {
          range: new D(a.lineNumber, a.column, l.lineNumber, l.column),
          text: r.newText
        };
      });
      this._applyUndoRedoEdits(o, t, !1, !0, i, n);
    }
    _applyUndoRedoEdits(e, t, i, n, o, r) {
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = n, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(o);
      } finally {
        this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(r), this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    applyEdits(e, t = !1) {
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
        const i = this._validateEditOperations(e);
        return this._doApplyEdits(i, t);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    _doApplyEdits(e, t) {
      const i = this._buffer.getLineCount(), n = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), o = this._buffer.getLineCount(), r = n.changes;
      if (this._trimAutoWhitespaceLines = n.trimAutoWhitespaceLineNumbers, r.length !== 0) {
        for (let c = 0, d = r.length; c < d; c++) {
          const h = r[c], [u, f, g] = eh(h.text);
          this._tokens.acceptEdit(h.range, u, f), this._semanticTokens.acceptEdit(h.range, u, f, g, h.text.length > 0 ? h.text.charCodeAt(0) : 0), this._decorationsTree.acceptReplace(h.rangeOffset, h.rangeLength, h.text.length, h.forceMoveMarkers);
        }
        const a = [];
        this._increaseVersionId();
        let l = i;
        for (let c = 0, d = r.length; c < d; c++) {
          const h = r[c], [u] = eh(h.text);
          this._onDidChangeDecorations.fire();
          const f = h.range.startLineNumber, g = h.range.endLineNumber, _ = g - f, b = u, C = Math.min(_, b), v = b - _, w = o - l - v + f, S = w, L = w + b, x = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new V(S, 1)), this.getOffsetAt(new V(L, this.getLineMaxColumn(L))), 0), y = vr.fromDecorations(x), k = new bf(y);
          for (let I = C; I >= 0; I--) {
            const F = f + I, R = w + I;
            k.takeFromEndWhile((j) => j.lineNumber > R);
            const $ = k.takeFromEndWhile((j) => j.lineNumber === R);
            a.push(new RT(F, this.getLineContent(R), $));
          }
          if (C < _) {
            const I = f + C;
            a.push(new pK(I + 1, g));
          }
          if (C < b) {
            const I = new bf(y), F = f + C, R = b - C, $ = o - l - R + F + 1, j = [], le = [];
            for (let he = 0; he < R; he++) {
              const Ce = $ + he;
              le[he] = this.getLineContent(Ce), I.takeWhile((Ne) => Ne.lineNumber < Ce), j[he] = I.takeWhile((Ne) => Ne.lineNumber === Ce);
            }
            a.push(new _K(F + 1, f + b, le, j));
          }
          l += v;
        }
        this._emitContentChangedEvent(new Od(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
          changes: r,
          eol: this._buffer.getEOL(),
          versionId: this.getVersionId(),
          isUndoing: this._isUndoing,
          isRedoing: this._isRedoing,
          isFlush: !1
        });
      }
      return n.reverseEdits === null ? void 0 : n.reverseEdits;
    }
    undo() {
      return this._undoRedoService.undo(this.uri);
    }
    canUndo() {
      return this._undoRedoService.canUndo(this.uri);
    }
    redo() {
      return this._undoRedoService.redo(this.uri);
    }
    canRedo() {
      return this._undoRedoService.canRedo(this.uri);
    }
    handleBeforeFireDecorationsChangedEvent(e) {
      if (e === null || e.size === 0)
        return;
      const i = [...e].map((n) => new RT(n, this.getLineContent(n), this._getInjectedTextInLine(n)));
      this._onDidChangeInjectedText.fire(new tF(i));
    }
    changeDecorations(e, t = 0) {
      this._assertNotDisposed();
      try {
        return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
      } finally {
        this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    _changeDecorations(e, t) {
      const i = {
        addDecoration: (o, r) => this._deltaDecorationsImpl(e, [], [{ range: o, options: r }])[0],
        changeDecoration: (o, r) => {
          this._changeDecorationImpl(o, r);
        },
        changeDecorationOptions: (o, r) => {
          this._changeDecorationOptionsImpl(o, aM(r));
        },
        removeDecoration: (o) => {
          this._deltaDecorationsImpl(e, [o], []);
        },
        deltaDecorations: (o, r) => o.length === 0 && r.length === 0 ? [] : this._deltaDecorationsImpl(e, o, r)
      };
      let n = null;
      try {
        n = t(i);
      } catch (o) {
        We(o);
      }
      return i.addDecoration = kg, i.changeDecoration = kg, i.changeDecorationOptions = kg, i.removeDecoration = kg, i.deltaDecorations = kg, n;
    }
    deltaDecorations(e, t, i = 0) {
      if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
        return [];
      try {
        return this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
      } finally {
        this._onDidChangeDecorations.endDeferredEmit();
      }
    }
    _getTrackedRange(e) {
      return this.getDecorationRange(e);
    }
    _setTrackedRange(e, t, i) {
      const n = e ? this._decorations[e] : null;
      if (!n)
        return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: rM[i] }])[0] : null;
      if (!t)
        return this._decorationsTree.delete(n), delete this._decorations[n.id], null;
      const o = this._validateRangeRelaxedNoAllocations(t), r = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), a = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
      return this._decorationsTree.delete(n), n.reset(this.getVersionId(), r, a, o), n.setOptions(rM[i]), this._decorationsTree.insert(n), n.id;
    }
    removeAllDecorationsWithOwnerId(e) {
      if (this._isDisposed)
        return;
      const t = this._decorationsTree.collectNodesFromOwner(e);
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i];
        this._decorationsTree.delete(o), delete this._decorations[o.id];
      }
    }
    getDecorationOptions(e) {
      const t = this._decorations[e];
      return t ? t.options : null;
    }
    getDecorationRange(e) {
      const t = this._decorations[e];
      return t ? this._decorationsTree.getNodeRange(this, t) : null;
    }
    getLineDecorations(e, t = 0, i = !1) {
      return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
    }
    getLinesDecorations(e, t, i = 0, n = !1) {
      const o = this.getLineCount(), r = Math.min(o, Math.max(1, e)), a = Math.min(o, Math.max(1, t)), l = this.getLineMaxColumn(a), c = new D(r, 1, a, l), d = this._getDecorationsInRange(c, i, n);
      return d.push(...this._decorationProvider.getDecorationsInRange(c, i, n)), d;
    }
    getDecorationsInRange(e, t = 0, i = !1) {
      const n = this.validateRange(e), o = this._getDecorationsInRange(n, t, i);
      return o.push(...this._decorationProvider.getDecorationsInRange(n, t, i)), o;
    }
    getOverviewRulerDecorations(e = 0, t = !1) {
      return this._decorationsTree.getAll(this, e, t, !0);
    }
    getInjectedTextDecorations(e = 0) {
      return this._decorationsTree.getAllInjectedText(this, e);
    }
    _getInjectedTextInLine(e) {
      const t = this._buffer.getOffsetAt(e, 1), i = t + this._buffer.getLineLength(e), n = this._decorationsTree.getInjectedTextInInterval(this, t, i, 0);
      return vr.fromDecorations(n).filter((o) => o.lineNumber === e);
    }
    getAllDecorations(e = 0, t = !1) {
      let i = this._decorationsTree.getAll(this, e, t, !1);
      return i = i.concat(this._decorationProvider.getAllDecorations(e, t)), i;
    }
    _getDecorationsInRange(e, t, i) {
      const n = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), o = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn);
      return this._decorationsTree.getAllInInterval(this, n, o, t, i);
    }
    getRangeAt(e, t) {
      return this._buffer.getRangeAt(e, t - e);
    }
    _changeDecorationImpl(e, t) {
      const i = this._decorations[e];
      if (!i)
        return;
      if (i.options.after) {
        const a = this.getDecorationRange(e);
        this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.endLineNumber);
      }
      if (i.options.before) {
        const a = this.getDecorationRange(e);
        this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.startLineNumber);
      }
      const n = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(n.startLineNumber, n.startColumn), r = this._buffer.getOffsetAt(n.endLineNumber, n.endColumn);
      this._decorationsTree.delete(i), i.reset(this.getVersionId(), o, r, n), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options), i.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.endLineNumber), i.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.startLineNumber);
    }
    _changeDecorationOptionsImpl(e, t) {
      const i = this._decorations[e];
      if (!i)
        return;
      const n = !!(i.options.overviewRuler && i.options.overviewRuler.color), o = !!(t.overviewRuler && t.overviewRuler.color);
      if (this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), i.options.after || t.after) {
        const r = this._decorationsTree.getNodeRange(this, i);
        this._onDidChangeDecorations.recordLineAffectedByInjectedText(r.endLineNumber);
      }
      if (i.options.before || t.before) {
        const r = this._decorationsTree.getNodeRange(this, i);
        this._onDidChangeDecorations.recordLineAffectedByInjectedText(r.startLineNumber);
      }
      n !== o ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
    }
    _deltaDecorationsImpl(e, t, i) {
      const n = this.getVersionId(), o = t.length;
      let r = 0;
      const a = i.length;
      let l = 0;
      const c = new Array(a);
      for (; r < o || l < a; ) {
        let d = null;
        if (r < o) {
          do
            d = this._decorations[t[r++]];
          while (!d && r < o);
          if (d) {
            if (d.options.after) {
              const h = this._decorationsTree.getNodeRange(this, d);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(h.endLineNumber);
            }
            if (d.options.before) {
              const h = this._decorationsTree.getNodeRange(this, d);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(h.startLineNumber);
            }
            this._decorationsTree.delete(d), this._onDidChangeDecorations.checkAffectedAndFire(d.options);
          }
        }
        if (l < a) {
          if (!d) {
            const b = ++this._lastDecorationId, C = `${this._instanceId};${b}`;
            d = new wF(C, 0, 0), this._decorations[C] = d;
          }
          const h = i[l], u = this._validateRangeRelaxedNoAllocations(h.range), f = aM(h.options), g = this._buffer.getOffsetAt(u.startLineNumber, u.startColumn), _ = this._buffer.getOffsetAt(u.endLineNumber, u.endColumn);
          d.ownerId = e, d.reset(n, g, _, u), d.setOptions(f), d.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.endLineNumber), d.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.startLineNumber), this._onDidChangeDecorations.checkAffectedAndFire(f), this._decorationsTree.insert(d), c[l] = d.id, l++;
        } else
          d && delete this._decorations[d.id];
      }
      return c;
    }
    setTokens(e, t = !1) {
      if (e.length !== 0) {
        const i = [];
        for (let n = 0, o = e.length; n < o; n++) {
          const r = e[n];
          let a = 0, l = 0, c = !1;
          for (let d = r.startLineNumber; d <= r.endLineNumber; d++)
            c ? (this._tokens.setTokens(this._languageId, d - 1, this._buffer.getLineLength(d), r.getLineTokens(d), !1), l = d) : this._tokens.setTokens(this._languageId, d - 1, this._buffer.getLineLength(d), r.getLineTokens(d), !0) && (c = !0, a = d, l = d);
          c && i.push({ fromLineNumber: a, toLineNumber: l });
        }
        i.length > 0 && this._emitModelTokensChangedEvent({
          tokenizationSupportChanged: !1,
          semanticTokensApplied: !1,
          ranges: i
        });
      }
      this.handleTokenizationProgress(t);
    }
    setSemanticTokens(e, t) {
      this._semanticTokens.set(e, t), this._emitModelTokensChangedEvent({
        tokenizationSupportChanged: !1,
        semanticTokensApplied: e !== null,
        ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]
      });
    }
    hasCompleteSemanticTokens() {
      return this._semanticTokens.isComplete();
    }
    hasSomeSemanticTokens() {
      return !this._semanticTokens.isEmpty();
    }
    setPartialSemanticTokens(e, t) {
      if (this.hasCompleteSemanticTokens())
        return;
      const i = this.validateRange(this._semanticTokens.setPartial(e, t));
      this._emitModelTokensChangedEvent({
        tokenizationSupportChanged: !1,
        semanticTokensApplied: !0,
        ranges: [{ fromLineNumber: i.startLineNumber, toLineNumber: i.endLineNumber }]
      });
    }
    tokenizeViewport(e, t) {
      e = Math.max(1, e), t = Math.min(this._buffer.getLineCount(), t), this._tokenization.tokenizeViewport(e, t);
    }
    clearTokens() {
      this._tokens.flush(), this._emitModelTokensChangedEvent({
        tokenizationSupportChanged: !0,
        semanticTokensApplied: !1,
        ranges: [{
          fromLineNumber: 1,
          toLineNumber: this._buffer.getLineCount()
        }]
      });
    }
    _emitModelTokensChangedEvent(e) {
      this._isDisposing || (this._bracketPairColorizer.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
    }
    resetTokenization() {
      this._tokenization.reset();
    }
    forceTokenization(e) {
      if (e < 1 || e > this.getLineCount())
        throw new Error("Illegal value for lineNumber");
      this._tokenization.forceTokenization(e);
    }
    isCheapToTokenize(e) {
      return this._tokenization.isCheapToTokenize(e);
    }
    tokenizeIfCheap(e) {
      this.isCheapToTokenize(e) && this.forceTokenization(e);
    }
    getLineTokens(e) {
      if (e < 1 || e > this.getLineCount())
        throw new Error("Illegal value for lineNumber");
      return this._getLineTokens(e);
    }
    _getLineTokens(e) {
      const t = this.getLineContent(e), i = this._tokens.getTokens(this._languageId, e - 1, t);
      return this._semanticTokens.addSparseTokens(e, i);
    }
    getLanguageId() {
      return this._languageId;
    }
    setMode(e) {
      if (this._languageId === e)
        return;
      const t = {
        oldLanguage: this._languageId,
        newLanguage: e
      };
      this._languageId = e, this._bracketPairColorizer.handleDidChangeLanguage(t), this._tokenization.handleDidChangeLanguage(t), this._onDidChangeLanguage.fire(t), this._onDidChangeLanguageConfiguration.fire({});
    }
    getLanguageIdAtPosition(e, t) {
      const i = this.validatePosition(new V(e, t)), n = this.getLineTokens(i.lineNumber);
      return n.getLanguageId(n.findTokenIndexAtOffset(i.column - 1));
    }
    getTokenTypeIfInsertingCharacter(e, t, i) {
      const n = this.validatePosition(new V(e, t));
      return this._tokenization.getTokenTypeIfInsertingCharacter(n, i);
    }
    tokenizeLineWithEdit(e, t, i) {
      const n = this.validatePosition(e);
      return this._tokenization.tokenizeLineWithEdit(n, t, i);
    }
    getLanguageConfiguration(e) {
      return this._languageConfigurationService.getLanguageConfiguration(e);
    }
    getWordAtPosition(e) {
      this._assertNotDisposed();
      const t = this.validatePosition(e), i = this.getLineContent(t.lineNumber), n = this._getLineTokens(t.lineNumber), o = n.findTokenIndexAtOffset(t.column - 1), [r, a] = id._findLanguageBoundaries(n, o), l = $m(t.column, this.getLanguageConfiguration(n.getLanguageId(o)).getWordDefinition(), i.substring(r, a), r);
      if (l && l.startColumn <= e.column && e.column <= l.endColumn)
        return l;
      if (o > 0 && r === t.column - 1) {
        const [c, d] = id._findLanguageBoundaries(n, o - 1), h = $m(t.column, this.getLanguageConfiguration(n.getLanguageId(o - 1)).getWordDefinition(), i.substring(c, d), c);
        if (h && h.startColumn <= e.column && e.column <= h.endColumn)
          return h;
      }
      return null;
    }
    static _findLanguageBoundaries(e, t) {
      const i = e.getLanguageId(t);
      let n = 0;
      for (let r = t; r >= 0 && e.getLanguageId(r) === i; r--)
        n = e.getStartOffset(r);
      let o = e.getLineContent().length;
      for (let r = t, a = e.getCount(); r < a && e.getLanguageId(r) === i; r++)
        o = e.getEndOffset(r);
      return [n, o];
    }
    getWordUntilPosition(e) {
      const t = this.getWordAtPosition(e);
      return t ? {
        word: t.word.substr(0, e.column - t.startColumn),
        startColumn: t.startColumn,
        endColumn: e.column
      } : {
        word: "",
        startColumn: e.column,
        endColumn: e.column
      };
    }
    normalizePosition(e, t) {
      return e;
    }
    getLineIndentColumn(e) {
      return hG(this.getLineContent(e)) + 1;
    }
  };
  gl.MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
  gl.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
  gl.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
  gl.DEFAULT_CREATION_OPTIONS = {
    isForSimpleWidget: !1,
    tabSize: On.tabSize,
    indentSize: On.indentSize,
    insertSpaces: On.insertSpaces,
    detectIndentation: !1,
    defaultEOL: 1,
    trimAutoWhitespace: On.trimAutoWhitespace,
    largeFileOptimizations: On.largeFileOptimizations,
    bracketPairColorizationOptions: On.bracketPairColorizationOptions
  };
  gl = oG([
    lS(4, uC),
    lS(5, Jt),
    lS(6, Mn)
  ], gl);
  function hG(s) {
    let e = 0;
    for (const t of s)
      if (t === " " || t === "	")
        e++;
      else
        break;
    return e;
  }
  function cS(s) {
    return !!(s.options.overviewRuler && s.options.overviewRuler.color);
  }
  function dS(s) {
    return !!s.options.after || !!s.options.before;
  }
  class oM {
    constructor() {
      this._decorationsTree0 = new sS(), this._decorationsTree1 = new sS(), this._injectedTextDecorationsTree = new sS();
    }
    ensureAllNodesHaveRanges(e) {
      this.getAll(e, 0, !1, !1);
    }
    _ensureNodesHaveRanges(e, t) {
      for (const i of t)
        i.range === null && (i.range = e.getRangeAt(i.cachedAbsoluteStart, i.cachedAbsoluteEnd));
      return t;
    }
    getAllInInterval(e, t, i, n, o) {
      const r = e.getVersionId(), a = this._intervalSearch(t, i, n, o, r);
      return this._ensureNodesHaveRanges(e, a);
    }
    _intervalSearch(e, t, i, n, o) {
      const r = this._decorationsTree0.intervalSearch(e, t, i, n, o), a = this._decorationsTree1.intervalSearch(e, t, i, n, o), l = this._injectedTextDecorationsTree.intervalSearch(e, t, i, n, o);
      return r.concat(a).concat(l);
    }
    getInjectedTextInInterval(e, t, i, n) {
      const o = e.getVersionId(), r = this._injectedTextDecorationsTree.intervalSearch(t, i, n, !1, o);
      return this._ensureNodesHaveRanges(e, r).filter((a) => a.options.showIfCollapsed || !a.range.isEmpty());
    }
    getAllInjectedText(e, t) {
      const i = e.getVersionId(), n = this._injectedTextDecorationsTree.search(t, !1, i);
      return this._ensureNodesHaveRanges(e, n).filter((o) => o.options.showIfCollapsed || !o.range.isEmpty());
    }
    getAll(e, t, i, n) {
      const o = e.getVersionId(), r = this._search(t, i, n, o);
      return this._ensureNodesHaveRanges(e, r);
    }
    _search(e, t, i, n) {
      if (i)
        return this._decorationsTree1.search(e, t, n);
      {
        const o = this._decorationsTree0.search(e, t, n), r = this._decorationsTree1.search(e, t, n), a = this._injectedTextDecorationsTree.search(e, t, n);
        return o.concat(r).concat(a);
      }
    }
    collectNodesFromOwner(e) {
      const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e), n = this._injectedTextDecorationsTree.collectNodesFromOwner(e);
      return t.concat(i).concat(n);
    }
    collectNodesPostOrder() {
      const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder(), i = this._injectedTextDecorationsTree.collectNodesPostOrder();
      return e.concat(t).concat(i);
    }
    insert(e) {
      dS(e) ? this._injectedTextDecorationsTree.insert(e) : cS(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
    }
    delete(e) {
      dS(e) ? this._injectedTextDecorationsTree.delete(e) : cS(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
    }
    getNodeRange(e, t) {
      const i = e.getVersionId();
      return t.cachedVersionId !== i && this._resolveNode(t, i), t.range === null && (t.range = e.getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
    }
    _resolveNode(e, t) {
      dS(e) ? this._injectedTextDecorationsTree.resolveNode(e, t) : cS(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
    }
    acceptReplace(e, t, i, n) {
      this._decorationsTree0.acceptReplace(e, t, i, n), this._decorationsTree1.acceptReplace(e, t, i, n), this._injectedTextDecorationsTree.acceptReplace(e, t, i, n);
    }
  }
  function El(s) {
    return s.replace(/[^a-z0-9\-_]/gi, " ");
  }
  class DF {
    constructor(e) {
      this.color = e.color || "", this.darkColor = e.darkColor || "";
    }
  }
  class uG extends DF {
    constructor(e) {
      super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : Lo.Center;
    }
    getColor(e) {
      return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
    }
    invalidateCachedColor() {
      this._resolvedColor = null;
    }
    _resolveColor(e, t) {
      if (typeof e == "string")
        return e;
      const i = e ? t.getColor(e.id) : null;
      return i ? i.toString() : "";
    }
  }
  class fG extends DF {
    constructor(e) {
      super(e), this.position = e.position;
    }
    getColor(e) {
      return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
    }
    invalidateCachedColor() {
      this._resolvedColor = void 0;
    }
    _resolveColor(e, t) {
      return typeof e == "string" ? H.fromHex(e) : t.getColor(e.id);
    }
  }
  class th {
    constructor(e) {
      this.content = e.content || "", this.inlineClassName = e.inlineClassName || null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.attachedData = e.attachedData || null, this.cursorStops = e.cursorStops || null;
    }
    static from(e) {
      return e instanceof th ? e : new th(e);
    }
  }
  class $e {
    constructor(e) {
      var t, i;
      this.description = e.description, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? El(e.className) : null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new uG(e.overviewRuler) : null, this.minimap = e.minimap ? new fG(e.minimap) : null, this.glyphMarginClassName = e.glyphMarginClassName ? El(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? El(e.linesDecorationsClassName) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? El(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? El(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? El(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? El(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? El(e.afterContentClassName) : null, this.after = e.after ? th.from(e.after) : null, this.before = e.before ? th.from(e.before) : null, this.hideInCommentTokens = (t = e.hideInCommentTokens) !== null && t !== void 0 ? t : !1, this.hideInStringTokens = (i = e.hideInStringTokens) !== null && i !== void 0 ? i : !1;
    }
    static register(e) {
      return new $e(e);
    }
    static createDynamic(e) {
      return new $e(e);
    }
  }
  $e.EMPTY = $e.register({ description: "empty" });
  const rM = [
    $e.register({ description: "tracked-range-always-grows-when-typing-at-edges", stickiness: 0 }),
    $e.register({ description: "tracked-range-never-grows-when-typing-at-edges", stickiness: 1 }),
    $e.register({ description: "tracked-range-grows-only-when-typing-before", stickiness: 2 }),
    $e.register({ description: "tracked-range-grows-only-when-typing-after", stickiness: 3 })
  ];
  function aM(s) {
    return s instanceof $e ? s : $e.createDynamic(s);
  }
  class gG extends z {
    constructor(e) {
      super(), this.handleBeforeFire = e, this._actual = this._register(new B()), this.event = this._actual.event, this._affectedInjectedTextLines = null, this._deferredCnt = 0, this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1;
    }
    beginDeferredEmit() {
      this._deferredCnt++;
    }
    endDeferredEmit() {
      var e;
      if (this._deferredCnt--, this._deferredCnt === 0) {
        if (this._shouldFire) {
          this.handleBeforeFire(this._affectedInjectedTextLines);
          const t = {
            affectsMinimap: this._affectsMinimap,
            affectsOverviewRuler: this._affectsOverviewRuler
          };
          this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._actual.fire(t);
        }
        (e = this._affectedInjectedTextLines) === null || e === void 0 || e.clear(), this._affectedInjectedTextLines = null;
      }
    }
    recordLineAffectedByInjectedText(e) {
      this._affectedInjectedTextLines || (this._affectedInjectedTextLines = /* @__PURE__ */ new Set()), this._affectedInjectedTextLines.add(e);
    }
    checkAffectedAndFire(e) {
      this._affectsMinimap || (this._affectsMinimap = !!(e.minimap && e.minimap.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!(e.overviewRuler && e.overviewRuler.color)), this._shouldFire = !0;
    }
    fire() {
      this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._shouldFire = !0;
    }
  }
  class mG extends z {
    constructor() {
      super(), this._fastEmitter = this._register(new B()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new B()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
    }
    beginDeferredEmit() {
      this._deferredCnt++;
    }
    endDeferredEmit(e = null) {
      if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
        this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
        const t = this._deferredEvent;
        this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
      }
    }
    fire(e) {
      if (this._deferredCnt > 0) {
        this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
        return;
      }
      this._fastEmitter.fire(e), this._slowEmitter.fire(e);
    }
  }
  function hS(s, e) {
    return s === null ? e ? S1.INSTANCE : y1.INSTANCE : new pG(s, e);
  }
  class pG {
    constructor(e, t) {
      this._projectionData = e, this._isVisible = t;
    }
    isVisible() {
      return this._isVisible;
    }
    setVisible(e) {
      return this._isVisible = e, this;
    }
    getProjectionData() {
      return this._projectionData;
    }
    getViewLineCount() {
      return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
    }
    getViewLineContent(e, t, i) {
      this._assertVisible();
      const n = i > 0 ? this._projectionData.breakOffsets[i - 1] : 0, o = this._projectionData.breakOffsets[i];
      let r;
      if (this._projectionData.injectionOffsets !== null) {
        const a = this._projectionData.injectionOffsets.map((c, d) => new vr(0, 0, c + 1, this._projectionData.injectionOptions[d], 0));
        r = vr.applyInjectedText(e.getLineContent(t), a).substring(n, o);
      } else
        r = e.getValueInRange({
          startLineNumber: t,
          startColumn: n + 1,
          endLineNumber: t,
          endColumn: o + 1
        });
      return i > 0 && (r = lM(this._projectionData.wrappedTextIndentLength) + r), r;
    }
    getViewLineLength(e, t, i) {
      return this._assertVisible(), this._projectionData.getLineLength(i);
    }
    getViewLineMinColumn(e, t, i) {
      return this._assertVisible(), this._projectionData.getMinOutputOffset(i) + 1;
    }
    getViewLineMaxColumn(e, t, i) {
      return this._assertVisible(), this._projectionData.getMaxOutputOffset(i) + 1;
    }
    getViewLineData(e, t, i) {
      const n = new Array();
      return this.getViewLinesData(e, t, i, 1, 0, [!0], n), n[0];
    }
    getViewLinesData(e, t, i, n, o, r, a) {
      this._assertVisible();
      const l = this._projectionData, c = l.injectionOffsets, d = l.injectionOptions;
      let h = null;
      if (c) {
        h = [];
        let f = 0, g = 0;
        for (let _ = 0; _ < l.getOutputLineCount(); _++) {
          const b = new Array();
          h[_] = b;
          const C = _ > 0 ? l.breakOffsets[_ - 1] : 0, v = l.breakOffsets[_];
          for (; g < c.length; ) {
            const w = d[g].content.length, S = c[g] + f, L = S + w;
            if (S > v)
              break;
            if (C < L) {
              const x = d[g];
              if (x.inlineClassName) {
                const y = _ > 0 ? l.wrappedTextIndentLength : 0, k = y + Math.max(S - C, 0), I = y + Math.min(L - C, v);
                k !== I && b.push(new zj(k, I, x.inlineClassName, x.inlineClassNameAffectsLetterSpacing));
              }
            }
            if (L <= v)
              f += w, g++;
            else
              break;
          }
        }
      }
      let u;
      c ? u = e.getLineTokens(t).withInserted(c.map((f, g) => ({
        offset: f,
        text: d[g].content,
        tokenMetadata: Fi.defaultTokenMetadata
      }))) : u = e.getLineTokens(t);
      for (let f = i; f < i + n; f++) {
        const g = o + f - i;
        if (!r[g]) {
          a[g] = null;
          continue;
        }
        a[g] = this._getViewLineData(u, h ? h[f] : null, f);
      }
    }
    _getViewLineData(e, t, i) {
      this._assertVisible();
      const n = this._projectionData, o = i > 0 ? n.wrappedTextIndentLength : 0, r = i > 0 ? n.breakOffsets[i - 1] : 0, a = n.breakOffsets[i], l = e.sliceAndInflate(r, a, o);
      let c = l.getLineContent();
      i > 0 && (c = lM(n.wrappedTextIndentLength) + c);
      const d = this._projectionData.getMinOutputOffset(i) + 1, h = c.length + 1, u = i + 1 < this.getViewLineCount(), f = i === 0 ? 0 : n.breakOffsetsVisibleColumn[i - 1];
      return new gE(c, u, d, h, f, l, t);
    }
    getModelColumnOfViewPosition(e, t) {
      return this._assertVisible(), this._projectionData.translateToInputOffset(e, t - 1) + 1;
    }
    getViewPositionOfModelPosition(e, t, i = 2) {
      return this._assertVisible(), this._projectionData.translateToOutputPosition(t - 1, i).toPosition(e);
    }
    getViewLineNumberOfModelPosition(e, t) {
      this._assertVisible();
      const i = this._projectionData.translateToOutputPosition(t - 1);
      return e + i.outputLineIndex;
    }
    normalizePosition(e, t, i) {
      const n = t.lineNumber - e;
      return this._projectionData.normalizeOutputPosition(e, t.column - 1, i).toPosition(n);
    }
    getInjectedTextAt(e, t) {
      return this._projectionData.getInjectedText(e, t - 1);
    }
    _assertVisible() {
      if (!this._isVisible)
        throw new Error("Not supported");
    }
  }
  class S1 {
    constructor() {
    }
    isVisible() {
      return !0;
    }
    setVisible(e) {
      return e ? this : y1.INSTANCE;
    }
    getProjectionData() {
      return null;
    }
    getViewLineCount() {
      return 1;
    }
    getViewLineContent(e, t, i) {
      return e.getLineContent(t);
    }
    getViewLineLength(e, t, i) {
      return e.getLineLength(t);
    }
    getViewLineMinColumn(e, t, i) {
      return e.getLineMinColumn(t);
    }
    getViewLineMaxColumn(e, t, i) {
      return e.getLineMaxColumn(t);
    }
    getViewLineData(e, t, i) {
      const n = e.getLineTokens(t), o = n.getLineContent();
      return new gE(o, !1, 1, o.length + 1, 0, n.inflate(), null);
    }
    getViewLinesData(e, t, i, n, o, r, a) {
      if (!r[o]) {
        a[o] = null;
        return;
      }
      a[o] = this.getViewLineData(e, t, 0);
    }
    getModelColumnOfViewPosition(e, t) {
      return t;
    }
    getViewPositionOfModelPosition(e, t) {
      return new V(e, t);
    }
    getViewLineNumberOfModelPosition(e, t) {
      return e;
    }
    normalizePosition(e, t, i) {
      return t;
    }
    getInjectedTextAt(e, t) {
      return null;
    }
  }
  S1.INSTANCE = new S1();
  class y1 {
    constructor() {
    }
    isVisible() {
      return !1;
    }
    setVisible(e) {
      return e ? S1.INSTANCE : this;
    }
    getProjectionData() {
      return null;
    }
    getViewLineCount() {
      return 0;
    }
    getViewLineContent(e, t, i) {
      throw new Error("Not supported");
    }
    getViewLineLength(e, t, i) {
      throw new Error("Not supported");
    }
    getViewLineMinColumn(e, t, i) {
      throw new Error("Not supported");
    }
    getViewLineMaxColumn(e, t, i) {
      throw new Error("Not supported");
    }
    getViewLineData(e, t, i) {
      throw new Error("Not supported");
    }
    getViewLinesData(e, t, i, n, o, r, a) {
      throw new Error("Not supported");
    }
    getModelColumnOfViewPosition(e, t) {
      throw new Error("Not supported");
    }
    getViewPositionOfModelPosition(e, t) {
      throw new Error("Not supported");
    }
    getViewLineNumberOfModelPosition(e, t) {
      throw new Error("Not supported");
    }
    normalizePosition(e, t, i) {
      throw new Error("Not supported");
    }
    getInjectedTextAt(e, t) {
      throw new Error("Not supported");
    }
  }
  y1.INSTANCE = new y1();
  let uS = [""];
  function lM(s) {
    if (s >= uS.length)
      for (let e = 1; e <= s; e++)
        uS[e] = _G(e);
    return uS[s];
  }
  function _G(s) {
    return new Array(s + 1).join(" ");
  }
  class bG {
    constructor(e) {
      this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
    }
    insertValues(e, t) {
      e = Qh(e);
      const i = this.values, n = this.prefixSum, o = t.length;
      return o === 0 ? !1 : (this.values = new Uint32Array(i.length + o), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + o), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
    }
    setValue(e, t) {
      return e = Qh(e), t = Qh(t), this.values[e] === t ? !1 : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
    }
    removeValues(e, t) {
      e = Qh(e), t = Qh(t);
      const i = this.values, n = this.prefixSum;
      if (e >= i.length)
        return !1;
      const o = i.length - e;
      return t >= o && (t = o), t === 0 ? !1 : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
    }
    getTotalSum() {
      return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
    }
    getPrefixSum(e) {
      return e < 0 ? 0 : (e = Qh(e), this._getPrefixSum(e));
    }
    _getPrefixSum(e) {
      if (e <= this.prefixSumValidIndex[0])
        return this.prefixSum[e];
      let t = this.prefixSumValidIndex[0] + 1;
      t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
      for (let i = t; i <= e; i++)
        this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
      return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
    }
    getIndexOf(e) {
      e = Math.floor(e), this.getTotalSum();
      let t = 0, i = this.values.length - 1, n = 0, o = 0, r = 0;
      for (; t <= i; )
        if (n = t + (i - t) / 2 | 0, o = this.prefixSum[n], r = o - this.values[n], e < r)
          i = n - 1;
        else if (e >= o)
          t = n + 1;
        else
          break;
      return new xF(n, e - r);
    }
  }
  class vG {
    constructor(e) {
      this._values = e, this._isValid = !1, this._validEndIndex = -1, this._prefixSum = [], this._indexBySum = [];
    }
    getTotalSum() {
      return this._ensureValid(), this._indexBySum.length;
    }
    getPrefixSum(e) {
      return this._ensureValid(), e === 0 ? 0 : this._prefixSum[e - 1];
    }
    getIndexOf(e) {
      this._ensureValid();
      const t = this._indexBySum[e], i = t > 0 ? this._prefixSum[t - 1] : 0;
      return new xF(t, e - i);
    }
    removeValues(e, t) {
      this._values.splice(e, t), this._invalidate(e);
    }
    insertValues(e, t) {
      this._values = $v(this._values, e, t), this._invalidate(e);
    }
    _invalidate(e) {
      this._isValid = !1, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
    }
    _ensureValid() {
      if (!this._isValid) {
        for (let e = this._validEndIndex + 1, t = this._values.length; e < t; e++) {
          const i = this._values[e], n = e > 0 ? this._prefixSum[e - 1] : 0;
          this._prefixSum[e] = n + i;
          for (let o = 0; o < i; o++)
            this._indexBySum[n + o] = e;
        }
        this._prefixSum.length = this._values.length, this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1], this._isValid = !0, this._validEndIndex = this._values.length - 1;
      }
    }
    setValue(e, t) {
      this._values[e] !== t && (this._values[e] = t, this._invalidate(e));
    }
  }
  class xF {
    constructor(e, t) {
      this.index = e, this.remainder = t, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = t;
    }
  }
  class CG {
    constructor(e, t, i, n, o, r, a, l, c) {
      this._editorId = e, this.model = t, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = i, this._monospaceLineBreaksComputerFactory = n, this.fontInfo = o, this.tabSize = r, this.wrappingStrategy = a, this.wrappingColumn = l, this.wrappingIndent = c, this._constructLines(!0, null);
    }
    dispose() {
      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
    }
    createCoordinatesConverter() {
      return new SG(this);
    }
    _constructLines(e, t) {
      this.modelLineProjections = [], e && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
      const i = this.model.getLinesContent(), n = this.model.getInjectedTextDecorations(this._editorId), o = i.length, r = this.createLineBreaksComputer(), a = new bf(vr.fromDecorations(n));
      for (let _ = 0; _ < o; _++) {
        const b = a.takeWhile((C) => C.lineNumber === _ + 1);
        r.addRequest(i[_], b, t ? t[_] : null);
      }
      const l = r.finalize(), c = [], d = this.hiddenAreasDecorationIds.map((_) => this.model.getDecorationRange(_)).sort(D.compareRangesUsingStarts);
      let h = 1, u = 0, f = -1, g = f + 1 < d.length ? u + 1 : o + 2;
      for (let _ = 0; _ < o; _++) {
        const b = _ + 1;
        b === g && (f++, h = d[f].startLineNumber, u = d[f].endLineNumber, g = f + 1 < d.length ? u + 1 : o + 2);
        const C = b >= h && b <= u, v = hS(l[_], !C);
        c[_] = v.getViewLineCount(), this.modelLineProjections[_] = v;
      }
      this._validModelVersionId = this.model.getVersionId(), this.projectedModelLineLineCounts = new vG(c);
    }
    getHiddenAreas() {
      return this.hiddenAreasDecorationIds.map((e) => this.model.getDecorationRange(e));
    }
    setHiddenAreas(e) {
      const t = e.map((u) => this.model.validateRange(u)), i = wG(t), n = this.hiddenAreasDecorationIds.map((u) => this.model.getDecorationRange(u)).sort(D.compareRangesUsingStarts);
      if (i.length === n.length) {
        let u = !1;
        for (let f = 0; f < i.length; f++)
          if (!i[f].equalsRange(n[f])) {
            u = !0;
            break;
          }
        if (!u)
          return !1;
      }
      const o = i.map((u) => ({
        range: u,
        options: $e.EMPTY
      }));
      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, o);
      const r = i;
      let a = 1, l = 0, c = -1, d = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2, h = !1;
      for (let u = 0; u < this.modelLineProjections.length; u++) {
        const f = u + 1;
        f === d && (c++, a = r[c].startLineNumber, l = r[c].endLineNumber, d = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2);
        let g = !1;
        if (f >= a && f <= l ? this.modelLineProjections[u].isVisible() && (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!1), g = !0) : (h = !0, this.modelLineProjections[u].isVisible() || (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!0), g = !0)), g) {
          const _ = this.modelLineProjections[u].getViewLineCount();
          this.projectedModelLineLineCounts.setValue(u, _);
        }
      }
      return h || this.setHiddenAreas([]), !0;
    }
    modelPositionIsVisible(e, t) {
      return e < 1 || e > this.modelLineProjections.length ? !1 : this.modelLineProjections[e - 1].isVisible();
    }
    getModelLineViewLineCount(e) {
      return e < 1 || e > this.modelLineProjections.length ? 1 : this.modelLineProjections[e - 1].getViewLineCount();
    }
    setTabSize(e) {
      return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(!1, null), !0);
    }
    setWrappingSettings(e, t, i, n) {
      const o = this.fontInfo.equals(e), r = this.wrappingStrategy === t, a = this.wrappingColumn === i, l = this.wrappingIndent === n;
      if (o && r && a && l)
        return !1;
      const c = o && r && !a && l;
      this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = n;
      let d = null;
      if (c) {
        d = [];
        for (let h = 0, u = this.modelLineProjections.length; h < u; h++)
          d[h] = this.modelLineProjections[h].getProjectionData();
      }
      return this._constructLines(!1, d), !0;
    }
    createLineBreaksComputer() {
      return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);
    }
    onModelFlushed() {
      this._constructLines(!0, null);
    }
    onModelLinesDeleted(e, t, i) {
      if (!e || e <= this._validModelVersionId)
        return null;
      const n = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, o = this.projectedModelLineLineCounts.getPrefixSum(i);
      return this.modelLineProjections.splice(t - 1, i - t + 1), this.projectedModelLineLineCounts.removeValues(t - 1, i - t + 1), new xL(n, o);
    }
    onModelLinesInserted(e, t, i, n) {
      if (!e || e <= this._validModelVersionId)
        return null;
      const o = t > 2 && !this.modelLineProjections[t - 2].isVisible(), r = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1;
      let a = 0;
      const l = [], c = [];
      for (let d = 0, h = n.length; d < h; d++) {
        const u = hS(n[d], !o);
        l.push(u);
        const f = u.getViewLineCount();
        a += f, c[d] = f;
      }
      return this.modelLineProjections = this.modelLineProjections.slice(0, t - 1).concat(l).concat(this.modelLineProjections.slice(t - 1)), this.projectedModelLineLineCounts.insertValues(t - 1, c), new IL(r, r + a - 1);
    }
    onModelLineChanged(e, t, i) {
      if (e !== null && e <= this._validModelVersionId)
        return [!1, null, null, null];
      const n = t - 1, o = this.modelLineProjections[n].getViewLineCount(), r = this.modelLineProjections[n].isVisible(), a = hS(i, r);
      this.modelLineProjections[n] = a;
      const l = this.modelLineProjections[n].getViewLineCount();
      let c = !1, d = 0, h = -1, u = 0, f = -1, g = 0, _ = -1;
      o > l ? (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = d + l - 1, g = h + 1, _ = g + (o - l) - 1, c = !0) : o < l ? (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = d + o - 1, u = h + 1, f = u + (l - o) - 1, c = !0) : (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = d + l - 1), this.projectedModelLineLineCounts.setValue(n, l);
      const b = d <= h ? new iF(d, h) : null, C = u <= f ? new IL(u, f) : null, v = g <= _ ? new xL(g, _) : null;
      return [c, b, C, v];
    }
    acceptVersionId(e) {
      this._validModelVersionId = e, this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible() && this.setHiddenAreas([]);
    }
    getViewLineCount() {
      return this.projectedModelLineLineCounts.getTotalSum();
    }
    _toValidViewLineNumber(e) {
      if (e < 1)
        return 1;
      const t = this.getViewLineCount();
      return e > t ? t : e | 0;
    }
    getActiveIndentGuide(e, t, i) {
      e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
      const n = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), o = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), r = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.guides.getActiveIndentGuide(n.lineNumber, o.lineNumber, r.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), c = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
      return {
        startLineNumber: l.lineNumber,
        endLineNumber: c.lineNumber,
        indent: a.indent
      };
    }
    getViewLineInfo(e) {
      e = this._toValidViewLineNumber(e);
      const t = this.projectedModelLineLineCounts.getIndexOf(e - 1), i = t.index, n = t.remainder;
      return new cM(i + 1, n);
    }
    getMinColumnOfViewLine(e) {
      return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
    }
    getModelStartPositionOfViewLine(e) {
      const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
      return new V(e.modelLineNumber, n);
    }
    getModelEndPositionOfViewLine(e) {
      const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
      return new V(e.modelLineNumber, n);
    }
    getViewLineInfosGroupedByModelRanges(e, t) {
      const i = this.getViewLineInfo(e), n = this.getViewLineInfo(t), o = new Array();
      let r = this.getModelStartPositionOfViewLine(i), a = new Array();
      for (let l = i.modelLineNumber; l <= n.modelLineNumber; l++) {
        const c = this.modelLineProjections[l - 1];
        if (c.isVisible()) {
          const d = l === i.modelLineNumber ? i.modelLineWrappedLineIdx : 0, h = l === n.modelLineNumber ? n.modelLineWrappedLineIdx + 1 : c.getViewLineCount();
          for (let u = d; u < h; u++)
            a.push(new cM(l, u));
        }
        if (!c.isVisible() && r) {
          const d = new V(l - 1, this.model.getLineMaxColumn(l - 1) + 1), h = D.fromPositions(r, d);
          o.push(new dM(h, a)), a = [], r = null;
        } else
          c.isVisible() && !r && (r = new V(l, 1));
      }
      if (r) {
        const l = D.fromPositions(r, this.getModelEndPositionOfViewLine(n));
        o.push(new dM(l, a));
      }
      return o;
    }
    getViewLinesBracketGuides(e, t, i, n) {
      const o = i ? this.convertViewPositionToModelPosition(i.lineNumber, i.column) : null, r = [];
      for (const a of this.getViewLineInfosGroupedByModelRanges(e, t)) {
        const l = a.modelRange.startLineNumber, c = this.model.guides.getLinesBracketGuides(l, a.modelRange.endLineNumber, o, n);
        for (const d of a.viewLines)
          if (d.isWrappedLineContinuation && this.getMinColumnOfViewLine(d) === 1)
            r.push([]);
          else {
            let h = c[d.modelLineNumber - l];
            h = h.map((u) => u.horizontalLine ? new Eu(u.visibleColumn, u.className, new DL(u.horizontalLine.top, this.convertModelPositionToViewPosition(d.modelLineNumber, u.horizontalLine.endColumn).column)) : u), r.push(h);
          }
      }
      return r;
    }
    getViewLinesIndentGuides(e, t) {
      e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
      const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), n = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
      let o = [];
      const r = [], a = [], l = i.lineNumber - 1, c = n.lineNumber - 1;
      let d = null;
      for (let g = l; g <= c; g++) {
        const _ = this.modelLineProjections[g];
        if (_.isVisible()) {
          const b = _.getViewLineNumberOfModelPosition(0, g === l ? i.column : 1), C = _.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(g + 1)), v = C - b + 1;
          let w = 0;
          v > 1 && _.getViewLineMinColumn(this.model, g + 1, C) === 1 && (w = b === 0 ? 1 : 2), r.push(v), a.push(w), d === null && (d = new V(g + 1, 0));
        } else
          d !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(d.lineNumber, g)), d = null);
      }
      d !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(d.lineNumber, n.lineNumber)), d = null);
      const h = t - e + 1, u = new Array(h);
      let f = 0;
      for (let g = 0, _ = o.length; g < _; g++) {
        let b = o[g];
        const C = Math.min(h - f, r[g]), v = a[g];
        let w;
        v === 2 ? w = 0 : v === 1 ? w = 1 : w = C;
        for (let S = 0; S < C; S++)
          S === w && (b = 0), u[f++] = b;
      }
      return u;
    }
    getViewLineContent(e) {
      const t = this.getViewLineInfo(e);
      return this.modelLineProjections[t.modelLineNumber - 1].getViewLineContent(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
    }
    getViewLineLength(e) {
      const t = this.getViewLineInfo(e);
      return this.modelLineProjections[t.modelLineNumber - 1].getViewLineLength(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
    }
    getViewLineMinColumn(e) {
      const t = this.getViewLineInfo(e);
      return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMinColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
    }
    getViewLineMaxColumn(e) {
      const t = this.getViewLineInfo(e);
      return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMaxColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
    }
    getViewLineData(e) {
      const t = this.getViewLineInfo(e);
      return this.modelLineProjections[t.modelLineNumber - 1].getViewLineData(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
    }
    getViewLinesData(e, t, i) {
      e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
      const n = this.projectedModelLineLineCounts.getIndexOf(e - 1);
      let o = e;
      const r = n.index, a = n.remainder, l = [];
      for (let c = r, d = this.model.getLineCount(); c < d; c++) {
        const h = this.modelLineProjections[c];
        if (!h.isVisible())
          continue;
        const u = c === r ? a : 0;
        let f = h.getViewLineCount() - u, g = !1;
        if (o + f > t && (g = !0, f = t - o + 1), h.getViewLinesData(this.model, c + 1, u, f, o - e, i, l), o += f, g)
          break;
      }
      return l;
    }
    validateViewPosition(e, t, i) {
      e = this._toValidViewLineNumber(e);
      const n = this.projectedModelLineLineCounts.getIndexOf(e - 1), o = n.index, r = n.remainder, a = this.modelLineProjections[o], l = a.getViewLineMinColumn(this.model, o + 1, r), c = a.getViewLineMaxColumn(this.model, o + 1, r);
      t < l && (t = l), t > c && (t = c);
      const d = a.getModelColumnOfViewPosition(r, t);
      return this.model.validatePosition(new V(o + 1, d)).equals(i) ? new V(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
    }
    validateViewRange(e, t) {
      const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), n = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
      return new D(i.lineNumber, i.column, n.lineNumber, n.column);
    }
    convertViewPositionToModelPosition(e, t) {
      const i = this.getViewLineInfo(e), n = this.modelLineProjections[i.modelLineNumber - 1].getModelColumnOfViewPosition(i.modelLineWrappedLineIdx, t);
      return this.model.validatePosition(new V(i.modelLineNumber, n));
    }
    convertViewRangeToModelRange(e) {
      const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
      return new D(t.lineNumber, t.column, i.lineNumber, i.column);
    }
    convertModelPositionToViewPosition(e, t, i = 2) {
      const n = this.model.validatePosition(new V(e, t)), o = n.lineNumber, r = n.column;
      let a = o - 1, l = !1;
      for (; a > 0 && !this.modelLineProjections[a].isVisible(); )
        a--, l = !0;
      if (a === 0 && !this.modelLineProjections[a].isVisible())
        return new V(1, 1);
      const c = 1 + this.projectedModelLineLineCounts.getPrefixSum(a);
      let d;
      return l ? d = this.modelLineProjections[a].getViewPositionOfModelPosition(c, this.model.getLineMaxColumn(a + 1), i) : d = this.modelLineProjections[o - 1].getViewPositionOfModelPosition(c, r, i), d;
    }
    convertModelRangeToViewRange(e, t = 0) {
      if (e.isEmpty()) {
        const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, t);
        return D.fromPositions(i);
      } else {
        const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, 1), n = this.convertModelPositionToViewPosition(e.endLineNumber, e.endColumn, 0);
        return new D(i.lineNumber, i.column, n.lineNumber, n.column);
      }
    }
    getViewLineNumberOfModelPosition(e, t) {
      let i = e - 1;
      if (this.modelLineProjections[i].isVisible()) {
        const o = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
        return this.modelLineProjections[i].getViewLineNumberOfModelPosition(o, t);
      }
      for (; i > 0 && !this.modelLineProjections[i].isVisible(); )
        i--;
      if (i === 0 && !this.modelLineProjections[i].isVisible())
        return 1;
      const n = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
      return this.modelLineProjections[i].getViewLineNumberOfModelPosition(n, this.model.getLineMaxColumn(i + 1));
    }
    getDecorationsInRange(e, t, i) {
      const n = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), o = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
      if (o.lineNumber - n.lineNumber <= e.endLineNumber - e.startLineNumber)
        return this.model.getDecorationsInRange(new D(n.lineNumber, 1, o.lineNumber, o.column), t, i);
      let r = [];
      const a = n.lineNumber - 1, l = o.lineNumber - 1;
      let c = null;
      for (let f = a; f <= l; f++)
        if (this.modelLineProjections[f].isVisible())
          c === null && (c = new V(f + 1, f === a ? n.column : 1));
        else if (c !== null) {
          const _ = this.model.getLineMaxColumn(f);
          r = r.concat(this.model.getDecorationsInRange(new D(c.lineNumber, c.column, f, _), t, i)), c = null;
        }
      c !== null && (r = r.concat(this.model.getDecorationsInRange(new D(c.lineNumber, c.column, o.lineNumber, o.column), t, i)), c = null), r.sort((f, g) => {
        const _ = D.compareRangesUsingStarts(f.range, g.range);
        return _ === 0 ? f.id < g.id ? -1 : f.id > g.id ? 1 : 0 : _;
      });
      let d = [], h = 0, u = null;
      for (const f of r) {
        const g = f.id;
        u !== g && (u = g, d[h++] = f);
      }
      return d;
    }
    getInjectedTextAt(e) {
      const t = this.getViewLineInfo(e.lineNumber);
      return this.modelLineProjections[t.modelLineNumber - 1].getInjectedTextAt(t.modelLineWrappedLineIdx, e.column);
    }
    normalizePosition(e, t) {
      const i = this.getViewLineInfo(e.lineNumber);
      return this.modelLineProjections[i.modelLineNumber - 1].normalizePosition(i.modelLineWrappedLineIdx, e, t);
    }
    getLineIndentColumn(e) {
      const t = this.getViewLineInfo(e);
      return t.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(t.modelLineNumber) : 0;
    }
  }
  function wG(s) {
    if (s.length === 0)
      return [];
    const e = s.slice();
    e.sort(D.compareRangesUsingStarts);
    const t = [];
    let i = e[0].startLineNumber, n = e[0].endLineNumber;
    for (let o = 1, r = e.length; o < r; o++) {
      const a = e[o];
      a.startLineNumber > n + 1 ? (t.push(new D(i, 1, n, 1)), i = a.startLineNumber, n = a.endLineNumber) : a.endLineNumber > n && (n = a.endLineNumber);
    }
    return t.push(new D(i, 1, n, 1)), t;
  }
  class cM {
    constructor(e, t) {
      this.modelLineNumber = e, this.modelLineWrappedLineIdx = t;
    }
    get isWrappedLineContinuation() {
      return this.modelLineWrappedLineIdx > 0;
    }
  }
  class dM {
    constructor(e, t) {
      this.modelRange = e, this.viewLines = t;
    }
  }
  class SG {
    constructor(e) {
      this._lines = e;
    }
    convertViewPositionToModelPosition(e) {
      return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
    }
    convertViewRangeToModelRange(e) {
      return this._lines.convertViewRangeToModelRange(e);
    }
    validateViewPosition(e, t) {
      return this._lines.validateViewPosition(e.lineNumber, e.column, t);
    }
    validateViewRange(e, t) {
      return this._lines.validateViewRange(e, t);
    }
    convertModelPositionToViewPosition(e, t) {
      return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column, t);
    }
    convertModelRangeToViewRange(e, t) {
      return this._lines.convertModelRangeToViewRange(e, t);
    }
    modelPositionIsVisible(e) {
      return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
    }
    getModelLineViewLineCount(e) {
      return this._lines.getModelLineViewLineCount(e);
    }
    getViewLineNumberOfModelPosition(e, t) {
      return this._lines.getViewLineNumberOfModelPosition(e, t);
    }
  }
  class yG {
    constructor(e) {
      this.model = e;
    }
    dispose() {
    }
    createCoordinatesConverter() {
      return new LG(this);
    }
    getHiddenAreas() {
      return [];
    }
    setHiddenAreas(e) {
      return !1;
    }
    setTabSize(e) {
      return !1;
    }
    setWrappingSettings(e, t, i, n) {
      return !1;
    }
    createLineBreaksComputer() {
      const e = [];
      return {
        addRequest: (t, i, n) => {
          e.push(null);
        },
        finalize: () => e
      };
    }
    onModelFlushed() {
    }
    onModelLinesDeleted(e, t, i) {
      return new xL(t, i);
    }
    onModelLinesInserted(e, t, i, n) {
      return new IL(t, i);
    }
    onModelLineChanged(e, t, i) {
      return [!1, new iF(t, t), null, null];
    }
    acceptVersionId(e) {
    }
    getViewLineCount() {
      return this.model.getLineCount();
    }
    getActiveIndentGuide(e, t, i) {
      return {
        startLineNumber: e,
        endLineNumber: e,
        indent: 0
      };
    }
    getViewLinesBracketGuides(e, t, i) {
      return new Array(t - e + 1).fill([]);
    }
    getViewLinesIndentGuides(e, t) {
      const i = t - e + 1, n = new Array(i);
      for (let o = 0; o < i; o++)
        n[o] = 0;
      return n;
    }
    getViewLineContent(e) {
      return this.model.getLineContent(e);
    }
    getViewLineLength(e) {
      return this.model.getLineLength(e);
    }
    getViewLineMinColumn(e) {
      return this.model.getLineMinColumn(e);
    }
    getViewLineMaxColumn(e) {
      return this.model.getLineMaxColumn(e);
    }
    getViewLineData(e) {
      const t = this.model.getLineTokens(e), i = t.getLineContent();
      return new gE(i, !1, 1, i.length + 1, 0, t.inflate(), null);
    }
    getViewLinesData(e, t, i) {
      const n = this.model.getLineCount();
      e = Math.min(Math.max(1, e), n), t = Math.min(Math.max(1, t), n);
      const o = [];
      for (let r = e; r <= t; r++) {
        const a = r - e;
        o[a] = i[a] ? this.getViewLineData(r) : null;
      }
      return o;
    }
    getDecorationsInRange(e, t, i) {
      return this.model.getDecorationsInRange(e, t, i);
    }
    normalizePosition(e, t) {
      return this.model.normalizePosition(e, t);
    }
    getLineIndentColumn(e) {
      return this.model.getLineIndentColumn(e);
    }
    getInjectedTextAt(e) {
      return null;
    }
  }
  class LG {
    constructor(e) {
      this._lines = e;
    }
    _validPosition(e) {
      return this._lines.model.validatePosition(e);
    }
    _validRange(e) {
      return this._lines.model.validateRange(e);
    }
    convertViewPositionToModelPosition(e) {
      return this._validPosition(e);
    }
    convertViewRangeToModelRange(e) {
      return this._validRange(e);
    }
    validateViewPosition(e, t) {
      return this._validPosition(t);
    }
    validateViewRange(e, t) {
      return this._validRange(t);
    }
    convertModelPositionToViewPosition(e) {
      return this._validPosition(e);
    }
    convertModelRangeToViewRange(e) {
      return this._validRange(e);
    }
    modelPositionIsVisible(e) {
      const t = this._lines.model.getLineCount();
      return !(e.lineNumber < 1 || e.lineNumber > t);
    }
    getModelLineViewLineCount(e) {
      return 1;
    }
    getViewLineNumberOfModelPosition(e, t) {
      return e;
    }
  }
  class kG extends z {
    constructor(e, t, i, n, o, r, a, l) {
      if (super(), this.languageConfigurationService = a, this._themeService = l, this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new NK(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new Xh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._tokenizeViewportSoon = this._register(new It(() => this.tokenizeViewport(), 50)), this._updateConfigurationViewLineCount = this._register(new It(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStartLine = -1, this._viewportStartLineTrackedRange = null, this._viewportStartLineDelta = 0, this.model.isTooLargeForTokenization())
        this._lines = new yG(this.model);
      else {
        const c = this._configuration.options, d = c.get(44), h = c.get(125), u = c.get(132), f = c.get(124);
        this._lines = new CG(this._editorId, this.model, n, o, d, this.model.getOptions().tabSize, h, u.wrappingColumn, f);
      }
      this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new yf(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new GK(this._configuration, this.getLineCount(), r)), this._register(this.viewLayout.onDidScroll((c) => {
        c.scrollTopChanged && this._tokenizeViewportSoon.schedule(), this._eventDispatcher.emitSingleViewEvent(new kK(c)), this._eventDispatcher.emitOutgoingEvent(new bE(c.oldScrollWidth, c.oldScrollLeft, c.oldScrollHeight, c.oldScrollTop, c.scrollWidth, c.scrollLeft, c.scrollHeight, c.scrollTop));
      })), this._register(this.viewLayout.onDidContentSizeChange((c) => {
        this._eventDispatcher.emitOutgoingEvent(c);
      })), this._decorations = new ZK(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((c) => {
        try {
          const d = this._eventDispatcher.beginEmitViewEvents();
          this._onConfigurationChanged(d, c);
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
      })), this._register(f_.getInstance().onDidChange(() => {
        this._eventDispatcher.emitSingleViewEvent(new IK());
      })), this._register(this._themeService.onDidColorThemeChange((c) => {
        this._invalidateDecorationsColorCache(), this._eventDispatcher.emitSingleViewEvent(new DK(c));
      })), this._updateConfigurationViewLineCountNow();
    }
    dispose() {
      super.dispose(), this._decorations.dispose(), this._lines.dispose(), this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1), this._eventDispatcher.dispose();
    }
    createLineBreaksComputer() {
      return this._lines.createLineBreaksComputer();
    }
    addViewEventHandler(e) {
      this._eventDispatcher.addViewEventHandler(e);
    }
    removeViewEventHandler(e) {
      this._eventDispatcher.removeViewEventHandler(e);
    }
    _updateConfigurationViewLineCountNow() {
      this._configuration.setViewLineCount(this._lines.getViewLineCount());
    }
    tokenizeViewport() {
      const e = this.viewLayout.getLinesViewportData(), t = new D(e.startLineNumber, this.getLineMinColumn(e.startLineNumber), e.endLineNumber, this.getLineMaxColumn(e.endLineNumber)), i = this._toModelVisibleRanges(t);
      for (const n of i)
        this.model.tokenizeViewport(n.startLineNumber, n.endLineNumber);
    }
    setHasFocus(e) {
      this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new yK(e)), this._eventDispatcher.emitOutgoingEvent(new _E(!e, e));
    }
    onCompositionStart() {
      this._eventDispatcher.emitSingleViewEvent(new vK());
    }
    onCompositionEnd() {
      this._eventDispatcher.emitSingleViewEvent(new CK());
    }
    _onConfigurationChanged(e, t) {
      let i = null;
      if (this._viewportStartLine !== -1) {
        const d = new V(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));
        i = this.coordinatesConverter.convertViewPositionToModelPosition(d);
      }
      let n = !1;
      const o = this._configuration.options, r = o.get(44), a = o.get(125), l = o.get(132), c = o.get(124);
      if (this._lines.setWrappingSettings(r, a, l.wrappingColumn, c) && (e.emitViewEvent(new X_()), e.emitViewEvent(new Q_()), e.emitViewEvent(new Jh(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.getCurrentScrollTop() !== 0 && (n = !0), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(81) && (this._decorations.reset(), e.emitViewEvent(new Jh(null))), e.emitViewEvent(new wK(t)), this.viewLayout.onConfigurationChanged(t), n && i) {
        const d = this.coordinatesConverter.convertModelPositionToViewPosition(i), h = this.viewLayout.getVerticalOffsetForLineNumber(d.lineNumber);
        this.viewLayout.setScrollPosition({ scrollTop: h + this._viewportStartLineDelta }, 1);
      }
      Xh.shouldRecreate(t) && (this.cursorConfig = new Xh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
    }
    _registerModelEvents() {
      this._register(this.model.onDidChangeContentOrInjectedText((e) => {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          let i = !1, n = !1;
          const o = e.changes, r = e instanceof Od ? e.versionId : null, a = this._lines.createLineBreaksComputer();
          for (const d of o)
            switch (d.changeType) {
              case 4: {
                for (let h = 0; h < d.detail.length; h++) {
                  const u = d.detail[h];
                  let f = d.injectedTexts[h];
                  f && (f = f.filter((g) => !g.ownerId || g.ownerId === this._editorId)), a.addRequest(u, f, null);
                }
                break;
              }
              case 2: {
                let h = null;
                d.injectedText && (h = d.injectedText.filter((u) => !u.ownerId || u.ownerId === this._editorId)), a.addRequest(d.detail, h, null);
                break;
              }
            }
          const l = a.finalize(), c = new bf(l);
          for (const d of o)
            switch (d.changeType) {
              case 1: {
                this._lines.onModelFlushed(), t.emitViewEvent(new X_()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), i = !0;
                break;
              }
              case 3: {
                const h = this._lines.onModelLinesDeleted(r, d.fromLineNumber, d.toLineNumber);
                h !== null && (t.emitViewEvent(h), this.viewLayout.onLinesDeleted(h.fromLineNumber, h.toLineNumber)), i = !0;
                break;
              }
              case 4: {
                const h = c.takeCount(d.detail.length), u = this._lines.onModelLinesInserted(r, d.fromLineNumber, d.toLineNumber, h);
                u !== null && (t.emitViewEvent(u), this.viewLayout.onLinesInserted(u.fromLineNumber, u.toLineNumber)), i = !0;
                break;
              }
              case 2: {
                const h = c.dequeue(), [u, f, g, _] = this._lines.onModelLineChanged(r, d.lineNumber, h);
                n = u, f && t.emitViewEvent(f), g && (t.emitViewEvent(g), this.viewLayout.onLinesInserted(g.fromLineNumber, g.toLineNumber)), _ && (t.emitViewEvent(_), this.viewLayout.onLinesDeleted(_.fromLineNumber, _.toLineNumber));
                break;
              }
              case 5:
                break;
            }
          r !== null && this._lines.acceptVersionId(r), this.viewLayout.onHeightMaybeChanged(), !i && n && (t.emitViewEvent(new Q_()), t.emitViewEvent(new Jh(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        if (this._viewportStartLine = -1, this._configuration.setModelLineCount(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {
          const t = this.model._getTrackedRange(this._viewportStartLineTrackedRange);
          if (t) {
            const i = this.coordinatesConverter.convertModelPositionToViewPosition(t.getStartPosition()), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber);
            this.viewLayout.setScrollPosition({ scrollTop: n + this._viewportStartLineDelta }, 1);
          }
        }
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          this._cursor.onModelContentChanged(t, e);
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._tokenizeViewportSoon.schedule();
      })), this._register(this.model.onDidChangeTokens((e) => {
        const t = [];
        for (let i = 0, n = e.ranges.length; i < n; i++) {
          const o = e.ranges[i], r = this.coordinatesConverter.convertModelPositionToViewPosition(new V(o.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new V(o.toLineNumber, this.model.getLineMaxColumn(o.toLineNumber))).lineNumber;
          t[i] = {
            fromLineNumber: r,
            toLineNumber: a
          };
        }
        this._eventDispatcher.emitSingleViewEvent(new xK(t)), e.tokenizationSupportChanged && this._tokenizeViewportSoon.schedule();
      })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
        this._eventDispatcher.emitSingleViewEvent(new LK()), this.cursorConfig = new Xh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig);
      })), this._register(this.model.onDidChangeLanguage((e) => {
        this.cursorConfig = new Xh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig);
      })), this._register(this.model.onDidChangeOptions((e) => {
        if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
          try {
            const t = this._eventDispatcher.beginEmitViewEvents();
            t.emitViewEvent(new X_()), t.emitViewEvent(new Q_()), t.emitViewEvent(new Jh(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
          } finally {
            this._eventDispatcher.endEmitViewEvents();
          }
          this._updateConfigurationViewLineCount.schedule();
        }
        this.cursorConfig = new Xh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig);
      })), this._register(this.model.onDidChangeDecorations((e) => {
        this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new Jh(e));
      }));
    }
    setHiddenAreas(e) {
      let t = !1;
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        t = this._lines.setHiddenAreas(e), t && (i.emitViewEvent(new X_()), i.emitViewEvent(new Q_()), i.emitViewEvent(new Jh(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      this._updateConfigurationViewLineCount.schedule(), t && this._eventDispatcher.emitOutgoingEvent(new OT());
    }
    getVisibleRangesPlusViewportAboveBelow() {
      const e = this._configuration.options.get(131), t = this._configuration.options.get(59), i = Math.max(20, Math.round(e.height / t)), n = this.viewLayout.getLinesViewportData(), o = Math.max(1, n.completelyVisibleStartLineNumber - i), r = Math.min(this.getLineCount(), n.completelyVisibleEndLineNumber + i);
      return this._toModelVisibleRanges(new D(o, this.getLineMinColumn(o), r, this.getLineMaxColumn(r)));
    }
    getVisibleRanges() {
      const e = this.getCompletelyVisibleViewRange();
      return this._toModelVisibleRanges(e);
    }
    _toModelVisibleRanges(e) {
      const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
      if (i.length === 0)
        return [t];
      const n = [];
      let o = 0, r = t.startLineNumber, a = t.startColumn;
      const l = t.endLineNumber, c = t.endColumn;
      for (let d = 0, h = i.length; d < h; d++) {
        const u = i[d].startLineNumber, f = i[d].endLineNumber;
        f < r || u > l || (r < u && (n[o++] = new D(r, a, u - 1, this.model.getLineMaxColumn(u - 1))), r = f + 1, a = 1);
      }
      return (r < l || r === l && a < c) && (n[o++] = new D(r, a, l, c)), n;
    }
    getCompletelyVisibleViewRange() {
      const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
      return new D(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
    }
    getCompletelyVisibleViewRangeAtScrollTop(e) {
      const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, n = t.completelyVisibleEndLineNumber;
      return new D(i, this.getLineMinColumn(i), n, this.getLineMaxColumn(n));
    }
    saveState() {
      const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), n = this.coordinatesConverter.convertViewPositionToModelPosition(new V(i, this.getLineMinColumn(i))), o = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
      return {
        scrollLeft: e.scrollLeft,
        firstPosition: n,
        firstPositionDeltaTop: o
      };
    }
    reduceRestoreState(e) {
      if (typeof e.firstPosition > "u")
        return this._reduceRestoreStateCompatibility(e);
      const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
      return {
        scrollLeft: e.scrollLeft,
        scrollTop: n
      };
    }
    _reduceRestoreStateCompatibility(e) {
      return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTopWithoutViewZones
      };
    }
    getTabSize() {
      return this.model.getOptions().tabSize;
    }
    getLineCount() {
      return this._lines.getViewLineCount();
    }
    setViewport(e, t, i) {
      this._viewportStartLine = e;
      const n = this.coordinatesConverter.convertViewPositionToModelPosition(new V(e, this.getLineMinColumn(e)));
      this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new D(n.lineNumber, n.column, n.lineNumber, n.column), 1);
      const o = this.viewLayout.getVerticalOffsetForLineNumber(e), r = this.viewLayout.getCurrentScrollTop();
      this._viewportStartLineDelta = r - o;
    }
    getActiveIndentGuide(e, t, i) {
      return this._lines.getActiveIndentGuide(e, t, i);
    }
    getLinesIndentGuides(e, t) {
      return this._lines.getViewLinesIndentGuides(e, t);
    }
    getBracketGuidesInRangeByLine(e, t, i, n) {
      return this._lines.getViewLinesBracketGuides(e, t, i, n);
    }
    getLineContent(e) {
      return this._lines.getViewLineContent(e);
    }
    getLineLength(e) {
      return this._lines.getViewLineLength(e);
    }
    getLineMinColumn(e) {
      return this._lines.getViewLineMinColumn(e);
    }
    getLineMaxColumn(e) {
      return this._lines.getViewLineMaxColumn(e);
    }
    getLineFirstNonWhitespaceColumn(e) {
      const t = jn(this.getLineContent(e));
      return t === -1 ? 0 : t + 1;
    }
    getLineLastNonWhitespaceColumn(e) {
      const t = ia(this.getLineContent(e));
      return t === -1 ? 0 : t + 2;
    }
    getDecorationsInViewport(e) {
      return this._decorations.getDecorationsViewportData(e).decorations;
    }
    getInjectedTextAt(e) {
      return this._lines.getInjectedTextAt(e);
    }
    getViewLineRenderingData(e, t) {
      const i = this.model.mightContainRTL(), n = this.model.mightContainNonBasicASCII(), o = this.getTabSize(), r = this._lines.getViewLineData(t);
      let l = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
      return r.inlineDecorations && (l = [
        ...l,
        ...r.inlineDecorations.map((c) => c.toInlineDecoration(t))
      ]), new Js(r.minColumn, r.maxColumn, r.content, r.continuesWithWrappedLine, i, n, r.tokens, l, o, r.startVisibleColumn);
    }
    getViewLineData(e) {
      return this._lines.getViewLineData(e);
    }
    getMinimapLinesRenderingData(e, t, i) {
      const n = this._lines.getViewLinesData(e, t, i);
      return new Hj(this.getTabSize(), n);
    }
    getAllOverviewRulerDecorations(e) {
      const t = this.model.getOverviewRulerDecorations(this._editorId, o1(this._configuration.options)), i = new DG();
      for (const n of t) {
        const o = n.options, r = o.overviewRuler;
        if (!r)
          continue;
        const a = r.position;
        if (a === 0)
          continue;
        const l = r.getColor(e.value), c = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.startLineNumber, n.range.startColumn), d = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.endLineNumber, n.range.endColumn);
        i.accept(l, o.zIndex, c, d, a);
      }
      return i.asArray;
    }
    _invalidateDecorationsColorCache() {
      const e = this.model.getOverviewRulerDecorations();
      for (const t of e) {
        const i = t.options.overviewRuler;
        i && i.invalidateCachedColor();
        const n = t.options.minimap;
        n && n.invalidateCachedColor();
      }
    }
    getValueInRange(e, t) {
      const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
      return this.model.getValueInRange(i, t);
    }
    deduceModelPositionRelativeToViewPosition(e, t, i) {
      const n = this.coordinatesConverter.convertViewPositionToModelPosition(e);
      this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
      const r = this.model.getOffsetAt(n) + t;
      return this.model.getPositionAt(r);
    }
    getPlainTextToCopy(e, t, i) {
      const n = i ? `\r
` : this.model.getEOL();
      e = e.slice(0), e.sort(D.compareRangesUsingStarts);
      let o = !1, r = !1;
      for (const l of e)
        l.isEmpty() ? o = !0 : r = !0;
      if (!r) {
        if (!t)
          return "";
        const l = e.map((d) => d.startLineNumber);
        let c = "";
        for (let d = 0; d < l.length; d++)
          d > 0 && l[d - 1] === l[d] || (c += this.model.getLineContent(l[d]) + n);
        return c;
      }
      if (o && t) {
        const l = [];
        let c = 0;
        for (const d of e) {
          const h = d.startLineNumber;
          d.isEmpty() ? h !== c && l.push(this.model.getLineContent(h)) : l.push(this.model.getValueInRange(d, i ? 2 : 0)), c = h;
        }
        return l.length === 1 ? l[0] : l;
      }
      const a = [];
      for (const l of e)
        l.isEmpty() || a.push(this.model.getValueInRange(l, i ? 2 : 0));
      return a.length === 1 ? a[0] : a;
    }
    getRichTextToCopy(e, t) {
      const i = this.model.getLanguageId();
      if (i === ya || e.length !== 1)
        return null;
      let n = e[0];
      if (n.isEmpty()) {
        if (!t)
          return null;
        const d = n.startLineNumber;
        n = new D(d, this.model.getLineMinColumn(d), d, this.model.getLineMaxColumn(d));
      }
      const o = this._configuration.options.get(44), r = this._getColorMap(), l = /[:;\\\/<>]/.test(o.fontFamily) || o.fontFamily === Fn.fontFamily;
      let c;
      return l ? c = Fn.fontFamily : (c = o.fontFamily, c = c.replace(/"/g, "'"), /[,']/.test(c) || /[+ ]/.test(c) && (c = `'${c}'`), c = `${c}, ${Fn.fontFamily}`), {
        mode: i,
        html: `<div style="color: ${r[1]};background-color: ${r[2]};font-family: ${c};font-weight: ${o.fontWeight};font-size: ${o.fontSize}px;line-height: ${o.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(n, r) + "</div>"
      };
    }
    _getHTMLToCopy(e, t) {
      const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn, a = this.getTabSize();
      let l = "";
      for (let c = i; c <= o; c++) {
        const d = this.model.getLineTokens(c), h = d.getLineContent(), u = c === i ? n - 1 : 0, f = c === o ? r - 1 : h.length;
        h === "" ? l += "<br>" : l += UK(h, d.inflate(), t, u, f, a, rn);
      }
      return l;
    }
    _getColorMap() {
      const e = Yt.getColorMap(), t = ["#000000"];
      if (e)
        for (let i = 1, n = e.length; i < n; i++)
          t[i] = H.Format.CSS.formatHex(e[i]);
      return t;
    }
    getPrimaryCursorState() {
      return this._cursor.getPrimaryCursorState();
    }
    getLastAddedCursorIndex() {
      return this._cursor.getLastAddedCursorIndex();
    }
    getCursorStates() {
      return this._cursor.getCursorStates();
    }
    setCursorStates(e, t, i) {
      return this._withViewEventsCollector((n) => this._cursor.setStates(n, e, t, i));
    }
    getCursorColumnSelectData() {
      return this._cursor.getCursorColumnSelectData();
    }
    getCursorAutoClosedCharacters() {
      return this._cursor.getAutoClosedCharacters();
    }
    setCursorColumnSelectData(e) {
      this._cursor.setCursorColumnSelectData(e);
    }
    getPrevEditOperationType() {
      return this._cursor.getPrevEditOperationType();
    }
    setPrevEditOperationType(e) {
      this._cursor.setPrevEditOperationType(e);
    }
    getSelection() {
      return this._cursor.getSelection();
    }
    getSelections() {
      return this._cursor.getSelections();
    }
    getPosition() {
      return this._cursor.getPrimaryCursorState().modelState.position;
    }
    setSelections(e, t, i = 0) {
      this._withViewEventsCollector((n) => this._cursor.setSelections(n, e, t, i));
    }
    saveCursorState() {
      return this._cursor.saveState();
    }
    restoreCursorState(e) {
      this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
    }
    _executeCursorEdit(e) {
      if (this._cursor.context.cursorConfig.readOnly) {
        this._eventDispatcher.emitOutgoingEvent(new MK());
        return;
      }
      this._withViewEventsCollector(e);
    }
    executeEdits(e, t, i) {
      this._executeCursorEdit((n) => this._cursor.executeEdits(n, e, t, i));
    }
    startComposition() {
      this._cursor.setIsDoingComposition(!0), this._executeCursorEdit((e) => this._cursor.startComposition(e));
    }
    endComposition(e) {
      this._cursor.setIsDoingComposition(!1), this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
    }
    type(e, t) {
      this._executeCursorEdit((i) => this._cursor.type(i, e, t));
    }
    compositionType(e, t, i, n, o) {
      this._executeCursorEdit((r) => this._cursor.compositionType(r, e, t, i, n, o));
    }
    paste(e, t, i, n) {
      this._executeCursorEdit((o) => this._cursor.paste(o, e, t, i, n));
    }
    cut(e) {
      this._executeCursorEdit((t) => this._cursor.cut(t, e));
    }
    executeCommand(e, t) {
      this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
    }
    executeCommands(e, t) {
      this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
    }
    revealPrimaryCursor(e, t, i = !1) {
      this._withViewEventsCollector((n) => this._cursor.revealPrimary(n, e, i, 0, t, 0));
    }
    revealTopMostCursor(e) {
      const t = this._cursor.getTopMostViewPosition(), i = new D(t.lineNumber, t.column, t.lineNumber, t.column);
      this._withViewEventsCollector((n) => n.emitViewEvent(new h0(e, !1, i, null, 0, !0, 0)));
    }
    revealBottomMostCursor(e) {
      const t = this._cursor.getBottomMostViewPosition(), i = new D(t.lineNumber, t.column, t.lineNumber, t.column);
      this._withViewEventsCollector((n) => n.emitViewEvent(new h0(e, !1, i, null, 0, !0, 0)));
    }
    revealRange(e, t, i, n, o) {
      this._withViewEventsCollector((r) => r.emitViewEvent(new h0(e, !1, i, null, n, t, o)));
    }
    changeWhitespace(e) {
      this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new EK()), this._eventDispatcher.emitOutgoingEvent(new OT()));
    }
    _withViewEventsCollector(e) {
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        return e(t);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    }
    normalizePosition(e, t) {
      return this._lines.normalizePosition(e, t);
    }
    getLineIndentColumn(e) {
      return this._lines.getLineIndentColumn(e);
    }
  }
  class DG {
    constructor() {
      this._asMap = /* @__PURE__ */ Object.create(null), this.asArray = [];
    }
    accept(e, t, i, n, o) {
      const r = this._asMap[e];
      if (r) {
        const a = r.data, l = a[a.length - 3], c = a[a.length - 1];
        if (l === o && c + 1 >= i) {
          n > c && (a[a.length - 1] = n);
          return;
        }
        a.push(o, i, n);
      } else {
        const a = new eF(e, t, [o, i, n]);
        this._asMap[e] = a, this.asArray.push(a);
      }
    }
  }
  class fC {
    constructor(...e) {
      this._entries = /* @__PURE__ */ new Map();
      for (let [t, i] of e)
        this.set(t, i);
    }
    set(e, t) {
      const i = this._entries.get(e);
      return this._entries.set(e, t), i;
    }
    get(e) {
      return this._entries.get(e);
    }
  }
  var dp;
  (function(s) {
    s[s.Ignore = 0] = "Ignore", s[s.Info = 1] = "Info", s[s.Warning = 2] = "Warning", s[s.Error = 3] = "Error";
  })(dp || (dp = {}));
  (function(s) {
    const e = "error", t = "warning", i = "warn", n = "info", o = "ignore";
    function r(l) {
      return l ? Su(e, l) ? s.Error : Su(t, l) || Su(i, l) ? s.Warning : Su(n, l) ? s.Info : s.Ignore : s.Ignore;
    }
    s.fromValue = r;
    function a(l) {
      switch (l) {
        case s.Error:
          return e;
        case s.Warning:
          return t;
        case s.Info:
          return n;
        default:
          return o;
      }
    }
    s.toString = a;
  })(dp || (dp = {}));
  const Zt = dp;
  var IF = Zt;
  const yi = st("notificationService");
  class xG {
  }
  class Cm {
    constructor(e, t, i, n, o) {
      this.injectionOffsets = e, this.injectionOptions = t, this.breakOffsets = i, this.breakOffsetsVisibleColumn = n, this.wrappedTextIndentLength = o;
    }
    getOutputLineCount() {
      return this.breakOffsets.length;
    }
    getMinOutputOffset(e) {
      return e > 0 ? this.wrappedTextIndentLength : 0;
    }
    getLineLength(e) {
      const t = e > 0 ? this.breakOffsets[e - 1] : 0;
      let n = this.breakOffsets[e] - t;
      return e > 0 && (n += this.wrappedTextIndentLength), n;
    }
    getMaxOutputOffset(e) {
      return this.getLineLength(e);
    }
    translateToInputOffset(e, t) {
      e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength));
      let n = e === 0 ? t : this.breakOffsets[e - 1] + t;
      if (this.injectionOffsets !== null)
        for (let o = 0; o < this.injectionOffsets.length && n > this.injectionOffsets[o]; o++)
          n < this.injectionOffsets[o] + this.injectionOptions[o].content.length ? n = this.injectionOffsets[o] : n -= this.injectionOptions[o].content.length;
      return n;
    }
    translateToOutputPosition(e, t = 2) {
      let i = e;
      if (this.injectionOffsets !== null)
        for (let n = 0; n < this.injectionOffsets.length && !(e < this.injectionOffsets[n] || t !== 1 && e === this.injectionOffsets[n]); n++)
          i += this.injectionOptions[n].content.length;
      return this.offsetInInputWithInjectionsToOutputPosition(i, t);
    }
    offsetInInputWithInjectionsToOutputPosition(e, t = 2) {
      let i = 0, n = this.breakOffsets.length - 1, o = 0, r = 0;
      for (; i <= n; ) {
        o = i + (n - i) / 2 | 0;
        const l = this.breakOffsets[o];
        if (r = o > 0 ? this.breakOffsets[o - 1] : 0, t === 0)
          if (e <= r)
            n = o - 1;
          else if (e > l)
            i = o + 1;
          else
            break;
        else if (e < r)
          n = o - 1;
        else if (e >= l)
          i = o + 1;
        else
          break;
      }
      let a = e - r;
      return o > 0 && (a += this.wrappedTextIndentLength), new ab(o, a);
    }
    normalizeOutputPosition(e, t, i) {
      if (this.injectionOffsets !== null) {
        const n = this.outputPositionToOffsetInInputWithInjections(e, t), o = this.normalizeOffsetInInputWithInjectionsAroundInjections(n, i);
        if (o !== n)
          return this.offsetInInputWithInjectionsToOutputPosition(o, i);
      }
      if (i === 0) {
        if (e > 0 && t === this.getMinOutputOffset(e))
          return new ab(e - 1, this.getMaxOutputOffset(e - 1));
      } else if (i === 1) {
        const n = this.getOutputLineCount() - 1;
        if (e < n && t === this.getMaxOutputOffset(e))
          return new ab(e + 1, this.getMinOutputOffset(e + 1));
      }
      return new ab(e, t);
    }
    outputPositionToOffsetInInputWithInjections(e, t) {
      return e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength)), (e > 0 ? this.breakOffsets[e - 1] : 0) + t;
    }
    normalizeOffsetInInputWithInjectionsAroundInjections(e, t) {
      const i = this.getInjectedTextAtOffset(e);
      if (!i)
        return e;
      if (t === 2) {
        if (e === i.offsetInInputWithInjections + i.length && hM(this.injectionOptions[i.injectedTextIndex].cursorStops))
          return i.offsetInInputWithInjections + i.length;
        {
          let n = i.offsetInInputWithInjections;
          if (uM(this.injectionOptions[i.injectedTextIndex].cursorStops))
            return n;
          let o = i.injectedTextIndex - 1;
          for (; o >= 0 && this.injectionOffsets[o] === this.injectionOffsets[i.injectedTextIndex] && !(hM(this.injectionOptions[o].cursorStops) || (n -= this.injectionOptions[o].content.length, uM(this.injectionOptions[o].cursorStops))); )
            o--;
          return n;
        }
      } else if (t === 1) {
        let n = i.offsetInInputWithInjections + i.length, o = i.injectedTextIndex;
        for (; o + 1 < this.injectionOffsets.length && this.injectionOffsets[o + 1] === this.injectionOffsets[o]; )
          n += this.injectionOptions[o + 1].content.length, o++;
        return n;
      } else if (t === 0) {
        let n = i.offsetInInputWithInjections, o = i.injectedTextIndex;
        for (; o - 1 >= 0 && this.injectionOffsets[o - 1] === this.injectionOffsets[o]; )
          n -= this.injectionOptions[o - 1].content.length, o--;
        return n;
      }
      _I();
    }
    getInjectedText(e, t) {
      const i = this.outputPositionToOffsetInInputWithInjections(e, t), n = this.getInjectedTextAtOffset(i);
      return n ? {
        options: this.injectionOptions[n.injectedTextIndex]
      } : null;
    }
    getInjectedTextAtOffset(e) {
      const t = this.injectionOffsets, i = this.injectionOptions;
      if (t !== null) {
        let n = 0;
        for (let o = 0; o < t.length; o++) {
          const r = i[o].content.length, a = t[o] + n, l = t[o] + n + r;
          if (a > e)
            break;
          if (e <= l)
            return {
              injectedTextIndex: o,
              offsetInInputWithInjections: a,
              length: r
            };
          n += r;
        }
      }
    }
  }
  function hM(s) {
    return s == null ? !0 : s === Jr.Right || s === Jr.Both;
  }
  function uM(s) {
    return s == null ? !0 : s === Jr.Left || s === Jr.Both;
  }
  class ab {
    constructor(e, t) {
      this.outputLineIndex = e, this.outputOffset = t;
    }
    toString() {
      return `${this.outputLineIndex}:${this.outputOffset}`;
    }
    toPosition(e) {
      return new V(e + this.outputLineIndex, this.outputOffset + 1);
    }
  }
  class RE {
    constructor(e, t) {
      this.classifier = new IG(e, t);
    }
    static create(e) {
      return new RE(e.get(120), e.get(119));
    }
    createLineBreaksComputer(e, t, i, n) {
      const o = [], r = [], a = [];
      return {
        addRequest: (l, c, d) => {
          o.push(l), r.push(c), a.push(d);
        },
        finalize: () => {
          const l = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth, c = [];
          for (let d = 0, h = o.length; d < h; d++) {
            const u = r[d], f = a[d];
            f && !f.injectionOptions && !u ? c[d] = EG(this.classifier, f, o[d], t, i, l, n) : c[d] = NG(this.classifier, o[d], u, t, i, l, n);
          }
          return OL.length = 0, PL.length = 0, c;
        }
      };
    }
  }
  class IG extends eg {
    constructor(e, t) {
      super(0);
      for (let i = 0; i < e.length; i++)
        this.set(e.charCodeAt(i), 1);
      for (let i = 0; i < t.length; i++)
        this.set(t.charCodeAt(i), 2);
    }
    get(e) {
      return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
    }
  }
  let OL = [], PL = [];
  function EG(s, e, t, i, n, o, r) {
    if (n === -1)
      return null;
    const a = t.length;
    if (a <= 1)
      return null;
    const l = e.breakOffsets, c = e.breakOffsetsVisibleColumn, d = EF(t, i, n, o, r), h = n - d, u = OL, f = PL;
    let g = 0, _ = 0, b = 0, C = n;
    const v = l.length;
    let w = 0;
    if (w >= 0) {
      let S = Math.abs(c[w] - C);
      for (; w + 1 < v; ) {
        const L = Math.abs(c[w + 1] - C);
        if (L >= S)
          break;
        S = L, w++;
      }
    }
    for (; w < v; ) {
      let S = w < 0 ? 0 : l[w], L = w < 0 ? 0 : c[w];
      _ > S && (S = _, L = b);
      let x = 0, y = 0, k = 0, I = 0;
      if (L <= C) {
        let R = L, $ = S === 0 ? 0 : t.charCodeAt(S - 1), j = S === 0 ? 0 : s.get($), le = !0;
        for (let he = S; he < a; he++) {
          const Ce = he, Ne = t.charCodeAt(he);
          let xe, Ve;
          if (Pi(Ne) ? (he++, xe = 0, Ve = 2) : (xe = s.get(Ne), Ve = wm(Ne, R, i, o)), Ce > _ && FL($, j, Ne, xe) && (x = Ce, y = R), R += Ve, R > C) {
            Ce > _ ? (k = Ce, I = R - Ve) : (k = he + 1, I = R), R - y > h && (x = 0), le = !1;
            break;
          }
          $ = Ne, j = xe;
        }
        if (le) {
          g > 0 && (u[g] = l[l.length - 1], f[g] = c[l.length - 1], g++);
          break;
        }
      }
      if (x === 0) {
        let R = L, $ = t.charCodeAt(S), j = s.get($), le = !1;
        for (let he = S - 1; he >= _; he--) {
          const Ce = he + 1, Ne = t.charCodeAt(he);
          if (Ne === 9) {
            le = !0;
            break;
          }
          let xe, Ve;
          if (Kd(Ne) ? (he--, xe = 0, Ve = 2) : (xe = s.get(Ne), Ve = _c(Ne) ? o : 1), R <= C) {
            if (k === 0 && (k = Ce, I = R), R <= C - h)
              break;
            if (FL(Ne, xe, $, j)) {
              x = Ce, y = R;
              break;
            }
          }
          R -= Ve, $ = Ne, j = xe;
        }
        if (x !== 0) {
          const he = h - (I - y);
          if (he <= i) {
            const Ce = t.charCodeAt(k);
            let Ne;
            Pi(Ce) ? Ne = 2 : Ne = wm(Ce, I, i, o), he - Ne < 0 && (x = 0);
          }
        }
        if (le) {
          w--;
          continue;
        }
      }
      if (x === 0 && (x = k, y = I), x <= _) {
        const R = t.charCodeAt(_);
        Pi(R) ? (x = _ + 2, y = b + 2) : (x = _ + 1, y = b + wm(R, b, i, o));
      }
      for (_ = x, u[g] = x, b = y, f[g] = y, g++, C = y + h; w < 0 || w < v && c[w] < y; )
        w++;
      let F = Math.abs(c[w] - C);
      for (; w + 1 < v; ) {
        const R = Math.abs(c[w + 1] - C);
        if (R >= F)
          break;
        F = R, w++;
      }
    }
    return g === 0 ? null : (u.length = g, f.length = g, OL = e.breakOffsets, PL = e.breakOffsetsVisibleColumn, e.breakOffsets = u, e.breakOffsetsVisibleColumn = f, e.wrappedTextIndentLength = d, e);
  }
  function NG(s, e, t, i, n, o, r) {
    const a = vr.applyInjectedText(e, t);
    let l, c;
    if (t && t.length > 0 ? (l = t.map((y) => y.options), c = t.map((y) => y.column - 1)) : (l = null, c = null), n === -1)
      return l ? new Cm(c, l, [a.length], [], 0) : null;
    const d = a.length;
    if (d <= 1)
      return l ? new Cm(c, l, [a.length], [], 0) : null;
    const h = EF(a, i, n, o, r), u = n - h, f = [], g = [];
    let _ = 0, b = 0, C = 0, v = n, w = a.charCodeAt(0), S = s.get(w), L = wm(w, 0, i, o), x = 1;
    Pi(w) && (L += 1, w = a.charCodeAt(1), S = s.get(w), x++);
    for (let y = x; y < d; y++) {
      const k = y, I = a.charCodeAt(y);
      let F, R;
      Pi(I) ? (y++, F = 0, R = 2) : (F = s.get(I), R = wm(I, L, i, o)), FL(w, S, I, F) && (b = k, C = L), L += R, L > v && ((b === 0 || L - C > u) && (b = k, C = L - R), f[_] = b, g[_] = C, _++, v = C + u, b = 0), w = I, S = F;
    }
    return _ === 0 && (!t || t.length === 0) ? null : (f[_] = d, g[_] = L, new Cm(c, l, f, g, h));
  }
  function wm(s, e, t, i) {
    return s === 9 ? t - e % t : _c(s) || s < 32 ? i : 1;
  }
  function fM(s, e) {
    return e - s % e;
  }
  function FL(s, e, t, i) {
    return t !== 32 && (e === 2 || e === 3 && i !== 2 || i === 1 || i === 3 && e !== 1);
  }
  function EF(s, e, t, i, n) {
    let o = 0;
    if (n !== 0) {
      const r = jn(s);
      if (r !== -1) {
        for (let l = 0; l < r; l++)
          o += s.charCodeAt(l) === 9 ? fM(o, e) : 1;
        const a = n === 3 ? 2 : n === 2 ? 1 : 0;
        for (let l = 0; l < a; l++)
          o += fM(o, e);
        o + i > t && (o = 0);
      }
    }
    return o;
  }
  var fS;
  const gS = (fS = window.trustedTypes) === null || fS === void 0 ? void 0 : fS.createPolicy("domLineBreaksComputer", { createHTML: (s) => s });
  class OE {
    static create() {
      return new OE();
    }
    constructor() {
    }
    createLineBreaksComputer(e, t, i, n) {
      const o = [], r = [];
      return {
        addRequest: (a, l, c) => {
          o.push(a), r.push(l);
        },
        finalize: () => TG(o, e, t, i, n, r)
      };
    }
  }
  function TG(s, e, t, i, n, o) {
    var r;
    function a(k) {
      const I = o[k];
      if (I) {
        const F = vr.applyInjectedText(s[k], I), R = I.map((j) => j.options), $ = I.map((j) => j.column - 1);
        return new Cm($, R, [F.length], [], 0);
      } else
        return null;
    }
    if (i === -1) {
      const k = [];
      for (let I = 0, F = s.length; I < F; I++)
        k[I] = a(I);
      return k;
    }
    const l = Math.round(i * e.typicalHalfwidthCharacterWidth), d = Math.round(t * (n === 3 ? 2 : n === 2 ? 1 : 0)), h = Math.ceil(e.spaceWidth * d), u = document.createElement("div");
    En(u, e);
    const f = Zd(1e4), g = [], _ = [], b = [], C = [], v = [];
    for (let k = 0; k < s.length; k++) {
      const I = vr.applyInjectedText(s[k], o[k]);
      let F = 0, R = 0, $ = l;
      if (n !== 0)
        if (F = jn(I), F === -1)
          F = 0;
        else {
          for (let Ce = 0; Ce < F; Ce++)
            R += I.charCodeAt(Ce) === 9 ? t - R % t : 1;
          const he = Math.ceil(e.spaceWidth * R);
          he + e.typicalFullwidthCharacterWidth > l ? (F = 0, R = 0) : $ = l - he;
        }
      const j = I.substr(F), le = MG(j, R, t, $, f, h);
      g[k] = F, _[k] = R, b[k] = j, C[k] = le[0], v[k] = le[1];
    }
    const w = f.build(), S = (r = gS?.createHTML(w)) !== null && r !== void 0 ? r : w;
    u.innerHTML = S, u.style.position = "absolute", u.style.top = "10000", u.style.wordWrap = "break-word", document.body.appendChild(u);
    const L = document.createRange(), x = Array.prototype.slice.call(u.children, 0), y = [];
    for (let k = 0; k < s.length; k++) {
      const I = x[k], F = AG(L, I, b[k], C[k]);
      if (F === null) {
        y[k] = a(k);
        continue;
      }
      const R = g[k], $ = _[k] + d, j = v[k], le = [];
      for (let xe = 0, Ve = F.length; xe < Ve; xe++)
        le[xe] = j[F[xe]];
      if (R !== 0)
        for (let xe = 0, Ve = F.length; xe < Ve; xe++)
          F[xe] += R;
      let he, Ce;
      const Ne = o[k];
      Ne ? (he = Ne.map((xe) => xe.options), Ce = Ne.map((xe) => xe.column - 1)) : (he = null, Ce = null), y[k] = new Cm(Ce, he, F, le, $);
    }
    return document.body.removeChild(u), y;
  }
  function MG(s, e, t, i, n, o) {
    if (o !== 0) {
      const u = String(o);
      n.appendASCIIString('<div style="text-indent: -'), n.appendASCIIString(u), n.appendASCIIString("px; padding-left: "), n.appendASCIIString(u), n.appendASCIIString("px; box-sizing: border-box; width:");
    } else
      n.appendASCIIString('<div style="width:');
    n.appendASCIIString(String(i)), n.appendASCIIString('px;">');
    const r = s.length;
    let a = e, l = 0;
    const c = [], d = [];
    let h = 0 < r ? s.charCodeAt(0) : 0;
    n.appendASCIIString("<span>");
    for (let u = 0; u < r; u++) {
      u !== 0 && u % 16384 === 0 && n.appendASCIIString("</span><span>"), c[u] = l, d[u] = a;
      const f = h;
      h = u + 1 < r ? s.charCodeAt(u + 1) : 0;
      let g = 1, _ = 1;
      switch (f) {
        case 9:
          g = t - a % t, _ = g;
          for (let b = 1; b <= g; b++)
            b < g ? n.write1(160) : n.appendASCII(32);
          break;
        case 32:
          h === 32 ? n.write1(160) : n.appendASCII(32);
          break;
        case 60:
          n.appendASCIIString("&lt;");
          break;
        case 62:
          n.appendASCIIString("&gt;");
          break;
        case 38:
          n.appendASCIIString("&amp;");
          break;
        case 0:
          n.appendASCIIString("&#00;");
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          n.write1(65533);
          break;
        default:
          _c(f) && _++, f < 32 ? n.write1(9216 + f) : n.write1(f);
      }
      l += g, a += _;
    }
    return n.appendASCIIString("</span>"), c[s.length] = l, d[s.length] = a, n.appendASCIIString("</div>"), [c, d];
  }
  function AG(s, e, t, i) {
    if (t.length <= 1)
      return null;
    const n = Array.prototype.slice.call(e.children, 0), o = [];
    try {
      BL(s, n, i, 0, null, t.length - 1, null, o);
    } catch (r) {
      return console.log(r), null;
    }
    return o.length === 0 ? null : (o.push(t.length), o);
  }
  function BL(s, e, t, i, n, o, r, a) {
    if (i === o || (n = n || mS(s, e, t[i], t[i + 1]), r = r || mS(s, e, t[o], t[o + 1]), Math.abs(n[0].top - r[0].top) <= 0.1))
      return;
    if (i + 1 === o) {
      a.push(o);
      return;
    }
    const l = i + (o - i) / 2 | 0, c = mS(s, e, t[l], t[l + 1]);
    BL(s, e, t, i, n, l, c, a), BL(s, e, t, l, c, o, r, a);
  }
  function mS(s, e, t, i) {
    return s.setStart(e[t / 16384 | 0].firstChild, t % 16384), s.setEnd(e[i / 16384 | 0].firstChild, i % 16384), s.getClientRects();
  }
  const me = st("ILanguageFeaturesService");
  var RG = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Ma = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let OG = 0;
  class PG {
    constructor(e, t, i, n, o) {
      this.model = e, this.viewModel = t, this.view = i, this.hasRealView = n, this.listenersToRemove = o;
    }
    dispose() {
      at(this.listenersToRemove), this.model.onBeforeDetached(), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
    }
  }
  let hp = class g0 extends z {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      super(), this.languageConfigurationService = h, this._onDidDispose = this._register(new B()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new B()), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new B()), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new B()), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new B()), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new B()), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeConfiguration = this._register(new B()), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onDidChangeModel = this._register(new B()), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new B()), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new B()), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new B()), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new B()), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new gM()), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new gM()), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new B()), this.onWillType = this._onWillType.event, this._onDidType = this._register(new B()), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new B()), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new B()), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new B()), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new B()), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new B()), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new B()), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new B()), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new B()), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onContextMenu = this._register(new B()), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new B()), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new B()), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new B()), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new B()), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new B()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new B()), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new B()), this.onDidChangeViewZones = this._onDidChangeViewZones.event, this._onDidChangeHiddenAreas = this._register(new B()), this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event, this._bannerDomNode = null;
      const f = Object.assign({}, t);
      this._domElement = e, this._overflowWidgetsDomNode = f.overflowWidgetsDomNode, delete f.overflowWidgetsDomNode, this._id = ++OG, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(i.isSimpleWidget || !1, f, d)), this._register(this._configuration.onDidChange((_) => {
        this._onDidChangeConfiguration.fire(_);
        const b = this._configuration.options;
        if (_.hasChanged(131)) {
          const C = b.get(131);
          this._onDidLayoutChange.fire(C);
        }
      })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = c, this._codeEditorService = o, this._commandService = r, this._themeService = l, this._register(new FG(this, this._contextKeyService)), this._register(new BG(this, this._contextKeyService, u)), this._instantiationService = n.createChild(new fC([Fe, this._contextKeyService])), this._modelData = null, this._contributions = {}, this._actions = {}, this._focusTracker = new WG(e), this._register(this._focusTracker.onChange(() => {
        this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
      })), this._contentWidgets = {}, this._overlayWidgets = {};
      let g;
      Array.isArray(i.contributions) ? g = i.contributions : g = Dd.getEditorContributions();
      for (const _ of g) {
        if (this._contributions[_.id]) {
          We(new Error(`Cannot have two contributions with the same id ${_.id}`));
          continue;
        }
        try {
          const b = this._instantiationService.createInstance(_.ctor, this);
          this._contributions[_.id] = b;
        } catch (b) {
          We(b);
        }
      }
      Dd.getEditorActions().forEach((_) => {
        if (this._actions[_.id]) {
          We(new Error(`Cannot have two actions with the same id ${_.id}`));
          return;
        }
        const b = new nF(_.id, _.label, _.alias, ys(_.precondition), () => this._instantiationService.invokeFunction((C) => Promise.resolve(_.runEditorCommand(C, this, null))), this._contextKeyService);
        this._actions[b.id] = b;
      }), this._codeEditorService.addCodeEditor(this);
    }
    get isSimpleWidget() {
      return this._configuration.isSimpleWidget;
    }
    _createConfiguration(e, t, i) {
      return new hL(e, t, this._domElement, i);
    }
    getId() {
      return this.getEditorType() + ":" + this._id;
    }
    getEditorType() {
      return g_.ICodeEditor;
    }
    dispose() {
      this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose();
      const e = Object.keys(this._contributions);
      for (let t = 0, i = e.length; t < i; t++) {
        const n = e[t];
        this._contributions[n].dispose();
      }
      this._contributions = {}, this._actions = {}, this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
    }
    invokeWithinContext(e) {
      return this._instantiationService.invokeFunction(e);
    }
    updateOptions(e) {
      this._configuration.updateOptions(e || {});
    }
    getOptions() {
      return this._configuration.options;
    }
    getOption(e) {
      return this._configuration.options.get(e);
    }
    getRawOptions() {
      return this._configuration.getRawOptions();
    }
    getOverflowWidgetsDomNode() {
      return this._overflowWidgetsDomNode;
    }
    getConfiguredWordAtPosition(e) {
      return this._modelData ? ct.getWordAtPosition(this._modelData.model, this._configuration.options.get(117), e) : null;
    }
    getValue(e = null) {
      if (!this._modelData)
        return "";
      const t = !!(e && e.preserveBOM);
      let i = 0;
      return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
    }
    setValue(e) {
      !this._modelData || this._modelData.model.setValue(e);
    }
    getModel() {
      return this._modelData ? this._modelData.model : null;
    }
    setModel(e = null) {
      const t = e;
      if (this._modelData === null && t === null || this._modelData && this._modelData.model === t)
        return;
      const i = this.hasTextFocus(), n = this._detachModel();
      this._attachModel(t), i && this.hasModel() && this.focus();
      const o = {
        oldModelUrl: n ? n.uri : null,
        newModelUrl: t ? t.uri : null
      };
      this._removeDecorationTypes(), this._onDidChangeModel.fire(o), this._postDetachModelCleanup(n);
    }
    _removeDecorationTypes() {
      if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
        for (let e in this._decorationTypeSubtypes) {
          const t = this._decorationTypeSubtypes[e];
          for (let i in t)
            this._removeDecorationType(e + "-" + i);
        }
        this._decorationTypeSubtypes = {};
      }
    }
    getVisibleRanges() {
      return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
    }
    getVisibleRangesPlusViewportAboveBelow() {
      return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
    }
    getWhitespaces() {
      return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
    }
    static _getVerticalOffsetForPosition(e, t, i) {
      const n = e.model.validatePosition({
        lineNumber: t,
        column: i
      }), o = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(n);
      return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(o.lineNumber);
    }
    getTopForLineNumber(e) {
      return this._modelData ? g0._getVerticalOffsetForPosition(this._modelData, e, 1) : -1;
    }
    getTopForPosition(e, t) {
      return this._modelData ? g0._getVerticalOffsetForPosition(this._modelData, e, t) : -1;
    }
    setHiddenAreas(e) {
      this._modelData && this._modelData.viewModel.setHiddenAreas(e.map((t) => D.lift(t)));
    }
    getVisibleColumnFromPosition(e) {
      if (!this._modelData)
        return e.column;
      const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
      return Oi.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
    }
    getPosition() {
      return this._modelData ? this._modelData.viewModel.getPosition() : null;
    }
    setPosition(e, t = "api") {
      if (!!this._modelData) {
        if (!V.isIPosition(e))
          throw new Error("Invalid arguments");
        this._modelData.viewModel.setSelections(t, [{
          selectionStartLineNumber: e.lineNumber,
          selectionStartColumn: e.column,
          positionLineNumber: e.lineNumber,
          positionColumn: e.column
        }]);
      }
    }
    _sendRevealRange(e, t, i, n) {
      if (!this._modelData)
        return;
      if (!D.isIRange(e))
        throw new Error("Invalid arguments");
      const o = this._modelData.model.validateRange(e), r = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(o);
      this._modelData.viewModel.revealRange("api", i, r, t, n);
    }
    revealLine(e, t = 0) {
      this._revealLine(e, 0, t);
    }
    revealLineInCenter(e, t = 0) {
      this._revealLine(e, 1, t);
    }
    revealLineInCenterIfOutsideViewport(e, t = 0) {
      this._revealLine(e, 2, t);
    }
    revealLineNearTop(e, t = 0) {
      this._revealLine(e, 5, t);
    }
    _revealLine(e, t, i) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._sendRevealRange(new D(e, 1, e, 1), t, !1, i);
    }
    revealPosition(e, t = 0) {
      this._revealPosition(e, 0, !0, t);
    }
    revealPositionInCenter(e, t = 0) {
      this._revealPosition(e, 1, !0, t);
    }
    revealPositionInCenterIfOutsideViewport(e, t = 0) {
      this._revealPosition(e, 2, !0, t);
    }
    revealPositionNearTop(e, t = 0) {
      this._revealPosition(e, 5, !0, t);
    }
    _revealPosition(e, t, i, n) {
      if (!V.isIPosition(e))
        throw new Error("Invalid arguments");
      this._sendRevealRange(new D(e.lineNumber, e.column, e.lineNumber, e.column), t, i, n);
    }
    getSelection() {
      return this._modelData ? this._modelData.viewModel.getSelection() : null;
    }
    getSelections() {
      return this._modelData ? this._modelData.viewModel.getSelections() : null;
    }
    setSelection(e, t = "api") {
      const i = ae.isISelection(e), n = D.isIRange(e);
      if (!i && !n)
        throw new Error("Invalid arguments");
      if (i)
        this._setSelectionImpl(e, t);
      else if (n) {
        const o = {
          selectionStartLineNumber: e.startLineNumber,
          selectionStartColumn: e.startColumn,
          positionLineNumber: e.endLineNumber,
          positionColumn: e.endColumn
        };
        this._setSelectionImpl(o, t);
      }
    }
    _setSelectionImpl(e, t) {
      if (!this._modelData)
        return;
      const i = new ae(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
      this._modelData.viewModel.setSelections(t, [i]);
    }
    revealLines(e, t, i = 0) {
      this._revealLines(e, t, 0, i);
    }
    revealLinesInCenter(e, t, i = 0) {
      this._revealLines(e, t, 1, i);
    }
    revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
      this._revealLines(e, t, 2, i);
    }
    revealLinesNearTop(e, t, i = 0) {
      this._revealLines(e, t, 5, i);
    }
    _revealLines(e, t, i, n) {
      if (typeof e != "number" || typeof t != "number")
        throw new Error("Invalid arguments");
      this._sendRevealRange(new D(e, 1, t, 1), i, !1, n);
    }
    revealRange(e, t = 0, i = !1, n = !0) {
      this._revealRange(e, i ? 1 : 0, n, t);
    }
    revealRangeInCenter(e, t = 0) {
      this._revealRange(e, 1, !0, t);
    }
    revealRangeInCenterIfOutsideViewport(e, t = 0) {
      this._revealRange(e, 2, !0, t);
    }
    revealRangeNearTop(e, t = 0) {
      this._revealRange(e, 5, !0, t);
    }
    revealRangeNearTopIfOutsideViewport(e, t = 0) {
      this._revealRange(e, 6, !0, t);
    }
    revealRangeAtTop(e, t = 0) {
      this._revealRange(e, 3, !0, t);
    }
    _revealRange(e, t, i, n) {
      if (!D.isIRange(e))
        throw new Error("Invalid arguments");
      this._sendRevealRange(D.lift(e), t, i, n);
    }
    setSelections(e, t = "api", i = 0) {
      if (!!this._modelData) {
        if (!e || e.length === 0)
          throw new Error("Invalid arguments");
        for (let n = 0, o = e.length; n < o; n++)
          if (!ae.isISelection(e[n]))
            throw new Error("Invalid arguments");
        this._modelData.viewModel.setSelections(t, e, i);
      }
    }
    getContentWidth() {
      return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
    }
    getScrollWidth() {
      return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
    }
    getScrollLeft() {
      return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
    }
    getContentHeight() {
      return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
    }
    getScrollHeight() {
      return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
    }
    getScrollTop() {
      return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
    }
    setScrollLeft(e, t = 1) {
      if (!!this._modelData) {
        if (typeof e != "number")
          throw new Error("Invalid arguments");
        this._modelData.viewModel.viewLayout.setScrollPosition({
          scrollLeft: e
        }, t);
      }
    }
    setScrollTop(e, t = 1) {
      if (!!this._modelData) {
        if (typeof e != "number")
          throw new Error("Invalid arguments");
        this._modelData.viewModel.viewLayout.setScrollPosition({
          scrollTop: e
        }, t);
      }
    }
    setScrollPosition(e, t = 1) {
      !this._modelData || this._modelData.viewModel.viewLayout.setScrollPosition(e, t);
    }
    saveViewState() {
      if (!this._modelData)
        return null;
      const e = {}, t = Object.keys(this._contributions);
      for (const o of t) {
        const r = this._contributions[o];
        typeof r.saveViewState == "function" && (e[o] = r.saveViewState());
      }
      const i = this._modelData.viewModel.saveCursorState(), n = this._modelData.viewModel.saveState();
      return {
        cursorState: i,
        viewState: n,
        contributionsState: e
      };
    }
    restoreViewState(e) {
      if (!this._modelData || !this._modelData.hasRealView)
        return;
      const t = e;
      if (t && t.cursorState && t.viewState) {
        const i = t.cursorState;
        Array.isArray(i) ? i.length > 0 && this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]);
        const n = t.contributionsState || {}, o = Object.keys(this._contributions);
        for (let a = 0, l = o.length; a < l; a++) {
          const c = o[a], d = this._contributions[c];
          typeof d.restoreViewState == "function" && d.restoreViewState(n[c]);
        }
        const r = this._modelData.viewModel.reduceRestoreState(t.viewState);
        this._modelData.view.restoreState(r);
      }
    }
    getContribution(e) {
      return this._contributions[e] || null;
    }
    getActions() {
      const e = [], t = Object.keys(this._actions);
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i];
        e.push(this._actions[o]);
      }
      return e;
    }
    getSupportedActions() {
      let e = this.getActions();
      return e = e.filter((t) => t.isSupported()), e;
    }
    getAction(e) {
      return this._actions[e] || null;
    }
    trigger(e, t, i) {
      switch (i = i || {}, t) {
        case "compositionStart":
          this._startComposition();
          return;
        case "compositionEnd":
          this._endComposition(e);
          return;
        case "type": {
          const o = i;
          this._type(e, o.text || "");
          return;
        }
        case "replacePreviousChar": {
          const o = i;
          this._compositionType(e, o.text || "", o.replaceCharCnt || 0, 0, 0);
          return;
        }
        case "compositionType": {
          const o = i;
          this._compositionType(e, o.text || "", o.replacePrevCharCnt || 0, o.replaceNextCharCnt || 0, o.positionDelta || 0);
          return;
        }
        case "paste": {
          const o = i;
          this._paste(e, o.text || "", o.pasteOnNewLine || !1, o.multicursorText || null, o.mode || null);
          return;
        }
        case "cut":
          this._cut(e);
          return;
      }
      const n = this.getAction(t);
      if (n) {
        Promise.resolve(n.run()).then(void 0, We);
        return;
      }
      !this._modelData || this._triggerEditorCommand(e, t, i) || this._triggerCommand(t, i);
    }
    _triggerCommand(e, t) {
      this._commandService.executeCommand(e, t);
    }
    _startComposition() {
      !this._modelData || (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
    }
    _endComposition(e) {
      !this._modelData || (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
    }
    _type(e, t) {
      !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
    }
    _compositionType(e, t, i, n, o) {
      !this._modelData || this._modelData.viewModel.compositionType(t, i, n, o, e);
    }
    _paste(e, t, i, n, o) {
      if (!this._modelData || t.length === 0)
        return;
      const r = this._modelData.viewModel.getSelection().getStartPosition();
      this._modelData.viewModel.paste(t, i, n, e);
      const a = this._modelData.viewModel.getSelection().getStartPosition();
      e === "keyboard" && this._onDidPaste.fire({
        range: new D(r.lineNumber, r.column, a.lineNumber, a.column),
        languageId: o
      });
    }
    _cut(e) {
      !this._modelData || this._modelData.viewModel.cut(e);
    }
    _triggerEditorCommand(e, t, i) {
      const n = Dd.getEditorCommand(t);
      return n ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((o) => {
        Promise.resolve(n.runEditorCommand(o, this, i)).then(void 0, We);
      }), !0) : !1;
    }
    _getViewModel() {
      return this._modelData ? this._modelData.viewModel : null;
    }
    pushUndoStop() {
      return !this._modelData || this._configuration.options.get(81) ? !1 : (this._modelData.model.pushStackElement(), !0);
    }
    popUndoStop() {
      return !this._modelData || this._configuration.options.get(81) ? !1 : (this._modelData.model.popStackElement(), !0);
    }
    executeEdits(e, t, i) {
      if (!this._modelData || this._configuration.options.get(81))
        return !1;
      let n;
      return i ? Array.isArray(i) ? n = () => i : n = i : n = () => null, this._modelData.viewModel.executeEdits(e, t, n), !0;
    }
    executeCommand(e, t) {
      !this._modelData || this._modelData.viewModel.executeCommand(t, e);
    }
    executeCommands(e, t) {
      !this._modelData || this._modelData.viewModel.executeCommands(t, e);
    }
    changeDecorations(e) {
      return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
    }
    getLineDecorations(e) {
      return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, o1(this._configuration.options)) : null;
    }
    getDecorationsInRange(e) {
      return this._modelData ? this._modelData.model.getDecorationsInRange(e, this._id, o1(this._configuration.options)) : null;
    }
    deltaDecorations(e, t) {
      return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
    }
    removeDecorations(e) {
      const t = this._decorationTypeKeysToIds[e];
      t && this.deltaDecorations(t, []), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
    }
    getLayoutInfo() {
      return this._configuration.options.get(131);
    }
    createOverviewRuler(e) {
      return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
    }
    getContainerDomNode() {
      return this._domElement;
    }
    getDomNode() {
      return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
    }
    delegateVerticalScrollbarMouseDown(e) {
      !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarMouseDown(e);
    }
    layout(e) {
      this._configuration.observeContainer(e), this.render();
    }
    focus() {
      !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
    }
    hasTextFocus() {
      return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
    }
    hasWidgetFocus() {
      return this._focusTracker && this._focusTracker.hasFocus();
    }
    addContentWidget(e) {
      const t = {
        widget: e,
        position: e.getPosition()
      };
      this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id."), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
    }
    layoutContentWidget(e) {
      const t = e.getId();
      if (this._contentWidgets.hasOwnProperty(t)) {
        const i = this._contentWidgets[t];
        i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
      }
    }
    removeContentWidget(e) {
      const t = e.getId();
      if (this._contentWidgets.hasOwnProperty(t)) {
        const i = this._contentWidgets[t];
        delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
      }
    }
    addOverlayWidget(e) {
      const t = {
        widget: e,
        position: e.getPosition()
      };
      this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
    }
    layoutOverlayWidget(e) {
      const t = e.getId();
      if (this._overlayWidgets.hasOwnProperty(t)) {
        const i = this._overlayWidgets[t];
        i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
      }
    }
    removeOverlayWidget(e) {
      const t = e.getId();
      if (this._overlayWidgets.hasOwnProperty(t)) {
        const i = this._overlayWidgets[t];
        delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
      }
    }
    changeViewZones(e) {
      !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
    }
    getTargetAtClientPoint(e, t) {
      return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
    }
    getScrolledVisiblePosition(e) {
      if (!this._modelData || !this._modelData.hasRealView)
        return null;
      const t = this._modelData.model.validatePosition(e), i = this._configuration.options, n = i.get(131), o = g0._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), r = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft();
      return {
        top: o,
        left: r,
        height: i.get(59)
      };
    }
    getOffsetForColumn(e, t) {
      return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
    }
    render(e = !1) {
      !this._modelData || !this._modelData.hasRealView || this._modelData.view.render(!0, e);
    }
    setAriaOptions(e) {
      !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
    }
    applyFontInfo(e) {
      En(e, this._configuration.options.get(44));
    }
    setBanner(e, t) {
      this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._domElement.removeChild(this._bannerDomNode), this._bannerDomNode = e, this._configuration.setReservedHeight(e ? t : 0), this._bannerDomNode && this._domElement.prepend(this._bannerDomNode);
    }
    _attachModel(e) {
      if (!e) {
        this._modelData = null;
        return;
      }
      const t = [];
      this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setModelLineCount(e.getLineCount()), e.onBeforeAttached();
      const i = new kG(this._id, this._configuration, e, OE.create(), RE.create(this._configuration.options), (r) => _r(r), this.languageConfigurationService, this._themeService);
      t.push(e.onDidChangeDecorations((r) => this._onDidChangeModelDecorations.fire(r))), t.push(e.onDidChangeLanguage((r) => {
        this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._onDidChangeModelLanguage.fire(r);
      })), t.push(e.onDidChangeLanguageConfiguration((r) => this._onDidChangeModelLanguageConfiguration.fire(r))), t.push(e.onDidChangeContent((r) => this._onDidChangeModelContent.fire(r))), t.push(e.onDidChangeOptions((r) => this._onDidChangeModelOptions.fire(r))), t.push(e.onWillDispose(() => this.setModel(null))), t.push(i.onEvent((r) => {
        switch (r.kind) {
          case 0:
            this._onDidContentSizeChange.fire(r);
            break;
          case 1:
            this._editorTextFocus.setValue(r.hasFocus);
            break;
          case 2:
            this._onDidScrollChange.fire(r);
            break;
          case 3:
            this._onDidChangeViewZones.fire();
            break;
          case 4:
            this._onDidChangeHiddenAreas.fire();
            break;
          case 5:
            this._onDidAttemptReadOnlyEdit.fire();
            break;
          case 6: {
            r.reachedMaxCursorCount && this._notificationService.warn(m("cursors.maximum", "The number of cursors has been limited to {0}.", yf.MAX_CURSOR_COUNT));
            const a = [];
            for (let d = 0, h = r.selections.length; d < h; d++)
              a[d] = r.selections[d].getPosition();
            const l = {
              position: a[0],
              secondaryPositions: a.slice(1),
              reason: r.reason,
              source: r.source
            };
            this._onDidChangeCursorPosition.fire(l);
            const c = {
              selection: r.selections[0],
              secondarySelections: r.selections.slice(1),
              modelVersionId: r.modelVersionId,
              oldSelections: r.oldSelections,
              oldModelVersionId: r.oldModelVersionId,
              source: r.source,
              reason: r.reason
            };
            this._onDidChangeCursorSelection.fire(c);
            break;
          }
        }
      }));
      const [n, o] = this._createView(i);
      if (o) {
        this._domElement.appendChild(n.domNode.domNode);
        let r = Object.keys(this._contentWidgets);
        for (let a = 0, l = r.length; a < l; a++) {
          const c = r[a];
          n.addContentWidget(this._contentWidgets[c]);
        }
        r = Object.keys(this._overlayWidgets);
        for (let a = 0, l = r.length; a < l; a++) {
          const c = r[a];
          n.addOverlayWidget(this._overlayWidgets[c]);
        }
        n.render(!1, !0), n.domNode.domNode.setAttribute("data-uri", e.uri.toString());
      }
      this._modelData = new PG(e, i, n, o, t);
    }
    _createView(e) {
      let t;
      this.isSimpleWidget ? t = {
        paste: (o, r, a, l) => {
          this._paste("keyboard", o, r, a, l);
        },
        type: (o) => {
          this._type("keyboard", o);
        },
        compositionType: (o, r, a, l) => {
          this._compositionType("keyboard", o, r, a, l);
        },
        startComposition: () => {
          this._startComposition();
        },
        endComposition: () => {
          this._endComposition("keyboard");
        },
        cut: () => {
          this._cut("keyboard");
        }
      } : t = {
        paste: (o, r, a, l) => {
          const c = { text: o, pasteOnNewLine: r, multicursorText: a, mode: l };
          this._commandService.executeCommand("paste", c);
        },
        type: (o) => {
          const r = { text: o };
          this._commandService.executeCommand("type", r);
        },
        compositionType: (o, r, a, l) => {
          if (a || l) {
            const c = { text: o, replacePrevCharCnt: r, replaceNextCharCnt: a, positionDelta: l };
            this._commandService.executeCommand("compositionType", c);
          } else {
            const c = { text: o, replaceCharCnt: r };
            this._commandService.executeCommand("replacePreviousChar", c);
          }
        },
        startComposition: () => {
          this._commandService.executeCommand("compositionStart", {});
        },
        endComposition: () => {
          this._commandService.executeCommand("compositionEnd", {});
        },
        cut: () => {
          this._commandService.executeCommand("cut", {});
        }
      };
      const i = new lC(e.coordinatesConverter);
      return i.onKeyDown = (o) => this._onKeyDown.fire(o), i.onKeyUp = (o) => this._onKeyUp.fire(o), i.onContextMenu = (o) => this._onContextMenu.fire(o), i.onMouseMove = (o) => this._onMouseMove.fire(o), i.onMouseLeave = (o) => this._onMouseLeave.fire(o), i.onMouseDown = (o) => this._onMouseDown.fire(o), i.onMouseUp = (o) => this._onMouseUp.fire(o), i.onMouseDrag = (o) => this._onMouseDrag.fire(o), i.onMouseDrop = (o) => this._onMouseDrop.fire(o), i.onMouseDropCanceled = (o) => this._onMouseDropCanceled.fire(o), i.onMouseWheel = (o) => this._onMouseWheel.fire(o), [new fK(t, this._configuration, this._themeService.getColorTheme(), e, i, this._overflowWidgetsDomNode), !0];
    }
    _postDetachModelCleanup(e) {
      e && e.removeAllDecorationsWithOwnerId(this._id);
    }
    _detachModel() {
      if (!this._modelData)
        return null;
      const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
      return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && this._domElement.removeChild(t), this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._domElement.removeChild(this._bannerDomNode), e;
    }
    _removeDecorationType(e) {
      this._codeEditorService.removeDecorationType(e);
    }
    hasModel() {
      return this._modelData !== null;
    }
  };
  hp = RG([
    Ma(3, et),
    Ma(4, St),
    Ma(5, wi),
    Ma(6, Fe),
    Ma(7, jt),
    Ma(8, yi),
    Ma(9, Ts),
    Ma(10, Mn),
    Ma(11, me)
  ], hp);
  class gM extends z {
    constructor() {
      super(), this._onDidChangeToTrue = this._register(new B()), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new B()), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
    }
    setValue(e) {
      const t = e ? 2 : 1;
      this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
    }
  }
  class FG extends z {
    constructor(e, t) {
      super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = T.editorSimpleInput.bindTo(t), this._editorFocus = T.focus.bindTo(t), this._textInputFocus = T.textInputFocus.bindTo(t), this._editorTextFocus = T.editorTextFocus.bindTo(t), this._editorTabMovesFocus = T.tabMovesFocus.bindTo(t), this._editorReadonly = T.readOnly.bindTo(t), this._inDiffEditor = T.inDiffEditor.bindTo(t), this._editorColumnSelection = T.columnSelection.bindTo(t), this._hasMultipleSelections = T.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = T.hasNonEmptySelection.bindTo(t), this._canUndo = T.canUndo.bindTo(t), this._canRedo = T.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
    }
    _updateFromConfig() {
      const e = this._editor.getOptions();
      this._editorTabMovesFocus.set(e.get(130)), this._editorReadonly.set(e.get(81)), this._inDiffEditor.set(e.get(54)), this._editorColumnSelection.set(e.get(18));
    }
    _updateFromSelection() {
      const e = this._editor.getSelections();
      e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
    }
    _updateFromFocus() {
      this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
    }
    _updateFromModel() {
      const e = this._editor.getModel();
      this._canUndo.set(Boolean(e && e.canUndo())), this._canRedo.set(Boolean(e && e.canRedo()));
    }
  }
  class BG extends z {
    constructor(e, t, i) {
      super(), this._editor = e, this._contextKeyService = t, this._languageFeaturesService = i, this._langId = T.languageId.bindTo(t), this._hasCompletionItemProvider = T.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = T.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = T.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = T.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = T.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = T.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = T.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = T.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = T.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = T.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = T.hasReferenceProvider.bindTo(t), this._hasRenameProvider = T.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = T.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = T.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = T.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = T.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = T.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = T.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInWalkThrough = T.isInWalkThroughSnippet.bindTo(t);
      const n = () => this._update();
      this._register(e.onDidChangeModel(n)), this._register(e.onDidChangeModelLanguage(n)), this._register(i.completionProvider.onDidChange(n)), this._register(i.codeActionProvider.onDidChange(n)), this._register(i.codeLensProvider.onDidChange(n)), this._register(i.definitionProvider.onDidChange(n)), this._register(i.declarationProvider.onDidChange(n)), this._register(i.implementationProvider.onDidChange(n)), this._register(i.typeDefinitionProvider.onDidChange(n)), this._register(i.hoverProvider.onDidChange(n)), this._register(i.documentHighlightProvider.onDidChange(n)), this._register(i.documentSymbolProvider.onDidChange(n)), this._register(i.referenceProvider.onDidChange(n)), this._register(i.renameProvider.onDidChange(n)), this._register(i.documentFormattingEditProvider.onDidChange(n)), this._register(i.documentRangeFormattingEditProvider.onDidChange(n)), this._register(i.signatureHelpProvider.onDidChange(n)), this._register(i.inlayHintsProvider.onDidChange(n)), n();
    }
    dispose() {
      super.dispose();
    }
    reset() {
      this._contextKeyService.bufferChangeEvents(() => {
        this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInWalkThrough.reset();
      });
    }
    _update() {
      const e = this._editor.getModel();
      if (!e) {
        this.reset();
        return;
      }
      this._contextKeyService.bufferChangeEvents(() => {
        this._langId.set(e.getLanguageId()), this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(e)), this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(e)), this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(e)), this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(e)), this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(e)), this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(e)), this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(e)), this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(e)), this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(e)), this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(e)), this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(e)), this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(e)), this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(e)), this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(e)), this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(e) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(e).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._isInWalkThrough.set(e.uri.scheme === ze.walkThroughSnippet);
      });
    }
  }
  class WG extends z {
    constructor(e) {
      super(), this._onChange = this._register(new B()), this.onChange = this._onChange.event, this._hasFocus = !1, this._domFocusTracker = this._register(ff(e)), this._register(this._domFocusTracker.onDidFocus(() => {
        this._hasFocus = !0, this._onChange.fire(void 0);
      })), this._register(this._domFocusTracker.onDidBlur(() => {
        this._hasFocus = !1, this._onChange.fire(void 0);
      }));
    }
    hasFocus() {
      return this._hasFocus;
    }
  }
  const VG = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), HG = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
  function pS(s) {
    return VG + encodeURIComponent(s.toString()) + HG;
  }
  const zG = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), UG = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
  function $G(s) {
    return zG + encodeURIComponent(s.toString()) + UG;
  }
  Vt((s, e) => {
    const t = s.getColor(L5);
    t && e.addRule(`.monaco-editor .squiggly-error { border-bottom: 4px double ${t}; }`);
    const i = s.getColor(ic);
    i && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${pS(i)}") repeat-x bottom left; }`);
    const n = s.getColor(Cz);
    n && e.addRule(`.monaco-editor .squiggly-error::before { display: block; content: ''; width: 100%; height: 100%; background: ${n}; }`);
    const o = s.getColor(Jv);
    o && e.addRule(`.monaco-editor .squiggly-warning { border-bottom: 4px double ${o}; }`);
    const r = s.getColor(Ko);
    r && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${pS(r)}") repeat-x bottom left; }`);
    const a = s.getColor(wz);
    a && e.addRule(`.monaco-editor .squiggly-warning::before { display: block; content: ''; width: 100%; height: 100%; background: ${a}; }`);
    const l = s.getColor(JI);
    l && e.addRule(`.monaco-editor .squiggly-info { border-bottom: 4px double ${l}; }`);
    const c = s.getColor(Zs);
    c && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${pS(c)}") repeat-x bottom left; }`);
    const d = s.getColor(Sz);
    d && e.addRule(`.monaco-editor .squiggly-info::before { display: block; content: ''; width: 100%; height: 100%; background: ${d}; }`);
    const h = s.getColor(Lz);
    h && e.addRule(`.monaco-editor .squiggly-hint { border-bottom: 2px dotted ${h}; }`);
    const u = s.getColor(yz);
    u && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${$G(u)}") no-repeat bottom left; }`);
    const f = s.getColor(F$);
    f && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${f.rgba.a}; }`);
    const g = s.getColor(P$);
    g && e.addRule(`.monaco-editor.showUnused .squiggly-unnecessary { border-bottom: 2px dashed ${g}; }`);
    const _ = s.getColor(nc) || "inherit";
    e.addRule(`.monaco-editor.showDeprecated .squiggly-inline-deprecated { text-decoration: line-through; text-decoration-color: ${_}}`);
  });
  class xt {
    constructor(e, t, i) {
      const n = (o) => this.emitter.fire(o);
      this.emitter = new B({
        onFirstListenerAdd: () => e.addEventListener(t, n, i),
        onLastListenerRemove: () => e.removeEventListener(t, n, i)
      });
    }
    get event() {
      return this.emitter.event;
    }
    dispose() {
      this.emitter.dispose();
    }
  }
  function mM(s) {
    return s.preventDefault(), s.stopPropagation(), s;
  }
  var ag = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  };
  let jG = !1;
  var L1;
  (function(s) {
    s.North = "north", s.South = "south", s.East = "east", s.West = "west";
  })(L1 || (L1 = {}));
  let KG = 4;
  const qG = new B();
  let GG = 300;
  const ZG = new B();
  class PE {
    constructor() {
      this.disposables = new te();
    }
    get onPointerMove() {
      return this.disposables.add(new xt(window, "mousemove")).event;
    }
    get onPointerUp() {
      return this.disposables.add(new xt(window, "mouseup")).event;
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  ag([
    Ai
  ], PE.prototype, "onPointerMove", null);
  ag([
    Ai
  ], PE.prototype, "onPointerUp", null);
  class FE {
    constructor(e) {
      this.el = e, this.disposables = new te();
    }
    get onPointerMove() {
      return this.disposables.add(new xt(this.el, Bt.Change)).event;
    }
    get onPointerUp() {
      return this.disposables.add(new xt(this.el, Bt.End)).event;
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  ag([
    Ai
  ], FE.prototype, "onPointerMove", null);
  ag([
    Ai
  ], FE.prototype, "onPointerUp", null);
  class k1 {
    constructor(e) {
      this.factory = e;
    }
    get onPointerMove() {
      return this.factory.onPointerMove;
    }
    get onPointerUp() {
      return this.factory.onPointerUp;
    }
    dispose() {
    }
  }
  ag([
    Ai
  ], k1.prototype, "onPointerMove", null);
  ag([
    Ai
  ], k1.prototype, "onPointerUp", null);
  const pM = "pointer-events-disabled";
  class Dn extends z {
    constructor(e, t, i) {
      super(), this.hoverDelay = GG, this.hoverDelayer = this._register(new ca(this.hoverDelay)), this._state = 3, this.onDidEnablementChange = this._register(new B()), this._onDidStart = this._register(new B()), this._onDidChange = this._register(new B()), this._onDidReset = this._register(new B()), this._onDidEnd = this._register(new B()), this.orthogonalStartSashDisposables = this._register(new te()), this.orthogonalStartDragHandleDisposables = this._register(new te()), this.orthogonalEndSashDisposables = this._register(new te()), this.orthogonalEndDragHandleDisposables = this._register(new te()), this.onDidStart = this._onDidStart.event, this.onDidChange = this._onDidChange.event, this.onDidReset = this._onDidReset.event, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.el = q(e, J(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), Ye && this.el.classList.add("mac");
      const n = this._register(new xt(this.el, "mousedown")).event;
      this._register(n((h) => this.onPointerStart(h, new PE()), this));
      const o = this._register(new xt(this.el, "dblclick")).event;
      this._register(o(this.onPointerDoublePress, this));
      const r = this._register(new xt(this.el, "mouseenter")).event;
      this._register(r(() => Dn.onMouseEnter(this)));
      const a = this._register(new xt(this.el, "mouseleave")).event;
      this._register(a(() => Dn.onMouseLeave(this))), this._register(kt.addTarget(this.el));
      const l = be.map(this._register(new xt(this.el, Bt.Start)).event, (h) => {
        var u;
        return Object.assign(Object.assign({}, h), { target: (u = h.initialTarget) !== null && u !== void 0 ? u : null });
      });
      this._register(l((h) => this.onPointerStart(h, new FE(this.el)), this));
      const c = this._register(new xt(this.el, Bt.Tap)).event, d = be.map(be.filter(be.debounce(c, (h, u) => {
        var f;
        return { event: u, count: ((f = h?.count) !== null && f !== void 0 ? f : 0) + 1 };
      }, 250), ({ count: h }) => h === 2), ({ event: h }) => {
        var u;
        return Object.assign(Object.assign({}, h), { target: (u = h.initialTarget) !== null && u !== void 0 ? u : null });
      });
      this._register(d(this.onPointerDoublePress, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = KG, this._register(qG.event((h) => {
        this.size = h, this.layout();
      }))), this._register(ZG.event((h) => this.hoverDelay = h)), this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", jG), this.layout();
    }
    get state() {
      return this._state;
    }
    get orthogonalStartSash() {
      return this._orthogonalStartSash;
    }
    get orthogonalEndSash() {
      return this._orthogonalEndSash;
    }
    set state(e) {
      this._state !== e && (this.el.classList.toggle("disabled", e === 0), this.el.classList.toggle("minimum", e === 1), this.el.classList.toggle("maximum", e === 2), this._state = e, this.onDidEnablementChange.fire(e));
    }
    set orthogonalStartSash(e) {
      if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = q(this.el, J(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(qe(() => this._orthogonalStartDragHandle.remove())), this.orthogonalStartDragHandleDisposables.add(new xt(this._orthogonalStartDragHandle, "mouseenter")).event(() => Dn.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalStartDragHandleDisposables.add(new xt(this._orthogonalStartDragHandle, "mouseleave")).event(() => Dn.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
        };
        this.orthogonalStartSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalStartSash = e;
    }
    set orthogonalEndSash(e) {
      if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = q(this.el, J(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(qe(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new xt(this._orthogonalEndDragHandle, "mouseenter")).event(() => Dn.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new xt(this._orthogonalEndDragHandle, "mouseleave")).event(() => Dn.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
        };
        this.orthogonalEndSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalEndSash = e;
    }
    onPointerStart(e, t) {
      wt.stop(e);
      let i = !1;
      if (!e.__orthogonalSashEvent) {
        const g = this.getOrthogonalSash(e);
        g && (i = !0, e.__orthogonalSashEvent = !0, g.onPointerStart(e, new k1(t)));
      }
      if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new k1(t))), !this.state)
        return;
      const n = PW("iframe");
      for (const g of n)
        g.classList.add(pM);
      const o = e.pageX, r = e.pageY, a = e.altKey, l = { startX: o, currentX: o, startY: r, currentY: r, altKey: a };
      this.el.classList.add("active"), this._onDidStart.fire(l);
      const c = Co(this.el), d = () => {
        let g = "";
        i ? g = "all-scroll" : this.orientation === 1 ? this.state === 1 ? g = "s-resize" : this.state === 2 ? g = "n-resize" : g = Ye ? "row-resize" : "ns-resize" : this.state === 1 ? g = "e-resize" : this.state === 2 ? g = "w-resize" : g = Ye ? "col-resize" : "ew-resize", c.textContent = `* { cursor: ${g} !important; }`;
      }, h = new te();
      d(), i || this.onDidEnablementChange.event(d, null, h);
      const u = (g) => {
        wt.stop(g, !1);
        const _ = { startX: o, currentX: g.pageX, startY: r, currentY: g.pageY, altKey: a };
        this._onDidChange.fire(_);
      }, f = (g) => {
        wt.stop(g, !1), this.el.removeChild(c), this.el.classList.remove("active"), this._onDidEnd.fire(), h.dispose();
        for (const _ of n)
          _.classList.remove(pM);
      };
      t.onPointerMove(u, null, h), t.onPointerUp(f, null, h), h.add(t);
    }
    onPointerDoublePress(e) {
      const t = this.getOrthogonalSash(e);
      t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
    }
    static onMouseEnter(e, t = !1) {
      e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
      }), !t && e.linkedSash && Dn.onMouseEnter(e.linkedSash, !0);
    }
    static onMouseLeave(e, t = !1) {
      e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && Dn.onMouseLeave(e.linkedSash, !0);
    }
    clearSashHoverState() {
      Dn.onMouseLeave(this);
    }
    layout() {
      if (this.orientation === 0) {
        const e = this.layoutProvider;
        this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
      } else {
        const e = this.layoutProvider;
        this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
      }
    }
    getOrthogonalSash(e) {
      if (!(!e.target || !(e.target instanceof HTMLElement)) && e.target.classList.contains("orthogonal-drag-handle"))
        return e.target.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
    }
    dispose() {
      super.dispose(), this.el.remove();
    }
  }
  class kc {
    constructor(e, t, i) {
      this._visiblePosition = e, this._visiblePositionScrollDelta = t, this._cursorPosition = i;
    }
    static capture(e) {
      let t = null, i = 0;
      if (e.getScrollTop() !== 0) {
        const n = e.getVisibleRanges();
        if (n.length > 0) {
          t = n[0].getStartPosition();
          const o = e.getTopForPosition(t.lineNumber, t.column);
          i = e.getScrollTop() - o;
        }
      }
      return new kc(t, i, e.getPosition());
    }
    restore(e) {
      if (this._visiblePosition) {
        const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
        e.setScrollTop(t + this._visiblePositionScrollDelta);
      }
    }
    restoreRelativeVerticalPositionOfCursor(e) {
      const t = e.getPosition();
      if (!this._cursorPosition || !t)
        return;
      const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
      e.setScrollTop(e.getScrollTop() + i);
    }
  }
  const NF = {
    RESOURCES: "ResourceURLs",
    DOWNLOAD_URL: "DownloadURL",
    FILES: "Files",
    TEXT: cr.text,
    TERMINALS: "Terminals"
  };
  class YG {
    constructor(e) {
      this.data = e;
    }
    update() {
    }
    getData() {
      return this.data;
    }
  }
  const za = {
    CurrentDragAndDropData: void 0
  };
  class zr extends z {
    constructor(e, t, i = {}) {
      super(), this.options = i, this._context = e || this, this._action = t, t instanceof ks && this._register(t.onDidChange((n) => {
        !this.element || this.handleActionChangeEvent(n);
      }));
    }
    handleActionChangeEvent(e) {
      e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
    }
    get actionRunner() {
      return this._actionRunner || (this._actionRunner = this._register(new gf())), this._actionRunner;
    }
    set actionRunner(e) {
      this._actionRunner = e;
    }
    getAction() {
      return this._action;
    }
    isEnabled() {
      return this._action.enabled;
    }
    setActionContext(e) {
      this._context = e;
    }
    render(e) {
      const t = this.element = e;
      this._register(kt.addTarget(e));
      const i = this.options && this.options.draggable;
      i && (e.draggable = !0, Xs && this._register(ee(e, ye.DRAG_START, (n) => {
        var o;
        return (o = n.dataTransfer) === null || o === void 0 ? void 0 : o.setData(NF.TEXT, this._action.label);
      }))), this._register(ee(t, Bt.Tap, (n) => this.onClick(n, !0))), this._register(ee(t, ye.MOUSE_DOWN, (n) => {
        i || wt.stop(n, !0), this._action.enabled && n.button === 0 && t.classList.add("active");
      })), Ye && this._register(ee(t, ye.CONTEXT_MENU, (n) => {
        n.button === 0 && n.ctrlKey === !0 && this.onClick(n);
      })), this._register(ee(t, ye.CLICK, (n) => {
        wt.stop(n, !0), this.options && this.options.isMenu || this.onClick(n);
      })), this._register(ee(t, ye.DBLCLICK, (n) => {
        wt.stop(n, !0);
      })), [ye.MOUSE_UP, ye.MOUSE_OUT].forEach((n) => {
        this._register(ee(t, n, (o) => {
          wt.stop(o), t.classList.remove("active");
        }));
      });
    }
    onClick(e, t = !1) {
      var i;
      wt.stop(e, !0);
      const n = Ws(this._context) ? !((i = this.options) === null || i === void 0) && i.useEventAsContext ? e : { preserveFocus: t } : this._context;
      this.actionRunner.run(this._action, n);
    }
    focus() {
      this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
    }
    blur() {
      this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
    }
    setFocusable(e) {
      this.element && (this.element.tabIndex = e ? 0 : -1);
    }
    get trapsArrowNavigation() {
      return !1;
    }
    updateEnabled() {
    }
    updateLabel() {
    }
    updateTooltip() {
    }
    updateClass() {
    }
    updateChecked() {
    }
    dispose() {
      this.element && (this.element.remove(), this.element = void 0), super.dispose();
    }
  }
  class up extends zr {
    constructor(e, t, i = {}) {
      super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
    }
    render(e) {
      super.render(e), this.element && (this.label = q(this.element, J("a.action-label"))), this.label && (this._action.id === mo.ID ? this.label.setAttribute("role", "presentation") : this.options.isMenu ? this.label.setAttribute("role", "menuitem") : this.label.setAttribute("role", "button")), this.options.label && this.options.keybinding && this.element && (q(this.element, J("span.keybinding")).textContent = this.options.keybinding), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
    }
    focus() {
      this.label && (this.label.tabIndex = 0, this.label.focus());
    }
    blur() {
      this.label && (this.label.tabIndex = -1);
    }
    setFocusable(e) {
      this.label && (this.label.tabIndex = e ? 0 : -1);
    }
    updateLabel() {
      this.options.label && this.label && (this.label.textContent = this.getAction().label);
    }
    updateTooltip() {
      let e = null;
      this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && (e = this.getAction().label, this.options.keybinding && (e = m({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e && this.label && (this.label.title = e);
    }
    updateClass() {
      this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getAction().class, this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : this.label && this.label.classList.remove("codicon");
    }
    updateEnabled() {
      this.getAction().enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), this.element && this.element.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), this.element && this.element.classList.add("disabled"));
    }
    updateChecked() {
      this.label && (this.getAction().checked ? this.label.classList.add("checked") : this.label.classList.remove("checked"));
    }
  }
  var XG = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class ga extends z {
    constructor(e, t = {}) {
      var i, n, o, r, a, l;
      super(), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new B()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new B({ onFirstListenerAdd: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new B()), this.onDidRun = this._onDidRun.event, this._onBeforeRun = this._register(new B()), this.onBeforeRun = this._onBeforeRun.event, this.options = t, this._context = (i = t.context) !== null && i !== void 0 ? i : null, this._orientation = (n = this.options.orientation) !== null && n !== void 0 ? n : 0, this._triggerKeys = {
        keyDown: (r = (o = this.options.triggerKeys) === null || o === void 0 ? void 0 : o.keyDown) !== null && r !== void 0 ? r : !1,
        keys: (l = (a = this.options.triggerKeys) === null || a === void 0 ? void 0 : a.keys) !== null && l !== void 0 ? l : [3, 10]
      }, this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new gf(), this._register(this._actionRunner)), this._register(this._actionRunner.onDidRun((h) => this._onDidRun.fire(h))), this._register(this._actionRunner.onBeforeRun((h) => this._onBeforeRun.fire(h))), this._actionIds = [], this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar", t.animated !== !1 && this.domNode.classList.add("animated");
      let c, d;
      switch (this._orientation) {
        case 0:
          c = [15], d = [17];
          break;
        case 1:
          c = [16], d = [18], this.domNode.className += " vertical";
          break;
      }
      this._register(ee(this.domNode, ye.KEY_DOWN, (h) => {
        const u = new $t(h);
        let f = !0;
        const g = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
        c && (u.equals(c[0]) || u.equals(c[1])) ? f = this.focusPrevious() : d && (u.equals(d[0]) || u.equals(d[1])) ? f = this.focusNext() : u.equals(9) && this.cancelHasListener ? this._onDidCancel.fire() : u.equals(14) ? f = this.focusFirst() : u.equals(13) ? f = this.focusLast() : u.equals(2) && g instanceof zr && g.trapsArrowNavigation ? f = this.focusNext() : this.isTriggerKeyEvent(u) ? this._triggerKeys.keyDown ? this.doTrigger(u) : this.triggerKeyDown = !0 : f = !1, f && (u.preventDefault(), u.stopPropagation());
      })), this._register(ee(this.domNode, ye.KEY_UP, (h) => {
        const u = new $t(h);
        this.isTriggerKeyEvent(u) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(u)), u.preventDefault(), u.stopPropagation()) : (u.equals(2) || u.equals(1026)) && this.updateFocusedItem();
      })), this.focusTracker = this._register(ff(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
        (Uu() === this.domNode || !al(Uu(), this.domNode)) && (this._onDidBlur.fire(), this.focusedItem = void 0, this.previouslyFocusedItem = void 0, this.triggerKeyDown = !1);
      })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.actionsList.setAttribute("role", "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
    }
    refreshRole() {
      this.length() >= 2 ? this.actionsList.setAttribute("role", "toolbar") : this.actionsList.setAttribute("role", "presentation");
    }
    setFocusable(e) {
      if (this.focusable = e, this.focusable) {
        const t = this.viewItems.find((i) => i instanceof zr && i.isEnabled());
        t instanceof zr && t.setFocusable(!0);
      } else
        this.viewItems.forEach((t) => {
          t instanceof zr && t.setFocusable(!1);
        });
    }
    isTriggerKeyEvent(e) {
      let t = !1;
      return this._triggerKeys.keys.forEach((i) => {
        t = t || e.equals(i);
      }), t;
    }
    updateFocusedItem() {
      for (let e = 0; e < this.actionsList.children.length; e++) {
        const t = this.actionsList.children[e];
        if (al(Uu(), t)) {
          this.focusedItem = e;
          break;
        }
      }
    }
    get context() {
      return this._context;
    }
    set context(e) {
      this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
    }
    get actionRunner() {
      return this._actionRunner;
    }
    set actionRunner(e) {
      e && (this._actionRunner = e, this.viewItems.forEach((t) => t.actionRunner = e));
    }
    getContainer() {
      return this.domNode;
    }
    push(e, t = {}) {
      const i = Array.isArray(e) ? e : [e];
      let n = zd(t.index) ? t.index : null;
      i.forEach((o) => {
        const r = document.createElement("li");
        r.className = "action-item", r.setAttribute("role", "presentation"), this.options.allowContextMenu || this._register(ee(r, ye.CONTEXT_MENU, (l) => {
          wt.stop(l, !0);
        }));
        let a;
        this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(o)), a || (a = new up(this.context, o, t)), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(r), this.focusable && a instanceof zr && this.viewItems.length === 0 && a.setFocusable(!0), n === null || n < 0 || n >= this.actionsList.children.length ? (this.actionsList.appendChild(r), this.viewItems.push(a), this._actionIds.push(o.id)) : (this.actionsList.insertBefore(r, this.actionsList.children[n]), this.viewItems.splice(n, 0, a), this._actionIds.splice(n, 0, o.id), n++);
      }), typeof this.focusedItem == "number" && this.focus(this.focusedItem), this.refreshRole();
    }
    clear() {
      at(this.viewItems), this.viewItems = [], this._actionIds = [], Bi(this.actionsList), this.refreshRole();
    }
    length() {
      return this.viewItems.length;
    }
    focus(e) {
      let t = !1, i;
      if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
        const n = this.viewItems.findIndex((o) => o.isEnabled());
        this.focusedItem = n === -1 ? void 0 : n, this.updateFocus(void 0, void 0, !0);
      } else
        i !== void 0 && (this.focusedItem = i), this.updateFocus(void 0, void 0, !0);
    }
    focusFirst() {
      return this.focusedItem = this.length() - 1, this.focusNext(!0);
    }
    focusLast() {
      return this.focusedItem = 0, this.focusPrevious(!0);
    }
    focusNext(e) {
      if (typeof this.focusedItem > "u")
        this.focusedItem = this.viewItems.length - 1;
      else if (this.viewItems.length <= 1)
        return !1;
      const t = this.focusedItem;
      let i;
      do {
        if (!e && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
          return this.focusedItem = t, !1;
        this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, i = this.viewItems[this.focusedItem];
      } while (this.focusedItem !== t && this.options.focusOnlyEnabledItems && !i.isEnabled());
      return this.updateFocus(), !0;
    }
    focusPrevious(e) {
      if (typeof this.focusedItem > "u")
        this.focusedItem = 0;
      else if (this.viewItems.length <= 1)
        return !1;
      const t = this.focusedItem;
      let i;
      do {
        if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
          if (!e && this.options.preventLoopNavigation)
            return this.focusedItem = t, !1;
          this.focusedItem = this.viewItems.length - 1;
        }
        i = this.viewItems[this.focusedItem];
      } while (this.focusedItem !== t && this.options.focusOnlyEnabledItems && !i.isEnabled());
      return this.updateFocus(!0), !0;
    }
    updateFocus(e, t, i = !1) {
      var n;
      typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem && ((n = this.viewItems[this.previouslyFocusedItem]) === null || n === void 0 || n.blur());
      const o = this.focusedItem !== void 0 && this.viewItems[this.focusedItem];
      if (o) {
        let r = !0;
        B0(o.focus) || (r = !1), this.options.focusOnlyEnabledItems && B0(o.isEnabled) && !o.isEnabled() && (r = !1), r ? (i || this.previouslyFocusedItem !== this.focusedItem) && (o.focus(e), this.previouslyFocusedItem = this.focusedItem) : (this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem = void 0);
      }
    }
    doTrigger(e) {
      if (typeof this.focusedItem > "u")
        return;
      const t = this.viewItems[this.focusedItem];
      if (t instanceof zr) {
        const i = t._context === null || t._context === void 0 ? e : t._context;
        this.run(t._action, i);
      }
    }
    run(e, t) {
      return XG(this, void 0, void 0, function* () {
        yield this._actionRunner.run(e, t);
      });
    }
    dispose() {
      at(this.viewItems), this.viewItems = [], this._actionIds = [], this.getContainer().remove(), super.dispose();
    }
  }
  const QG = {
    IconContribution: "base.contributions.icons"
  };
  var _M;
  (function(s) {
    function e(t, i) {
      let n = t.defaults;
      for (; Tt.isThemeIcon(n); ) {
        const o = Ph.getIcon(n.id);
        if (!o)
          return;
        n = o.defaults;
      }
      return n;
    }
    s.getDefinition = e;
  })(_M || (_M = {}));
  class JG {
    constructor() {
      this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
        definitions: {
          icons: {
            type: "object",
            properties: {
              fontId: { type: "string", description: m("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
              fontCharacter: { type: "string", description: m("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
            },
            additionalProperties: !1,
            defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
          }
        },
        type: "object",
        properties: {}
      }, this.iconReferenceSchema = { type: "string", pattern: `^${Un.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
    }
    registerIcon(e, t, i, n) {
      const o = this.iconsById[e];
      if (o) {
        if (i && !o.description) {
          o.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
          const l = this.iconReferenceSchema.enum.indexOf(e);
          l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
        }
        return o;
      }
      let r = { id: e, description: i, defaults: t, deprecationMessage: n };
      this.iconsById[e] = r;
      let a = { $ref: "#/definitions/icons" };
      return n && (a.deprecationMessage = n), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
    }
    getIcons() {
      return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
    }
    getIcon(e) {
      return this.iconsById[e];
    }
    getIconSchema() {
      return this.iconSchema;
    }
    toString() {
      const e = (o, r) => o.id.localeCompare(r.id), t = (o) => {
        for (; Tt.isThemeIcon(o.defaults); )
          o = this.iconsById[o.defaults.id];
        return `codicon codicon-${o ? o.id : ""}`;
      };
      let i = [];
      i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
      const n = Object.keys(this.iconsById).map((o) => this.iconsById[o]);
      for (const o of n.filter((r) => !!r.description).sort(e))
        i.push(`|<i class="${t(o)}"></i>|${o.id}|${Tt.isThemeIcon(o.defaults) ? o.defaults.id : o.id}|${o.description || ""}|`);
      i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
      for (const o of n.filter((r) => !Tt.isThemeIcon(r.defaults)).sort(e))
        i.push(`|<i class="${t(o)}"></i>|${o.id}|`);
      return i.join(`
`);
    }
  }
  const Ph = new JG();
  Si.add(QG.IconContribution, Ph);
  function Vi(s, e, t, i) {
    return Ph.registerIcon(s, e, t, i);
  }
  function TF() {
    return Ph;
  }
  function eZ() {
    for (const s of p.getAll())
      Ph.registerIcon(s.id, s.definition, s.description);
  }
  eZ();
  const MF = "vscode://schemas/icons";
  let AF = Si.as(Zv.JSONContribution);
  AF.registerSchema(MF, Ph.getIconSchema());
  const bM = new It(() => AF.notifySchemaChanged(MF), 200);
  Ph.onDidChange(() => {
    bM.isScheduled() || bM.schedule();
  });
  const RF = Vi("widget-close", p.close, m("widgetClose", "Icon for the close action in widgets."));
  Vi("goto-previous-location", p.arrowUp, m("previousChangeIcon", "Icon for goto previous editor location."));
  Vi("goto-next-location", p.arrowDown, m("nextChangeIcon", "Icon for goto next editor location."));
  Tt.modify(p.sync, "spin");
  Tt.modify(p.loading, "spin");
  var tZ = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, iZ = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, nZ = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, _S;
  const lb = 3;
  class Dg {
    constructor(e, t, i, n) {
      this.originalLineStart = e, this.originalLineEnd = t, this.modifiedLineStart = i, this.modifiedLineEnd = n;
    }
    getType() {
      return this.originalLineStart === 0 ? 1 : this.modifiedLineStart === 0 ? 2 : 0;
    }
  }
  class bS {
    constructor(e) {
      this.entries = e;
    }
  }
  const sZ = Vi("diff-review-insert", p.add, m("diffReviewInsertIcon", "Icon for 'Insert' in diff review.")), oZ = Vi("diff-review-remove", p.remove, m("diffReviewRemoveIcon", "Icon for 'Remove' in diff review.")), rZ = Vi("diff-review-close", p.close, m("diffReviewCloseIcon", "Icon for 'Close' in diff review."));
  let D1 = class nd extends z {
    constructor(e, t) {
      super(), this._languageService = t, this._width = 0, this._diffEditor = e, this._isVisible = !1, this.shadow = dt(document.createElement("div")), this.shadow.setClassName("diff-review-shadow"), this.actionBarContainer = dt(document.createElement("div")), this.actionBarContainer.setClassName("diff-review-actions"), this._actionBar = this._register(new ga(this.actionBarContainer.domNode)), this._actionBar.push(new ks("diffreview.close", m("label.close", "Close"), "close-diff-review " + Tt.asClassName(rZ), !0, () => nZ(this, void 0, void 0, function* () {
        return this.hide();
      })), { label: !1, icon: !0 }), this.domNode = dt(document.createElement("div")), this.domNode.setClassName("diff-review monaco-editor-background"), this._content = dt(document.createElement("div")), this._content.setClassName("diff-review-content"), this._content.setAttribute("role", "code"), this.scrollbar = this._register(new u_(this._content.domNode, {})), this.domNode.domNode.appendChild(this.scrollbar.getDomNode()), this._register(e.onDidUpdateDiff(() => {
        !this._isVisible || (this._diffs = this._compute(), this._render());
      })), this._register(e.getModifiedEditor().onDidChangeCursorPosition(() => {
        !this._isVisible || this._render();
      })), this._register(on(this.domNode.domNode, "click", (i) => {
        i.preventDefault();
        const n = pP(i.target, "diff-review-row");
        n && this._goToRow(n);
      })), this._register(on(this.domNode.domNode, "keydown", (i) => {
        (i.equals(18) || i.equals(2066) || i.equals(530)) && (i.preventDefault(), this._goToRow(this._getNextRow())), (i.equals(16) || i.equals(2064) || i.equals(528)) && (i.preventDefault(), this._goToRow(this._getPrevRow())), (i.equals(9) || i.equals(2057) || i.equals(521) || i.equals(1033)) && (i.preventDefault(), this.hide()), (i.equals(10) || i.equals(3)) && (i.preventDefault(), this.accept());
      })), this._diffs = [], this._currentDiff = null;
    }
    prev() {
      let e = 0;
      if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
        let i = -1;
        for (let n = 0, o = this._diffs.length; n < o; n++)
          if (this._diffs[n] === this._currentDiff) {
            i = n;
            break;
          }
        e = this._diffs.length + i - 1;
      } else
        e = this._findDiffIndex(this._diffEditor.getPosition());
      if (this._diffs.length === 0)
        return;
      e = e % this._diffs.length;
      const t = this._diffs[e].entries;
      this._diffEditor.setPosition(new V(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
    }
    next() {
      let e = 0;
      if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
        let i = -1;
        for (let n = 0, o = this._diffs.length; n < o; n++)
          if (this._diffs[n] === this._currentDiff) {
            i = n;
            break;
          }
        e = i + 1;
      } else
        e = this._findDiffIndex(this._diffEditor.getPosition());
      if (this._diffs.length === 0)
        return;
      e = e % this._diffs.length;
      const t = this._diffs[e].entries;
      this._diffEditor.setPosition(new V(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
    }
    accept() {
      let e = -1;
      const t = this._getCurrentFocusedRow();
      if (t) {
        const i = parseInt(t.getAttribute("data-line"), 10);
        isNaN(i) || (e = i);
      }
      this.hide(), e !== -1 && (this._diffEditor.setPosition(new V(e, 1)), this._diffEditor.revealPosition(new V(e, 1), 1));
    }
    hide() {
      this._isVisible = !1, this._diffEditor.updateOptions({ readOnly: !1 }), this._diffEditor.focus(), this._diffEditor.doLayout(), this._render();
    }
    _getPrevRow() {
      const e = this._getCurrentFocusedRow();
      return e ? e.previousElementSibling ? e.previousElementSibling : e : this._getFirstRow();
    }
    _getNextRow() {
      const e = this._getCurrentFocusedRow();
      return e ? e.nextElementSibling ? e.nextElementSibling : e : this._getFirstRow();
    }
    _getFirstRow() {
      return this.domNode.domNode.querySelector(".diff-review-row");
    }
    _getCurrentFocusedRow() {
      const e = document.activeElement;
      return e && /diff-review-row/.test(e.className) ? e : null;
    }
    _goToRow(e) {
      const t = this._getCurrentFocusedRow();
      e.tabIndex = 0, e.focus(), t && t !== e && (t.tabIndex = -1), this.scrollbar.scanDomNode();
    }
    isVisible() {
      return this._isVisible;
    }
    layout(e, t, i) {
      this._width = t, this.shadow.setTop(e - 6), this.shadow.setWidth(t), this.shadow.setHeight(this._isVisible ? 6 : 0), this.domNode.setTop(e), this.domNode.setWidth(t), this.domNode.setHeight(i), this._content.setHeight(i), this._content.setWidth(t), this._isVisible ? (this.actionBarContainer.setAttribute("aria-hidden", "false"), this.actionBarContainer.setDisplay("block")) : (this.actionBarContainer.setAttribute("aria-hidden", "true"), this.actionBarContainer.setDisplay("none"));
    }
    _compute() {
      const e = this._diffEditor.getLineChanges();
      if (!e || e.length === 0)
        return [];
      const t = this._diffEditor.getOriginalEditor().getModel(), i = this._diffEditor.getModifiedEditor().getModel();
      return !t || !i ? [] : nd._mergeAdjacent(e, t.getLineCount(), i.getLineCount());
    }
    static _mergeAdjacent(e, t, i) {
      if (!e || e.length === 0)
        return [];
      const n = [];
      let o = 0;
      for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c], u = h.originalStartLineNumber, f = h.originalEndLineNumber, g = h.modifiedStartLineNumber, _ = h.modifiedEndLineNumber, b = [];
        let C = 0;
        {
          const v = f === 0 ? u : u - 1, w = _ === 0 ? g : g - 1;
          let S = 1, L = 1;
          if (c > 0) {
            const k = e[c - 1];
            k.originalEndLineNumber === 0 ? S = k.originalStartLineNumber + 1 : S = k.originalEndLineNumber + 1, k.modifiedEndLineNumber === 0 ? L = k.modifiedStartLineNumber + 1 : L = k.modifiedEndLineNumber + 1;
          }
          let x = v - lb + 1, y = w - lb + 1;
          if (x < S) {
            const k = S - x;
            x = x + k, y = y + k;
          }
          if (y < L) {
            const k = L - y;
            x = x + k, y = y + k;
          }
          b[C++] = new Dg(x, v, y, w);
        }
        f !== 0 && (b[C++] = new Dg(u, f, 0, 0)), _ !== 0 && (b[C++] = new Dg(0, 0, g, _));
        {
          const v = f === 0 ? u + 1 : f + 1, w = _ === 0 ? g + 1 : _ + 1;
          let S = t, L = i;
          if (c + 1 < d) {
            const k = e[c + 1];
            k.originalEndLineNumber === 0 ? S = k.originalStartLineNumber : S = k.originalStartLineNumber - 1, k.modifiedEndLineNumber === 0 ? L = k.modifiedStartLineNumber : L = k.modifiedStartLineNumber - 1;
          }
          let x = v + lb - 1, y = w + lb - 1;
          if (x > S) {
            const k = S - x;
            x = x + k, y = y + k;
          }
          if (y > L) {
            const k = L - y;
            x = x + k, y = y + k;
          }
          b[C++] = new Dg(v, x, w, y);
        }
        n[o++] = new bS(b);
      }
      let r = n[0].entries;
      const a = [];
      let l = 0;
      for (let c = 1, d = n.length; c < d; c++) {
        const h = n[c].entries, u = r[r.length - 1], f = h[0];
        if (u.getType() === 0 && f.getType() === 0 && f.originalLineStart <= u.originalLineEnd) {
          r[r.length - 1] = new Dg(u.originalLineStart, f.originalLineEnd, u.modifiedLineStart, f.modifiedLineEnd), r = r.concat(h.slice(1));
          continue;
        }
        a[l++] = new bS(r), r = h;
      }
      return a[l++] = new bS(r), a;
    }
    _findDiffIndex(e) {
      const t = e.lineNumber;
      for (let i = 0, n = this._diffs.length; i < n; i++) {
        const o = this._diffs[i].entries, r = o[o.length - 1].modifiedLineEnd;
        if (t <= r)
          return i;
      }
      return 0;
    }
    _render() {
      const e = this._diffEditor.getOriginalEditor().getOptions(), t = this._diffEditor.getModifiedEditor().getOptions(), i = this._diffEditor.getOriginalEditor().getModel(), n = this._diffEditor.getModifiedEditor().getModel(), o = i.getOptions(), r = n.getOptions();
      if (!this._isVisible || !i || !n) {
        Bi(this._content.domNode), this._currentDiff = null, this.scrollbar.scanDomNode();
        return;
      }
      this._diffEditor.updateOptions({ readOnly: !0 });
      const a = this._findDiffIndex(this._diffEditor.getPosition());
      if (this._diffs[a] === this._currentDiff)
        return;
      this._currentDiff = this._diffs[a];
      const l = this._diffs[a].entries, c = document.createElement("div");
      c.className = "diff-review-table", c.setAttribute("role", "list"), c.setAttribute("aria-label", 'Difference review. Use "Stage | Unstage | Revert Selected Ranges" commands'), En(c, t.get(44));
      let d = 0, h = 0, u = 0, f = 0;
      for (let y = 0, k = l.length; y < k; y++) {
        const I = l[y], F = I.originalLineStart, R = I.originalLineEnd, $ = I.modifiedLineStart, j = I.modifiedLineEnd;
        F !== 0 && (d === 0 || F < d) && (d = F), R !== 0 && (h === 0 || R > h) && (h = R), $ !== 0 && (u === 0 || $ < u) && (u = $), j !== 0 && (f === 0 || j > f) && (f = j);
      }
      const g = document.createElement("div");
      g.className = "diff-review-row";
      const _ = document.createElement("div");
      _.className = "diff-review-cell diff-review-summary";
      const b = h - d + 1, C = f - u + 1;
      _.appendChild(document.createTextNode(`${a + 1}/${this._diffs.length}: @@ -${d},${b} +${u},${C} @@`)), g.setAttribute("data-line", String(u));
      const v = (y) => y === 0 ? m("no_lines_changed", "no lines changed") : y === 1 ? m("one_line_changed", "1 line changed") : m("more_lines_changed", "{0} lines changed", y), w = v(b), S = v(C);
      g.setAttribute("aria-label", m({
        key: "header",
        comment: [
          "This is the ARIA label for a git diff header.",
          "A git diff header looks like this: @@ -154,12 +159,39 @@.",
          "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
          "Variables 0 and 1 refer to the diff index out of total number of diffs.",
          "Variables 2 and 4 will be numbers (a line number).",
          'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
        ]
      }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", a + 1, this._diffs.length, d, w, u, S)), g.appendChild(_), g.setAttribute("role", "listitem"), c.appendChild(g);
      const L = t.get(59);
      let x = u;
      for (let y = 0, k = l.length; y < k; y++) {
        const I = l[y];
        nd._renderSection(c, I, x, L, this._width, e, i, o, t, n, r, this._languageService.languageIdCodec), I.modifiedLineStart !== 0 && (x = I.modifiedLineEnd);
      }
      Bi(this._content.domNode), this._content.domNode.appendChild(c), this.scrollbar.scanDomNode();
    }
    static _renderSection(e, t, i, n, o, r, a, l, c, d, h, u) {
      const f = t.getType();
      let g = "diff-review-row", _ = "";
      const b = "diff-review-spacer";
      let C = null;
      switch (f) {
        case 1:
          g = "diff-review-row line-insert", _ = " char-insert", C = sZ;
          break;
        case 2:
          g = "diff-review-row line-delete", _ = " char-delete", C = oZ;
          break;
      }
      const v = t.originalLineStart, w = t.originalLineEnd, S = t.modifiedLineStart, L = t.modifiedLineEnd, x = Math.max(L - S, w - v), y = r.get(131), k = y.glyphMarginWidth + y.lineNumbersWidth, I = c.get(131), F = 10 + I.glyphMarginWidth + I.lineNumbersWidth;
      for (let R = 0; R <= x; R++) {
        const $ = v === 0 ? 0 : v + R, j = S === 0 ? 0 : S + R, le = document.createElement("div");
        le.style.minWidth = o + "px", le.className = g, le.setAttribute("role", "listitem"), j !== 0 && (i = j), le.setAttribute("data-line", String(i));
        const he = document.createElement("div");
        he.className = "diff-review-cell", he.style.height = `${n}px`, le.appendChild(he);
        const Ce = document.createElement("span");
        Ce.style.width = k + "px", Ce.style.minWidth = k + "px", Ce.className = "diff-review-line-number" + _, $ !== 0 ? Ce.appendChild(document.createTextNode(String($))) : Ce.innerText = "\xA0", he.appendChild(Ce);
        const Ne = document.createElement("span");
        Ne.style.width = F + "px", Ne.style.minWidth = F + "px", Ne.style.paddingRight = "10px", Ne.className = "diff-review-line-number" + _, j !== 0 ? Ne.appendChild(document.createTextNode(String(j))) : Ne.innerText = "\xA0", he.appendChild(Ne);
        const xe = document.createElement("span");
        if (xe.className = b, C) {
          const bt = document.createElement("span");
          bt.className = Tt.asClassName(C), bt.innerText = "\xA0\xA0", xe.appendChild(bt);
        } else
          xe.innerText = "\xA0\xA0";
        he.appendChild(xe);
        let Ve;
        if (j !== 0) {
          let bt = this._renderLine(d, c, h.tabSize, j, u);
          nd._ttPolicy && (bt = nd._ttPolicy.createHTML(bt)), he.insertAdjacentHTML("beforeend", bt), Ve = d.getLineContent(j);
        } else {
          let bt = this._renderLine(a, r, l.tabSize, $, u);
          nd._ttPolicy && (bt = nd._ttPolicy.createHTML(bt)), he.insertAdjacentHTML("beforeend", bt), Ve = a.getLineContent($);
        }
        Ve.length === 0 && (Ve = m("blankLine", "blank"));
        let Ct = "";
        switch (f) {
          case 0:
            $ === j ? Ct = m({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", Ve, $) : Ct = m("equalLine", "{0} original line {1} modified line {2}", Ve, $, j);
            break;
          case 1:
            Ct = m("insertLine", "+ {0} modified line {1}", Ve, j);
            break;
          case 2:
            Ct = m("deleteLine", "- {0} original line {1}", Ve, $);
            break;
        }
        le.setAttribute("aria-label", Ct), e.appendChild(le);
      }
    }
    static _renderLine(e, t, i, n, o) {
      const r = e.getLineContent(n), a = t.get(44), l = Fi.createEmpty(r, o), c = Js.isBasicASCII(r, e.mightContainNonBasicASCII()), d = Js.containsRTL(r, c, e.mightContainRTL());
      return nC(new Rh(a.isMonospace && !t.get(29), a.canUseHalfwidthRightwardsArrow, r, !1, c, d, 0, l, [], i, 0, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, t.get(105), t.get(88), t.get(83), t.get(45) !== zs.OFF, null)).html;
    }
  };
  D1._ttPolicy = (_S = window.trustedTypes) === null || _S === void 0 ? void 0 : _S.createPolicy("diffReview", { createHTML: (s) => s });
  D1 = tZ([
    iZ(1, Jt)
  ], D1);
  Vt((s, e) => {
    const t = s.getColor(B5);
    t && e.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${t}; }`);
    const i = s.getColor(sg);
    i && e.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${i} 0 -6px 6px -6px inset; }`);
  });
  class aZ extends ge {
    constructor() {
      super({
        id: "editor.action.diffReview.next",
        label: m("editor.action.diffReview.next", "Go to Next Difference"),
        alias: "Go to Next Difference",
        precondition: ce.has("isInDiffEditor"),
        kbOpts: {
          kbExpr: null,
          primary: 65,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = OF(e);
      i && i.diffReviewNext();
    }
  }
  class lZ extends ge {
    constructor() {
      super({
        id: "editor.action.diffReview.prev",
        label: m("editor.action.diffReview.prev", "Go to Previous Difference"),
        alias: "Go to Previous Difference",
        precondition: ce.has("isInDiffEditor"),
        kbOpts: {
          kbExpr: null,
          primary: 1089,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = OF(e);
      i && i.diffReviewPrev();
    }
  }
  function OF(s) {
    const e = s.get(St), t = e.listDiffEditors(), i = e.getActiveCodeEditor();
    if (!i)
      return null;
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      if (r.getModifiedEditor().getId() === i.getId() || r.getOriginalEditor().getId() === i.getId())
        return r;
    }
    return null;
  }
  oe(aZ);
  oe(lZ);
  const cZ = "editorWorkerService", xo = st(cZ), m_ = st("contextViewService"), Fc = st("contextMenuService");
  var vS = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class dZ extends z {
    constructor(e, t, i, n, o, r) {
      super(), this._viewZoneId = e, this._marginDomNode = t, this.editor = i, this.diff = n, this._contextMenuService = o, this._clipboardService = r, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = p.lightBulb.classNames + " lightbulb-glyph", this._diffActions.style.position = "absolute";
      const a = i.getOption(59), l = i.getModel().getEOL();
      this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${a}px`, this._diffActions.style.lineHeight = `${a}px`, this._marginDomNode.appendChild(this._diffActions);
      const c = [], d = n.modifiedEndLineNumber === 0;
      c.push(new ks("diff.clipboard.copyDeletedContent", d ? n.originalEndLineNumber > n.modifiedStartLineNumber ? m("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : m("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : n.originalEndLineNumber > n.modifiedStartLineNumber ? m("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : m("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, !0, () => vS(this, void 0, void 0, function* () {
        const _ = new D(n.originalStartLineNumber, 1, n.originalEndLineNumber + 1, 1), b = n.originalModel.getValueInRange(_);
        yield this._clipboardService.writeText(b);
      })));
      let h = 0, u;
      n.originalEndLineNumber > n.modifiedStartLineNumber && (u = new ks("diff.clipboard.copyDeletedLineContent", d ? m("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.originalStartLineNumber) : m("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.originalStartLineNumber), void 0, !0, () => vS(this, void 0, void 0, function* () {
        const _ = n.originalModel.getLineContent(n.originalStartLineNumber + h);
        if (_ === "") {
          const b = n.originalModel.getEndOfLineSequence();
          yield this._clipboardService.writeText(b === 0 ? `
` : `\r
`);
        } else
          yield this._clipboardService.writeText(_);
      })), c.push(u)), i.getOption(81) || c.push(new ks("diff.inline.revertChange", m("diff.inline.revertChange.label", "Revert this change"), void 0, !0, () => vS(this, void 0, void 0, function* () {
        const _ = new D(n.originalStartLineNumber, 1, n.originalEndLineNumber, n.originalModel.getLineMaxColumn(n.originalEndLineNumber)), b = n.originalModel.getValueInRange(_);
        if (n.modifiedEndLineNumber === 0) {
          const C = i.getModel().getLineMaxColumn(n.modifiedStartLineNumber);
          i.executeEdits("diffEditor", [
            {
              range: new D(n.modifiedStartLineNumber, C, n.modifiedStartLineNumber, C),
              text: l + b
            }
          ]);
        } else {
          const C = i.getModel().getLineMaxColumn(n.modifiedEndLineNumber);
          i.executeEdits("diffEditor", [
            {
              range: new D(n.modifiedStartLineNumber, 1, n.modifiedEndLineNumber, C),
              text: b
            }
          ]);
        }
      })));
      const g = (_, b) => {
        this._contextMenuService.showContextMenu({
          getAnchor: () => ({
            x: _,
            y: b
          }),
          getActions: () => (u && (u.label = d ? m("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.originalStartLineNumber + h) : m("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.originalStartLineNumber + h)), c),
          autoSelectFirstItem: !0
        });
      };
      this._register(on(this._diffActions, "mousedown", (_) => {
        const { top: b, height: C } = mn(this._diffActions), v = Math.floor(a / 3);
        _.preventDefault(), g(_.posx, b + C + v);
      })), this._register(i.onMouseMove((_) => {
        _.target.type === 8 || _.target.type === 5 ? _.target.detail.viewZoneId === this._viewZoneId ? (this.visibility = !0, h = this._updateLightBulbPosition(this._marginDomNode, _.event.browserEvent.y, a)) : this.visibility = !1 : this.visibility = !1;
      })), this._register(i.onMouseDown((_) => {
        !_.event.rightButton || (_.target.type === 8 || _.target.type === 5) && _.target.detail.viewZoneId === this._viewZoneId && (_.event.preventDefault(), h = this._updateLightBulbPosition(this._marginDomNode, _.event.browserEvent.y, a), g(_.event.posx, _.event.posy + a));
      }));
    }
    get visibility() {
      return this._visibility;
    }
    set visibility(e) {
      this._visibility !== e && (this._visibility = e, e ? this._diffActions.style.visibility = "visible" : this._diffActions.style.visibility = "hidden");
    }
    _updateLightBulbPosition(e, t, i) {
      const { top: n } = mn(e), o = t - n, r = Math.floor(o / i), a = r * i;
      if (this._diffActions.style.top = `${a}px`, this.diff.viewLineCounts) {
        let l = 0;
        for (let c = 0; c < this.diff.viewLineCounts.length; c++)
          if (l += this.diff.viewLineCounts[c], r < l)
            return c;
      }
      return r;
    }
  }
  const Fh = st("clipboardService");
  Object.freeze({
    total() {
    },
    worked() {
    },
    done() {
    }
  });
  class Bh {
    constructor(e) {
      this.callback = e;
    }
    report(e) {
      this._value = e, this.callback(this._value);
    }
  }
  Bh.None = Object.freeze({ report() {
  } });
  const Bc = st("editorProgressService");
  var hZ = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Aa = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, CS;
  class vM {
    constructor(e, t) {
      this._contextMenuService = e, this._clipboardService = t, this._zones = [], this._inlineDiffMargins = [], this._zonesMap = {}, this._decorations = [];
    }
    getForeignViewZones(e) {
      return e.filter((t) => !this._zonesMap[String(t.id)]);
    }
    clean(e) {
      this._zones.length > 0 && e.changeViewZones((t) => {
        for (const i of this._zones)
          t.removeZone(i);
      }), this._zones = [], this._zonesMap = {}, this._decorations = e.deltaDecorations(this._decorations, []);
    }
    apply(e, t, i, n) {
      const o = n ? kc.capture(e) : null;
      e.changeViewZones((r) => {
        var a;
        for (const l of this._zones)
          r.removeZone(l);
        for (const l of this._inlineDiffMargins)
          l.dispose();
        this._zones = [], this._zonesMap = {}, this._inlineDiffMargins = [];
        for (let l = 0, c = i.zones.length; l < c; l++) {
          const d = i.zones[l];
          d.suppressMouseDown = !0;
          const h = r.addZone(d);
          this._zones.push(h), this._zonesMap[String(h)] = !0, i.zones[l].diff && d.marginDomNode && (d.suppressMouseDown = !1, ((a = i.zones[l].diff) === null || a === void 0 ? void 0 : a.originalModel.getValueLength()) !== 0 && this._inlineDiffMargins.push(new dZ(h, d.marginDomNode, e, i.zones[l].diff, this._contextMenuService, this._clipboardService)));
        }
      }), o && o.restore(e), this._decorations = e.deltaDecorations(this._decorations, i.decorations), t && t.setZones(i.overviewZones);
    }
  }
  let uZ = 0;
  const fZ = Vi("diff-insert", p.add, m("diffInsertIcon", "Line decoration for inserts in the diff editor.")), PF = Vi("diff-remove", p.remove, m("diffRemoveIcon", "Line decoration for removals in the diff editor.")), CM = (CS = window.trustedTypes) === null || CS === void 0 ? void 0 : CS.createPolicy("diffEditorWidget", { createHTML: (s) => s });
  let Dc = class Sn extends z {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      super(), this._editorProgressService = u, this._onDidDispose = this._register(new B()), this.onDidDispose = this._onDidDispose.event, this._onDidUpdateDiff = this._register(new B()), this.onDidUpdateDiff = this._onDidUpdateDiff.event, this._onDidContentSizeChange = this._register(new B()), this._lastOriginalWarning = null, this._lastModifiedWarning = null, this._editorWorkerService = o, this._codeEditorService = l, this._contextKeyService = this._register(r.createScoped(e)), this._instantiationService = a.createChild(new fC([Fe, this._contextKeyService])), this._contextKeyService.createKey("isInDiffEditor", !0), this._themeService = c, this._notificationService = d, this._id = ++uZ, this._state = 0, this._updatingDiffProgress = null, this._domElement = e, t = t || {}, this._options = yM(t, {
        enableSplitViewResizing: !0,
        renderSideBySide: !0,
        maxComputationTime: 5e3,
        maxFileSize: 50,
        ignoreTrimWhitespace: !0,
        renderIndicators: !0,
        originalEditable: !1,
        diffCodeLens: !1,
        renderOverviewRuler: !0,
        diffWordWrap: "inherit"
      }), typeof t.isInEmbeddedEditor < "u" ? this._contextKeyService.createKey("isInEmbeddedDiffEditor", t.isInEmbeddedEditor) : this._contextKeyService.createKey("isInEmbeddedDiffEditor", !1), this._updateDecorationsRunner = this._register(new It(() => this._updateDecorations(), 0)), this._containerDomElement = document.createElement("div"), this._containerDomElement.className = Sn._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide), this._containerDomElement.style.position = "relative", this._containerDomElement.style.height = "100%", this._domElement.appendChild(this._containerDomElement), this._overviewViewportDomElement = dt(document.createElement("div")), this._overviewViewportDomElement.setClassName("diffViewport"), this._overviewViewportDomElement.setPosition("absolute"), this._overviewDomElement = document.createElement("div"), this._overviewDomElement.className = "diffOverview", this._overviewDomElement.style.position = "absolute", this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode), this._register(on(this._overviewDomElement, "mousedown", (g) => {
        this._modifiedEditor.delegateVerticalScrollbarMouseDown(g);
      })), this._options.renderOverviewRuler && this._containerDomElement.appendChild(this._overviewDomElement), this._originalDomNode = document.createElement("div"), this._originalDomNode.className = "editor original", this._originalDomNode.style.position = "absolute", this._originalDomNode.style.height = "100%", this._containerDomElement.appendChild(this._originalDomNode), this._modifiedDomNode = document.createElement("div"), this._modifiedDomNode.className = "editor modified", this._modifiedDomNode.style.position = "absolute", this._modifiedDomNode.style.height = "100%", this._containerDomElement.appendChild(this._modifiedDomNode), this._beginUpdateDecorationsTimeout = -1, this._currentlyChangingViewZones = !1, this._diffComputationToken = 0, this._originalEditorState = new vM(h, n), this._modifiedEditorState = new vM(h, n), this._isVisible = !0, this._isHandlingScrollEvent = !1, this._elementSizeObserver = this._register(new l5(this._containerDomElement, t.dimension)), this._register(this._elementSizeObserver.onDidChange(() => this._onDidContainerSizeChanged())), t.automaticLayout && this._elementSizeObserver.startObserving(), this._diffComputationResult = null, this._originalEditor = this._createLeftHandSideEditor(t, i.originalEditor || {}), this._modifiedEditor = this._createRightHandSideEditor(t, i.modifiedEditor || {}), this._originalOverviewRuler = null, this._modifiedOverviewRuler = null, this._reviewPane = a.createInstance(D1, this), this._containerDomElement.appendChild(this._reviewPane.domNode.domNode), this._containerDomElement.appendChild(this._reviewPane.shadow.domNode), this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode), this._options.renderSideBySide ? this._setStrategy(new Ja(this._createDataSource(), this._options.enableSplitViewResizing)) : this._setStrategy(new SM(this._createDataSource(), this._options.enableSplitViewResizing)), this._register(c.onDidColorThemeChange((g) => {
        this._strategy && this._strategy.applyColors(g) && this._updateDecorationsRunner.schedule(), this._containerDomElement.className = Sn._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide);
      }));
      const f = Dd.getDiffEditorContributions();
      for (const g of f)
        try {
          this._register(a.createInstance(g.ctor, this));
        } catch (_) {
          We(_);
        }
      this._codeEditorService.addDiffEditor(this);
    }
    _setState(e) {
      this._state !== e && (this._state = e, this._updatingDiffProgress && (this._updatingDiffProgress.done(), this._updatingDiffProgress = null), this._state === 1 && (this._updatingDiffProgress = this._editorProgressService.show(!0, 1e3)));
    }
    diffReviewNext() {
      this._reviewPane.next();
    }
    diffReviewPrev() {
      this._reviewPane.prev();
    }
    static _getClassName(e, t) {
      let i = "monaco-diff-editor monaco-editor-background ";
      return t && (i += "side-by-side "), i += X0(e.type), i;
    }
    _recreateOverviewRulers() {
      !this._options.renderOverviewRuler || (this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose()), this._originalEditor.hasModel() && (this._originalOverviewRuler = this._originalEditor.createOverviewRuler("original diffOverviewRuler"), this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode())), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose()), this._modifiedEditor.hasModel() && (this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler("modified diffOverviewRuler"), this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode())), this._layoutOverviewRulers());
    }
    _createLeftHandSideEditor(e, t) {
      const i = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(e), t);
      this._register(i.onDidScrollChange((o) => {
        this._isHandlingScrollEvent || !o.scrollTopChanged && !o.scrollLeftChanged && !o.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._modifiedEditor.setScrollPosition({
          scrollLeft: o.scrollLeft,
          scrollTop: o.scrollTop
        }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
      })), this._register(i.onDidChangeViewZones(() => {
        this._onViewZonesChanged();
      })), this._register(i.onDidChangeConfiguration((o) => {
        !i.getModel() || (o.hasChanged(44) && this._updateDecorationsRunner.schedule(), o.hasChanged(132) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
      })), this._register(i.onDidChangeHiddenAreas(() => {
        this._updateDecorationsRunner.cancel(), this._updateDecorations();
      })), this._register(i.onDidChangeModelContent(() => {
        this._isVisible && this._beginUpdateDecorationsSoon();
      }));
      const n = this._contextKeyService.createKey("isInDiffLeftEditor", i.hasWidgetFocus());
      return this._register(i.onDidFocusEditorWidget(() => n.set(!0))), this._register(i.onDidBlurEditorWidget(() => n.set(!1))), this._register(i.onDidContentSizeChange((o) => {
        const r = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + Sn.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
        this._onDidContentSizeChange.fire({
          contentHeight: a,
          contentWidth: r,
          contentHeightChanged: o.contentHeightChanged,
          contentWidthChanged: o.contentWidthChanged
        });
      })), i;
    }
    _createRightHandSideEditor(e, t) {
      const i = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(e), t);
      this._register(i.onDidScrollChange((o) => {
        this._isHandlingScrollEvent || !o.scrollTopChanged && !o.scrollLeftChanged && !o.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._originalEditor.setScrollPosition({
          scrollLeft: o.scrollLeft,
          scrollTop: o.scrollTop
        }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
      })), this._register(i.onDidChangeViewZones(() => {
        this._onViewZonesChanged();
      })), this._register(i.onDidChangeConfiguration((o) => {
        !i.getModel() || (o.hasChanged(44) && this._updateDecorationsRunner.schedule(), o.hasChanged(132) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
      })), this._register(i.onDidChangeHiddenAreas(() => {
        this._updateDecorationsRunner.cancel(), this._updateDecorations();
      })), this._register(i.onDidChangeModelContent(() => {
        this._isVisible && this._beginUpdateDecorationsSoon();
      })), this._register(i.onDidChangeModelOptions((o) => {
        o.tabSize && this._updateDecorationsRunner.schedule();
      }));
      const n = this._contextKeyService.createKey("isInDiffRightEditor", i.hasWidgetFocus());
      return this._register(i.onDidFocusEditorWidget(() => n.set(!0))), this._register(i.onDidBlurEditorWidget(() => n.set(!1))), this._register(i.onDidContentSizeChange((o) => {
        const r = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + Sn.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
        this._onDidContentSizeChange.fire({
          contentHeight: a,
          contentWidth: r,
          contentHeightChanged: o.contentHeightChanged,
          contentWidthChanged: o.contentWidthChanged
        });
      })), i;
    }
    _createInnerEditor(e, t, i, n) {
      return e.createInstance(hp, t, i, n);
    }
    dispose() {
      this._codeEditorService.removeDiffEditor(this), this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._cleanViewZonesAndDecorations(), this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose()), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose()), this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode), this._options.renderOverviewRuler && this._containerDomElement.removeChild(this._overviewDomElement), this._containerDomElement.removeChild(this._originalDomNode), this._originalEditor.dispose(), this._containerDomElement.removeChild(this._modifiedDomNode), this._modifiedEditor.dispose(), this._strategy.dispose(), this._containerDomElement.removeChild(this._reviewPane.domNode.domNode), this._containerDomElement.removeChild(this._reviewPane.shadow.domNode), this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode), this._reviewPane.dispose(), this._domElement.removeChild(this._containerDomElement), this._onDidDispose.fire(), super.dispose();
    }
    getId() {
      return this.getEditorType() + ":" + this._id;
    }
    getEditorType() {
      return g_.IDiffEditor;
    }
    getLineChanges() {
      return this._diffComputationResult ? this._diffComputationResult.changes : null;
    }
    getOriginalEditor() {
      return this._originalEditor;
    }
    getModifiedEditor() {
      return this._modifiedEditor;
    }
    updateOptions(e) {
      const t = yM(e, this._options), i = _Z(this._options, t);
      this._options = t;
      const n = i.ignoreTrimWhitespace || i.renderIndicators, o = this._isVisible && (i.maxComputationTime || i.maxFileSize);
      n ? this._beginUpdateDecorations() : o && this._beginUpdateDecorationsSoon(), this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(e)), this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(e)), this._strategy.setEnableSplitViewResizing(this._options.enableSplitViewResizing), i.renderSideBySide && (this._options.renderSideBySide ? this._setStrategy(new Ja(this._createDataSource(), this._options.enableSplitViewResizing)) : this._setStrategy(new SM(this._createDataSource(), this._options.enableSplitViewResizing)), this._containerDomElement.className = Sn._getClassName(this._themeService.getColorTheme(), this._options.renderSideBySide)), i.renderOverviewRuler && (this._options.renderOverviewRuler ? this._containerDomElement.appendChild(this._overviewDomElement) : this._containerDomElement.removeChild(this._overviewDomElement));
    }
    getModel() {
      return {
        original: this._originalEditor.getModel(),
        modified: this._modifiedEditor.getModel()
      };
    }
    setModel(e) {
      if (e && (!e.original || !e.modified))
        throw new Error(e.original ? "DiffEditorWidget.setModel: Modified model is null" : "DiffEditorWidget.setModel: Original model is null");
      this._cleanViewZonesAndDecorations(), this._originalEditor.setModel(e ? e.original : null), this._modifiedEditor.setModel(e ? e.modified : null), this._updateDecorationsRunner.cancel(), e && (this._originalEditor.setScrollTop(0), this._modifiedEditor.setScrollTop(0)), this._diffComputationResult = null, this._diffComputationToken++, this._setState(0), e && (this._recreateOverviewRulers(), this._beginUpdateDecorations()), this._layoutOverviewViewport();
    }
    getContainerDomNode() {
      return this._domElement;
    }
    getVisibleColumnFromPosition(e) {
      return this._modifiedEditor.getVisibleColumnFromPosition(e);
    }
    getPosition() {
      return this._modifiedEditor.getPosition();
    }
    setPosition(e, t = "api") {
      this._modifiedEditor.setPosition(e, t);
    }
    revealLine(e, t = 0) {
      this._modifiedEditor.revealLine(e, t);
    }
    revealLineInCenter(e, t = 0) {
      this._modifiedEditor.revealLineInCenter(e, t);
    }
    revealLineInCenterIfOutsideViewport(e, t = 0) {
      this._modifiedEditor.revealLineInCenterIfOutsideViewport(e, t);
    }
    revealLineNearTop(e, t = 0) {
      this._modifiedEditor.revealLineNearTop(e, t);
    }
    revealPosition(e, t = 0) {
      this._modifiedEditor.revealPosition(e, t);
    }
    revealPositionInCenter(e, t = 0) {
      this._modifiedEditor.revealPositionInCenter(e, t);
    }
    revealPositionInCenterIfOutsideViewport(e, t = 0) {
      this._modifiedEditor.revealPositionInCenterIfOutsideViewport(e, t);
    }
    revealPositionNearTop(e, t = 0) {
      this._modifiedEditor.revealPositionNearTop(e, t);
    }
    getSelection() {
      return this._modifiedEditor.getSelection();
    }
    getSelections() {
      return this._modifiedEditor.getSelections();
    }
    setSelection(e, t = "api") {
      this._modifiedEditor.setSelection(e, t);
    }
    setSelections(e, t = "api") {
      this._modifiedEditor.setSelections(e, t);
    }
    revealLines(e, t, i = 0) {
      this._modifiedEditor.revealLines(e, t, i);
    }
    revealLinesInCenter(e, t, i = 0) {
      this._modifiedEditor.revealLinesInCenter(e, t, i);
    }
    revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
      this._modifiedEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
    }
    revealLinesNearTop(e, t, i = 0) {
      this._modifiedEditor.revealLinesNearTop(e, t, i);
    }
    revealRange(e, t = 0, i = !1, n = !0) {
      this._modifiedEditor.revealRange(e, t, i, n);
    }
    revealRangeInCenter(e, t = 0) {
      this._modifiedEditor.revealRangeInCenter(e, t);
    }
    revealRangeInCenterIfOutsideViewport(e, t = 0) {
      this._modifiedEditor.revealRangeInCenterIfOutsideViewport(e, t);
    }
    revealRangeNearTop(e, t = 0) {
      this._modifiedEditor.revealRangeNearTop(e, t);
    }
    revealRangeNearTopIfOutsideViewport(e, t = 0) {
      this._modifiedEditor.revealRangeNearTopIfOutsideViewport(e, t);
    }
    revealRangeAtTop(e, t = 0) {
      this._modifiedEditor.revealRangeAtTop(e, t);
    }
    getSupportedActions() {
      return this._modifiedEditor.getSupportedActions();
    }
    saveViewState() {
      const e = this._originalEditor.saveViewState(), t = this._modifiedEditor.saveViewState();
      return {
        original: e,
        modified: t
      };
    }
    restoreViewState(e) {
      if (e && e.original && e.modified) {
        const t = e;
        this._originalEditor.restoreViewState(t.original), this._modifiedEditor.restoreViewState(t.modified);
      }
    }
    layout(e) {
      this._elementSizeObserver.observe(e);
    }
    focus() {
      this._modifiedEditor.focus();
    }
    hasTextFocus() {
      return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();
    }
    trigger(e, t, i) {
      this._modifiedEditor.trigger(e, t, i);
    }
    changeDecorations(e) {
      return this._modifiedEditor.changeDecorations(e);
    }
    _onDidContainerSizeChanged() {
      this._doLayout();
    }
    _getReviewHeight() {
      return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;
    }
    _layoutOverviewRulers() {
      if (!this._options.renderOverviewRuler || !this._originalOverviewRuler || !this._modifiedOverviewRuler)
        return;
      const e = this._elementSizeObserver.getHeight(), t = this._getReviewHeight(), i = Sn.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * Sn.ONE_OVERVIEW_WIDTH;
      this._modifiedEditor.getLayoutInfo() && (this._originalOverviewRuler.setLayout({
        top: 0,
        width: Sn.ONE_OVERVIEW_WIDTH,
        right: i + Sn.ONE_OVERVIEW_WIDTH,
        height: e - t
      }), this._modifiedOverviewRuler.setLayout({
        top: 0,
        right: 0,
        width: Sn.ONE_OVERVIEW_WIDTH,
        height: e - t
      }));
    }
    _onViewZonesChanged() {
      this._currentlyChangingViewZones || this._updateDecorationsRunner.schedule();
    }
    _beginUpdateDecorationsSoon() {
      this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), Sn.UPDATE_DIFF_DECORATIONS_DELAY);
    }
    static _equals(e, t) {
      return !e && !t ? !0 : !e || !t ? !1 : e.toString() === t.toString();
    }
    _beginUpdateDecorations() {
      this._beginUpdateDecorationsTimeout = -1;
      const e = this._originalEditor.getModel(), t = this._modifiedEditor.getModel();
      if (!e || !t)
        return;
      this._diffComputationToken++;
      const i = this._diffComputationToken, n = this._options.maxFileSize * 1024 * 1024, o = (r) => {
        const a = r.getValueLength();
        return n === 0 || a <= n;
      };
      if (!o(e) || !o(t)) {
        (!Sn._equals(e.uri, this._lastOriginalWarning) || !Sn._equals(t.uri, this._lastModifiedWarning)) && (this._lastOriginalWarning = e.uri, this._lastModifiedWarning = t.uri, this._notificationService.warn(m("diff.tooLarge", "Cannot compare files because one file is too large.")));
        return;
      }
      this._setState(1), this._editorWorkerService.computeDiff(e.uri, t.uri, this._options.ignoreTrimWhitespace, this._options.maxComputationTime).then((r) => {
        i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(2), this._diffComputationResult = r, this._updateDecorationsRunner.schedule(), this._onDidUpdateDiff.fire());
      }, (r) => {
        i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(2), this._diffComputationResult = null, this._updateDecorationsRunner.schedule());
      });
    }
    _cleanViewZonesAndDecorations() {
      this._originalEditorState.clean(this._originalEditor), this._modifiedEditorState.clean(this._modifiedEditor);
    }
    _updateDecorations() {
      if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel())
        return;
      const e = this._diffComputationResult ? this._diffComputationResult.changes : [], t = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces()), i = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces()), n = this._strategy.getEditorsDiffDecorations(e, this._options.ignoreTrimWhitespace, this._options.renderIndicators, t, i);
      try {
        this._currentlyChangingViewZones = !0, this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, n.original, !1), this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, n.modified, !0);
      } finally {
        this._currentlyChangingViewZones = !1;
      }
    }
    _adjustOptionsForSubEditor(e) {
      const t = Object.assign({}, e);
      return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = Object.assign({}, t.scrollbar || {}), t.scrollbar.vertical = "visible", t.folding = !1, t.codeLens = this._options.diffCodeLens, t.fixedOverflowWidgets = !0, t.minimap = Object.assign({}, t.minimap || {}), t.minimap.enabled = !1, t;
    }
    _adjustOptionsForLeftHandSide(e) {
      const t = this._adjustOptionsForSubEditor(e);
      return this._options.renderSideBySide ? t.wordWrapOverride1 = this._options.diffWordWrap : (t.wordWrapOverride1 = "off", t.wordWrapOverride2 = "off"), e.originalAriaLabel && (t.ariaLabel = e.originalAriaLabel), t.readOnly = !this._options.originalEditable, t.extraEditorClassName = "original-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
        height: 0,
        width: 0
      } });
    }
    _adjustOptionsForRightHandSide(e) {
      const t = this._adjustOptionsForSubEditor(e);
      return e.modifiedAriaLabel && (t.ariaLabel = e.modifiedAriaLabel), t.wordWrapOverride1 = this._options.diffWordWrap, t.revealHorizontalRightPadding = yr.revealHorizontalRightPadding.defaultValue + Sn.ENTIRE_DIFF_OVERVIEW_WIDTH, t.scrollbar.verticalHasArrows = !1, t.extraEditorClassName = "modified-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
        height: 0,
        width: 0
      } });
    }
    doLayout() {
      this._elementSizeObserver.observe(), this._doLayout();
    }
    _doLayout() {
      const e = this._elementSizeObserver.getWidth(), t = this._elementSizeObserver.getHeight(), i = this._getReviewHeight(), n = this._strategy.layout();
      this._originalDomNode.style.width = n + "px", this._originalDomNode.style.left = "0px", this._modifiedDomNode.style.width = e - n + "px", this._modifiedDomNode.style.left = n + "px", this._overviewDomElement.style.top = "0px", this._overviewDomElement.style.height = t - i + "px", this._overviewDomElement.style.width = Sn.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewDomElement.style.left = e - Sn.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewViewportDomElement.setWidth(Sn.ENTIRE_DIFF_OVERVIEW_WIDTH), this._overviewViewportDomElement.setHeight(30), this._originalEditor.layout({ width: n, height: t - i }), this._modifiedEditor.layout({ width: e - n - (this._options.renderOverviewRuler ? Sn.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: t - i }), (this._originalOverviewRuler || this._modifiedOverviewRuler) && this._layoutOverviewRulers(), this._reviewPane.layout(t - i, e, i), this._layoutOverviewViewport();
    }
    _layoutOverviewViewport() {
      const e = this._computeOverviewViewport();
      e ? (this._overviewViewportDomElement.setTop(e.top), this._overviewViewportDomElement.setHeight(e.height)) : (this._overviewViewportDomElement.setTop(0), this._overviewViewportDomElement.setHeight(0));
    }
    _computeOverviewViewport() {
      const e = this._modifiedEditor.getLayoutInfo();
      if (!e)
        return null;
      const t = this._modifiedEditor.getScrollTop(), i = this._modifiedEditor.getScrollHeight(), n = Math.max(0, e.height), o = Math.max(0, n - 2 * 0), r = i > 0 ? o / i : 0, a = Math.max(0, Math.floor(e.height * r)), l = Math.floor(t * r);
      return {
        height: a,
        top: l
      };
    }
    _createDataSource() {
      return {
        getWidth: () => this._elementSizeObserver.getWidth(),
        getHeight: () => this._elementSizeObserver.getHeight() - this._getReviewHeight(),
        getOptions: () => ({
          renderOverviewRuler: this._options.renderOverviewRuler
        }),
        getContainerDomNode: () => this._containerDomElement,
        relayoutEditors: () => {
          this._doLayout();
        },
        getOriginalEditor: () => this._originalEditor,
        getModifiedEditor: () => this._modifiedEditor
      };
    }
    _setStrategy(e) {
      this._strategy && this._strategy.dispose(), this._strategy = e, e.applyColors(this._themeService.getColorTheme()), this._diffComputationResult && this._updateDecorations(), this._doLayout();
    }
    _getLineChangeAtOrBeforeLineNumber(e, t) {
      const i = this._diffComputationResult ? this._diffComputationResult.changes : [];
      if (i.length === 0 || e < t(i[0]))
        return null;
      let n = 0, o = i.length - 1;
      for (; n < o; ) {
        const r = Math.floor((n + o) / 2), a = t(i[r]), l = r + 1 <= o ? t(i[r + 1]) : 1073741824;
        e < a ? o = r - 1 : e >= l ? n = r + 1 : (n = r, o = r);
      }
      return i[n];
    }
    _getEquivalentLineForOriginalLineNumber(e) {
      const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.originalStartLineNumber);
      if (!t)
        return e;
      const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), n = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, r = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - i;
      return a <= o ? n + Math.min(a, r) : n + r - o + a;
    }
    _getEquivalentLineForModifiedLineNumber(e) {
      const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.modifiedStartLineNumber);
      if (!t)
        return e;
      const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), n = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, r = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - n;
      return a <= r ? i + Math.min(a, o) : i + o - r + a;
    }
    getDiffLineInformationForOriginal(e) {
      return this._diffComputationResult ? {
        equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(e)
      } : null;
    }
    getDiffLineInformationForModified(e) {
      return this._diffComputationResult ? {
        equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(e)
      } : null;
    }
  };
  Dc.ONE_OVERVIEW_WIDTH = 15;
  Dc.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
  Dc.UPDATE_DIFF_DECORATIONS_DELAY = 200;
  Dc = hZ([
    Aa(3, Fh),
    Aa(4, xo),
    Aa(5, Fe),
    Aa(6, et),
    Aa(7, St),
    Aa(8, jt),
    Aa(9, yi),
    Aa(10, Fc),
    Aa(11, Bc)
  ], Dc);
  class FF extends z {
    constructor(e) {
      super(), this._dataSource = e, this._insertColor = null, this._removeColor = null;
    }
    applyColors(e) {
      const t = e.getColor(Qz) || (e.getColor(k5) || pL).transparent(2), i = e.getColor(Jz) || (e.getColor(D5) || _L).transparent(2), n = !t.equals(this._insertColor) || !i.equals(this._removeColor);
      return this._insertColor = t, this._removeColor = i, n;
    }
    getEditorsDiffDecorations(e, t, i, n, o) {
      o = o.sort((c, d) => c.afterLineNumber - d.afterLineNumber), n = n.sort((c, d) => c.afterLineNumber - d.afterLineNumber);
      const r = this._getViewZones(e, n, o, i), a = this._getOriginalEditorDecorations(r, e, t, i), l = this._getModifiedEditorDecorations(r, e, t, i);
      return {
        original: {
          decorations: a.decorations,
          overviewZones: a.overviewZones,
          zones: r.original
        },
        modified: {
          decorations: l.decorations,
          overviewZones: l.overviewZones,
          zones: r.modified
        }
      };
    }
  }
  class wM {
    constructor(e) {
      this._source = e, this._index = -1, this.current = null, this.advance();
    }
    advance() {
      this._index++, this._index < this._source.length ? this.current = this._source[this._index] : this.current = null;
    }
  }
  class yd {
    constructor(e, t, i, n, o) {
      this._lineChanges = e, this._originalForeignVZ = t, this._modifiedForeignVZ = i, this._originalEditor = n, this._modifiedEditor = o;
    }
    static _getViewLineCount(e, t, i) {
      const n = e.getModel(), o = e._getViewModel();
      if (n && o) {
        const r = fp(n, o, t, i);
        return r.endLineNumber - r.startLineNumber + 1;
      }
      return i - t + 1;
    }
    getViewZones() {
      const e = this._originalEditor.getOption(59), t = this._modifiedEditor.getOption(59), i = this._originalEditor.getOption(132).wrappingColumn !== -1, n = this._modifiedEditor.getOption(132).wrappingColumn !== -1, o = i || n, r = this._originalEditor.getModel(), a = this._originalEditor._getViewModel().coordinatesConverter, l = this._modifiedEditor._getViewModel().coordinatesConverter, c = {
        original: [],
        modified: []
      };
      let d = 0, h = 0, u = 0, f = 0, g = 0, _ = 0;
      const b = (x, y) => x.afterLineNumber - y.afterLineNumber, C = (x, y) => {
        if (y.domNode === null && x.length > 0) {
          const k = x[x.length - 1];
          if (k.afterLineNumber === y.afterLineNumber && k.domNode === null) {
            k.heightInLines += y.heightInLines;
            return;
          }
        }
        x.push(y);
      }, v = new wM(this._modifiedForeignVZ), w = new wM(this._originalForeignVZ);
      let S = 1, L = 1;
      for (let x = 0, y = this._lineChanges.length; x <= y; x++) {
        const k = x < y ? this._lineChanges[x] : null;
        k !== null ? (u = k.originalStartLineNumber + (k.originalEndLineNumber > 0 ? -1 : 0), f = k.modifiedStartLineNumber + (k.modifiedEndLineNumber > 0 ? -1 : 0), h = k.originalEndLineNumber > 0 ? yd._getViewLineCount(this._originalEditor, k.originalStartLineNumber, k.originalEndLineNumber) : 0, d = k.modifiedEndLineNumber > 0 ? yd._getViewLineCount(this._modifiedEditor, k.modifiedStartLineNumber, k.modifiedEndLineNumber) : 0, g = Math.max(k.originalStartLineNumber, k.originalEndLineNumber), _ = Math.max(k.modifiedStartLineNumber, k.modifiedEndLineNumber)) : (u += 1e7 + h, f += 1e7 + d, g = u, _ = f);
        let I = [], F = [];
        if (o) {
          let j;
          k ? k.originalEndLineNumber > 0 ? j = k.originalStartLineNumber - S : j = k.modifiedStartLineNumber - L : j = r.getLineCount() - S + 1;
          for (let le = 0; le < j; le++) {
            const he = S + le, Ce = L + le, Ne = a.getModelLineViewLineCount(he), xe = l.getModelLineViewLineCount(Ce);
            Ne < xe ? I.push({
              afterLineNumber: he,
              heightInLines: xe - Ne,
              domNode: null,
              marginDomNode: null
            }) : Ne > xe && F.push({
              afterLineNumber: Ce,
              heightInLines: Ne - xe,
              domNode: null,
              marginDomNode: null
            });
          }
          k && (S = (k.originalEndLineNumber > 0 ? k.originalEndLineNumber : k.originalStartLineNumber) + 1, L = (k.modifiedEndLineNumber > 0 ? k.modifiedEndLineNumber : k.modifiedStartLineNumber) + 1);
        }
        for (; v.current && v.current.afterLineNumber <= _; ) {
          let j;
          v.current.afterLineNumber <= f ? j = u - f + v.current.afterLineNumber : j = g;
          let le = null;
          k && k.modifiedStartLineNumber <= v.current.afterLineNumber && v.current.afterLineNumber <= k.modifiedEndLineNumber && (le = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion()), I.push({
            afterLineNumber: j,
            heightInLines: v.current.height / t,
            domNode: null,
            marginDomNode: le
          }), v.advance();
        }
        for (; w.current && w.current.afterLineNumber <= g; ) {
          let j;
          w.current.afterLineNumber <= u ? j = f - u + w.current.afterLineNumber : j = _, F.push({
            afterLineNumber: j,
            heightInLines: w.current.height / e,
            domNode: null
          }), w.advance();
        }
        if (k !== null && ef(k)) {
          const j = this._produceOriginalFromDiff(k, h, d);
          j && I.push(j);
        }
        if (k !== null && tf(k)) {
          const j = this._produceModifiedFromDiff(k, h, d);
          j && F.push(j);
        }
        let R = 0, $ = 0;
        for (I = I.sort(b), F = F.sort(b); R < I.length && $ < F.length; ) {
          const j = I[R], le = F[$], he = j.afterLineNumber - u, Ce = le.afterLineNumber - f;
          he < Ce ? (C(c.original, j), R++) : Ce < he ? (C(c.modified, le), $++) : j.shouldNotShrink ? (C(c.original, j), R++) : le.shouldNotShrink ? (C(c.modified, le), $++) : j.heightInLines >= le.heightInLines ? (j.heightInLines -= le.heightInLines, $++) : (le.heightInLines -= j.heightInLines, R++);
        }
        for (; R < I.length; )
          C(c.original, I[R]), R++;
        for (; $ < F.length; )
          C(c.modified, F[$]), $++;
      }
      return {
        original: yd._ensureDomNodes(c.original),
        modified: yd._ensureDomNodes(c.modified)
      };
    }
    static _ensureDomNodes(e) {
      return e.map((t) => (t.domNode || (t.domNode = BF()), t));
    }
  }
  function Ga(s, e, t, i, n) {
    return {
      range: new D(s, e, t, i),
      options: n
    };
  }
  const is = {
    charDelete: $e.register({
      description: "diff-editor-char-delete",
      className: "char-delete"
    }),
    charDeleteWholeLine: $e.register({
      description: "diff-editor-char-delete-whole-line",
      className: "char-delete",
      isWholeLine: !0
    }),
    charInsert: $e.register({
      description: "diff-editor-char-insert",
      className: "char-insert"
    }),
    charInsertWholeLine: $e.register({
      description: "diff-editor-char-insert-whole-line",
      className: "char-insert",
      isWholeLine: !0
    }),
    lineInsert: $e.register({
      description: "diff-editor-line-insert",
      className: "line-insert",
      marginClassName: "gutter-insert",
      isWholeLine: !0
    }),
    lineInsertWithSign: $e.register({
      description: "diff-editor-line-insert-with-sign",
      className: "line-insert",
      linesDecorationsClassName: "insert-sign " + Tt.asClassName(fZ),
      marginClassName: "gutter-insert",
      isWholeLine: !0
    }),
    lineDelete: $e.register({
      description: "diff-editor-line-delete",
      className: "line-delete",
      marginClassName: "gutter-delete",
      isWholeLine: !0
    }),
    lineDeleteWithSign: $e.register({
      description: "diff-editor-line-delete-with-sign",
      className: "line-delete",
      linesDecorationsClassName: "delete-sign " + Tt.asClassName(PF),
      marginClassName: "gutter-delete",
      isWholeLine: !0
    }),
    lineDeleteMargin: $e.register({
      description: "diff-editor-line-delete-margin",
      marginClassName: "gutter-delete"
    })
  };
  class Ja extends FF {
    constructor(e, t) {
      super(e), this._disableSash = t === !1, this._sashRatio = null, this._sashPosition = null, this._startSashPosition = null, this._sash = this._register(new Dn(this._dataSource.getContainerDomNode(), this, { orientation: 0 })), this._disableSash && (this._sash.state = 0), this._sash.onDidStart(() => this._onSashDragStart()), this._sash.onDidChange((i) => this._onSashDrag(i)), this._sash.onDidEnd(() => this._onSashDragEnd()), this._sash.onDidReset(() => this._onSashReset());
    }
    setEnableSplitViewResizing(e) {
      const t = e === !1;
      this._disableSash !== t && (this._disableSash = t, this._sash.state = this._disableSash ? 0 : 3);
    }
    layout(e = this._sashRatio) {
      const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? Dc.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
      let n = Math.floor((e || 0.5) * i);
      const o = Math.floor(0.5 * i);
      return n = this._disableSash ? o : n || o, i > Ja.MINIMUM_EDITOR_WIDTH * 2 ? (n < Ja.MINIMUM_EDITOR_WIDTH && (n = Ja.MINIMUM_EDITOR_WIDTH), n > i - Ja.MINIMUM_EDITOR_WIDTH && (n = i - Ja.MINIMUM_EDITOR_WIDTH)) : n = o, this._sashPosition !== n && (this._sashPosition = n), this._sash.layout(), this._sashPosition;
    }
    _onSashDragStart() {
      this._startSashPosition = this._sashPosition;
    }
    _onSashDrag(e) {
      const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? Dc.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), n = this.layout((this._startSashPosition + (e.currentX - e.startX)) / i);
      this._sashRatio = n / i, this._dataSource.relayoutEditors();
    }
    _onSashDragEnd() {
      this._sash.layout();
    }
    _onSashReset() {
      this._sashRatio = 0.5, this._dataSource.relayoutEditors(), this._sash.layout();
    }
    getVerticalSashTop(e) {
      return 0;
    }
    getVerticalSashLeft(e) {
      return this._sashPosition;
    }
    getVerticalSashHeight(e) {
      return this._dataSource.getHeight();
    }
    _getViewZones(e, t, i) {
      const n = this._dataSource.getOriginalEditor(), o = this._dataSource.getModifiedEditor();
      return new gZ(e, t, i, n, o).getViewZones();
    }
    _getOriginalEditorDecorations(e, t, i, n) {
      const o = this._dataSource.getOriginalEditor(), r = String(this._removeColor), a = {
        decorations: [],
        overviewZones: []
      }, l = o.getModel(), c = o._getViewModel();
      for (const d of t)
        if (tf(d)) {
          a.decorations.push({
            range: new D(d.originalStartLineNumber, 1, d.originalEndLineNumber, 1073741824),
            options: n ? is.lineDeleteWithSign : is.lineDelete
          }), (!ef(d) || !d.charChanges) && a.decorations.push(Ga(d.originalStartLineNumber, 1, d.originalEndLineNumber, 1073741824, is.charDeleteWholeLine));
          const h = fp(l, c, d.originalStartLineNumber, d.originalEndLineNumber);
          if (a.overviewZones.push(new sp(h.startLineNumber, h.endLineNumber, 0, r)), d.charChanges) {
            for (const u of d.charChanges)
              if (tf(u))
                if (i)
                  for (let f = u.originalStartLineNumber; f <= u.originalEndLineNumber; f++) {
                    let g, _;
                    f === u.originalStartLineNumber ? g = u.originalStartColumn : g = l.getLineFirstNonWhitespaceColumn(f), f === u.originalEndLineNumber ? _ = u.originalEndColumn : _ = l.getLineLastNonWhitespaceColumn(f), a.decorations.push(Ga(f, g, f, _, is.charDelete));
                  }
                else
                  a.decorations.push(Ga(u.originalStartLineNumber, u.originalStartColumn, u.originalEndLineNumber, u.originalEndColumn, is.charDelete));
          }
        }
      return a;
    }
    _getModifiedEditorDecorations(e, t, i, n) {
      const o = this._dataSource.getModifiedEditor(), r = String(this._insertColor), a = {
        decorations: [],
        overviewZones: []
      }, l = o.getModel(), c = o._getViewModel();
      for (const d of t)
        if (ef(d)) {
          a.decorations.push({
            range: new D(d.modifiedStartLineNumber, 1, d.modifiedEndLineNumber, 1073741824),
            options: n ? is.lineInsertWithSign : is.lineInsert
          }), (!tf(d) || !d.charChanges) && a.decorations.push(Ga(d.modifiedStartLineNumber, 1, d.modifiedEndLineNumber, 1073741824, is.charInsertWholeLine));
          const h = fp(l, c, d.modifiedStartLineNumber, d.modifiedEndLineNumber);
          if (a.overviewZones.push(new sp(h.startLineNumber, h.endLineNumber, 0, r)), d.charChanges) {
            for (const u of d.charChanges)
              if (ef(u))
                if (i)
                  for (let f = u.modifiedStartLineNumber; f <= u.modifiedEndLineNumber; f++) {
                    let g, _;
                    f === u.modifiedStartLineNumber ? g = u.modifiedStartColumn : g = l.getLineFirstNonWhitespaceColumn(f), f === u.modifiedEndLineNumber ? _ = u.modifiedEndColumn : _ = l.getLineLastNonWhitespaceColumn(f), a.decorations.push(Ga(f, g, f, _, is.charInsert));
                  }
                else
                  a.decorations.push(Ga(u.modifiedStartLineNumber, u.modifiedStartColumn, u.modifiedEndLineNumber, u.modifiedEndColumn, is.charInsert));
          }
        }
      return a;
    }
  }
  Ja.MINIMUM_EDITOR_WIDTH = 100;
  class gZ extends yd {
    constructor(e, t, i, n, o) {
      super(e, t, i, n, o);
    }
    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
      return null;
    }
    _produceOriginalFromDiff(e, t, i) {
      return i > t ? {
        afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
        heightInLines: i - t,
        domNode: null
      } : null;
    }
    _produceModifiedFromDiff(e, t, i) {
      return t > i ? {
        afterLineNumber: Math.max(e.modifiedStartLineNumber, e.modifiedEndLineNumber),
        heightInLines: t - i,
        domNode: null
      } : null;
    }
  }
  class SM extends FF {
    constructor(e, t) {
      super(e), this._decorationsLeft = e.getOriginalEditor().getLayoutInfo().decorationsLeft, this._register(e.getOriginalEditor().onDidLayoutChange((i) => {
        this._decorationsLeft !== i.decorationsLeft && (this._decorationsLeft = i.decorationsLeft, e.relayoutEditors());
      }));
    }
    setEnableSplitViewResizing(e) {
    }
    _getViewZones(e, t, i, n) {
      const o = this._dataSource.getOriginalEditor(), r = this._dataSource.getModifiedEditor();
      return new mZ(e, t, i, o, r, n).getViewZones();
    }
    _getOriginalEditorDecorations(e, t, i, n) {
      const o = String(this._removeColor), r = {
        decorations: [],
        overviewZones: []
      }, a = this._dataSource.getOriginalEditor(), l = a.getModel(), c = a._getViewModel();
      let d = 0;
      for (const h of t)
        if (tf(h)) {
          for (r.decorations.push({
            range: new D(h.originalStartLineNumber, 1, h.originalEndLineNumber, 1073741824),
            options: is.lineDeleteMargin
          }); d < e.modified.length; ) {
            const g = e.modified[d];
            if (g.diff && g.diff.originalStartLineNumber >= h.originalStartLineNumber)
              break;
            d++;
          }
          let u = 0;
          if (d < e.modified.length) {
            const g = e.modified[d];
            g.diff && g.diff.originalStartLineNumber === h.originalStartLineNumber && g.diff.originalEndLineNumber === h.originalEndLineNumber && g.diff.modifiedStartLineNumber === h.modifiedStartLineNumber && g.diff.modifiedEndLineNumber === h.modifiedEndLineNumber && (u = g.heightInLines);
          }
          const f = fp(l, c, h.originalStartLineNumber, h.originalEndLineNumber);
          r.overviewZones.push(new sp(f.startLineNumber, f.endLineNumber, u, o));
        }
      return r;
    }
    _getModifiedEditorDecorations(e, t, i, n) {
      const o = this._dataSource.getModifiedEditor(), r = String(this._insertColor), a = {
        decorations: [],
        overviewZones: []
      }, l = o.getModel(), c = o._getViewModel();
      for (const d of t)
        if (ef(d)) {
          a.decorations.push({
            range: new D(d.modifiedStartLineNumber, 1, d.modifiedEndLineNumber, 1073741824),
            options: n ? is.lineInsertWithSign : is.lineInsert
          });
          const h = fp(l, c, d.modifiedStartLineNumber, d.modifiedEndLineNumber);
          if (a.overviewZones.push(new sp(h.startLineNumber, h.endLineNumber, 0, r)), d.charChanges) {
            for (const u of d.charChanges)
              if (ef(u))
                if (i)
                  for (let f = u.modifiedStartLineNumber; f <= u.modifiedEndLineNumber; f++) {
                    let g, _;
                    f === u.modifiedStartLineNumber ? g = u.modifiedStartColumn : g = l.getLineFirstNonWhitespaceColumn(f), f === u.modifiedEndLineNumber ? _ = u.modifiedEndColumn : _ = l.getLineLastNonWhitespaceColumn(f), a.decorations.push(Ga(f, g, f, _, is.charInsert));
                  }
                else
                  a.decorations.push(Ga(u.modifiedStartLineNumber, u.modifiedStartColumn, u.modifiedEndLineNumber, u.modifiedEndColumn, is.charInsert));
          } else
            a.decorations.push(Ga(d.modifiedStartLineNumber, 1, d.modifiedEndLineNumber, 1073741824, is.charInsertWholeLine));
        }
      return a;
    }
    layout() {
      return Math.max(5, this._decorationsLeft);
    }
  }
  class mZ extends yd {
    constructor(e, t, i, n, o, r) {
      super(e, t, i, n, o), this._originalModel = n.getModel(), this._renderIndicators = r, this._pendingLineChange = [], this._pendingViewZones = [], this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();
    }
    getViewZones() {
      const e = super.getViewZones();
      return this._finalize(e), e;
    }
    _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
      const e = document.createElement("div");
      return e.className = "inline-added-margin-view-zone", e;
    }
    _produceOriginalFromDiff(e, t, i) {
      const n = document.createElement("div");
      return n.className = "inline-added-margin-view-zone", {
        afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
        heightInLines: i,
        domNode: document.createElement("div"),
        marginDomNode: n
      };
    }
    _produceModifiedFromDiff(e, t, i) {
      const n = document.createElement("div");
      n.className = `view-lines line-delete ${Ad}`;
      const o = document.createElement("div");
      o.className = "inline-deleted-margin-view-zone";
      const r = {
        shouldNotShrink: !0,
        afterLineNumber: e.modifiedEndLineNumber === 0 ? e.modifiedStartLineNumber : e.modifiedStartLineNumber - 1,
        heightInLines: t,
        minWidthInPx: 0,
        domNode: n,
        marginDomNode: o,
        diff: {
          originalStartLineNumber: e.originalStartLineNumber,
          originalEndLineNumber: e.originalEndLineNumber,
          modifiedStartLineNumber: e.modifiedStartLineNumber,
          modifiedEndLineNumber: e.modifiedEndLineNumber,
          originalModel: this._originalModel,
          viewLineCounts: null
        }
      };
      for (let a = e.originalStartLineNumber; a <= e.originalEndLineNumber; a++)
        this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(a), null, null);
      return this._pendingLineChange.push(e), this._pendingViewZones.push(r), r;
    }
    _finalize(e) {
      const t = this._modifiedEditor.getOptions(), i = this._modifiedEditor.getModel().getOptions().tabSize, n = t.get(44), o = t.get(29), r = n.typicalHalfwidthCharacterWidth, a = t.get(93), l = this._originalModel.mightContainNonBasicASCII(), c = this._originalModel.mightContainRTL(), d = t.get(59), u = t.get(131).decorationsWidth, f = t.get(105), g = t.get(88), _ = t.get(83), b = t.get(45), C = this._lineBreaksComputer.finalize();
      let v = 0;
      for (let w = 0; w < this._pendingLineChange.length; w++) {
        const S = this._pendingLineChange[w], L = this._pendingViewZones[w], x = L.domNode;
        En(x, n);
        const y = L.marginDomNode;
        En(y, n);
        const k = [];
        if (S.charChanges)
          for (const Ce of S.charChanges)
            tf(Ce) && k.push(new um(new D(Ce.originalStartLineNumber, Ce.originalStartColumn, Ce.originalEndLineNumber, Ce.originalEndColumn), "char-delete", 0));
        const I = k.length > 0, F = Zd(1e4);
        let R = 0, $ = 0, j = null;
        for (let Ce = S.originalStartLineNumber; Ce <= S.originalEndLineNumber; Ce++) {
          const Ne = Ce - S.originalStartLineNumber, xe = this._originalModel.getLineTokens(Ce), Ve = xe.getLineContent(), Ct = C[v++], bt = js.filter(k, Ce, 1, Ve.length + 1);
          if (Ct) {
            let ve = 0;
            for (const ft of Ct.breakOffsets) {
              const Hi = xe.sliceAndInflate(ve, ft, 0), Ri = Ve.substring(ve, ft);
              R = Math.max(R, this._renderOriginalLine($++, Ri, Hi, js.extractWrapped(bt, ve, ft), I, l, c, n, o, d, u, f, g, _, b, i, F, y)), ve = ft;
            }
            for (j || (j = []); j.length < Ne; )
              j[j.length] = 1;
            j[Ne] = Ct.breakOffsets.length, L.heightInLines += Ct.breakOffsets.length - 1;
            const pe = document.createElement("div");
            pe.className = "gutter-delete", e.original.push({
              afterLineNumber: Ce,
              afterColumn: 0,
              heightInLines: Ct.breakOffsets.length - 1,
              domNode: BF(),
              marginDomNode: pe
            });
          } else
            R = Math.max(R, this._renderOriginalLine($++, Ve, xe, bt, I, l, c, n, o, d, u, f, g, _, b, i, F, y));
        }
        R += a;
        const le = F.build(), he = CM ? CM.createHTML(le) : le;
        if (x.innerHTML = he, L.minWidthInPx = R * r, j) {
          const Ce = S.originalEndLineNumber - S.originalStartLineNumber;
          for (; j.length <= Ce; )
            j[j.length] = 1;
        }
        L.diff.viewLineCounts = j;
      }
      e.original.sort((w, S) => w.afterLineNumber - S.afterLineNumber);
    }
    _renderOriginalLine(e, t, i, n, o, r, a, l, c, d, h, u, f, g, _, b, C, v) {
      C.appendASCIIString('<div class="view-line'), o || C.appendASCIIString(" char-delete"), C.appendASCIIString('" style="top:'), C.appendASCIIString(String(e * d)), C.appendASCIIString('px;width:1000000px;">');
      const w = Js.isBasicASCII(t, r), S = Js.containsRTL(t, w, a), L = iC(new Rh(l.isMonospace && !c, l.canUseHalfwidthRightwardsArrow, t, !1, w, S, 0, i, n, b, 0, l.spaceWidth, l.middotWidth, l.wsmiddotWidth, u, f, g, _ !== zs.OFF, null), C);
      if (C.appendASCIIString("</div>"), this._renderIndicators) {
        const x = document.createElement("div");
        x.className = `delete-sign ${Tt.asClassName(PF)}`, x.setAttribute("style", `position:absolute;top:${e * d}px;width:${h}px;height:${d}px;right:0;`), v.appendChild(x);
      }
      return L.characterMapping.getAbsoluteOffset(L.characterMapping.length);
    }
  }
  function pZ(s, e) {
    return rs(s, e, ["off", "on", "inherit"]);
  }
  function ef(s) {
    return s.modifiedEndLineNumber > 0;
  }
  function tf(s) {
    return s.originalEndLineNumber > 0;
  }
  function BF() {
    const s = document.createElement("div");
    return s.className = "diagonal-fill", s;
  }
  function fp(s, e, t, i) {
    const n = s.getLineCount();
    return t = Math.min(n, Math.max(1, t)), i = Math.min(n, Math.max(1, i)), e.coordinatesConverter.convertModelRangeToViewRange(new D(t, s.getLineMinColumn(t), i, s.getLineMaxColumn(i)));
  }
  function yM(s, e) {
    return {
      enableSplitViewResizing: De(s.enableSplitViewResizing, e.enableSplitViewResizing),
      renderSideBySide: De(s.renderSideBySide, e.renderSideBySide),
      maxComputationTime: lL(s.maxComputationTime, e.maxComputationTime, 0, 1073741824),
      maxFileSize: lL(s.maxFileSize, e.maxFileSize, 0, 1073741824),
      ignoreTrimWhitespace: De(s.ignoreTrimWhitespace, e.ignoreTrimWhitespace),
      renderIndicators: De(s.renderIndicators, e.renderIndicators),
      originalEditable: De(s.originalEditable, e.originalEditable),
      diffCodeLens: De(s.diffCodeLens, e.diffCodeLens),
      renderOverviewRuler: De(s.renderOverviewRuler, e.renderOverviewRuler),
      diffWordWrap: pZ(s.diffWordWrap, e.diffWordWrap)
    };
  }
  function _Z(s, e) {
    return {
      enableSplitViewResizing: s.enableSplitViewResizing !== e.enableSplitViewResizing,
      renderSideBySide: s.renderSideBySide !== e.renderSideBySide,
      maxComputationTime: s.maxComputationTime !== e.maxComputationTime,
      maxFileSize: s.maxFileSize !== e.maxFileSize,
      ignoreTrimWhitespace: s.ignoreTrimWhitespace !== e.ignoreTrimWhitespace,
      renderIndicators: s.renderIndicators !== e.renderIndicators,
      originalEditable: s.originalEditable !== e.originalEditable,
      diffCodeLens: s.diffCodeLens !== e.diffCodeLens,
      renderOverviewRuler: s.renderOverviewRuler !== e.renderOverviewRuler,
      diffWordWrap: s.diffWordWrap !== e.diffWordWrap
    };
  }
  Vt((s, e) => {
    const t = s.getColor(k5);
    t && e.addRule(`.monaco-editor .char-insert, .monaco-diff-editor .char-insert { background-color: ${t}; }`);
    const i = s.getColor(Gz) || t;
    i && e.addRule(`.monaco-editor .line-insert, .monaco-diff-editor .line-insert { background-color: ${i}; }`);
    const n = s.getColor(Yz) || i;
    n && (e.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${n}; }`), e.addRule(`.monaco-editor .gutter-insert, .monaco-diff-editor .gutter-insert { background-color: ${n}; }`));
    const o = s.getColor(D5);
    o && e.addRule(`.monaco-editor .char-delete, .monaco-diff-editor .char-delete { background-color: ${o}; }`);
    const r = s.getColor(Zz) || o;
    r && e.addRule(`.monaco-editor .line-delete, .monaco-diff-editor .line-delete { background-color: ${r}; }`);
    const a = s.getColor(Xz) || r;
    a && (e.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${a}; }`), e.addRule(`.monaco-editor .gutter-delete, .monaco-diff-editor .gutter-delete { background-color: ${a}; }`));
    const l = s.getColor(eU);
    l && e.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${s.type === "hc" ? "dashed" : "solid"} ${l}; }`);
    const c = s.getColor(tU);
    c && e.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${s.type === "hc" ? "dashed" : "solid"} ${c}; }`);
    const d = s.getColor(sg);
    d && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${d}; }`);
    const h = s.getColor(iU);
    h && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${h}; }`);
    const u = s.getColor(qu);
    u && e.addRule(`
			.monaco-diff-editor .diffViewport {
				background: ${u};
			}
		`);
    const f = s.getColor(Gu);
    f && e.addRule(`
			.monaco-diff-editor .diffViewport:hover {
				background: ${f};
			}
		`);
    const g = s.getColor(Zu);
    g && e.addRule(`
			.monaco-diff-editor .diffViewport:active {
				background: ${g};
			}
		`);
    const _ = s.getColor(nU);
    e.addRule(`
	.monaco-editor .diagonal-fill {
		background-image: linear-gradient(
			-45deg,
			${_} 12.5%,
			#0000 12.5%, #0000 50%,
			${_} 50%, ${_} 62.5%,
			#0000 62.5%, #0000 100%
		);
		background-size: 8px 8px;
	}
	`);
  });
  const bZ = {
    followsCaret: !0,
    ignoreCharChanges: !0,
    alwaysRevealFirst: !0
  };
  class vZ extends z {
    constructor(e, t = {}) {
      super(), this._onDidUpdate = this._register(new B()), this._editor = e, this._options = Sa(t, bZ, !1), this.disposed = !1, this.nextIdx = -1, this.ranges = [], this.ignoreSelectionChange = !1, this.revealFirst = Boolean(this._options.alwaysRevealFirst), this._register(this._editor.onDidDispose(() => this.dispose())), this._register(this._editor.onDidUpdateDiff(() => this._onDiffUpdated())), this._options.followsCaret && this._register(this._editor.getModifiedEditor().onDidChangeCursorPosition((i) => {
        this.ignoreSelectionChange || (this.nextIdx = -1);
      })), this._options.alwaysRevealFirst && this._register(this._editor.getModifiedEditor().onDidChangeModel((i) => {
        this.revealFirst = !0;
      })), this._init();
    }
    _init() {
      this._editor.getLineChanges();
    }
    _onDiffUpdated() {
      this._init(), this._compute(this._editor.getLineChanges()), this.revealFirst && this._editor.getLineChanges() !== null && (this.revealFirst = !1, this.nextIdx = -1, this.next(1));
    }
    _compute(e) {
      this.ranges = [], e && e.forEach((t) => {
        !this._options.ignoreCharChanges && t.charChanges ? t.charChanges.forEach((i) => {
          this.ranges.push({
            rhs: !0,
            range: new D(i.modifiedStartLineNumber, i.modifiedStartColumn, i.modifiedEndLineNumber, i.modifiedEndColumn)
          });
        }) : t.modifiedEndLineNumber === 0 ? this.ranges.push({
          rhs: !0,
          range: new D(t.modifiedStartLineNumber, 1, t.modifiedStartLineNumber + 1, 1)
        }) : this.ranges.push({
          rhs: !0,
          range: new D(t.modifiedStartLineNumber, 1, t.modifiedEndLineNumber + 1, 1)
        });
      }), this.ranges.sort((t, i) => D.compareRangesUsingStarts(t.range, i.range)), this._onDidUpdate.fire(this);
    }
    _initIdx(e) {
      let t = !1;
      const i = this._editor.getPosition();
      if (!i) {
        this.nextIdx = 0;
        return;
      }
      for (let n = 0, o = this.ranges.length; n < o && !t; n++) {
        const r = this.ranges[n].range;
        i.isBeforeOrEqual(r.getStartPosition()) && (this.nextIdx = n + (e ? 0 : -1), t = !0);
      }
      t || (this.nextIdx = e ? 0 : this.ranges.length - 1), this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1);
    }
    _move(e, t) {
      if (n0(!this.disposed, "Illegal State - diff navigator has been disposed"), !this.canNavigate())
        return;
      this.nextIdx === -1 ? this._initIdx(e) : e ? (this.nextIdx += 1, this.nextIdx >= this.ranges.length && (this.nextIdx = 0)) : (this.nextIdx -= 1, this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1));
      const i = this.ranges[this.nextIdx];
      this.ignoreSelectionChange = !0;
      try {
        const n = i.range.getStartPosition();
        this._editor.setPosition(n), this._editor.revealRangeInCenter(i.range, t);
      } finally {
        this.ignoreSelectionChange = !1;
      }
    }
    canNavigate() {
      return this.ranges && this.ranges.length > 0;
    }
    next(e = 0) {
      this._move(!0, e);
    }
    previous(e = 0) {
      this._move(!1, e);
    }
    dispose() {
      super.dispose(), this.ranges = [], this.disposed = !0;
    }
  }
  var LM, kM;
  class CZ {
    constructor() {
      this._value = "", this._pos = 0;
    }
    reset(e) {
      return this._value = e, this._pos = 0, this;
    }
    next() {
      return this._pos += 1, this;
    }
    hasNext() {
      return this._pos < this._value.length - 1;
    }
    cmp(e) {
      const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
      return t - i;
    }
    value() {
      return this._value[this._pos];
    }
  }
  class wZ {
    constructor(e = !0) {
      this._caseSensitive = e;
    }
    reset(e) {
      return this._value = e, this._from = 0, this._to = 0, this.next();
    }
    hasNext() {
      return this._to < this._value.length;
    }
    next() {
      this._from = this._to;
      let e = !0;
      for (; this._to < this._value.length; this._to++)
        if (this._value.charCodeAt(this._to) === 46)
          if (e)
            this._from++;
          else
            break;
        else
          e = !1;
      return this;
    }
    cmp(e) {
      return this._caseSensitive ? NI(e, this._value, 0, e.length, this._from, this._to) : r_(e, this._value, 0, e.length, this._from, this._to);
    }
    value() {
      return this._value.substring(this._from, this._to);
    }
  }
  class SZ {
    constructor(e = !0, t = !0) {
      this._splitOnBackslash = e, this._caseSensitive = t;
    }
    reset(e) {
      this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
      for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
        const i = this._value.charCodeAt(t);
        if (!(i === 47 || this._splitOnBackslash && i === 92))
          break;
      }
      return this.next();
    }
    hasNext() {
      return this._to < this._valueLen;
    }
    next() {
      this._from = this._to;
      let e = !0;
      for (; this._to < this._valueLen; this._to++) {
        const t = this._value.charCodeAt(this._to);
        if (t === 47 || this._splitOnBackslash && t === 92)
          if (e)
            this._from++;
          else
            break;
        else
          e = !1;
      }
      return this;
    }
    cmp(e) {
      return this._caseSensitive ? NI(e, this._value, 0, e.length, this._from, this._to) : r_(e, this._value, 0, e.length, this._from, this._to);
    }
    value() {
      return this._value.substring(this._from, this._to);
    }
  }
  class yZ {
    constructor(e) {
      this._ignorePathCasing = e, this._states = [], this._stateIdx = 0;
    }
    reset(e) {
      return this._value = e, this._states = [], this._value.scheme && this._states.push(1), this._value.authority && this._states.push(2), this._value.path && (this._pathIterator = new SZ(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(3)), this._value.query && this._states.push(4), this._value.fragment && this._states.push(5), this._stateIdx = 0, this;
    }
    next() {
      return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
    }
    hasNext() {
      return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
    }
    cmp(e) {
      if (this._states[this._stateIdx] === 1)
        return eL(e, this._value.scheme);
      if (this._states[this._stateIdx] === 2)
        return eL(e, this._value.authority);
      if (this._states[this._stateIdx] === 3)
        return this._pathIterator.cmp(e);
      if (this._states[this._stateIdx] === 4)
        return zm(e, this._value.query);
      if (this._states[this._stateIdx] === 5)
        return zm(e, this._value.fragment);
      throw new Error();
    }
    value() {
      if (this._states[this._stateIdx] === 1)
        return this._value.scheme;
      if (this._states[this._stateIdx] === 2)
        return this._value.authority;
      if (this._states[this._stateIdx] === 3)
        return this._pathIterator.value();
      if (this._states[this._stateIdx] === 4)
        return this._value.query;
      if (this._states[this._stateIdx] === 5)
        return this._value.fragment;
      throw new Error();
    }
  }
  class cb {
    constructor() {
      this.height = 1;
    }
    rotateLeft() {
      const e = this.right;
      return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
    }
    rotateRight() {
      const e = this.left;
      return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
    }
    updateHeight() {
      this.height = 1 + Math.max(this.heightLeft, this.heightRight);
    }
    balanceFactor() {
      return this.heightRight - this.heightLeft;
    }
    get heightLeft() {
      var e, t;
      return (t = (e = this.left) === null || e === void 0 ? void 0 : e.height) !== null && t !== void 0 ? t : 0;
    }
    get heightRight() {
      var e, t;
      return (t = (e = this.right) === null || e === void 0 ? void 0 : e.height) !== null && t !== void 0 ? t : 0;
    }
  }
  class nf {
    constructor(e) {
      this._iter = e;
    }
    static forUris(e = () => !1) {
      return new nf(new yZ(e));
    }
    static forStrings() {
      return new nf(new CZ());
    }
    static forConfigKeys() {
      return new nf(new wZ());
    }
    clear() {
      this._root = void 0;
    }
    set(e, t) {
      const i = this._iter.reset(e);
      let n;
      this._root || (this._root = new cb(), this._root.segment = i.value());
      const o = [];
      for (n = this._root; ; ) {
        const a = i.cmp(n.segment);
        if (a > 0)
          n.left || (n.left = new cb(), n.left.segment = i.value()), o.push([-1, n]), n = n.left;
        else if (a < 0)
          n.right || (n.right = new cb(), n.right.segment = i.value()), o.push([1, n]), n = n.right;
        else if (i.hasNext())
          i.next(), n.mid || (n.mid = new cb(), n.mid.segment = i.value()), o.push([0, n]), n = n.mid;
        else
          break;
      }
      const r = n.value;
      n.value = t, n.key = e;
      for (let a = o.length - 1; a >= 0; a--) {
        const l = o[a][1];
        l.updateHeight();
        const c = l.balanceFactor();
        if (c < -1 || c > 1) {
          const d = o[a][0], h = o[a + 1][0];
          if (d === 1 && h === 1)
            o[a][1] = l.rotateLeft();
          else if (d === -1 && h === -1)
            o[a][1] = l.rotateRight();
          else if (d === 1 && h === -1)
            l.right = o[a + 1][1] = o[a + 1][1].rotateRight(), o[a][1] = l.rotateLeft();
          else if (d === -1 && h === 1)
            l.left = o[a + 1][1] = o[a + 1][1].rotateLeft(), o[a][1] = l.rotateRight();
          else
            throw new Error();
          if (a > 0)
            switch (o[a - 1][0]) {
              case -1:
                o[a - 1][1].left = o[a][1];
                break;
              case 1:
                o[a - 1][1].right = o[a][1];
                break;
              case 0:
                o[a - 1][1].mid = o[a][1];
                break;
            }
          else
            this._root = o[0][1];
        }
      }
      return r;
    }
    get(e) {
      var t;
      return (t = this._getNode(e)) === null || t === void 0 ? void 0 : t.value;
    }
    _getNode(e) {
      const t = this._iter.reset(e);
      let i = this._root;
      for (; i; ) {
        const n = t.cmp(i.segment);
        if (n > 0)
          i = i.left;
        else if (n < 0)
          i = i.right;
        else if (t.hasNext())
          t.next(), i = i.mid;
        else
          break;
      }
      return i;
    }
    has(e) {
      const t = this._getNode(e);
      return !(t?.value === void 0 && t?.mid === void 0);
    }
    delete(e) {
      return this._delete(e, !1);
    }
    deleteSuperstr(e) {
      return this._delete(e, !0);
    }
    _delete(e, t) {
      var i;
      const n = this._iter.reset(e), o = [];
      let r = this._root;
      for (; r; ) {
        const a = n.cmp(r.segment);
        if (a > 0)
          o.push([-1, r]), r = r.left;
        else if (a < 0)
          o.push([1, r]), r = r.right;
        else if (n.hasNext())
          n.next(), o.push([0, r]), r = r.mid;
        else
          break;
      }
      if (!!r) {
        if (t ? (r.left = void 0, r.mid = void 0, r.right = void 0, r.height = 1) : (r.key = void 0, r.value = void 0), !r.mid && !r.value)
          if (r.left && r.right) {
            const a = this._min(r.right), { key: l, value: c, segment: d } = a;
            this._delete(a.key, !1), r.key = l, r.value = c, r.segment = d;
          } else {
            const a = (i = r.left) !== null && i !== void 0 ? i : r.right;
            if (o.length > 0) {
              const [l, c] = o[o.length - 1];
              switch (l) {
                case -1:
                  c.left = a;
                  break;
                case 0:
                  c.mid = a;
                  break;
                case 1:
                  c.right = a;
                  break;
              }
            } else
              this._root = a;
          }
        for (let a = o.length - 1; a >= 0; a--) {
          const l = o[a][1];
          l.updateHeight();
          const c = l.balanceFactor();
          if (c > 1 ? (l.right.balanceFactor() >= 0 || (l.right = l.right.rotateRight()), o[a][1] = l.rotateLeft()) : c < -1 && (l.left.balanceFactor() <= 0 || (l.left = l.left.rotateLeft()), o[a][1] = l.rotateRight()), a > 0)
            switch (o[a - 1][0]) {
              case -1:
                o[a - 1][1].left = o[a][1];
                break;
              case 1:
                o[a - 1][1].right = o[a][1];
                break;
              case 0:
                o[a - 1][1].mid = o[a][1];
                break;
            }
          else
            this._root = o[0][1];
        }
      }
    }
    _min(e) {
      for (; e.left; )
        e = e.left;
      return e;
    }
    findSubstr(e) {
      const t = this._iter.reset(e);
      let i = this._root, n;
      for (; i; ) {
        const o = t.cmp(i.segment);
        if (o > 0)
          i = i.left;
        else if (o < 0)
          i = i.right;
        else if (t.hasNext())
          t.next(), n = i.value || n, i = i.mid;
        else
          break;
      }
      return i && i.value || n;
    }
    findSuperstr(e) {
      const t = this._iter.reset(e);
      let i = this._root;
      for (; i; ) {
        const n = t.cmp(i.segment);
        if (n > 0)
          i = i.left;
        else if (n < 0)
          i = i.right;
        else if (t.hasNext())
          t.next(), i = i.mid;
        else
          return i.mid ? this._entries(i.mid) : void 0;
      }
    }
    forEach(e) {
      for (const [t, i] of this)
        e(i, t);
    }
    *[Symbol.iterator]() {
      yield* this._entries(this._root);
    }
    *_entries(e) {
      !e || (e.left && (yield* this._entries(e.left)), e.value && (yield [e.key, e.value]), e.mid && (yield* this._entries(e.mid)), e.right && (yield* this._entries(e.right)));
    }
  }
  class LZ {
    constructor(e, t) {
      this.uri = e, this.value = t;
    }
  }
  class $n {
    constructor(e, t) {
      this[LM] = "ResourceMap", e instanceof $n ? (this.map = new Map(e.map), this.toKey = t ?? $n.defaultToKey) : (this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? $n.defaultToKey);
    }
    set(e, t) {
      return this.map.set(this.toKey(e), new LZ(e, t)), this;
    }
    get(e) {
      var t;
      return (t = this.map.get(this.toKey(e))) === null || t === void 0 ? void 0 : t.value;
    }
    has(e) {
      return this.map.has(this.toKey(e));
    }
    get size() {
      return this.map.size;
    }
    clear() {
      this.map.clear();
    }
    delete(e) {
      return this.map.delete(this.toKey(e));
    }
    forEach(e, t) {
      typeof t < "u" && (e = e.bind(t));
      for (let [i, n] of this.map)
        e(n.value, n.uri, this);
    }
    *values() {
      for (let e of this.map.values())
        yield e.value;
    }
    *keys() {
      for (let e of this.map.values())
        yield e.uri;
    }
    *entries() {
      for (let e of this.map.values())
        yield [e.uri, e.value];
    }
    *[(LM = Symbol.toStringTag, Symbol.iterator)]() {
      for (let [, e] of this.map)
        yield [e.uri, e.value];
    }
  }
  $n.defaultToKey = (s) => s.toString();
  class kZ {
    constructor() {
      this[kM] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
    }
    clear() {
      this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var e;
      return (e = this._head) === null || e === void 0 ? void 0 : e.value;
    }
    get last() {
      var e;
      return (e = this._tail) === null || e === void 0 ? void 0 : e.value;
    }
    has(e) {
      return this._map.has(e);
    }
    get(e, t = 0) {
      const i = this._map.get(e);
      if (!!i)
        return t !== 0 && this.touch(i, t), i.value;
    }
    set(e, t, i = 0) {
      let n = this._map.get(e);
      if (n)
        n.value = t, i !== 0 && this.touch(n, i);
      else {
        switch (n = { key: e, value: t, next: void 0, previous: void 0 }, i) {
          case 0:
            this.addItemLast(n);
            break;
          case 1:
            this.addItemFirst(n);
            break;
          case 2:
            this.addItemLast(n);
            break;
          default:
            this.addItemLast(n);
            break;
        }
        this._map.set(e, n), this._size++;
      }
      return this;
    }
    delete(e) {
      return !!this.remove(e);
    }
    remove(e) {
      const t = this._map.get(e);
      if (!!t)
        return this._map.delete(e), this.removeItem(t), this._size--, t.value;
    }
    shift() {
      if (!this._head && !this._tail)
        return;
      if (!this._head || !this._tail)
        throw new Error("Invalid list");
      const e = this._head;
      return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
    }
    forEach(e, t) {
      const i = this._state;
      let n = this._head;
      for (; n; ) {
        if (t ? e.bind(t)(n.value, n.key, this) : e(n.value, n.key, this), this._state !== i)
          throw new Error("LinkedMap got modified during iteration.");
        n = n.next;
      }
    }
    keys() {
      const e = this, t = this._state;
      let i = this._head;
      const n = {
        [Symbol.iterator]() {
          return n;
        },
        next() {
          if (e._state !== t)
            throw new Error("LinkedMap got modified during iteration.");
          if (i) {
            const o = { value: i.key, done: !1 };
            return i = i.next, o;
          } else
            return { value: void 0, done: !0 };
        }
      };
      return n;
    }
    values() {
      const e = this, t = this._state;
      let i = this._head;
      const n = {
        [Symbol.iterator]() {
          return n;
        },
        next() {
          if (e._state !== t)
            throw new Error("LinkedMap got modified during iteration.");
          if (i) {
            const o = { value: i.value, done: !1 };
            return i = i.next, o;
          } else
            return { value: void 0, done: !0 };
        }
      };
      return n;
    }
    entries() {
      const e = this, t = this._state;
      let i = this._head;
      const n = {
        [Symbol.iterator]() {
          return n;
        },
        next() {
          if (e._state !== t)
            throw new Error("LinkedMap got modified during iteration.");
          if (i) {
            const o = { value: [i.key, i.value], done: !1 };
            return i = i.next, o;
          } else
            return { value: void 0, done: !0 };
        }
      };
      return n;
    }
    [(kM = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(e) {
      if (e >= this.size)
        return;
      if (e === 0) {
        this.clear();
        return;
      }
      let t = this._head, i = this.size;
      for (; t && i > e; )
        this._map.delete(t.key), t = t.next, i--;
      this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
    }
    addItemFirst(e) {
      if (!this._head && !this._tail)
        this._tail = e;
      else if (this._head)
        e.next = this._head, this._head.previous = e;
      else
        throw new Error("Invalid list");
      this._head = e, this._state++;
    }
    addItemLast(e) {
      if (!this._head && !this._tail)
        this._head = e;
      else if (this._tail)
        e.previous = this._tail, this._tail.next = e;
      else
        throw new Error("Invalid list");
      this._tail = e, this._state++;
    }
    removeItem(e) {
      if (e === this._head && e === this._tail)
        this._head = void 0, this._tail = void 0;
      else if (e === this._head) {
        if (!e.next)
          throw new Error("Invalid list");
        e.next.previous = void 0, this._head = e.next;
      } else if (e === this._tail) {
        if (!e.previous)
          throw new Error("Invalid list");
        e.previous.next = void 0, this._tail = e.previous;
      } else {
        const t = e.next, i = e.previous;
        if (!t || !i)
          throw new Error("Invalid list");
        t.previous = i, i.next = t;
      }
      e.next = void 0, e.previous = void 0, this._state++;
    }
    touch(e, t) {
      if (!this._head || !this._tail)
        throw new Error("Invalid list");
      if (!(t !== 1 && t !== 2)) {
        if (t === 1) {
          if (e === this._head)
            return;
          const i = e.next, n = e.previous;
          e === this._tail ? (n.next = void 0, this._tail = n) : (i.previous = n, n.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
        } else if (t === 2) {
          if (e === this._tail)
            return;
          const i = e.next, n = e.previous;
          e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = n, n.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
        }
      }
    }
    toJSON() {
      const e = [];
      return this.forEach((t, i) => {
        e.push([i, t]);
      }), e;
    }
    fromJSON(e) {
      this.clear();
      for (const [t, i] of e)
        this.set(t, i);
    }
  }
  class Wc extends kZ {
    constructor(e, t = 1) {
      super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(e) {
      this._limit = e, this.checkTrim();
    }
    get(e, t = 2) {
      return super.get(e, t);
    }
    peek(e) {
      return super.get(e, 0);
    }
    set(e, t) {
      return super.set(e, t, 2), this.checkTrim(), this;
    }
    checkTrim() {
      this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio));
    }
  }
  function BE(...s) {
    return function(e, t) {
      for (let i = 0, n = s.length; i < n; i++) {
        const o = s[i](e, t);
        if (o)
          return o;
      }
      return null;
    };
  }
  WF.bind(void 0, !1);
  const gC = WF.bind(void 0, !0);
  function WF(s, e, t) {
    if (!t || t.length < e.length)
      return null;
    let i;
    return s ? i = TI(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
  }
  function VF(s, e) {
    const t = e.toLowerCase().indexOf(s.toLowerCase());
    return t === -1 ? null : [{ start: t, end: t + s.length }];
  }
  function DZ(s, e) {
    return WL(s.toLowerCase(), e.toLowerCase(), 0, 0);
  }
  function WL(s, e, t, i) {
    if (t === s.length)
      return [];
    if (i === e.length)
      return null;
    if (s[t] === e[i]) {
      let n = null;
      return (n = WL(s, e, t + 1, i + 1)) ? HE({ start: i, end: i + 1 }, n) : null;
    }
    return WL(s, e, t, i + 1);
  }
  function WE(s) {
    return 97 <= s && s <= 122;
  }
  function mC(s) {
    return 65 <= s && s <= 90;
  }
  function VE(s) {
    return 48 <= s && s <= 57;
  }
  function HF(s) {
    return s === 32 || s === 9 || s === 10 || s === 13;
  }
  const zF = /* @__PURE__ */ new Set();
  "()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => zF.add(s.charCodeAt(0)));
  function x1(s) {
    return HF(s) || zF.has(s);
  }
  function xZ(s, e) {
    return s === e || x1(s) && x1(e);
  }
  function UF(s) {
    return WE(s) || mC(s) || VE(s);
  }
  function HE(s, e) {
    return e.length === 0 ? e = [s] : s.end === e[0].start ? e[0].start = s.start : e.unshift(s), e;
  }
  function $F(s, e) {
    for (let t = e; t < s.length; t++) {
      const i = s.charCodeAt(t);
      if (mC(i) || VE(i) || t > 0 && !UF(s.charCodeAt(t - 1)))
        return t;
    }
    return s.length;
  }
  function VL(s, e, t, i) {
    if (t === s.length)
      return [];
    if (i === e.length)
      return null;
    if (s[t] !== e[i].toLowerCase())
      return null;
    {
      let n = null, o = i + 1;
      for (n = VL(s, e, t + 1, i + 1); !n && (o = $F(e, o)) < e.length; )
        n = VL(s, e, t + 1, o), o++;
      return n === null ? null : HE({ start: i, end: i + 1 }, n);
    }
  }
  function IZ(s) {
    let e = 0, t = 0, i = 0, n = 0, o = 0;
    for (let d = 0; d < s.length; d++)
      o = s.charCodeAt(d), mC(o) && e++, WE(o) && t++, UF(o) && i++, VE(o) && n++;
    const r = e / s.length, a = t / s.length, l = i / s.length, c = n / s.length;
    return { upperPercent: r, lowerPercent: a, alphaPercent: l, numericPercent: c };
  }
  function EZ(s) {
    const { upperPercent: e, lowerPercent: t } = s;
    return t === 0 && e > 0.6;
  }
  function NZ(s) {
    const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: n } = s;
    return t > 0.2 && e < 0.8 && i > 0.6 && n < 0.2;
  }
  function TZ(s) {
    let e = 0, t = 0, i = 0, n = 0;
    for (let o = 0; o < s.length; o++)
      i = s.charCodeAt(o), mC(i) && e++, WE(i) && t++, HF(i) && n++;
    return (e === 0 || t === 0) && n === 0 ? s.length <= 30 : e <= 5;
  }
  function jF(s, e) {
    if (!e || (e = e.trim(), e.length === 0) || !TZ(s) || e.length > 60)
      return null;
    const t = IZ(e);
    if (!NZ(t)) {
      if (!EZ(t))
        return null;
      e = e.toLowerCase();
    }
    let i = null, n = 0;
    for (s = s.toLowerCase(); n < e.length && (i = VL(s, e, 0, n)) === null; )
      n = $F(e, n + 1);
    return i;
  }
  function MZ(s, e, t = !1) {
    if (!e || e.length === 0)
      return null;
    let i = null, n = 0;
    for (s = s.toLowerCase(), e = e.toLowerCase(); n < e.length && (i = HL(s, e, 0, n, t)) === null; )
      n = KF(e, n + 1);
    return i;
  }
  function HL(s, e, t, i, n) {
    if (t === s.length)
      return [];
    if (i === e.length)
      return null;
    if (xZ(s.charCodeAt(t), e.charCodeAt(i))) {
      let o = null, r = i + 1;
      if (o = HL(s, e, t + 1, i + 1, n), !n)
        for (; !o && (r = KF(e, r)) < e.length; )
          o = HL(s, e, t + 1, r, n), r++;
      return o === null ? null : HE({ start: i, end: i + 1 }, o);
    } else
      return null;
  }
  function KF(s, e) {
    for (let t = e; t < s.length; t++)
      if (x1(s.charCodeAt(t)) || t > 0 && x1(s.charCodeAt(t - 1)))
        return t;
    return s.length;
  }
  const AZ = BE(gC, jF, VF), RZ = BE(gC, jF, DZ), DM = new Wc(1e4);
  function xM(s, e, t = !1) {
    if (typeof s != "string" || typeof e != "string")
      return null;
    let i = DM.get(s);
    i || (i = new RegExp(jW(s), "i"), DM.set(s, i));
    const n = i.exec(e);
    return n ? [{ start: n.index, end: n.index + n[0].length }] : t ? RZ(s, e) : AZ(s, e);
  }
  function OZ(s, e, t, i, n, o) {
    const r = Math.min(13, s.length);
    for (; t < r; t++) {
      const a = xf(s, e, t, i, n, o, !1);
      if (a)
        return a;
    }
    return [0, o];
  }
  function pC(s) {
    if (typeof s > "u")
      return [];
    const e = [], t = s[1];
    for (let i = s.length - 1; i > 1; i--) {
      const n = s[i] + t, o = e[e.length - 1];
      o && o.end === n ? o.end = n + 1 : e.push({ start: n, end: n + 1 });
    }
    return e;
  }
  const Gl = 128;
  function zE() {
    const s = [], e = [];
    for (let t = 0; t <= Gl; t++)
      e[t] = 0;
    for (let t = 0; t <= Gl; t++)
      s.push(e.slice(0));
    return s;
  }
  function qF(s) {
    const e = [];
    for (let t = 0; t <= s; t++)
      e[t] = 0;
    return e;
  }
  const GF = qF(2 * Gl), zL = qF(2 * Gl), Ra = zE(), Zc = zE(), db = zE();
  function hb(s, e) {
    if (e < 0 || e >= s.length)
      return !1;
    const t = s.codePointAt(e);
    switch (t) {
      case 95:
      case 45:
      case 46:
      case 32:
      case 47:
      case 92:
      case 39:
      case 34:
      case 58:
      case 36:
      case 60:
      case 40:
      case 91:
        return !0;
      case void 0:
        return !1;
      default:
        return !!OI(t);
    }
  }
  function IM(s, e) {
    if (e < 0 || e >= s.length)
      return !1;
    switch (s.charCodeAt(e)) {
      case 32:
      case 9:
        return !0;
      default:
        return !1;
    }
  }
  function m0(s, e, t) {
    return e[s] !== t[s];
  }
  function PZ(s, e, t, i, n, o, r = !1) {
    for (; e < t && n < o; )
      s[e] === i[n] && (r && (GF[e] = n), e += 1), n += 1;
    return e === t;
  }
  var mr;
  (function(s) {
    s.Default = [-100, 0];
    function e(t) {
      return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
    }
    s.isDefault = e;
  })(mr || (mr = {}));
  function xf(s, e, t, i, n, o, r) {
    const a = s.length > Gl ? Gl : s.length, l = i.length > Gl ? Gl : i.length;
    if (t >= a || o >= l || a - t > l - o || !PZ(e, t, a, n, o, l, !0))
      return;
    FZ(a, l, t, o, e, n);
    let c = 1, d = 1, h = t, u = o;
    const f = [!1];
    for (c = 1, h = t; h < a; c++, h++) {
      const v = GF[h], w = zL[h], S = h + 1 < a ? zL[h + 1] : l;
      for (d = v - o + 1, u = v; u < S; d++, u++) {
        let L = Number.MIN_SAFE_INTEGER, x = !1;
        u <= w && (L = BZ(s, e, h, t, i, n, u, l, o, Ra[c - 1][d - 1] === 0, f));
        let y = 0;
        L !== Number.MAX_SAFE_INTEGER && (x = !0, y = L + Zc[c - 1][d - 1]);
        const k = u > v, I = k ? Zc[c][d - 1] + (Ra[c][d - 1] > 0 ? -5 : 0) : 0, F = u > v + 1 && Ra[c][d - 1] > 0, R = F ? Zc[c][d - 2] + (Ra[c][d - 2] > 0 ? -5 : 0) : 0;
        if (F && (!k || R >= I) && (!x || R >= y))
          Zc[c][d] = R, db[c][d] = 3, Ra[c][d] = 0;
        else if (k && (!x || I >= y))
          Zc[c][d] = I, db[c][d] = 2, Ra[c][d] = 0;
        else if (x)
          Zc[c][d] = y, db[c][d] = 1, Ra[c][d] = Ra[c - 1][d - 1] + 1;
        else
          throw new Error("not possible");
      }
    }
    if (!f[0] && !r)
      return;
    c--, d--;
    const g = [Zc[c][d], o];
    let _ = 0, b = 0;
    for (; c >= 1; ) {
      let v = d;
      do {
        const w = db[c][v];
        if (w === 3)
          v = v - 2;
        else if (w === 2)
          v = v - 1;
        else
          break;
      } while (v >= 1);
      _ > 1 && e[t + c - 1] === n[o + d - 1] && !m0(v + o - 1, i, n) && _ + 1 > Ra[c][v] && (v = d), v === d ? _++ : _ = 1, b || (b = v), c--, d = v - 1, g.push(d);
    }
    l === a && (g[0] += 2);
    const C = b - a;
    return g[0] -= C, g;
  }
  function FZ(s, e, t, i, n, o) {
    let r = s - 1, a = e - 1;
    for (; r >= t && a >= i; )
      n[r] === o[a] && (zL[r] = a, r--), a--;
  }
  function BZ(s, e, t, i, n, o, r, a, l, c, d) {
    if (e[t] !== o[r])
      return Number.MIN_SAFE_INTEGER;
    let h = 1, u = !1;
    return r === t - i ? h = s[t] === n[r] ? 7 : 5 : m0(r, n, o) && (r === 0 || !m0(r - 1, n, o)) ? (h = s[t] === n[r] ? 7 : 5, u = !0) : hb(o, r) && (r === 0 || !hb(o, r - 1)) ? h = 5 : (hb(o, r - 1) || IM(o, r - 1)) && (h = 5, u = !0), h > 1 && t === i && (d[0] = !0), u || (u = m0(r, n, o) || hb(o, r - 1) || IM(o, r - 1)), t === i ? r > l && (h -= u ? 3 : 5) : c ? h += u ? 2 : 0 : h += u ? 0 : 1, r + 1 === a && (h -= u ? 3 : 5), h;
  }
  function WZ(s, e, t, i, n, o, r) {
    return VZ(s, e, t, i, n, o, !0, r);
  }
  function VZ(s, e, t, i, n, o, r, a) {
    let l = xf(s, e, t, i, n, o, a);
    if (l && !r)
      return l;
    if (s.length >= 3) {
      const c = Math.min(7, s.length - 1);
      for (let d = t + 1; d < c; d++) {
        const h = HZ(s, d);
        if (h) {
          const u = xf(h, h.toLowerCase(), t, i, n, o, a);
          u && (u[0] -= 3, (!l || u[0] > l[0]) && (l = u));
        }
      }
    }
    return l;
  }
  function HZ(s, e) {
    if (e + 1 >= s.length)
      return;
    const t = s[e], i = s[e + 1];
    if (t !== i)
      return s.slice(0, e) + i + t + s.slice(e + 2);
  }
  const Sm = "$(", UE = new RegExp(`\\$\\(${Un.iconNameExpression}(?:${Un.iconModifierExpression})?\\)`, "g"), zZ = new RegExp(Un.iconNameCharacter), UZ = new RegExp(`(\\\\)?${UE.source}`, "g");
  function $Z(s) {
    return s.replace(UZ, (e, t) => t ? e : `\\${e}`);
  }
  const jZ = new RegExp(`\\\\${UE.source}`, "g");
  function KZ(s) {
    return s.replace(jZ, (e) => `\\${e}`);
  }
  const qZ = new RegExp(`(\\s)?(\\\\)?${UE.source}(\\s)?`, "g");
  function $E(s) {
    return s.indexOf(Sm) === -1 ? s : s.replace(qZ, (e, t, i, n) => i ? e : t || n || "");
  }
  function ub(s) {
    const e = s.indexOf(Sm);
    return e === -1 ? { text: s } : GZ(s, e);
  }
  function GZ(s, e) {
    const t = [];
    let i = "";
    function n(u) {
      if (u) {
        i += u;
        for (const f of u)
          t.push(a);
      }
    }
    let o = -1, r = "", a = 0, l, c, d = e;
    const h = s.length;
    for (n(s.substr(0, e)); d < h; )
      l = s[d], c = s[d + 1], l === Sm[0] && c === Sm[1] ? (o = d, n(r), r = Sm, d++) : l === ")" && o !== -1 ? (a += d - o + 1, o = -1, r = "") : o !== -1 ? zZ.test(l) ? r += l : (n(r), o = -1, r = "") : n(l), d++;
    return n(r), { text: i, iconOffsets: t };
  }
  function fb(s, e, t = !1) {
    const { text: i, iconOffsets: n } = e;
    if (!n || n.length === 0)
      return xM(s, i, t);
    const o = EI(i, " "), r = i.length - o.length, a = xM(s, o, t);
    if (a)
      for (const l of a) {
        const c = n[l.start + r] + r;
        l.start += c, l.end += c;
      }
    return a;
  }
  class Us {
    constructor(e = "", t = !1) {
      var i, n, o;
      if (this.value = e, typeof this.value != "string")
        throw fr("value");
      typeof t == "boolean" ? (this.isTrusted = t, this.supportThemeIcons = !1, this.supportHtml = !1) : (this.isTrusted = (i = t.isTrusted) !== null && i !== void 0 ? i : void 0, this.supportThemeIcons = (n = t.supportThemeIcons) !== null && n !== void 0 ? n : !1, this.supportHtml = (o = t.supportHtml) !== null && o !== void 0 ? o : !1);
    }
    appendText(e, t = 0) {
      return this.value += ZZ(this.supportThemeIcons ? $Z(e) : e).replace(/([ \t]+)/g, (i, n) => "&nbsp;".repeat(n.length)).replace(/\>/gm, "\\>").replace(/\n/g, t === 1 ? `\\
` : `

`), this;
    }
    appendMarkdown(e) {
      return this.value += e, this;
    }
    appendCodeblock(e, t) {
      return this.value += "\n```", this.value += e, this.value += `
`, this.value += t, this.value += "\n```\n", this;
    }
  }
  function If(s) {
    return ZF(s) ? !s.value : Array.isArray(s) ? s.every(If) : !0;
  }
  function ZF(s) {
    return s instanceof Us ? !0 : s && typeof s == "object" ? typeof s.value == "string" && (typeof s.isTrusted == "boolean" || s.isTrusted === void 0) && (typeof s.supportThemeIcons == "boolean" || s.supportThemeIcons === void 0) : !1;
  }
  function ZZ(s) {
    return s.replace(/[\\`*_{}[\]()#+\-!]/g, "\\$&");
  }
  function wS(s) {
    return s && s.replace(/\\([\\`*_{}[\]()#+\-.!])/g, "$1");
  }
  function YZ(s) {
    const e = [], t = s.split("|").map((n) => n.trim());
    s = t[0];
    const i = t[1];
    if (i) {
      const n = /height=(\d+)/.exec(i), o = /width=(\d+)/.exec(i), r = n ? n[1] : "", a = o ? o[1] : "", l = isFinite(parseInt(a)), c = isFinite(parseInt(r));
      l && e.push(`width="${a}"`), c && e.push(`height="${r}"`);
    }
    return { href: s, dimensions: e };
  }
  var XZ = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, QZ = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, _C = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const bC = new ue("selectionAnchorSet", !1);
  let ml = class YF {
    constructor(e, t) {
      this.editor = e, this.selectionAnchorSetContextKey = bC.bindTo(t), this.modelChangeListener = e.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
    }
    static get(e) {
      return e.getContribution(YF.ID);
    }
    setSelectionAnchor() {
      if (this.editor.hasModel()) {
        const e = this.editor.getPosition(), t = this.decorationId ? [this.decorationId] : [], i = this.editor.deltaDecorations(t, [{
          range: ae.fromPositions(e, e),
          options: {
            description: "selection-anchor",
            stickiness: 1,
            hoverMessage: new Us().appendText(m("selectionAnchor", "Selection Anchor")),
            className: "selection-anchor"
          }
        }]);
        this.decorationId = i[0], this.selectionAnchorSetContextKey.set(!!this.decorationId), pn(m("anchorSet", "Anchor set at {0}:{1}", e.lineNumber, e.column));
      }
    }
    goToSelectionAnchor() {
      if (this.editor.hasModel() && this.decorationId) {
        const e = this.editor.getModel().getDecorationRange(this.decorationId);
        e && this.editor.setPosition(e.getStartPosition());
      }
    }
    selectFromAnchorToCursor() {
      if (this.editor.hasModel() && this.decorationId) {
        const e = this.editor.getModel().getDecorationRange(this.decorationId);
        if (e) {
          const t = this.editor.getPosition();
          this.editor.setSelection(ae.fromPositions(e.getStartPosition(), t)), this.cancelSelectionAnchor();
        }
      }
    }
    cancelSelectionAnchor() {
      this.decorationId && (this.editor.deltaDecorations([this.decorationId], []), this.decorationId = void 0, this.selectionAnchorSetContextKey.set(!1));
    }
    dispose() {
      this.cancelSelectionAnchor(), this.modelChangeListener.dispose();
    }
  };
  ml.ID = "editor.contrib.selectionAnchorController";
  ml = XZ([
    QZ(1, Fe)
  ], ml);
  class JZ extends ge {
    constructor() {
      super({
        id: "editor.action.setSelectionAnchor",
        label: m("setSelectionAnchor", "Set Selection Anchor"),
        alias: "Set Selection Anchor",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2080),
          weight: 100
        }
      });
    }
    run(e, t) {
      var i;
      return _C(this, void 0, void 0, function* () {
        (i = ml.get(t)) === null || i === void 0 || i.setSelectionAnchor();
      });
    }
  }
  class eY extends ge {
    constructor() {
      super({
        id: "editor.action.goToSelectionAnchor",
        label: m("goToSelectionAnchor", "Go to Selection Anchor"),
        alias: "Go to Selection Anchor",
        precondition: bC
      });
    }
    run(e, t) {
      var i;
      return _C(this, void 0, void 0, function* () {
        (i = ml.get(t)) === null || i === void 0 || i.goToSelectionAnchor();
      });
    }
  }
  class tY extends ge {
    constructor() {
      super({
        id: "editor.action.selectFromAnchorToCursor",
        label: m("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
        alias: "Select from Anchor to Cursor",
        precondition: bC,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2089),
          weight: 100
        }
      });
    }
    run(e, t) {
      var i;
      return _C(this, void 0, void 0, function* () {
        (i = ml.get(t)) === null || i === void 0 || i.selectFromAnchorToCursor();
      });
    }
  }
  class iY extends ge {
    constructor() {
      super({
        id: "editor.action.cancelSelectionAnchor",
        label: m("cancelSelectionAnchor", "Cancel Selection Anchor"),
        alias: "Cancel Selection Anchor",
        precondition: bC,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 9,
          weight: 100
        }
      });
    }
    run(e, t) {
      var i;
      return _C(this, void 0, void 0, function* () {
        (i = ml.get(t)) === null || i === void 0 || i.cancelSelectionAnchor();
      });
    }
  }
  vt(ml.ID, ml);
  oe(JZ);
  oe(eY);
  oe(tY);
  oe(iY);
  const nY = M("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hc: "#A0A0A0" }, m("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
  class sY extends ge {
    constructor() {
      super({
        id: "editor.action.jumpToBracket",
        label: m("smartSelect.jumpBracket", "Go to Bracket"),
        alias: "Go to Bracket",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3160,
          weight: 100
        }
      });
    }
    run(e, t) {
      var i;
      (i = pr.get(t)) === null || i === void 0 || i.jumpToBracket();
    }
  }
  class oY extends ge {
    constructor() {
      super({
        id: "editor.action.selectToBracket",
        label: m("smartSelect.selectToBracket", "Select to Bracket"),
        alias: "Select to Bracket",
        precondition: void 0,
        description: {
          description: "Select to Bracket",
          args: [{
            name: "args",
            schema: {
              type: "object",
              properties: {
                selectBrackets: {
                  type: "boolean",
                  default: !0
                }
              }
            }
          }]
        }
      });
    }
    run(e, t, i) {
      var n;
      let o = !0;
      i && i.selectBrackets === !1 && (o = !1), (n = pr.get(t)) === null || n === void 0 || n.selectToBracket(o);
    }
  }
  class rY {
    constructor(e, t, i) {
      this.position = e, this.brackets = t, this.options = i;
    }
  }
  class pr extends z {
    constructor(e) {
      super(), this._editor = e, this._lastBracketsData = [], this._lastVersionId = 0, this._decorations = [], this._updateBracketsSoon = this._register(new It(() => this._updateBrackets(), 50)), this._matchBrackets = this._editor.getOption(64), this._updateBracketsSoon.schedule(), this._register(e.onDidChangeCursorPosition((t) => {
        this._matchBrackets !== "never" && this._updateBracketsSoon.schedule();
      })), this._register(e.onDidChangeModelContent((t) => {
        this._updateBracketsSoon.schedule();
      })), this._register(e.onDidChangeModel((t) => {
        this._lastBracketsData = [], this._decorations = [], this._updateBracketsSoon.schedule();
      })), this._register(e.onDidChangeModelLanguageConfiguration((t) => {
        this._lastBracketsData = [], this._updateBracketsSoon.schedule();
      })), this._register(e.onDidChangeConfiguration((t) => {
        t.hasChanged(64) && (this._matchBrackets = this._editor.getOption(64), this._decorations = this._editor.deltaDecorations(this._decorations, []), this._lastBracketsData = [], this._lastVersionId = 0, this._updateBracketsSoon.schedule());
      })), this._register(e.onDidBlurEditorWidget(() => {
        this._updateBracketsSoon.schedule();
      })), this._register(e.onDidFocusEditorWidget(() => {
        this._updateBracketsSoon.schedule();
      }));
    }
    static get(e) {
      return e.getContribution(pr.ID);
    }
    jumpToBracket() {
      if (!this._editor.hasModel())
        return;
      const e = this._editor.getModel(), t = this._editor.getSelections().map((i) => {
        const n = i.getStartPosition(), o = e.bracketPairs.matchBracket(n);
        let r = null;
        if (o)
          o[0].containsPosition(n) ? r = o[1].getStartPosition() : o[1].containsPosition(n) && (r = o[0].getStartPosition());
        else {
          const a = e.bracketPairs.findEnclosingBrackets(n);
          if (a)
            r = a[0].getStartPosition();
          else {
            const l = e.bracketPairs.findNextBracket(n);
            l && l.range && (r = l.range.getStartPosition());
          }
        }
        return r ? new ae(r.lineNumber, r.column, r.lineNumber, r.column) : new ae(n.lineNumber, n.column, n.lineNumber, n.column);
      });
      this._editor.setSelections(t), this._editor.revealRange(t[0]);
    }
    selectToBracket(e) {
      if (!this._editor.hasModel())
        return;
      const t = this._editor.getModel(), i = [];
      this._editor.getSelections().forEach((n) => {
        const o = n.getStartPosition();
        let r = t.bracketPairs.matchBracket(o);
        if (!r && (r = t.bracketPairs.findEnclosingBrackets(o), !r)) {
          const c = t.bracketPairs.findNextBracket(o);
          c && c.range && (r = t.bracketPairs.matchBracket(c.range.getStartPosition()));
        }
        let a = null, l = null;
        if (r) {
          r.sort(D.compareRangesUsingStarts);
          const [c, d] = r;
          if (a = e ? c.getStartPosition() : c.getEndPosition(), l = e ? d.getEndPosition() : d.getStartPosition(), d.containsPosition(o)) {
            const h = a;
            a = l, l = h;
          }
        }
        a && l && i.push(new ae(a.lineNumber, a.column, l.lineNumber, l.column));
      }), i.length > 0 && (this._editor.setSelections(i), this._editor.revealRange(i[0]));
    }
    _updateBrackets() {
      if (this._matchBrackets === "never")
        return;
      this._recomputeBrackets();
      let e = [], t = 0;
      for (const i of this._lastBracketsData) {
        let n = i.brackets;
        n && (e[t++] = { range: n[0], options: i.options }, e[t++] = { range: n[1], options: i.options });
      }
      this._decorations = this._editor.deltaDecorations(this._decorations, e);
    }
    _recomputeBrackets() {
      if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
        this._lastBracketsData = [], this._lastVersionId = 0;
        return;
      }
      const e = this._editor.getSelections();
      if (e.length > 100) {
        this._lastBracketsData = [], this._lastVersionId = 0;
        return;
      }
      const t = this._editor.getModel(), i = t.getVersionId();
      let n = [];
      this._lastVersionId === i && (n = this._lastBracketsData);
      let o = [], r = 0;
      for (let h = 0, u = e.length; h < u; h++) {
        let f = e[h];
        f.isEmpty() && (o[r++] = f.getStartPosition());
      }
      o.length > 1 && o.sort(V.compare);
      let a = [], l = 0, c = 0, d = n.length;
      for (let h = 0, u = o.length; h < u; h++) {
        let f = o[h];
        for (; c < d && n[c].position.isBefore(f); )
          c++;
        if (c < d && n[c].position.equals(f))
          a[l++] = n[c];
        else {
          let g = t.bracketPairs.matchBracket(f, 20), _ = pr._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
          !g && this._matchBrackets === "always" && (g = t.bracketPairs.findEnclosingBrackets(f, 20), _ = pr._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER), a[l++] = new rY(f, g, _);
        }
      }
      this._lastBracketsData = a, this._lastVersionId = i;
    }
  }
  pr.ID = "editor.contrib.bracketMatchingController";
  pr._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = $e.register({
    description: "bracket-match-overview",
    stickiness: 1,
    className: "bracket-match",
    overviewRuler: {
      color: ai(nY),
      position: Lo.Center
    }
  });
  pr._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = $e.register({
    description: "bracket-match-no-overview",
    stickiness: 1,
    className: "bracket-match"
  });
  vt(pr.ID, pr);
  oe(oY);
  oe(sY);
  Vt((s, e) => {
    const t = s.getColor(M$);
    t && e.addRule(`.monaco-editor .bracket-match { background-color: ${t}; }`);
    const i = s.getColor(W5);
    i && e.addRule(`.monaco-editor .bracket-match { border: 1px solid ${i}; }`);
  });
  qs.appendMenuItem(A.MenubarGoMenu, {
    group: "5_infile_nav",
    command: {
      id: "editor.action.jumpToBracket",
      title: m({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
    },
    order: 2
  });
  class aY {
    constructor(e, t) {
      this._selection = e, this._isMovingLeft = t;
    }
    getEditOperations(e, t) {
      if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty())
        return;
      const i = this._selection.startLineNumber, n = this._selection.startColumn, o = this._selection.endColumn;
      if (!(this._isMovingLeft && n === 1) && !(!this._isMovingLeft && o === e.getLineMaxColumn(i)))
        if (this._isMovingLeft) {
          const r = new D(i, n - 1, i, n), a = e.getValueInRange(r);
          t.addEditOperation(r, null), t.addEditOperation(new D(i, o, i, o), a);
        } else {
          const r = new D(i, o, i, o + 1), a = e.getValueInRange(r);
          t.addEditOperation(r, null), t.addEditOperation(new D(i, n, i, n), a);
        }
    }
    computeCursorState(e, t) {
      return this._isMovingLeft ? new ae(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1) : new ae(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
    }
  }
  class XF extends ge {
    constructor(e, t) {
      super(t), this.left = e;
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      const i = [], n = t.getSelections();
      for (const o of n)
        i.push(new aY(o, this.left));
      t.pushUndoStop(), t.executeCommands(this.id, i), t.pushUndoStop();
    }
  }
  class lY extends XF {
    constructor() {
      super(!0, {
        id: "editor.action.moveCarretLeftAction",
        label: m("caret.moveLeft", "Move Selected Text Left"),
        alias: "Move Selected Text Left",
        precondition: T.writable
      });
    }
  }
  class cY extends XF {
    constructor() {
      super(!1, {
        id: "editor.action.moveCarretRightAction",
        label: m("caret.moveRight", "Move Selected Text Right"),
        alias: "Move Selected Text Right",
        precondition: T.writable
      });
    }
  }
  oe(lY);
  oe(cY);
  class dY extends ge {
    constructor() {
      super({
        id: "editor.action.transposeLetters",
        label: m("transposeLetters.label", "Transpose Letters"),
        alias: "Transpose Letters",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: {
            primary: 306
          },
          weight: 100
        }
      });
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      let i = t.getModel(), n = [], o = t.getSelections();
      for (let r of o) {
        if (!r.isEmpty())
          continue;
        let a = r.startLineNumber, l = r.startColumn, c = i.getLineMaxColumn(a);
        if (a === 1 && (l === 1 || l === 2 && c === 2))
          continue;
        let d = l === c ? r.getPosition() : ut.rightPosition(i, r.getPosition().lineNumber, r.getPosition().column), h = ut.leftPosition(i, d), u = ut.leftPosition(i, h), f = i.getValueInRange(D.fromPositions(u, h)), g = i.getValueInRange(D.fromPositions(h, d)), _ = D.fromPositions(u, d);
        n.push(new fn(_, g + f));
      }
      n.length > 0 && (t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop());
    }
  }
  oe(dY);
  var hY = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const ih = "9_cutcopypaste", uY = gr || document.queryCommandSupported("cut"), QF = gr || document.queryCommandSupported("copy"), fY = typeof navigator.clipboard > "u" || Xs ? document.queryCommandSupported("paste") : !0;
  function jE(s) {
    return s.register(), s;
  }
  const gY = uY ? jE(new Jf({
    id: "editor.action.clipboardCutAction",
    precondition: void 0,
    kbOpts: gr ? {
      primary: 2102,
      win: { primary: 2102, secondary: [1044] },
      weight: 100
    } : void 0,
    menuOpts: [{
      menuId: A.MenubarEditMenu,
      group: "2_ccp",
      title: m({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
      order: 1
    }, {
      menuId: A.EditorContext,
      group: ih,
      title: m("actions.clipboard.cutLabel", "Cut"),
      when: T.writable,
      order: 1
    }, {
      menuId: A.CommandPalette,
      group: "",
      title: m("actions.clipboard.cutLabel", "Cut"),
      order: 1
    }, {
      menuId: A.SimpleEditorContext,
      group: ih,
      title: m("actions.clipboard.cutLabel", "Cut"),
      when: T.writable,
      order: 1
    }]
  })) : void 0, mY = QF ? jE(new Jf({
    id: "editor.action.clipboardCopyAction",
    precondition: void 0,
    kbOpts: gr ? {
      primary: 2081,
      win: { primary: 2081, secondary: [2067] },
      weight: 100
    } : void 0,
    menuOpts: [{
      menuId: A.MenubarEditMenu,
      group: "2_ccp",
      title: m({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
      order: 2
    }, {
      menuId: A.EditorContext,
      group: ih,
      title: m("actions.clipboard.copyLabel", "Copy"),
      order: 2
    }, {
      menuId: A.CommandPalette,
      group: "",
      title: m("actions.clipboard.copyLabel", "Copy"),
      order: 1
    }, {
      menuId: A.SimpleEditorContext,
      group: ih,
      title: m("actions.clipboard.copyLabel", "Copy"),
      order: 2
    }]
  })) : void 0;
  qs.appendMenuItem(A.MenubarEditMenu, { submenu: A.MenubarCopy, title: { value: m("copy as", "Copy As"), original: "Copy As" }, group: "2_ccp", order: 3 });
  qs.appendMenuItem(A.EditorContext, { submenu: A.EditorContextCopy, title: { value: m("copy as", "Copy As"), original: "Copy As" }, group: ih, order: 3 });
  const SS = fY ? jE(new Jf({
    id: "editor.action.clipboardPasteAction",
    precondition: void 0,
    kbOpts: gr ? {
      primary: 2100,
      win: { primary: 2100, secondary: [1043] },
      linux: { primary: 2100, secondary: [1043] },
      weight: 100
    } : void 0,
    menuOpts: [{
      menuId: A.MenubarEditMenu,
      group: "2_ccp",
      title: m({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
      order: 4
    }, {
      menuId: A.EditorContext,
      group: ih,
      title: m("actions.clipboard.pasteLabel", "Paste"),
      when: T.writable,
      order: 4
    }, {
      menuId: A.CommandPalette,
      group: "",
      title: m("actions.clipboard.pasteLabel", "Paste"),
      order: 1
    }, {
      menuId: A.SimpleEditorContext,
      group: ih,
      title: m("actions.clipboard.pasteLabel", "Paste"),
      when: T.writable,
      order: 4
    }]
  })) : void 0;
  class pY extends ge {
    constructor() {
      super({
        id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
        label: m("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
        alias: "Copy With Syntax Highlighting",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          weight: 100
        }
      });
    }
    run(e, t) {
      !t.hasModel() || !t.getOption(32) && t.getSelection().isEmpty() || (wL.forceCopyWithSyntaxHighlighting = !0, t.focus(), document.execCommand("copy"), wL.forceCopyWithSyntaxHighlighting = !1);
    }
  }
  function JF(s, e) {
    !s || (s.addImplementation(1e4, "code-editor", (t, i) => {
      const n = t.get(St).getFocusedCodeEditor();
      if (n && n.hasTextFocus()) {
        const o = n.getOption(32), r = n.getSelection();
        return r && r.isEmpty() && !o || document.execCommand(e), !0;
      }
      return !1;
    }), s.addImplementation(0, "generic-dom", (t, i) => (document.execCommand(e), !0)));
  }
  JF(gY, "cut");
  JF(mY, "copy");
  SS && (SS.addImplementation(1e4, "code-editor", (s, e) => {
    const t = s.get(St), i = s.get(Fh), n = t.getFocusedCodeEditor();
    return n && n.hasTextFocus() ? !document.execCommand("paste") && Pc ? (() => hY(void 0, void 0, void 0, function* () {
      const r = yield i.readText();
      if (r !== "") {
        const a = Gm.INSTANCE.get(r);
        let l = !1, c = null, d = null;
        a && (l = n.getOption(32) && !!a.isFromEmptySelection, c = typeof a.multicursorText < "u" ? a.multicursorText : null, d = a.mode), n.trigger("keyboard", "paste", {
          text: r,
          pasteOnNewLine: l,
          multicursorText: c,
          mode: d
        });
      }
    }))() : !0 : !1;
  }), SS.addImplementation(0, "generic-dom", (s, e) => (document.execCommand("paste"), !0)));
  QF && oe(pY);
  const KE = st("IWorkspaceEditService");
  function _Y(s) {
    return ls(s) && (Boolean(s.newUri) || Boolean(s.oldUri));
  }
  function bY(s) {
    return ls(s) && Ee.isUri(s.resource) && ls(s.edit);
  }
  class vC {
    constructor(e) {
      this.metadata = e;
    }
    static convert(e) {
      return e.edits.map((t) => {
        if (bY(t))
          return new e3(t.resource, t.edit, t.modelVersionId, t.metadata);
        if (_Y(t))
          return new vY(t.oldUri, t.newUri, t.options, t.metadata);
        throw new Error("Unsupported edit");
      });
    }
  }
  class e3 extends vC {
    constructor(e, t, i, n) {
      super(n), this.resource = e, this.textEdit = t, this.versionId = i;
    }
  }
  class vY extends vC {
    constructor(e, t, i, n) {
      super(n), this.oldResource = e, this.newResource = t, this.options = i;
    }
  }
  const qE = st("IEditorCancelService"), t3 = new ue("cancellableOperation", !1, m("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
  ht(qE, class {
    constructor() {
      this._tokens = /* @__PURE__ */ new WeakMap();
    }
    add(s, e) {
      let t = this._tokens.get(s);
      t || (t = s.invokeWithinContext((n) => {
        const o = t3.bindTo(n.get(Fe)), r = new $s();
        return { key: o, tokens: r };
      }), this._tokens.set(s, t));
      let i;
      return t.key.set(!0), i = t.tokens.push(e), () => {
        i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
      };
    }
    cancel(s) {
      const e = this._tokens.get(s);
      if (!e)
        return;
      const t = e.tokens.pop();
      t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
    }
  }, !0);
  class CY extends bn {
    constructor(e, t) {
      super(t), this.editor = e, this._unregister = e.invokeWithinContext((i) => i.get(qE).add(e, this));
    }
    dispose() {
      this._unregister(), super.dispose();
    }
  }
  se(new class extends wn {
    constructor() {
      super({
        id: "editor.cancelOperation",
        kbOpts: {
          weight: 100,
          primary: 9
        },
        precondition: t3
      });
    }
    runEditorCommand(s, e) {
      s.get(qE).cancel(e);
    }
  }());
  class gp {
    constructor(e, t) {
      if (this.flags = t, (this.flags & 1) !== 0) {
        const i = e.getModel();
        this.modelVersionId = i ? uo("{0}#{1}", i.uri.toString(), i.getVersionId()) : null;
      } else
        this.modelVersionId = null;
      (this.flags & 4) !== 0 ? this.position = e.getPosition() : this.position = null, (this.flags & 2) !== 0 ? this.selection = e.getSelection() : this.selection = null, (this.flags & 8) !== 0 ? (this.scrollLeft = e.getScrollLeft(), this.scrollTop = e.getScrollTop()) : (this.scrollLeft = -1, this.scrollTop = -1);
    }
    _equals(e) {
      if (!(e instanceof gp))
        return !1;
      const t = e;
      return !(this.modelVersionId !== t.modelVersionId || this.scrollLeft !== t.scrollLeft || this.scrollTop !== t.scrollTop || !this.position && t.position || this.position && !t.position || this.position && t.position && !this.position.equals(t.position) || !this.selection && t.selection || this.selection && !t.selection || this.selection && t.selection && !this.selection.equalsRange(t.selection));
    }
    validate(e) {
      return this._equals(new gp(e, this.flags));
    }
  }
  class mp extends CY {
    constructor(e, t, i, n) {
      super(e, n), this._listener = new te(), t & 4 && this._listener.add(e.onDidChangeCursorPosition((o) => {
        (!i || !D.containsPosition(i, o.position)) && this.cancel();
      })), t & 2 && this._listener.add(e.onDidChangeCursorSelection((o) => {
        (!i || !D.containsRange(i, o.selection)) && this.cancel();
      })), t & 8 && this._listener.add(e.onDidScrollChange((o) => this.cancel())), t & 1 && (this._listener.add(e.onDidChangeModel((o) => this.cancel())), this._listener.add(e.onDidChangeModelContent((o) => this.cancel())));
    }
    dispose() {
      this._listener.dispose(), super.dispose();
    }
  }
  class GE extends bn {
    constructor(e, t) {
      super(t), this._listener = e.onDidChangeContent(() => this.cancel());
    }
    dispose() {
      this._listener.dispose(), super.dispose();
    }
  }
  class it {
    constructor(e) {
      this.value = e;
    }
    equals(e) {
      return this.value === e.value;
    }
    contains(e) {
      return this.equals(e) || this.value === "" || e.value.startsWith(this.value + it.sep);
    }
    intersects(e) {
      return this.contains(e) || e.contains(this);
    }
    append(e) {
      return new it(this.value + it.sep + e);
    }
  }
  it.sep = ".";
  it.None = new it("@@none@@");
  it.Empty = new it("");
  it.QuickFix = new it("quickfix");
  it.Refactor = new it("refactor");
  it.Source = new it("source");
  it.SourceOrganizeImports = it.Source.append("organizeImports");
  it.SourceFixAll = it.Source.append("fixAll");
  function wY(s, e) {
    return !(s.include && !s.include.intersects(e) || s.excludes && s.excludes.some((t) => i3(e, t, s.include)) || !s.includeSourceActions && it.Source.contains(e));
  }
  function SY(s, e) {
    const t = e.kind ? new it(e.kind) : void 0;
    return !(s.include && (!t || !s.include.contains(t)) || s.excludes && t && s.excludes.some((i) => i3(t, i, s.include)) || !s.includeSourceActions && t && it.Source.contains(t) || s.onlyIncludePreferredActions && !e.isPreferred);
  }
  function i3(s, e, t) {
    return !(!e.contains(s) || t && e.contains(t));
  }
  class Zr {
    constructor(e, t, i) {
      this.kind = e, this.apply = t, this.preferred = i;
    }
    static fromUser(e, t) {
      return !e || typeof e != "object" ? new Zr(t.kind, t.apply, !1) : new Zr(Zr.getKindFromUser(e, t.kind), Zr.getApplyFromUser(e, t.apply), Zr.getPreferredUser(e));
    }
    static getApplyFromUser(e, t) {
      switch (typeof e.apply == "string" ? e.apply.toLowerCase() : "") {
        case "first":
          return "first";
        case "never":
          return "never";
        case "ifsingle":
          return "ifSingle";
        default:
          return t;
      }
    }
    static getKindFromUser(e, t) {
      return typeof e.kind == "string" ? new it(e.kind) : t;
    }
    static getPreferredUser(e) {
      return typeof e.preferred == "boolean" ? e.preferred : !1;
    }
  }
  var ZE = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const n3 = "editor.action.codeAction", s3 = "editor.action.refactor", o3 = "editor.action.sourceAction", YE = "editor.action.organizeImports", XE = "editor.action.fixAll";
  class r3 {
    constructor(e, t) {
      this.action = e, this.provider = t;
    }
    resolve(e) {
      var t;
      return ZE(this, void 0, void 0, function* () {
        if (((t = this.provider) === null || t === void 0 ? void 0 : t.resolveCodeAction) && !this.action.edit) {
          let i;
          try {
            i = yield this.provider.resolveCodeAction(this.action, e);
          } catch (n) {
            Xi(n);
          }
          i && (this.action.edit = i.edit);
        }
        return this;
      });
    }
  }
  class QE extends z {
    constructor(e, t, i) {
      super(), this.documentation = t, this._register(i), this.allActions = [...e].sort(QE.codeActionsComparator), this.validActions = this.allActions.filter(({ action: n }) => !n.disabled);
    }
    static codeActionsComparator({ action: e }, { action: t }) {
      return e.isPreferred && !t.isPreferred ? -1 : !e.isPreferred && t.isPreferred ? 1 : Ds(e.diagnostics) ? Ds(t.diagnostics) ? e.diagnostics[0].message.localeCompare(t.diagnostics[0].message) : -1 : Ds(t.diagnostics) ? 1 : 0;
    }
    get hasAutoFix() {
      return this.validActions.some(({ action: e }) => !!e.kind && it.QuickFix.contains(new it(e.kind)) && !!e.isPreferred);
    }
  }
  const EM = { actions: [], documentation: void 0 };
  function JE(s, e, t, i, n, o) {
    var r;
    const a = i.filter || {}, l = {
      only: (r = a.include) === null || r === void 0 ? void 0 : r.value,
      trigger: i.type
    }, c = new GE(e, o), d = yY(s, e, a), h = new te(), u = d.map((g) => ZE(this, void 0, void 0, function* () {
      try {
        n.report(g);
        const _ = yield g.provideCodeActions(e, t, l, c.token);
        if (_ && h.add(_), c.token.isCancellationRequested)
          return EM;
        const b = (_?.actions || []).filter((v) => v && SY(a, v)), C = LY(g, b, a.include);
        return {
          actions: b.map((v) => new r3(v, g)),
          documentation: C
        };
      } catch (_) {
        if (va(_))
          throw _;
        return Xi(_), EM;
      }
    })), f = s.onDidChange(() => {
      const g = s.all(e);
      Gs(g, d) || c.cancel();
    });
    return Promise.all(u).then((g) => {
      const _ = $I(g.map((C) => C.actions)), b = Nh(g.map((C) => C.documentation));
      return new QE(_, b, h);
    }).finally(() => {
      f.dispose(), c.dispose();
    });
  }
  function yY(s, e, t) {
    return s.all(e).filter((i) => i.providedCodeActionKinds ? i.providedCodeActionKinds.some((n) => wY(t, new it(n))) : !0);
  }
  function LY(s, e, t) {
    if (!s.documentation)
      return;
    const i = s.documentation.map((n) => ({ kind: new it(n.kind), command: n.command }));
    if (t) {
      let n;
      for (const o of i)
        o.kind.contains(t) && (n ? n.kind.contains(o.kind) && (n = o) : n = o);
      if (n)
        return n?.command;
    }
    for (const n of e)
      if (!!n.kind) {
        for (const o of i)
          if (o.kind.contains(new it(n.kind)))
            return o.command;
      }
  }
  lt.registerCommand("_executeCodeActionProvider", function(s, e, t, i, n) {
    return ZE(this, void 0, void 0, function* () {
      if (!(e instanceof Ee))
        throw fr();
      const { codeActionProvider: o } = s.get(me), r = s.get(Qt).getModel(e);
      if (!r)
        throw fr();
      const a = ae.isISelection(t) ? ae.liftSelection(t) : D.isIRange(t) ? r.validateRange(t) : void 0;
      if (!a)
        throw fr();
      const l = typeof i == "string" ? new it(i) : void 0, c = yield JE(o, r, a, { type: 1, filter: { includeSourceActions: !0, include: l } }, Bh.None, Je.None), d = [], h = Math.min(c.validActions.length, typeof n == "number" ? n : 0);
      for (let u = 0; u < h; u++)
        d.push(c.validActions[u].resolve(Je.None));
      try {
        return yield Promise.all(d), c.validActions.map((u) => u.action);
      } finally {
        setTimeout(() => c.dispose(), 100);
      }
    });
  });
  var kY = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, DY = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let eo = class UL {
    constructor(e, t) {
      this._messageWidget = new Gn(), this._messageListeners = new te(), this._editor = e, this._visible = UL.MESSAGE_VISIBLE.bindTo(t), this._editorListener = this._editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit());
    }
    static get(e) {
      return e.getContribution(UL.ID);
    }
    dispose() {
      this._editorListener.dispose(), this._messageListeners.dispose(), this._messageWidget.dispose(), this._visible.reset();
    }
    showMessage(e, t) {
      pn(e), this._visible.set(!0), this._messageWidget.clear(), this._messageListeners.clear(), this._messageWidget.value = new NM(this._editor, t, e), this._messageListeners.add(this._editor.onDidBlurEditorText(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage())), this._messageListeners.add(new Ns(() => this.closeMessage(), 3e3));
      let i;
      this._messageListeners.add(this._editor.onMouseMove((n) => {
        !n.target.position || (i ? i.containsPosition(n.target.position) || this.closeMessage() : i = new D(t.lineNumber - 3, 1, n.target.position.lineNumber + 3, 1));
      }));
    }
    closeMessage() {
      this._visible.reset(), this._messageListeners.clear(), this._messageWidget.value && this._messageListeners.add(NM.fadeOut(this._messageWidget.value));
    }
    _onDidAttemptReadOnlyEdit() {
      this._editor.hasModel() && this.showMessage(m("editor.readonly", "Cannot edit in read-only editor"), this._editor.getPosition());
    }
  };
  eo.ID = "editor.contrib.messageController";
  eo.MESSAGE_VISIBLE = new ue("messageVisible", !1, m("messageVisible", "Whether the editor is currently showing an inline message"));
  eo = kY([
    DY(1, Fe)
  ], eo);
  const xY = wn.bindToContribution(eo.get);
  se(new xY({
    id: "leaveEditorMessage",
    precondition: eo.MESSAGE_VISIBLE,
    handler: (s) => s.closeMessage(),
    kbOpts: {
      weight: 100 + 30,
      primary: 9
    }
  }));
  class NM {
    constructor(e, { lineNumber: t, column: i }, n) {
      this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._editor = e, this._editor.revealLinesInCenterIfOutsideViewport(t, t, 0), this._position = { lineNumber: t, column: i - 1 }, this._domNode = document.createElement("div"), this._domNode.classList.add("monaco-editor-overlaymessage");
      const o = document.createElement("div");
      o.classList.add("anchor", "top"), this._domNode.appendChild(o);
      const r = document.createElement("div");
      r.classList.add("message"), r.textContent = n, this._domNode.appendChild(r);
      const a = document.createElement("div");
      a.classList.add("anchor", "below"), this._domNode.appendChild(a), this._editor.addContentWidget(this), this._domNode.classList.add("fadeIn");
    }
    static fadeOut(e) {
      let t;
      const i = () => {
        e.dispose(), clearTimeout(t), e.getDomNode().removeEventListener("animationend", i);
      };
      return t = setTimeout(i, 110), e.getDomNode().addEventListener("animationend", i), e.getDomNode().classList.add("fadeOut"), { dispose: i };
    }
    dispose() {
      this._editor.removeContentWidget(this);
    }
    getId() {
      return "messageoverlay";
    }
    getDomNode() {
      return this._domNode;
    }
    getPosition() {
      return { position: this._position, preference: [1, 2] };
    }
    afterRender(e) {
      this._domNode.classList.toggle("below", e === 2);
    }
  }
  vt(eo.ID, eo);
  const ci = st("keybindingService");
  var IY = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, yS = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, EY = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class TM extends ks {
    constructor(e, t) {
      super(e.command ? e.command.id : e.title, NY(e.title), void 0, !e.disabled, t), this.action = e;
    }
  }
  function NY(s) {
    return s.replace(/\r\n|\r|\n/g, " ");
  }
  let $L = class extends z {
    constructor(e, t, i, n, o) {
      super(), this._editor = e, this._delegate = t, this._contextMenuService = i, this._languageFeaturesService = o, this._visible = !1, this._showingActions = this._register(new Gn()), this._keybindingResolver = new CC({
        getKeybindings: () => n.getKeybindings()
      });
    }
    get isVisible() {
      return this._visible;
    }
    show(e, t, i, n) {
      return EY(this, void 0, void 0, function* () {
        const o = n.includeDisabledActions ? t.allActions : t.validActions;
        if (!o.length) {
          this._visible = !1;
          return;
        }
        if (!this._editor.getDomNode())
          throw this._visible = !1, aI();
        this._visible = !0, this._showingActions.value = t;
        const r = this.getMenuActions(e, o, t.documentation), a = V.isIPosition(i) ? this._toCoords(i) : i || { x: 0, y: 0 }, l = this._keybindingResolver.getResolver(), c = this._editor.getOption(115);
        this._contextMenuService.showContextMenu({
          domForShadowRoot: c ? this._editor.getDomNode() : void 0,
          getAnchor: () => a,
          getActions: () => r,
          onHide: () => {
            this._visible = !1, this._editor.focus();
          },
          autoSelectFirstItem: !0,
          getKeyBinding: (d) => d instanceof TM ? l(d.action) : void 0
        });
      });
    }
    getMenuActions(e, t, i) {
      var n, o;
      const r = (d) => new TM(d.action, () => this._delegate.onSelectCodeAction(d)), a = t.map(r), l = [...i], c = this._editor.getModel();
      if (c && a.length)
        for (const d of this._languageFeaturesService.codeActionProvider.all(c))
          d._getAdditionalMenuItems && l.push(...d._getAdditionalMenuItems({ trigger: e.type, only: (o = (n = e.filter) === null || n === void 0 ? void 0 : n.include) === null || o === void 0 ? void 0 : o.value }, t.map((h) => h.action)));
      return l.length && a.push(new mo(), ...l.map((d) => r(new r3({
        title: d.title,
        command: d
      }, void 0)))), a;
    }
    _toCoords(e) {
      if (!this._editor.hasModel())
        return { x: 0, y: 0 };
      this._editor.revealPosition(e, 1), this._editor.render();
      const t = this._editor.getScrolledVisiblePosition(e), i = mn(this._editor.getDomNode()), n = i.left + t.left, o = i.top + t.top + t.height;
      return { x: n, y: o };
    }
  };
  $L = IY([
    yS(2, Fc),
    yS(3, ci),
    yS(4, me)
  ], $L);
  class CC {
    constructor(e) {
      this._keybindingProvider = e;
    }
    getResolver() {
      const e = new mf(() => this._keybindingProvider.getKeybindings().filter((t) => CC.codeActionCommands.indexOf(t.command) >= 0).filter((t) => t.resolvedKeybinding).map((t) => {
        let i = t.commandArgs;
        return t.command === YE ? i = { kind: it.SourceOrganizeImports.value } : t.command === XE && (i = { kind: it.SourceFixAll.value }), Object.assign({ resolvedKeybinding: t.resolvedKeybinding }, Zr.fromUser(i, {
          kind: it.None,
          apply: "never"
        }));
      }));
      return (t) => {
        if (t.kind) {
          const i = this.bestKeybindingForCodeAction(t, e.getValue());
          return i?.resolvedKeybinding;
        }
      };
    }
    bestKeybindingForCodeAction(e, t) {
      if (!e.kind)
        return;
      const i = new it(e.kind);
      return t.filter((n) => n.kind.contains(i)).filter((n) => n.preferred ? e.isPreferred : !0).reduceRight((n, o) => n ? n.kind.contains(o.kind) ? o : n : o, void 0);
    }
  }
  CC.codeActionCommands = [
    s3,
    n3,
    o3,
    YE,
    XE
  ];
  var TY = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, MY = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, ym;
  (function(s) {
    s.Hidden = { type: 0 };
    class e {
      constructor(i, n, o, r) {
        this.actions = i, this.trigger = n, this.editorPosition = o, this.widgetPosition = r, this.type = 1;
      }
    }
    s.Showing = e;
  })(ym || (ym = {}));
  let I1 = class a3 extends z {
    constructor(e, t, i, n) {
      super(), this._editor = e, this._quickFixActionId = t, this._preferredFixActionId = i, this._keybindingService = n, this._onClick = this._register(new B()), this.onClick = this._onClick.event, this._state = ym.Hidden, this._domNode = document.createElement("div"), this._domNode.className = p.lightBulb.classNames, this._editor.addContentWidget(this), this._register(this._editor.onDidChangeModelContent((o) => {
        const r = this._editor.getModel();
        (this.state.type !== 1 || !r || this.state.editorPosition.lineNumber >= r.getLineCount()) && this.hide();
      })), kt.ignoreTarget(this._domNode), this._register(yW(this._domNode, (o) => {
        if (this.state.type !== 1)
          return;
        this._editor.focus(), o.preventDefault();
        const { top: r, height: a } = mn(this._domNode), l = this._editor.getOption(59);
        let c = Math.floor(l / 3);
        this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber && (c += l), this._onClick.fire({
          x: o.posx,
          y: r + a + c,
          actions: this.state.actions,
          trigger: this.state.trigger
        });
      })), this._register(ee(this._domNode, "mouseenter", (o) => {
        if ((o.buttons & 1) !== 1)
          return;
        this.hide();
        const r = new Ah();
        r.startMonitoring(o.target, o.buttons, ng, () => {
        }, () => {
          r.dispose();
        });
      })), this._register(this._editor.onDidChangeConfiguration((o) => {
        o.hasChanged(57) && !this._editor.getOption(57).enabled && this.hide();
      })), this._updateLightBulbTitleAndIcon(), this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitleAndIcon, this));
    }
    dispose() {
      super.dispose(), this._editor.removeContentWidget(this);
    }
    getId() {
      return "LightBulbWidget";
    }
    getDomNode() {
      return this._domNode;
    }
    getPosition() {
      return this._state.type === 1 ? this._state.widgetPosition : null;
    }
    update(e, t, i) {
      if (e.validActions.length <= 0)
        return this.hide();
      const n = this._editor.getOptions();
      if (!n.get(57).enabled)
        return this.hide();
      const o = this._editor.getModel();
      if (!o)
        return this.hide();
      const { lineNumber: r, column: a } = o.validatePosition(i), l = o.getOptions().tabSize, c = n.get(44), d = o.getLineContent(r), h = cC(d, l), u = c.spaceWidth * h > 22, f = (_) => _ > 2 && this._editor.getTopForLineNumber(_) === this._editor.getTopForLineNumber(_ - 1);
      let g = r;
      if (!u) {
        if (r > 1 && !f(r - 1))
          g -= 1;
        else if (!f(r + 1))
          g += 1;
        else if (a * c.spaceWidth < 22)
          return this.hide();
      }
      this.state = new ym.Showing(e, t, i, {
        position: { lineNumber: g, column: 1 },
        preference: a3._posPref
      }), this._editor.layoutContentWidget(this);
    }
    hide() {
      this.state = ym.Hidden, this._editor.layoutContentWidget(this);
    }
    get state() {
      return this._state;
    }
    set state(e) {
      this._state = e, this._updateLightBulbTitleAndIcon();
    }
    _updateLightBulbTitleAndIcon() {
      if (this.state.type === 1 && this.state.actions.hasAutoFix) {
        this._domNode.classList.remove(...p.lightBulb.classNamesArray), this._domNode.classList.add(...p.lightbulbAutofix.classNamesArray);
        const t = this._keybindingService.lookupKeybinding(this._preferredFixActionId);
        if (t) {
          this.title = m("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", t.getLabel());
          return;
        }
      }
      this._domNode.classList.remove(...p.lightbulbAutofix.classNamesArray), this._domNode.classList.add(...p.lightBulb.classNamesArray);
      const e = this._keybindingService.lookupKeybinding(this._quickFixActionId);
      e ? this.title = m("codeActionWithKb", "Show Code Actions ({0})", e.getLabel()) : this.title = m("codeAction", "Show Code Actions");
    }
    set title(e) {
      this._domNode.title = e;
    }
  };
  I1._posPref = [0];
  I1 = TY([
    MY(3, ci)
  ], I1);
  Vt((s, e) => {
    var t;
    const i = (t = s.getColor(cs)) === null || t === void 0 ? void 0 : t.transparent(0.7), n = s.getColor(Kz);
    n && e.addRule(`
		.monaco-editor .contentWidgets ${p.lightBulb.cssSelector} {
			color: ${n};
			background-color: ${i};
		}`);
    const o = s.getColor(qz);
    o && e.addRule(`
		.monaco-editor .contentWidgets ${p.lightbulbAutofix.cssSelector} {
			color: ${o};
			background-color: ${i};
		}`);
  });
  var AY = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, RY = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, LS = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, OY = globalThis && globalThis.__classPrivateFieldSet || function(s, e, t, i, n) {
    if (i === "m")
      throw new TypeError("Private method is not writable");
    if (i === "a" && !n)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? s !== e || !n : !e.has(s))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return i === "a" ? n.call(s, t) : n ? n.value = t : e.set(s, t), t;
  }, PY = globalThis && globalThis.__classPrivateFieldGet || function(s, e, t, i) {
    if (t === "a" && !i)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? s !== e || !i : !e.has(s))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? i : t === "a" ? i.call(s) : i ? i.value : e.get(s);
  }, p0;
  let jL = class extends z {
    constructor(e, t, i, n, o) {
      super(), this._editor = e, this.delegate = n, this._activeCodeActions = this._register(new Gn()), p0.set(this, !1), this._codeActionWidget = new mf(() => this._register(o.createInstance($L, this._editor, {
        onSelectCodeAction: (r) => LS(this, void 0, void 0, function* () {
          this.delegate.applyCodeAction(r, !0);
        })
      }))), this._lightBulbWidget = new mf(() => {
        const r = this._register(o.createInstance(I1, this._editor, t, i));
        return this._register(r.onClick((a) => this.showCodeActionList(a.trigger, a.actions, a, { includeDisabledActions: !1 }))), r;
      });
    }
    dispose() {
      OY(this, p0, !0, "f"), super.dispose();
    }
    update(e) {
      var t, i, n, o, r;
      return LS(this, void 0, void 0, function* () {
        if (e.type !== 1) {
          (t = this._lightBulbWidget.rawValue) === null || t === void 0 || t.hide();
          return;
        }
        let a;
        try {
          a = yield e.actions;
        } catch (l) {
          We(l);
          return;
        }
        if (!PY(this, p0, "f"))
          if (this._lightBulbWidget.getValue().update(a, e.trigger, e.position), e.trigger.type === 1) {
            if (!((i = e.trigger.filter) === null || i === void 0) && i.include) {
              const c = this.tryGetValidActionToApply(e.trigger, a);
              if (c) {
                try {
                  this._lightBulbWidget.getValue().hide(), yield this.delegate.applyCodeAction(c, !1);
                } finally {
                  a.dispose();
                }
                return;
              }
              if (e.trigger.context) {
                const d = this.getInvalidActionThatWouldHaveBeenApplied(e.trigger, a);
                if (d && d.action.disabled) {
                  (n = eo.get(this._editor)) === null || n === void 0 || n.showMessage(d.action.disabled, e.trigger.context.position), a.dispose();
                  return;
                }
              }
            }
            const l = !!(!((o = e.trigger.filter) === null || o === void 0) && o.include);
            if (e.trigger.context && (!a.allActions.length || !l && !a.validActions.length)) {
              (r = eo.get(this._editor)) === null || r === void 0 || r.showMessage(e.trigger.context.notAvailableMessage, e.trigger.context.position), this._activeCodeActions.value = a, a.dispose();
              return;
            }
            this._activeCodeActions.value = a, this._codeActionWidget.getValue().show(e.trigger, a, e.position, { includeDisabledActions: l });
          } else
            this._codeActionWidget.getValue().isVisible ? a.dispose() : this._activeCodeActions.value = a;
      });
    }
    getInvalidActionThatWouldHaveBeenApplied(e, t) {
      if (!!t.allActions.length && (e.autoApply === "first" && t.validActions.length === 0 || e.autoApply === "ifSingle" && t.allActions.length === 1))
        return t.allActions.find(({ action: i }) => i.disabled);
    }
    tryGetValidActionToApply(e, t) {
      if (!!t.validActions.length && (e.autoApply === "first" && t.validActions.length > 0 || e.autoApply === "ifSingle" && t.validActions.length === 1))
        return t.validActions[0];
    }
    showCodeActionList(e, t, i, n) {
      return LS(this, void 0, void 0, function* () {
        this._codeActionWidget.getValue().show(e, t, i, n);
      });
    }
  };
  p0 = /* @__PURE__ */ new WeakMap();
  jL = AY([
    RY(4, et)
  ], jL);
  var Xt;
  (function(s) {
    s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
  })(Xt || (Xt = {}));
  (function(s) {
    function e(r, a) {
      return a - r;
    }
    s.compare = e;
    const t = /* @__PURE__ */ Object.create(null);
    t[s.Error] = m("sev.error", "Error"), t[s.Warning] = m("sev.warning", "Warning"), t[s.Info] = m("sev.info", "Info");
    function i(r) {
      return t[r] || "";
    }
    s.toString = i;
    function n(r) {
      switch (r) {
        case Zt.Error:
          return s.Error;
        case Zt.Warning:
          return s.Warning;
        case Zt.Info:
          return s.Info;
        case Zt.Ignore:
          return s.Hint;
      }
    }
    s.fromSeverity = n;
    function o(r) {
      switch (r) {
        case s.Error:
          return Zt.Error;
        case s.Warning:
          return Zt.Warning;
        case s.Info:
          return Zt.Info;
        case s.Hint:
          return Zt.Ignore;
      }
    }
    s.toSeverity = o;
  })(Xt || (Xt = {}));
  var E1;
  (function(s) {
    const e = "";
    function t(n) {
      return i(n, !0);
    }
    s.makeKey = t;
    function i(n, o) {
      let r = [e];
      return n.source ? r.push(n.source.replace("\xA6", "\\\xA6")) : r.push(e), n.code ? typeof n.code == "string" ? r.push(n.code.replace("\xA6", "\\\xA6")) : r.push(n.code.value.replace("\xA6", "\\\xA6")) : r.push(e), n.severity !== void 0 && n.severity !== null ? r.push(Xt.toString(n.severity)) : r.push(e), n.message && o ? r.push(n.message.replace("\xA6", "\\\xA6")) : r.push(e), n.startLineNumber !== void 0 && n.startLineNumber !== null ? r.push(n.startLineNumber.toString()) : r.push(e), n.startColumn !== void 0 && n.startColumn !== null ? r.push(n.startColumn.toString()) : r.push(e), n.endLineNumber !== void 0 && n.endLineNumber !== null ? r.push(n.endLineNumber.toString()) : r.push(e), n.endColumn !== void 0 && n.endColumn !== null ? r.push(n.endColumn.toString()) : r.push(e), r.push(e), r.join("\xA6");
    }
    s.makeKeyOptionalMessage = i;
  })(E1 || (E1 = {}));
  const wl = st("markerService");
  var kS = globalThis && globalThis.__classPrivateFieldGet || function(s, e, t, i) {
    if (t === "a" && !i)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? s !== e || !i : !e.has(s))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? i : t === "a" ? i.call(s) : i ? i.value : e.get(s);
  }, FY = globalThis && globalThis.__classPrivateFieldSet || function(s, e, t, i, n) {
    if (i === "m")
      throw new TypeError("Private method is not writable");
    if (i === "a" && !n)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? s !== e || !n : !e.has(s))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return i === "a" ? n.call(s, t) : n ? n.value = t : e.set(s, t), t;
  }, bu;
  const l3 = new ue("supportedCodeAction", "");
  class BY extends z {
    constructor(e, t, i, n = 250) {
      super(), this._editor = e, this._markerService = t, this._signalChange = i, this._delay = n, this._autoTriggerTimer = this._register(new Ns()), this._register(this._markerService.onMarkerChanged((o) => this._onMarkerChanges(o))), this._register(this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));
    }
    trigger(e) {
      const t = this._getRangeOfSelectionUnlessWhitespaceEnclosed(e);
      return this._createEventAndSignalChange(e, t);
    }
    _onMarkerChanges(e) {
      const t = this._editor.getModel();
      !t || e.some((i) => bF(i, t.uri)) && this._autoTriggerTimer.cancelAndSet(() => {
        this.trigger({ type: 2 });
      }, this._delay);
    }
    _onCursorChange() {
      this._autoTriggerTimer.cancelAndSet(() => {
        this.trigger({ type: 2 });
      }, this._delay);
    }
    _getRangeOfMarker(e) {
      const t = this._editor.getModel();
      if (!!t)
        for (const i of this._markerService.read({ resource: t.uri })) {
          const n = t.validateRange(i);
          if (D.intersectRanges(n, e))
            return D.lift(n);
        }
    }
    _getRangeOfSelectionUnlessWhitespaceEnclosed(e) {
      if (!this._editor.hasModel())
        return;
      const t = this._editor.getModel(), i = this._editor.getSelection();
      if (i.isEmpty() && e.type === 2) {
        const { lineNumber: n, column: o } = i.getPosition(), r = t.getLineContent(n);
        if (r.length === 0)
          return;
        if (o === 1) {
          if (/\s/.test(r[0]))
            return;
        } else if (o === t.getLineMaxColumn(n)) {
          if (/\s/.test(r[r.length - 1]))
            return;
        } else if (/\s/.test(r[o - 2]) && /\s/.test(r[o - 1]))
          return;
      }
      return i;
    }
    _createEventAndSignalChange(e, t) {
      const i = this._editor.getModel();
      if (!t || !i) {
        this._signalChange(void 0);
        return;
      }
      const n = this._getRangeOfMarker(t), o = n ? n.getStartPosition() : t.getStartPosition(), r = {
        trigger: e,
        selection: t,
        position: o
      };
      return this._signalChange(r), r;
    }
  }
  var hd;
  (function(s) {
    s.Empty = { type: 0 };
    class e {
      constructor(i, n, o, r) {
        this.trigger = i, this.rangeOrSelection = n, this.position = o, this._cancellablePromise = r, this.type = 1, this.actions = r.catch((a) => {
          if (va(a))
            return WY;
          throw a;
        });
      }
      cancel() {
        this._cancellablePromise.cancel();
      }
    }
    s.Triggered = e;
  })(hd || (hd = {}));
  const WY = {
    allActions: [],
    validActions: [],
    dispose: () => {
    },
    documentation: [],
    hasAutoFix: !1
  };
  class VY extends z {
    constructor(e, t, i, n, o) {
      super(), this._editor = e, this._registry = t, this._markerService = i, this._progressService = o, this._codeActionOracle = this._register(new Gn()), this._state = hd.Empty, this._onDidChangeState = this._register(new B()), this.onDidChangeState = this._onDidChangeState.event, bu.set(this, !1), this._supportedCodeActions = l3.bindTo(n), this._register(this._editor.onDidChangeModel(() => this._update())), this._register(this._editor.onDidChangeModelLanguage(() => this._update())), this._register(this._registry.onDidChange(() => this._update())), this._update();
    }
    dispose() {
      kS(this, bu, "f") || (FY(this, bu, !0, "f"), super.dispose(), this.setState(hd.Empty, !0));
    }
    _update() {
      if (kS(this, bu, "f"))
        return;
      this._codeActionOracle.value = void 0, this.setState(hd.Empty);
      const e = this._editor.getModel();
      if (e && this._registry.has(e) && !this._editor.getOption(81)) {
        const t = [];
        for (const i of this._registry.all(e))
          Array.isArray(i.providedCodeActionKinds) && t.push(...i.providedCodeActionKinds);
        this._supportedCodeActions.set(t.join(" ")), this._codeActionOracle.value = new BY(this._editor, this._markerService, (i) => {
          var n;
          if (!i) {
            this.setState(hd.Empty);
            return;
          }
          const o = an((r) => JE(this._registry, e, i.selection, i.trigger, Bh.None, r));
          i.trigger.type === 1 && ((n = this._progressService) === null || n === void 0 || n.showWhile(o, 250)), this.setState(new hd.Triggered(i.trigger, i.selection, i.position, o));
        }, void 0), this._codeActionOracle.value.trigger({ type: 2 });
      } else
        this._supportedCodeActions.reset();
    }
    trigger(e) {
      this._codeActionOracle.value && this._codeActionOracle.value.trigger(e);
    }
    setState(e, t) {
      e !== this._state && (this._state.type === 1 && this._state.cancel(), this._state = e, !t && !kS(this, bu, "f") && this._onDidChangeState.fire(e));
    }
  }
  bu = /* @__PURE__ */ new WeakMap();
  var HY = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, xg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, c3 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function p_(s) {
    return ce.regex(l3.keys()[0], new RegExp("(\\s|^)" + wo(s.value) + "\\b"));
  }
  const eN = {
    type: "object",
    defaultSnippets: [{ body: { kind: "" } }],
    properties: {
      kind: {
        type: "string",
        description: m("args.schema.kind", "Kind of the code action to run.")
      },
      apply: {
        type: "string",
        description: m("args.schema.apply", "Controls when the returned actions are applied."),
        default: "ifSingle",
        enum: ["first", "ifSingle", "never"],
        enumDescriptions: [
          m("args.schema.apply.first", "Always apply the first returned code action."),
          m("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
          m("args.schema.apply.never", "Do not apply the returned code actions.")
        ]
      },
      preferred: {
        type: "boolean",
        default: !1,
        description: m("args.schema.preferred", "Controls if only preferred code actions should be returned.")
      }
    }
  };
  let nh = class d3 extends z {
    constructor(e, t, i, n, o, r) {
      super(), this._instantiationService = o, this._editor = e, this._model = this._register(new VY(this._editor, r.codeActionProvider, t, i, n)), this._register(this._model.onDidChangeState((a) => this.update(a))), this._ui = new mf(() => this._register(new jL(e, lg.Id, __.Id, {
        applyCodeAction: (a, l) => c3(this, void 0, void 0, function* () {
          try {
            yield this._applyCodeAction(a);
          } finally {
            l && this._trigger({ type: 2, filter: {} });
          }
        })
      }, this._instantiationService)));
    }
    static get(e) {
      return e.getContribution(d3.ID);
    }
    update(e) {
      this._ui.getValue().update(e);
    }
    showCodeActions(e, t, i) {
      return this._ui.getValue().showCodeActionList(e, t, i, { includeDisabledActions: !1 });
    }
    manualTriggerAtCurrentPosition(e, t, i) {
      var n;
      if (!this._editor.hasModel())
        return;
      (n = eo.get(this._editor)) === null || n === void 0 || n.closeMessage();
      const o = this._editor.getPosition();
      this._trigger({ type: 1, filter: t, autoApply: i, context: { notAvailableMessage: e, position: o } });
    }
    _trigger(e) {
      return this._model.trigger(e);
    }
    _applyCodeAction(e) {
      return this._instantiationService.invokeFunction(zY, e, this._editor);
    }
  };
  nh.ID = "editor.contrib.quickFixController";
  nh = HY([
    xg(1, wl),
    xg(2, Fe),
    xg(3, Bc),
    xg(4, et),
    xg(5, me)
  ], nh);
  function zY(s, e, t) {
    return c3(this, void 0, void 0, function* () {
      const i = s.get(KE), n = s.get(wi), o = s.get(Ca), r = s.get(yi);
      if (o.publicLog2("codeAction.applyCodeAction", {
        codeActionTitle: e.action.title,
        codeActionKind: e.action.kind,
        codeActionIsPreferred: !!e.action.isPreferred
      }), yield e.resolve(Je.None), e.action.edit && (yield i.apply(vC.convert(e.action.edit), { editor: t, label: e.action.title })), e.action.command)
        try {
          yield n.executeCommand(e.action.command.id, ...e.action.command.arguments || []);
        } catch (a) {
          const l = UY(a);
          r.error(typeof l == "string" ? l : m("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
        }
    });
  }
  function UY(s) {
    return typeof s == "string" ? s : s instanceof Error && typeof s.message == "string" ? s.message : void 0;
  }
  function Wh(s, e, t, i) {
    if (s.hasModel()) {
      const n = nh.get(s);
      n && n.manualTriggerAtCurrentPosition(e, t, i);
    }
  }
  class lg extends ge {
    constructor() {
      super({
        id: lg.Id,
        label: m("quickfix.trigger.label", "Quick Fix..."),
        alias: "Quick Fix...",
        precondition: ce.and(T.writable, T.hasCodeActionsProvider),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2132,
          weight: 100
        }
      });
    }
    run(e, t) {
      return Wh(t, m("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0);
    }
  }
  lg.Id = "editor.action.quickFix";
  class $Y extends wn {
    constructor() {
      super({
        id: n3,
        precondition: ce.and(T.writable, T.hasCodeActionsProvider),
        description: {
          description: "Trigger a code action",
          args: [{ name: "args", schema: eN }]
        }
      });
    }
    runEditorCommand(e, t, i) {
      const n = Zr.fromUser(i, {
        kind: it.Empty,
        apply: "ifSingle"
      });
      return Wh(t, typeof i?.kind == "string" ? n.preferred ? m("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", i.kind) : m("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", i.kind) : n.preferred ? m("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : m("editor.action.codeAction.noneMessage", "No code actions available"), {
        include: n.kind,
        includeSourceActions: !0,
        onlyIncludePreferredActions: n.preferred
      }, n.apply);
    }
  }
  class jY extends ge {
    constructor() {
      super({
        id: s3,
        label: m("refactor.label", "Refactor..."),
        alias: "Refactor...",
        precondition: ce.and(T.writable, T.hasCodeActionsProvider),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3120,
          mac: {
            primary: 1328
          },
          weight: 100
        },
        contextMenuOpts: {
          group: "1_modification",
          order: 2,
          when: ce.and(T.writable, p_(it.Refactor))
        },
        description: {
          description: "Refactor...",
          args: [{ name: "args", schema: eN }]
        }
      });
    }
    run(e, t, i) {
      const n = Zr.fromUser(i, {
        kind: it.Refactor,
        apply: "never"
      });
      return Wh(t, typeof i?.kind == "string" ? n.preferred ? m("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", i.kind) : m("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", i.kind) : n.preferred ? m("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : m("editor.action.refactor.noneMessage", "No refactorings available"), {
        include: it.Refactor.contains(n.kind) ? n.kind : it.None,
        onlyIncludePreferredActions: n.preferred
      }, n.apply);
    }
  }
  class KY extends ge {
    constructor() {
      super({
        id: o3,
        label: m("source.label", "Source Action..."),
        alias: "Source Action...",
        precondition: ce.and(T.writable, T.hasCodeActionsProvider),
        contextMenuOpts: {
          group: "1_modification",
          order: 2.1,
          when: ce.and(T.writable, p_(it.Source))
        },
        description: {
          description: "Source Action...",
          args: [{ name: "args", schema: eN }]
        }
      });
    }
    run(e, t, i) {
      const n = Zr.fromUser(i, {
        kind: it.Source,
        apply: "never"
      });
      return Wh(t, typeof i?.kind == "string" ? n.preferred ? m("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", i.kind) : m("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", i.kind) : n.preferred ? m("editor.action.source.noneMessage.preferred", "No preferred source actions available") : m("editor.action.source.noneMessage", "No source actions available"), {
        include: it.Source.contains(n.kind) ? n.kind : it.None,
        includeSourceActions: !0,
        onlyIncludePreferredActions: n.preferred
      }, n.apply);
    }
  }
  class qY extends ge {
    constructor() {
      super({
        id: YE,
        label: m("organizeImports.label", "Organize Imports"),
        alias: "Organize Imports",
        precondition: ce.and(T.writable, p_(it.SourceOrganizeImports)),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1581,
          weight: 100
        }
      });
    }
    run(e, t) {
      return Wh(t, m("editor.action.organize.noneMessage", "No organize imports action available"), { include: it.SourceOrganizeImports, includeSourceActions: !0 }, "ifSingle");
    }
  }
  class GY extends ge {
    constructor() {
      super({
        id: XE,
        label: m("fixAll.label", "Fix All"),
        alias: "Fix All",
        precondition: ce.and(T.writable, p_(it.SourceFixAll))
      });
    }
    run(e, t) {
      return Wh(t, m("fixAll.noneMessage", "No fix all action available"), { include: it.SourceFixAll, includeSourceActions: !0 }, "ifSingle");
    }
  }
  class __ extends ge {
    constructor() {
      super({
        id: __.Id,
        label: m("autoFix.label", "Auto Fix..."),
        alias: "Auto Fix...",
        precondition: ce.and(T.writable, p_(it.QuickFix)),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1620,
          mac: {
            primary: 2644
          },
          weight: 100
        }
      });
    }
    run(e, t) {
      return Wh(t, m("editor.action.autoFix.noneMessage", "No auto fixes available"), {
        include: it.QuickFix,
        onlyIncludePreferredActions: !0
      }, "ifSingle");
    }
  }
  __.Id = "editor.action.autoFix";
  vt(nh.ID, nh);
  oe(lg);
  oe(jY);
  oe(KY);
  oe(qY);
  oe(__);
  oe(GY);
  se(new $Y());
  function h3(s) {
    return wC(s, 0);
  }
  function wC(s, e) {
    switch (typeof s) {
      case "object":
        return s === null ? il(349, e) : Array.isArray(s) ? YY(s, e) : XY(s, e);
      case "string":
        return tN(s, e);
      case "boolean":
        return ZY(s, e);
      case "number":
        return il(s, e);
      case "undefined":
        return il(937, e);
      default:
        return il(617, e);
    }
  }
  function il(s, e) {
    return (e << 5) - e + s | 0;
  }
  function ZY(s, e) {
    return il(s ? 433 : 863, e);
  }
  function tN(s, e) {
    e = il(149417, e);
    for (let t = 0, i = s.length; t < i; t++)
      e = il(s.charCodeAt(t), e);
    return e;
  }
  function YY(s, e) {
    return e = il(104579, e), s.reduce((t, i) => wC(i, t), e);
  }
  function XY(s, e) {
    return e = il(181387, e), Object.keys(s).sort().reduce((t, i) => (t = tN(i, t), wC(s[i], t)), e);
  }
  function DS(s, e, t = 32) {
    const i = t - e, n = ~((1 << i) - 1);
    return (s << e | (n & s) >>> i) >>> 0;
  }
  function MM(s, e = 0, t = s.byteLength, i = 0) {
    for (let n = 0; n < t; n++)
      s[e + n] = i;
  }
  function QY(s, e, t = "0") {
    for (; s.length < e; )
      s = t + s;
    return s;
  }
  function Ig(s, e = 32) {
    return s instanceof ArrayBuffer ? Array.from(new Uint8Array(s)).map((t) => t.toString(16).padStart(2, "0")).join("") : QY((s >>> 0).toString(16), e / 4);
  }
  class SC {
    constructor() {
      this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(64 + 3), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
    }
    update(e) {
      const t = e.length;
      if (t === 0)
        return;
      const i = this._buff;
      let n = this._buffLen, o = this._leftoverHighSurrogate, r, a;
      for (o !== 0 ? (r = o, a = -1, o = 0) : (r = e.charCodeAt(0), a = 0); ; ) {
        let l = r;
        if (Pi(r))
          if (a + 1 < t) {
            const c = e.charCodeAt(a + 1);
            Kd(c) ? (a++, l = MI(r, c)) : l = 65533;
          } else {
            o = r;
            break;
          }
        else
          Kd(r) && (l = 65533);
        if (n = this._push(i, n, l), a++, a < t)
          r = e.charCodeAt(a);
        else
          break;
      }
      this._buffLen = n, this._leftoverHighSurrogate = o;
    }
    _push(e, t, i) {
      return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64 + 0], e[1] = e[64 + 1], e[2] = e[64 + 2]), t;
    }
    digest() {
      return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(this._buff, this._buffLen, 65533)), this._totalLen += this._buffLen, this._wrapUp()), Ig(this._h0) + Ig(this._h1) + Ig(this._h2) + Ig(this._h3) + Ig(this._h4);
    }
    _wrapUp() {
      this._buff[this._buffLen++] = 128, MM(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), MM(this._buff));
      const e = 8 * this._totalLen;
      this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
    }
    _step() {
      const e = SC._bigBlock32, t = this._buffDV;
      for (let h = 0; h < 64; h += 4)
        e.setUint32(h, t.getUint32(h, !1), !1);
      for (let h = 64; h < 320; h += 4)
        e.setUint32(h, DS(e.getUint32(h - 12, !1) ^ e.getUint32(h - 32, !1) ^ e.getUint32(h - 56, !1) ^ e.getUint32(h - 64, !1), 1), !1);
      let i = this._h0, n = this._h1, o = this._h2, r = this._h3, a = this._h4, l, c, d;
      for (let h = 0; h < 80; h++)
        h < 20 ? (l = n & o | ~n & r, c = 1518500249) : h < 40 ? (l = n ^ o ^ r, c = 1859775393) : h < 60 ? (l = n & o | n & r | o & r, c = 2400959708) : (l = n ^ o ^ r, c = 3395469782), d = DS(i, 5) + l + a + c + e.getUint32(h * 4, !1) & 4294967295, a = r, r = o, o = DS(n, 30), n = i, i = d;
      this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + n & 4294967295, this._h2 = this._h2 + o & 4294967295, this._h3 = this._h3 + r & 4294967295, this._h4 = this._h4 + a & 4294967295;
    }
  }
  SC._bigBlock32 = new DataView(new ArrayBuffer(320));
  var AM = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class KL {
    constructor() {
      this.lenses = [], this._disposables = new te();
    }
    dispose() {
      this._disposables.dispose();
    }
    get isDisposed() {
      return this._disposables.isDisposed;
    }
    add(e, t) {
      this._disposables.add(e);
      for (const i of e.lenses)
        this.lenses.push({ symbol: i, provider: t });
    }
  }
  function u3(s, e, t) {
    return AM(this, void 0, void 0, function* () {
      const i = s.ordered(e), n = /* @__PURE__ */ new Map(), o = new KL(), r = i.map((a, l) => AM(this, void 0, void 0, function* () {
        n.set(a, l);
        try {
          const c = yield Promise.resolve(a.provideCodeLenses(e, t));
          c && o.add(c, a);
        } catch (c) {
          Xi(c);
        }
      }));
      return yield Promise.all(r), o.lenses = o.lenses.sort((a, l) => a.symbol.range.startLineNumber < l.symbol.range.startLineNumber ? -1 : a.symbol.range.startLineNumber > l.symbol.range.startLineNumber ? 1 : n.get(a.provider) < n.get(l.provider) ? -1 : n.get(a.provider) > n.get(l.provider) ? 1 : a.symbol.range.startColumn < l.symbol.range.startColumn ? -1 : a.symbol.range.startColumn > l.symbol.range.startColumn ? 1 : 0), o;
    });
  }
  lt.registerCommand("_executeCodeLensProvider", function(s, ...e) {
    let [t, i] = e;
    Nt(Ee.isUri(t)), Nt(typeof i == "number" || !i);
    const { codeLensProvider: n } = s.get(me), o = s.get(Qt).getModel(t);
    if (!o)
      throw fr();
    const r = [], a = new te();
    return u3(n, o, Je.None).then((l) => {
      a.add(l);
      let c = [];
      for (const d of l.lenses)
        i == null || Boolean(d.symbol.command) ? r.push(d.symbol) : i-- > 0 && d.provider.resolveCodeLens && c.push(Promise.resolve(d.provider.resolveCodeLens(o, d.symbol, Je.None)).then((h) => r.push(h || d.symbol)));
      return Promise.all(c);
    }).then(() => r).finally(() => {
      setTimeout(() => a.dispose(), 100);
    });
  });
  var Zg = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, Tu;
  (function(s) {
    s[s.None = 0] = "None", s[s.Initialized = 1] = "Initialized", s[s.Closed = 2] = "Closed";
  })(Tu || (Tu = {}));
  class pp extends z {
    constructor(e, t = /* @__PURE__ */ Object.create(null)) {
      super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new B()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = Tu.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = new tW(pp.DEFAULT_FLUSH_DELAY), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
    }
    registerListeners() {
      this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
    }
    onDidChangeItemsExternal(e) {
      var t, i;
      (t = e.changed) === null || t === void 0 || t.forEach((n, o) => this.accept(o, n)), (i = e.deleted) === null || i === void 0 || i.forEach((n) => this.accept(n, void 0));
    }
    accept(e, t) {
      if (this.state === Tu.Closed)
        return;
      let i = !1;
      Ws(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire(e);
    }
    get(e, t) {
      const i = this.cache.get(e);
      return Ws(i) ? t : i;
    }
    getBoolean(e, t) {
      const i = this.get(e);
      return Ws(i) ? t : i === "true";
    }
    getNumber(e, t) {
      const i = this.get(e);
      return Ws(i) ? t : parseInt(i, 10);
    }
    set(e, t) {
      return Zg(this, void 0, void 0, function* () {
        if (this.state === Tu.Closed)
          return;
        if (Ws(t))
          return this.delete(e);
        const i = String(t);
        if (this.cache.get(e) !== i)
          return this.cache.set(e, i), this.pendingInserts.set(e, i), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire(e), this.doFlush();
      });
    }
    delete(e) {
      return Zg(this, void 0, void 0, function* () {
        if (!(this.state === Tu.Closed || !this.cache.delete(e)))
          return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire(e), this.doFlush();
      });
    }
    get hasPending() {
      return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
    }
    flushPending() {
      return Zg(this, void 0, void 0, function* () {
        if (!this.hasPending)
          return;
        const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
        return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
          var t;
          if (!this.hasPending)
            for (; this.whenFlushedCallbacks.length; )
              (t = this.whenFlushedCallbacks.pop()) === null || t === void 0 || t();
        });
      });
    }
    doFlush(e) {
      return Zg(this, void 0, void 0, function* () {
        return this.flushDelayer.trigger(() => this.flushPending(), e);
      });
    }
    dispose() {
      this.flushDelayer.dispose(), super.dispose();
    }
  }
  pp.DEFAULT_FLUSH_DELAY = 100;
  class RM {
    constructor() {
      this.onDidChangeItemsExternal = be.None, this.items = /* @__PURE__ */ new Map();
    }
    updateItems(e) {
      return Zg(this, void 0, void 0, function* () {
        e.insert && e.insert.forEach((t, i) => this.items.set(i, t)), e.delete && e.delete.forEach((t) => this.items.delete(t));
      });
    }
  }
  const gb = "__$__targetStorageMarker", La = st("storageService");
  var N1;
  (function(s) {
    s[s.NONE = 0] = "NONE", s[s.SHUTDOWN = 1] = "SHUTDOWN";
  })(N1 || (N1 = {}));
  class yC extends z {
    constructor(e = { flushInterval: yC.DEFAULT_FLUSH_INTERVAL }) {
      super(), this.options = e, this._onDidChangeValue = this._register(new F0()), this._onDidChangeTarget = this._register(new F0()), this._onWillSaveState = this._register(new B()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._globalKeyTargets = void 0;
    }
    emitDidChangeValue(e, t) {
      t === gb ? (e === 0 ? this._globalKeyTargets = void 0 : e === 1 && (this._workspaceKeyTargets = void 0), this._onDidChangeTarget.fire({ scope: e })) : this._onDidChangeValue.fire({ scope: e, key: t, target: this.getKeyTargets(e)[t] });
    }
    get(e, t, i) {
      var n;
      return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.get(e, i);
    }
    getBoolean(e, t, i) {
      var n;
      return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.getBoolean(e, i);
    }
    getNumber(e, t, i) {
      var n;
      return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.getNumber(e, i);
    }
    store(e, t, i, n) {
      if (Ws(t)) {
        this.remove(e, i);
        return;
      }
      this.withPausedEmitters(() => {
        var o;
        this.updateKeyTarget(e, i, n), (o = this.getStorage(i)) === null || o === void 0 || o.set(e, t);
      });
    }
    remove(e, t) {
      this.withPausedEmitters(() => {
        var i;
        this.updateKeyTarget(e, t, void 0), (i = this.getStorage(t)) === null || i === void 0 || i.delete(e);
      });
    }
    withPausedEmitters(e) {
      this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
      try {
        e();
      } finally {
        this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
      }
    }
    updateKeyTarget(e, t, i) {
      var n, o;
      const r = this.getKeyTargets(t);
      typeof i == "number" ? r[e] !== i && (r[e] = i, (n = this.getStorage(t)) === null || n === void 0 || n.set(gb, JSON.stringify(r))) : typeof r[e] == "number" && (delete r[e], (o = this.getStorage(t)) === null || o === void 0 || o.set(gb, JSON.stringify(r)));
    }
    get workspaceKeyTargets() {
      return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(1)), this._workspaceKeyTargets;
    }
    get globalKeyTargets() {
      return this._globalKeyTargets || (this._globalKeyTargets = this.loadKeyTargets(0)), this._globalKeyTargets;
    }
    getKeyTargets(e) {
      return e === 0 ? this.globalKeyTargets : this.workspaceKeyTargets;
    }
    loadKeyTargets(e) {
      const t = this.get(gb, e);
      if (t)
        try {
          return JSON.parse(t);
        } catch {
        }
      return /* @__PURE__ */ Object.create(null);
    }
  }
  yC.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
  class JY extends yC {
    constructor() {
      super(), this.globalStorage = this._register(new pp(new RM())), this.workspaceStorage = this._register(new pp(new RM())), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.globalStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e)));
    }
    getStorage(e) {
      return e === 0 ? this.globalStorage : this.workspaceStorage;
    }
  }
  var eX = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, tX = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const f3 = st("ICodeLensCache");
  class OM {
    constructor(e, t) {
      this.lineCount = e, this.data = t;
    }
  }
  let qL = class {
    constructor(e) {
      this._fakeProvider = new class {
        provideCodeLenses() {
          throw new Error("not supported");
        }
      }(), this._cache = new Wc(20, 0.75);
      const t = "codelens/cache";
      Bm(() => e.remove(t, 1));
      const i = "codelens/cache2", n = e.get(i, 1, "{}");
      this._deserialize(n), ul(e.onWillSaveState)((o) => {
        o.reason === N1.SHUTDOWN && e.store(i, this._serialize(), 1, 1);
      });
    }
    put(e, t) {
      const i = t.lenses.map((r) => {
        var a;
        return {
          range: r.symbol.range,
          command: r.symbol.command && { id: "", title: (a = r.symbol.command) === null || a === void 0 ? void 0 : a.title }
        };
      }), n = new KL();
      n.add({ lenses: i, dispose: () => {
      } }, this._fakeProvider);
      const o = new OM(e.getLineCount(), n);
      this._cache.set(e.uri.toString(), o);
    }
    get(e) {
      const t = this._cache.get(e.uri.toString());
      return t && t.lineCount === e.getLineCount() ? t.data : void 0;
    }
    delete(e) {
      this._cache.delete(e.uri.toString());
    }
    _serialize() {
      const e = /* @__PURE__ */ Object.create(null);
      for (const [t, i] of this._cache) {
        const n = /* @__PURE__ */ new Set();
        for (const o of i.data.lenses)
          n.add(o.symbol.range.startLineNumber);
        e[t] = {
          lineCount: i.lineCount,
          lines: [...n.values()]
        };
      }
      return JSON.stringify(e);
    }
    _deserialize(e) {
      try {
        const t = JSON.parse(e);
        for (const i in t) {
          const n = t[i], o = [];
          for (const a of n.lines)
            o.push({ range: new D(a, 1, a, 11) });
          const r = new KL();
          r.add({ lenses: o, dispose() {
          } }, this._fakeProvider), this._cache.set(i, new OM(n.lineCount, r));
        }
      } catch {
      }
    }
  };
  qL = eX([
    tX(0, La)
  ], qL);
  ht(f3, qL);
  const iX = new RegExp(`(\\\\)?\\$\\((${Un.iconNameExpression}(?:${Un.iconModifierExpression})?)\\)`, "g");
  function Pd(s) {
    const e = new Array();
    let t, i = 0, n = 0;
    for (; (t = iX.exec(s)) !== null; ) {
      n = t.index || 0, e.push(s.substring(i, n)), i = (t.index || 0) + t[0].length;
      const [, o, r] = t;
      e.push(o ? `$(${r})` : nX({ id: r }));
    }
    return i < s.length && e.push(s.substring(i)), e;
  }
  function nX(s) {
    const e = J("span");
    return e.classList.add(...Un.asClassNameArray(s)), e;
  }
  class sX {
    constructor(e, t, i) {
      this.afterColumn = 1073741824, this.afterLineNumber = e, this.heightInPx = t, this._onHeight = i, this.suppressMouseDown = !0, this.domNode = document.createElement("div");
    }
    onComputedHeight(e) {
      this._lastHeight === void 0 ? this._lastHeight = e : this._lastHeight !== e && (this._lastHeight = e, this._onHeight());
    }
    isVisible() {
      return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
    }
  }
  class LC {
    constructor(e, t, i) {
      this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this._commands = /* @__PURE__ */ new Map(), this._isEmpty = !0, this._editor = e, this._id = `codelens.widget-${LC._idPool++}`, this.updatePosition(i), this._domNode = document.createElement("span"), this._domNode.className = `codelens-decoration ${t}`;
    }
    withCommands(e, t) {
      this._commands.clear();
      let i = [], n = !1;
      for (let o = 0; o < e.length; o++) {
        const r = e[o];
        if (!!r && (n = !0, r.command)) {
          const a = Pd(r.command.title.trim());
          r.command.id ? (i.push(J("a", { id: String(o), title: r.command.tooltip }, ...a)), this._commands.set(String(o), r.command)) : i.push(J("span", { title: r.command.tooltip }, ...a)), o + 1 < e.length && i.push(J("span", void 0, "\xA0|\xA0"));
        }
      }
      n ? (pc(this._domNode, ...i), this._isEmpty && t && this._domNode.classList.add("fadein"), this._isEmpty = !1) : pc(this._domNode, J("span", void 0, "no commands"));
    }
    getCommand(e) {
      return e.parentElement === this._domNode ? this._commands.get(e.id) : void 0;
    }
    getId() {
      return this._id;
    }
    getDomNode() {
      return this._domNode;
    }
    updatePosition(e) {
      const t = this._editor.getModel().getLineFirstNonWhitespaceColumn(e);
      this._widgetPosition = {
        position: { lineNumber: e, column: t },
        preference: [1]
      };
    }
    getPosition() {
      return this._widgetPosition || null;
    }
  }
  LC._idPool = 0;
  class xS {
    constructor() {
      this._removeDecorations = [], this._addDecorations = [], this._addDecorationsCallbacks = [];
    }
    addDecoration(e, t) {
      this._addDecorations.push(e), this._addDecorationsCallbacks.push(t);
    }
    removeDecoration(e) {
      this._removeDecorations.push(e);
    }
    commit(e) {
      let t = e.deltaDecorations(this._removeDecorations, this._addDecorations);
      for (let i = 0, n = t.length; i < n; i++)
        this._addDecorationsCallbacks[i](t[i]);
    }
  }
  class PM {
    constructor(e, t, i, n, o, r, a) {
      this._isDisposed = !1, this._editor = t, this._className = i, this._data = e, this._decorationIds = [];
      let l, c = [];
      this._data.forEach((d, h) => {
        d.symbol.command && c.push(d.symbol), n.addDecoration({
          range: d.symbol.range,
          options: $e.EMPTY
        }, (u) => this._decorationIds[h] = u), l ? l = D.plusRange(l, d.symbol.range) : l = D.lift(d.symbol.range);
      }), this._viewZone = new sX(l.startLineNumber - 1, r, a), this._viewZoneId = o.addZone(this._viewZone), c.length > 0 && (this._createContentWidgetIfNecessary(), this._contentWidget.withCommands(c, !1));
    }
    _createContentWidgetIfNecessary() {
      this._contentWidget ? this._editor.layoutContentWidget(this._contentWidget) : (this._contentWidget = new LC(this._editor, this._className, this._viewZone.afterLineNumber + 1), this._editor.addContentWidget(this._contentWidget));
    }
    dispose(e, t) {
      this._decorationIds.forEach(e.removeDecoration, e), this._decorationIds = [], t && t.removeZone(this._viewZoneId), this._contentWidget && (this._editor.removeContentWidget(this._contentWidget), this._contentWidget = void 0), this._isDisposed = !0;
    }
    isDisposed() {
      return this._isDisposed;
    }
    isValid() {
      return this._decorationIds.some((e, t) => {
        const i = this._editor.getModel().getDecorationRange(e), n = this._data[t].symbol;
        return !!(i && D.isEmpty(n.range) === i.isEmpty());
      });
    }
    updateCodeLensSymbols(e, t) {
      this._decorationIds.forEach(t.removeDecoration, t), this._decorationIds = [], this._data = e, this._data.forEach((i, n) => {
        t.addDecoration({
          range: i.symbol.range,
          options: $e.EMPTY
        }, (o) => this._decorationIds[n] = o);
      });
    }
    updateHeight(e, t) {
      this._viewZone.heightInPx = e, t.layoutZone(this._viewZoneId), this._contentWidget && this._editor.layoutContentWidget(this._contentWidget);
    }
    computeIfNecessary(e) {
      if (!this._viewZone.isVisible())
        return null;
      for (let t = 0; t < this._decorationIds.length; t++) {
        const i = e.getDecorationRange(this._decorationIds[t]);
        i && (this._data[t].symbol.range = i);
      }
      return this._data;
    }
    updateCommands(e) {
      this._createContentWidgetIfNecessary(), this._contentWidget.withCommands(e, !0);
      for (let t = 0; t < this._data.length; t++) {
        const i = e[t];
        if (i) {
          const { symbol: n } = this._data[t];
          n.command = i.command || n.command;
        }
      }
    }
    getCommand(e) {
      var t;
      return (t = this._contentWidget) === null || t === void 0 ? void 0 : t.getCommand(e);
    }
    getLineNumber() {
      const e = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      return e ? e.startLineNumber : -1;
    }
    update(e) {
      if (this.isValid()) {
        const t = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
        t && (this._viewZone.afterLineNumber = t.startLineNumber - 1, e.layoutZone(this._viewZoneId), this._contentWidget && (this._contentWidget.updatePosition(t.startLineNumber), this._editor.layoutContentWidget(this._contentWidget)));
      }
    }
  }
  const oX = { ctrlCmd: !1, alt: !1 };
  var _p;
  (function(s) {
    s[s.Blur = 1] = "Blur", s[s.Gesture = 2] = "Gesture", s[s.Other = 3] = "Other";
  })(_p || (_p = {}));
  var sr;
  (function(s) {
    s[s.NONE = 0] = "NONE", s[s.FIRST = 1] = "FIRST", s[s.SECOND = 2] = "SECOND", s[s.LAST = 3] = "LAST";
  })(sr || (sr = {}));
  const Sl = st("quickInputService");
  function vs(s, e, t) {
    return Math.min(Math.max(s, e), t);
  }
  class g3 {
    constructor() {
      this._n = 1, this._val = 0;
    }
    update(e) {
      return this._val = this._val + (e - this._val) / this._n, this._n += 1, this._val;
    }
    get value() {
      return this._val;
    }
  }
  class rX {
    constructor(e) {
      this._n = 0, this._val = 0, this._values = [], this._index = 0, this._sum = 0, this._values = new Array(e), this._values.fill(0, 0, e);
    }
    update(e) {
      const t = this._values[this._index];
      return this._values[this._index] = e, this._index = (this._index + 1) % this._values.length, this._sum -= t, this._sum += e, this._n < this._values.length && (this._n += 1), this._val = this._sum / this._n, this._val;
    }
    get value() {
      return this._val;
    }
  }
  var aX = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, lX = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Io = st("ILanguageFeatureDebounceService");
  var T1;
  (function(s) {
    const e = /* @__PURE__ */ new WeakMap();
    let t = 0;
    function i(n) {
      let o = e.get(n);
      return o === void 0 && (o = ++t, e.set(n, o)), o;
    }
    s.of = i;
  })(T1 || (T1 = {}));
  class cX {
    constructor(e, t, i, n, o, r) {
      this._logService = e, this._name = t, this._registry = i, this._default = n, this._min = o, this._max = r, this._cache = new Wc(50, 0.7);
    }
    _key(e) {
      return e.id + this._registry.all(e).reduce((t, i) => wC(T1.of(i), t), 0);
    }
    get(e) {
      const t = this._key(e), i = this._cache.get(t);
      return i ? vs(i.value, this._min, this._max) : this.default();
    }
    update(e, t) {
      const i = this._key(e);
      let n = this._cache.get(i);
      n || (n = new rX(6), this._cache.set(i, n));
      const o = vs(n.update(t), this._min, this._max);
      return this._logService.trace(`[DEBOUNCE: ${this._name}] for ${e.uri.toString()} is ${o}ms`), o;
    }
    _overall() {
      const e = new g3();
      for (const [, t] of this._cache)
        e.update(t.value);
      return e.value;
    }
    default() {
      const e = this._overall() | 0 || this._default;
      return vs(e, this._min, this._max);
    }
  }
  let GL = class {
    constructor(e) {
      this._logService = e, this._data = /* @__PURE__ */ new Map();
    }
    for(e, t, i) {
      var n, o, r;
      const a = (n = i?.min) !== null && n !== void 0 ? n : 50, l = (o = i?.max) !== null && o !== void 0 ? o : Math.pow(a, 2), c = (r = i?.key) !== null && r !== void 0 ? r : void 0, d = `${T1.of(e)},${a}${c ? "," + c : ""}`;
      let h = this._data.get(d);
      return h || (h = new cX(this._logService, t, e, this._overallAverage() | 0 || a * 1.5, a, l), this._data.set(d, h)), h;
    }
    _overallAverage() {
      let e = new g3();
      for (let t of this._data.values())
        e.update(t.default());
      return e.value;
    }
  };
  GL = aX([
    lX(0, Xo)
  ], GL);
  ht(Io, GL, !0);
  var dX = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Eg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, hX = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Ef = class {
    constructor(e, t, i, n, o, r) {
      this._editor = e, this._languageFeaturesService = t, this._commandService = n, this._notificationService = o, this._codeLensCache = r, this._disposables = new te(), this._localToDispose = new te(), this._lenses = [], this._oldCodeLensModels = new te(), this._provideCodeLensDebounce = i.for(t.codeLensProvider, "CodeLensProvide", { min: 250 }), this._resolveCodeLensesDebounce = i.for(t.codeLensProvider, "CodeLensResolve", { min: 250, salt: "resolve" }), this._resolveCodeLensesScheduler = new It(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default()), this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange())), this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange())), this._disposables.add(this._editor.onDidChangeConfiguration((a) => {
        (a.hasChanged(44) || a.hasChanged(16) || a.hasChanged(15)) && this._updateLensStyle(), a.hasChanged(14) && this._onModelChange();
      })), this._disposables.add(t.codeLensProvider.onDidChange(this._onModelChange, this)), this._onModelChange(), this._styleClassName = "_" + h3(this._editor.getId()).toString(16), this._styleElement = Co(Vm(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0), this._updateLensStyle();
    }
    dispose() {
      var e;
      this._localDispose(), this._disposables.dispose(), this._oldCodeLensModels.dispose(), (e = this._currentCodeLensModel) === null || e === void 0 || e.dispose(), this._styleElement.remove();
    }
    _getLayoutInfo() {
      let e = this._editor.getOption(16), t;
      return !e || e < 5 ? (e = this._editor.getOption(46) * 0.9 | 0, t = this._editor.getOption(59)) : t = e * Math.max(1.3, this._editor.getOption(59) / this._editor.getOption(46)) | 0, { codeLensHeight: t, fontSize: e };
    }
    _updateLensStyle() {
      const { codeLensHeight: e, fontSize: t } = this._getLayoutInfo(), i = this._editor.getOption(15), n = this._editor.getOption(44), o = `--codelens-font-family${this._styleClassName}`, r = `--codelens-font-features${this._styleClassName}`;
      let a = `
		.monaco-editor .codelens-decoration.${this._styleClassName} { line-height: ${e}px; font-size: ${t}px; padding-right: ${Math.round(t * 0.5)}px; font-feature-settings: var(${r}) }
		.monaco-editor .codelens-decoration.${this._styleClassName} span.codicon { line-height: ${e}px; font-size: ${t}px; }
		`;
      i && (a += `.monaco-editor .codelens-decoration.${this._styleClassName} { font-family: var(${o}), ${Fn.fontFamily}}`), this._styleElement.textContent = a, this._editor.getContainerDomNode().style.setProperty(o, i ?? "inherit"), this._editor.getContainerDomNode().style.setProperty(r, n.fontFeatureSettings), this._editor.changeViewZones((l) => {
        for (let c of this._lenses)
          c.updateHeight(e, l);
      });
    }
    _localDispose() {
      var e, t, i;
      (e = this._getCodeLensModelPromise) === null || e === void 0 || e.cancel(), this._getCodeLensModelPromise = void 0, (t = this._resolveCodeLensesPromise) === null || t === void 0 || t.cancel(), this._resolveCodeLensesPromise = void 0, this._localToDispose.clear(), this._oldCodeLensModels.clear(), (i = this._currentCodeLensModel) === null || i === void 0 || i.dispose();
    }
    _onModelChange() {
      this._localDispose();
      const e = this._editor.getModel();
      if (!e || !this._editor.getOption(14))
        return;
      const t = this._codeLensCache.get(e);
      if (t && this._renderCodeLensSymbols(t), !this._languageFeaturesService.codeLensProvider.has(e)) {
        t && this._localToDispose.add($d(() => {
          const n = this._codeLensCache.get(e);
          t === n && (this._codeLensCache.delete(e), this._onModelChange());
        }, 30 * 1e3));
        return;
      }
      for (const n of this._languageFeaturesService.codeLensProvider.all(e))
        if (typeof n.onDidChange == "function") {
          let o = n.onDidChange(() => i.schedule());
          this._localToDispose.add(o);
        }
      const i = new It(() => {
        var n;
        const o = Date.now();
        (n = this._getCodeLensModelPromise) === null || n === void 0 || n.cancel(), this._getCodeLensModelPromise = an((r) => u3(this._languageFeaturesService.codeLensProvider, e, r)), this._getCodeLensModelPromise.then((r) => {
          this._currentCodeLensModel && this._oldCodeLensModels.add(this._currentCodeLensModel), this._currentCodeLensModel = r, this._codeLensCache.put(e, r);
          const a = this._provideCodeLensDebounce.update(e, Date.now() - o);
          i.delay = a, this._renderCodeLensSymbols(r), this._resolveCodeLensesInViewportSoon();
        }, We);
      }, this._provideCodeLensDebounce.get(e));
      this._localToDispose.add(i), this._localToDispose.add(qe(() => this._resolveCodeLensesScheduler.cancel())), this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
        this._editor.changeDecorations((n) => {
          this._editor.changeViewZones((o) => {
            let r = [], a = -1;
            this._lenses.forEach((c) => {
              !c.isValid() || a === c.getLineNumber() ? r.push(c) : (c.update(o), a = c.getLineNumber());
            });
            let l = new xS();
            r.forEach((c) => {
              c.dispose(l, o), this._lenses.splice(this._lenses.indexOf(c), 1);
            }), l.commit(n);
          });
        }), i.schedule();
      })), this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
        i.schedule();
      })), this._localToDispose.add(this._editor.onDidScrollChange((n) => {
        n.scrollTopChanged && this._lenses.length > 0 && this._resolveCodeLensesInViewportSoon();
      })), this._localToDispose.add(this._editor.onDidLayoutChange(() => {
        this._resolveCodeLensesInViewportSoon();
      })), this._localToDispose.add(qe(() => {
        if (this._editor.getModel()) {
          const n = kc.capture(this._editor);
          this._editor.changeDecorations((o) => {
            this._editor.changeViewZones((r) => {
              this._disposeAllLenses(o, r);
            });
          }), n.restore(this._editor);
        } else
          this._disposeAllLenses(void 0, void 0);
      })), this._localToDispose.add(this._editor.onMouseDown((n) => {
        if (n.target.type !== 9)
          return;
        let o = n.target.element;
        if (o?.tagName === "SPAN" && (o = o.parentElement), o?.tagName === "A")
          for (const r of this._lenses) {
            let a = r.getCommand(o);
            if (a) {
              this._commandService.executeCommand(a.id, ...a.arguments || []).catch((l) => this._notificationService.error(l));
              break;
            }
          }
      })), i.schedule();
    }
    _disposeAllLenses(e, t) {
      const i = new xS();
      for (const n of this._lenses)
        n.dispose(i, t);
      e && i.commit(e), this._lenses.length = 0;
    }
    _renderCodeLensSymbols(e) {
      if (!this._editor.hasModel())
        return;
      let t = this._editor.getModel().getLineCount(), i = [], n;
      for (let a of e.lenses) {
        let l = a.symbol.range.startLineNumber;
        l < 1 || l > t || (n && n[n.length - 1].symbol.range.startLineNumber === l ? n.push(a) : (n = [a], i.push(n)));
      }
      const o = kc.capture(this._editor), r = this._getLayoutInfo();
      this._editor.changeDecorations((a) => {
        this._editor.changeViewZones((l) => {
          const c = new xS();
          let d = 0, h = 0;
          for (; h < i.length && d < this._lenses.length; ) {
            let u = i[h][0].symbol.range.startLineNumber, f = this._lenses[d].getLineNumber();
            f < u ? (this._lenses[d].dispose(c, l), this._lenses.splice(d, 1)) : f === u ? (this._lenses[d].updateCodeLensSymbols(i[h], c), h++, d++) : (this._lenses.splice(d, 0, new PM(i[h], this._editor, this._styleClassName, c, l, r.codeLensHeight, () => this._resolveCodeLensesInViewportSoon())), d++, h++);
          }
          for (; d < this._lenses.length; )
            this._lenses[d].dispose(c, l), this._lenses.splice(d, 1);
          for (; h < i.length; )
            this._lenses.push(new PM(i[h], this._editor, this._styleClassName, c, l, r.codeLensHeight, () => this._resolveCodeLensesInViewportSoon())), h++;
          c.commit(a);
        });
      }), o.restore(this._editor);
    }
    _resolveCodeLensesInViewportSoon() {
      this._editor.getModel() && this._resolveCodeLensesScheduler.schedule();
    }
    _resolveCodeLensesInViewport() {
      var e;
      (e = this._resolveCodeLensesPromise) === null || e === void 0 || e.cancel(), this._resolveCodeLensesPromise = void 0;
      const t = this._editor.getModel();
      if (!t)
        return;
      const i = [], n = [];
      if (this._lenses.forEach((a) => {
        const l = a.computeIfNecessary(t);
        l && (i.push(l), n.push(a));
      }), i.length === 0)
        return;
      const o = Date.now(), r = an((a) => {
        const l = i.map((c, d) => {
          const h = new Array(c.length), u = c.map((f, g) => !f.symbol.command && typeof f.provider.resolveCodeLens == "function" ? Promise.resolve(f.provider.resolveCodeLens(t, f.symbol, a)).then((_) => {
            h[g] = _;
          }, Xi) : (h[g] = f.symbol, Promise.resolve(void 0)));
          return Promise.all(u).then(() => {
            !a.isCancellationRequested && !n[d].isDisposed() && n[d].updateCommands(h);
          });
        });
        return Promise.all(l);
      });
      this._resolveCodeLensesPromise = r, this._resolveCodeLensesPromise.then(() => {
        const a = this._resolveCodeLensesDebounce.update(t, Date.now() - o);
        this._resolveCodeLensesScheduler.delay = a, this._currentCodeLensModel && this._codeLensCache.put(t, this._currentCodeLensModel), this._oldCodeLensModels.clear(), r === this._resolveCodeLensesPromise && (this._resolveCodeLensesPromise = void 0);
      }, (a) => {
        We(a), r === this._resolveCodeLensesPromise && (this._resolveCodeLensesPromise = void 0);
      });
    }
    getModel() {
      return this._currentCodeLensModel;
    }
  };
  Ef.ID = "css.editor.codeLens";
  Ef = dX([
    Eg(1, me),
    Eg(2, Io),
    Eg(3, wi),
    Eg(4, yi),
    Eg(5, f3)
  ], Ef);
  vt(Ef.ID, Ef);
  oe(class extends ge {
    constructor() {
      super({
        id: "codelens.showLensesInCurrentLine",
        precondition: T.hasCodeLensProvider,
        label: m("showLensOnLine", "Show CodeLens Commands For Current Line"),
        alias: "Show CodeLens Commands For Current Line"
      });
    }
    run(e, t) {
      return hX(this, void 0, void 0, function* () {
        if (!t.hasModel())
          return;
        const i = e.get(Sl), n = e.get(wi), o = e.get(yi), r = t.getSelection().positionLineNumber, a = t.getContribution(Ef.ID);
        if (!a)
          return;
        const l = a.getModel();
        if (!l)
          return;
        const c = [];
        for (const h of l.lenses)
          h.symbol.command && h.symbol.range.startLineNumber === r && c.push({
            label: h.symbol.command.title,
            command: h.symbol.command
          });
        if (c.length === 0)
          return;
        const d = yield i.pick(c, { canPickMany: !1 });
        if (!!d) {
          if (l.isDisposed)
            return yield n.executeCommand(this.id);
          try {
            yield n.executeCommand(d.command.id, ...d.command.arguments || []);
          } catch (h) {
            o.error(h);
          }
        }
      });
    }
  });
  function uX(s, e, t) {
    const i = [], o = s.ordered(e).reverse().map((r) => Promise.resolve(r.provideDocumentColors(e, t)).then((a) => {
      if (Array.isArray(a))
        for (let l of a)
          i.push({ colorInfo: l, provider: r });
    }));
    return Promise.all(o).then(() => i);
  }
  function FM(s, e, t, i) {
    return Promise.resolve(t.provideColorPresentations(s, e, i));
  }
  lt.registerCommand("_executeDocumentColorProvider", function(s, ...e) {
    const [t] = e;
    if (!(t instanceof Ee))
      throw fr();
    const { colorProvider: i } = s.get(me), n = s.get(Qt).getModel(t);
    if (!n)
      throw fr();
    const o = [], a = i.ordered(n).reverse().map((l) => Promise.resolve(l.provideDocumentColors(n, Je.None)).then((c) => {
      if (Array.isArray(c))
        for (let d of c)
          o.push({ range: d.range, color: [d.color.red, d.color.green, d.color.blue, d.color.alpha] });
    }));
    return Promise.all(a).then(() => o);
  });
  lt.registerCommand("_executeColorPresentationProvider", function(s, ...e) {
    const [t, i] = e, { uri: n, range: o } = i;
    if (!(n instanceof Ee) || !Array.isArray(t) || t.length !== 4 || !D.isIRange(o))
      throw fr();
    const [r, a, l, c] = t, { colorProvider: d } = s.get(me), h = s.get(Qt).getModel(n);
    if (!h)
      throw fr();
    const u = {
      range: o,
      color: { red: r, green: a, blue: l, alpha: c }
    }, f = [], _ = d.ordered(h).reverse().map((b) => Promise.resolve(b.provideColorPresentations(h, u, Je.None)).then((C) => {
      Array.isArray(C) && f.push(...C);
    }));
    return Promise.all(_).then(() => f);
  });
  var fX = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, IS = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, gX = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const m3 = /* @__PURE__ */ Object.create({}), mX = 500;
  let sh = class p3 extends z {
    constructor(e, t, i, n) {
      super(), this._editor = e, this._configurationService = t, this._languageFeaturesService = i, this._localToDispose = this._register(new te()), this._decorationsIds = [], this._colorDatas = /* @__PURE__ */ new Map(), this._colorDecoratorIds = /* @__PURE__ */ new Set(), this._ruleFactory = new c_(this._editor), this._colorDecorationClassRefs = this._register(new te()), this._debounceInformation = n.for(i.colorProvider, "Document Colors", { min: p3.RECOMPUTE_TIME }), this._register(e.onDidChangeModel(() => {
        this._isEnabled = this.isEnabled(), this.onModelChanged();
      })), this._register(e.onDidChangeModelLanguage(() => this.onModelChanged())), this._register(i.colorProvider.onDidChange(() => this.onModelChanged())), this._register(e.onDidChangeConfiguration(() => {
        let o = this._isEnabled;
        this._isEnabled = this.isEnabled(), o !== this._isEnabled && (this._isEnabled ? this.onModelChanged() : this.removeAllDecorations());
      })), this._timeoutTimer = null, this._computePromise = null, this._isEnabled = this.isEnabled(), this.onModelChanged();
    }
    isEnabled() {
      const e = this._editor.getModel();
      if (!e)
        return !1;
      const t = e.getLanguageId(), i = this._configurationService.getValue(t);
      if (i && typeof i == "object") {
        const n = i.colorDecorators;
        if (n && n.enable !== void 0 && !n.enable)
          return n.enable;
      }
      return this._editor.getOption(17);
    }
    static get(e) {
      return e.getContribution(this.ID);
    }
    dispose() {
      this.stop(), this.removeAllDecorations(), super.dispose();
    }
    onModelChanged() {
      if (this.stop(), !this._isEnabled)
        return;
      const e = this._editor.getModel();
      !e || !this._languageFeaturesService.colorProvider.has(e) || (this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
        this._timeoutTimer || (this._timeoutTimer = new Ns(), this._timeoutTimer.cancelAndSet(() => {
          this._timeoutTimer = null, this.beginCompute();
        }, this._debounceInformation.get(e)));
      })), this.beginCompute());
    }
    beginCompute() {
      this._computePromise = an((e) => gX(this, void 0, void 0, function* () {
        const t = this._editor.getModel();
        if (!t)
          return Promise.resolve([]);
        const i = new hs(!1), n = yield uX(this._languageFeaturesService.colorProvider, t, e);
        return this._debounceInformation.update(t, i.elapsed()), n;
      })), this._computePromise.then((e) => {
        this.updateDecorations(e), this.updateColorDecorators(e), this._computePromise = null;
      }, We);
    }
    stop() {
      this._timeoutTimer && (this._timeoutTimer.cancel(), this._timeoutTimer = null), this._computePromise && (this._computePromise.cancel(), this._computePromise = null), this._localToDispose.clear();
    }
    updateDecorations(e) {
      const t = e.map((i) => ({
        range: {
          startLineNumber: i.colorInfo.range.startLineNumber,
          startColumn: i.colorInfo.range.startColumn,
          endLineNumber: i.colorInfo.range.endLineNumber,
          endColumn: i.colorInfo.range.endColumn
        },
        options: $e.EMPTY
      }));
      this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, t), this._colorDatas = /* @__PURE__ */ new Map(), this._decorationsIds.forEach((i, n) => this._colorDatas.set(i, e[n]));
    }
    updateColorDecorators(e) {
      this._colorDecorationClassRefs.clear();
      let t = [];
      for (let i = 0; i < e.length && t.length < mX; i++) {
        const { red: n, green: o, blue: r, alpha: a } = e[i].colorInfo.color, l = new tt(Math.round(n * 255), Math.round(o * 255), Math.round(r * 255), a);
        let c = `rgba(${l.r}, ${l.g}, ${l.b}, ${l.a})`;
        const d = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
          backgroundColor: c
        }));
        t.push({
          range: {
            startLineNumber: e[i].colorInfo.range.startLineNumber,
            startColumn: e[i].colorInfo.range.startColumn,
            endLineNumber: e[i].colorInfo.range.endLineNumber,
            endColumn: e[i].colorInfo.range.endColumn
          },
          options: {
            description: "colorDetector",
            before: {
              content: sV,
              inlineClassName: `${d.className} colorpicker-color-decoration`,
              inlineClassNameAffectsLetterSpacing: !0,
              attachedData: m3
            }
          }
        });
      }
      this._colorDecoratorIds = new Set(this._editor.deltaDecorations([...this._colorDecoratorIds], t));
    }
    removeAllDecorations() {
      this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, []), this._colorDecoratorIds = new Set(this._editor.deltaDecorations([...this._colorDecoratorIds], [])), this._colorDecorationClassRefs.clear();
    }
    getColorData(e) {
      const t = this._editor.getModel();
      if (!t)
        return null;
      const i = t.getDecorationsInRange(D.fromPositions(e, e)).filter((n) => this._colorDatas.has(n.id));
      return i.length === 0 ? null : this._colorDatas.get(i[0].id);
    }
    isColorDecorationId(e) {
      return this._colorDecoratorIds.has(e);
    }
  };
  sh.ID = "editor.contrib.colorDetector";
  sh.RECOMPUTE_TIME = 1e3;
  sh = fX([
    IS(1, At),
    IS(2, me),
    IS(3, Io)
  ], sh);
  vt(sh.ID, sh);
  class pX {
    constructor(e, t, i) {
      this.presentationIndex = i, this._onColorFlushed = new B(), this.onColorFlushed = this._onColorFlushed.event, this._onDidChangeColor = new B(), this.onDidChangeColor = this._onDidChangeColor.event, this._onDidChangePresentation = new B(), this.onDidChangePresentation = this._onDidChangePresentation.event, this.originalColor = e, this._color = e, this._colorPresentations = t;
    }
    get color() {
      return this._color;
    }
    set color(e) {
      this._color.equals(e) || (this._color = e, this._onDidChangeColor.fire(e));
    }
    get presentation() {
      return this.colorPresentations[this.presentationIndex];
    }
    get colorPresentations() {
      return this._colorPresentations;
    }
    set colorPresentations(e) {
      this._colorPresentations = e, this.presentationIndex > e.length - 1 && (this.presentationIndex = 0), this._onDidChangePresentation.fire(this.presentation);
    }
    selectNextColorPresentation() {
      this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length, this.flushColor(), this._onDidChangePresentation.fire(this.presentation);
    }
    guessColorPresentation(e, t) {
      for (let i = 0; i < this.colorPresentations.length; i++)
        if (t.toLowerCase() === this.colorPresentations[i].label) {
          this.presentationIndex = i, this._onDidChangePresentation.fire(this.presentation);
          break;
        }
    }
    flushColor() {
      this._onColorFlushed.fire(this._color);
    }
  }
  const ur = J;
  class _X extends z {
    constructor(e, t, i) {
      super(), this.model = t, this.domNode = ur(".colorpicker-header"), q(e, this.domNode), this.pickedColorNode = q(this.domNode, ur(".picked-color"));
      const n = m("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
      this.pickedColorNode.setAttribute("title", n);
      const o = q(this.domNode, ur(".original-color"));
      o.style.backgroundColor = H.Format.CSS.format(this.model.originalColor) || "", this.backgroundColor = i.getColorTheme().getColor(Yd) || H.white, this._register(Vt((r, a) => {
        this.backgroundColor = r.getColor(Yd) || H.white;
      })), this._register(ee(this.pickedColorNode, ye.CLICK, () => this.model.selectNextColorPresentation())), this._register(ee(o, ye.CLICK, () => {
        this.model.color = this.model.originalColor, this.model.flushColor();
      })), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this._register(t.onDidChangePresentation(this.onDidChangePresentation, this)), this.pickedColorNode.style.backgroundColor = H.Format.CSS.format(t.color) || "", this.pickedColorNode.classList.toggle("light", t.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : t.color.isLighter()), this.onDidChangeColor(this.model.color);
    }
    onDidChangeColor(e) {
      this.pickedColorNode.style.backgroundColor = H.Format.CSS.format(e) || "", this.pickedColorNode.classList.toggle("light", e.rgba.a < 0.5 ? this.backgroundColor.isLighter() : e.isLighter()), this.onDidChangePresentation();
    }
    onDidChangePresentation() {
      this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : "", this.pickedColorNode.prepend(ur(".codicon.codicon-color-mode"));
    }
  }
  class bX extends z {
    constructor(e, t, i) {
      super(), this.model = t, this.pixelRatio = i, this.domNode = ur(".colorpicker-body"), q(e, this.domNode), this.saturationBox = new vX(this.domNode, this.model, this.pixelRatio), this._register(this.saturationBox), this._register(this.saturationBox.onDidChange(this.onDidSaturationValueChange, this)), this._register(this.saturationBox.onColorFlushed(this.flushColor, this)), this.opacityStrip = new CX(this.domNode, this.model), this._register(this.opacityStrip), this._register(this.opacityStrip.onDidChange(this.onDidOpacityChange, this)), this._register(this.opacityStrip.onColorFlushed(this.flushColor, this)), this.hueStrip = new wX(this.domNode, this.model), this._register(this.hueStrip), this._register(this.hueStrip.onDidChange(this.onDidHueChange, this)), this._register(this.hueStrip.onColorFlushed(this.flushColor, this));
    }
    flushColor() {
      this.model.flushColor();
    }
    onDidSaturationValueChange({ s: e, v: t }) {
      const i = this.model.color.hsva;
      this.model.color = new H(new Qr(i.h, e, t, i.a));
    }
    onDidOpacityChange(e) {
      const t = this.model.color.hsva;
      this.model.color = new H(new Qr(t.h, t.s, t.v, e));
    }
    onDidHueChange(e) {
      const t = this.model.color.hsva, i = (1 - e) * 360;
      this.model.color = new H(new Qr(i === 360 ? 0 : i, t.s, t.v, t.a));
    }
    layout() {
      this.saturationBox.layout(), this.opacityStrip.layout(), this.hueStrip.layout();
    }
  }
  class vX extends z {
    constructor(e, t, i) {
      super(), this.model = t, this.pixelRatio = i, this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new B(), this.onColorFlushed = this._onColorFlushed.event, this.domNode = ur(".saturation-wrap"), q(e, this.domNode), this.canvas = document.createElement("canvas"), this.canvas.className = "saturation-box", q(this.domNode, this.canvas), this.selection = ur(".saturation-selection"), q(this.domNode, this.selection), this.layout(), this._register(LI(this.domNode, (n) => this.onMouseDown(n))), this._register(this.model.onDidChangeColor(this.onDidChangeColor, this)), this.monitor = null;
    }
    onMouseDown(e) {
      this.monitor = this._register(new Ah());
      const t = mn(this.domNode);
      e.target !== this.selection && this.onDidChangePosition(e.offsetX, e.offsetY), this.monitor.startMonitoring(e.target, e.buttons, ng, (n) => this.onDidChangePosition(n.posx - t.left, n.posy - t.top), () => null);
      const i = fP(document, () => {
        this._onColorFlushed.fire(), i.dispose(), this.monitor && (this.monitor.stopMonitoring(!0), this.monitor = null);
      }, !0);
    }
    onDidChangePosition(e, t) {
      const i = Math.max(0, Math.min(1, e / this.width)), n = Math.max(0, Math.min(1, 1 - t / this.height));
      this.paintSelection(i, n), this._onDidChange.fire({ s: i, v: n });
    }
    layout() {
      this.width = this.domNode.offsetWidth, this.height = this.domNode.offsetHeight, this.canvas.width = this.width * this.pixelRatio, this.canvas.height = this.height * this.pixelRatio, this.paint();
      const e = this.model.color.hsva;
      this.paintSelection(e.s, e.v);
    }
    paint() {
      const e = this.model.color.hsva, t = new H(new Qr(e.h, 1, 1, 1)), i = this.canvas.getContext("2d"), n = i.createLinearGradient(0, 0, this.canvas.width, 0);
      n.addColorStop(0, "rgba(255, 255, 255, 1)"), n.addColorStop(0.5, "rgba(255, 255, 255, 0.5)"), n.addColorStop(1, "rgba(255, 255, 255, 0)");
      const o = i.createLinearGradient(0, 0, 0, this.canvas.height);
      o.addColorStop(0, "rgba(0, 0, 0, 0)"), o.addColorStop(1, "rgba(0, 0, 0, 1)"), i.rect(0, 0, this.canvas.width, this.canvas.height), i.fillStyle = H.Format.CSS.format(t), i.fill(), i.fillStyle = n, i.fill(), i.fillStyle = o, i.fill();
    }
    paintSelection(e, t) {
      this.selection.style.left = `${e * this.width}px`, this.selection.style.top = `${this.height - t * this.height}px`;
    }
    onDidChangeColor() {
      this.monitor && this.monitor.isMonitoring() || this.paint();
    }
  }
  class _3 extends z {
    constructor(e, t) {
      super(), this.model = t, this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new B(), this.onColorFlushed = this._onColorFlushed.event, this.domNode = q(e, ur(".strip")), this.overlay = q(this.domNode, ur(".overlay")), this.slider = q(this.domNode, ur(".slider")), this.slider.style.top = "0px", this._register(LI(this.domNode, (i) => this.onMouseDown(i))), this.layout();
    }
    layout() {
      this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
      const e = this.getValue(this.model.color);
      this.updateSliderPosition(e);
    }
    onMouseDown(e) {
      const t = this._register(new Ah()), i = mn(this.domNode);
      this.domNode.classList.add("grabbing"), e.target !== this.slider && this.onDidChangeTop(e.offsetY), t.startMonitoring(e.target, e.buttons, ng, (o) => this.onDidChangeTop(o.posy - i.top), () => null);
      const n = fP(document, () => {
        this._onColorFlushed.fire(), n.dispose(), t.stopMonitoring(!0), this.domNode.classList.remove("grabbing");
      }, !0);
    }
    onDidChangeTop(e) {
      const t = Math.max(0, Math.min(1, 1 - e / this.height));
      this.updateSliderPosition(t), this._onDidChange.fire(t);
    }
    updateSliderPosition(e) {
      this.slider.style.top = `${(1 - e) * this.height}px`;
    }
  }
  class CX extends _3 {
    constructor(e, t) {
      super(e, t), this.domNode.classList.add("opacity-strip"), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this.onDidChangeColor(this.model.color);
    }
    onDidChangeColor(e) {
      const { r: t, g: i, b: n } = e.rgba, o = new H(new tt(t, i, n, 1)), r = new H(new tt(t, i, n, 0));
      this.overlay.style.background = `linear-gradient(to bottom, ${o} 0%, ${r} 100%)`;
    }
    getValue(e) {
      return e.hsva.a;
    }
  }
  class wX extends _3 {
    constructor(e, t) {
      super(e, t), this.domNode.classList.add("hue-strip");
    }
    getValue(e) {
      return 1 - e.hsva.h / 360;
    }
  }
  class SX extends Qo {
    constructor(e, t, i, n) {
      super(), this.model = t, this.pixelRatio = i, this._register(hf.onDidChange(() => this.layout()));
      const o = ur(".colorpicker-widget");
      e.appendChild(o);
      const r = new _X(o, this.model, n);
      this.body = new bX(o, this.model, this.pixelRatio), this._register(r), this._register(this.body);
    }
    layout() {
      this.body.layout();
    }
  }
  var yX = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, LX = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, BM = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class kX {
    constructor(e, t, i, n) {
      this.owner = e, this.range = t, this.model = i, this.provider = n, this.forceShowAtRange = !0;
    }
    isValidForHoverAnchor(e) {
      return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
    }
  }
  let ZL = class {
    constructor(e, t) {
      this._editor = e, this._themeService = t, this.hoverOrdinal = 1;
    }
    computeSync(e, t) {
      return [];
    }
    computeAsync(e, t, i) {
      return vi.fromPromise(this._computeAsync(e, t, i));
    }
    _computeAsync(e, t, i) {
      return BM(this, void 0, void 0, function* () {
        if (!this._editor.hasModel())
          return [];
        const n = sh.get(this._editor);
        if (!n)
          return [];
        for (const o of t) {
          if (!n.isColorDecorationId(o.id))
            continue;
          const r = n.getColorData(o.range.getStartPosition());
          if (r)
            return [yield this._createColorHover(this._editor.getModel(), r.colorInfo, r.provider)];
        }
        return [];
      });
    }
    _createColorHover(e, t, i) {
      return BM(this, void 0, void 0, function* () {
        const n = e.getValueInRange(t.range), { red: o, green: r, blue: a, alpha: l } = t.color, c = new tt(Math.round(o * 255), Math.round(r * 255), Math.round(a * 255), l), d = new H(c), h = yield FM(e, t, i, Je.None), u = new pX(d, [], 0);
        return u.colorPresentations = h || [], u.guessColorPresentation(d, n), new kX(this, D.lift(t.range), u, i);
      });
    }
    renderHoverParts(e, t) {
      if (t.length === 0 || !this._editor.hasModel())
        return z.None;
      const i = new te(), n = t[0], o = this._editor.getModel(), r = n.model, a = i.add(new SX(e.fragment, r, this._editor.getOption(129), this._themeService));
      e.setColorPicker(a);
      let l = new D(n.range.startLineNumber, n.range.startColumn, n.range.endLineNumber, n.range.endColumn);
      const c = () => {
        let h, u;
        if (r.presentation.textEdit) {
          h = [r.presentation.textEdit], u = new D(r.presentation.textEdit.range.startLineNumber, r.presentation.textEdit.range.startColumn, r.presentation.textEdit.range.endLineNumber, r.presentation.textEdit.range.endColumn);
          const f = this._editor.getModel()._setTrackedRange(null, u, 3);
          this._editor.pushUndoStop(), this._editor.executeEdits("colorpicker", h), u = this._editor.getModel()._getTrackedRange(f) || u;
        } else
          h = [{ range: l, text: r.presentation.label, forceMoveMarkers: !1 }], u = l.setEndPosition(l.endLineNumber, l.startColumn + r.presentation.label.length), this._editor.pushUndoStop(), this._editor.executeEdits("colorpicker", h);
        r.presentation.additionalTextEdits && (h = [...r.presentation.additionalTextEdits], this._editor.executeEdits("colorpicker", h), e.hide()), this._editor.pushUndoStop(), l = u;
      }, d = (h) => FM(o, {
        range: l,
        color: {
          red: h.rgba.r / 255,
          green: h.rgba.g / 255,
          blue: h.rgba.b / 255,
          alpha: h.rgba.a
        }
      }, n.provider, Je.None).then((u) => {
        r.colorPresentations = u || [];
      });
      return i.add(r.onColorFlushed((h) => {
        d(h).then(c);
      })), i.add(r.onDidChangeColor(d)), i;
    }
  };
  ZL = yX([
    LX(1, jt)
  ], ZL);
  function YL(s, e) {
    return !!s[e];
  }
  class ES {
    constructor(e, t) {
      this.target = e.target, this.hasTriggerModifier = YL(e.event, t.triggerModifier), this.hasSideBySideModifier = YL(e.event, t.triggerSideBySideModifier), this.isNoneOrSingleMouseDown = e.event.detail <= 1;
    }
  }
  class WM {
    constructor(e, t) {
      this.keyCodeIsTriggerKey = e.keyCode === t.triggerKey, this.keyCodeIsSideBySideKey = e.keyCode === t.triggerSideBySideKey, this.hasTriggerModifier = YL(e, t.triggerModifier);
    }
  }
  class mb {
    constructor(e, t, i, n) {
      this.triggerKey = e, this.triggerModifier = t, this.triggerSideBySideKey = i, this.triggerSideBySideModifier = n;
    }
    equals(e) {
      return this.triggerKey === e.triggerKey && this.triggerModifier === e.triggerModifier && this.triggerSideBySideKey === e.triggerSideBySideKey && this.triggerSideBySideModifier === e.triggerSideBySideModifier;
    }
  }
  function VM(s) {
    return s === "altKey" ? Ye ? new mb(57, "metaKey", 6, "altKey") : new mb(5, "ctrlKey", 6, "altKey") : Ye ? new mb(6, "altKey", 57, "metaKey") : new mb(6, "altKey", 5, "ctrlKey");
  }
  class iN extends z {
    constructor(e) {
      super(), this._onMouseMoveOrRelevantKeyDown = this._register(new B()), this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event, this._onExecute = this._register(new B()), this.onExecute = this._onExecute.event, this._onCancel = this._register(new B()), this.onCancel = this._onCancel.event, this._editor = e, this._opts = VM(this._editor.getOption(70)), this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._register(this._editor.onDidChangeConfiguration((t) => {
        if (t.hasChanged(70)) {
          const i = VM(this._editor.getOption(70));
          if (this._opts.equals(i))
            return;
          this._opts = i, this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._onCancel.fire();
        }
      })), this._register(this._editor.onMouseMove((t) => this._onEditorMouseMove(new ES(t, this._opts)))), this._register(this._editor.onMouseDown((t) => this._onEditorMouseDown(new ES(t, this._opts)))), this._register(this._editor.onMouseUp((t) => this._onEditorMouseUp(new ES(t, this._opts)))), this._register(this._editor.onKeyDown((t) => this._onEditorKeyDown(new WM(t, this._opts)))), this._register(this._editor.onKeyUp((t) => this._onEditorKeyUp(new WM(t, this._opts)))), this._register(this._editor.onMouseDrag(() => this._resetHandler())), this._register(this._editor.onDidChangeCursorSelection((t) => this._onDidChangeCursorSelection(t))), this._register(this._editor.onDidChangeModel((t) => this._resetHandler())), this._register(this._editor.onDidChangeModelContent(() => this._resetHandler())), this._register(this._editor.onDidScrollChange((t) => {
        (t.scrollTopChanged || t.scrollLeftChanged) && this._resetHandler();
      }));
    }
    _onDidChangeCursorSelection(e) {
      e.selection && e.selection.startColumn !== e.selection.endColumn && this._resetHandler();
    }
    _onEditorMouseMove(e) {
      this._lastMouseMoveEvent = e, this._onMouseMoveOrRelevantKeyDown.fire([e, null]);
    }
    _onEditorMouseDown(e) {
      this._hasTriggerKeyOnMouseDown = e.hasTriggerModifier, this._lineNumberOnMouseDown = e.target.position ? e.target.position.lineNumber : 0;
    }
    _onEditorMouseUp(e) {
      const t = e.target.position ? e.target.position.lineNumber : 0;
      this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === t && this._onExecute.fire(e);
    }
    _onEditorKeyDown(e) {
      this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier) ? this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]) : e.hasTriggerModifier && this._onCancel.fire();
    }
    _onEditorKeyUp(e) {
      e.keyCodeIsTriggerKey && this._onCancel.fire();
    }
    _resetHandler() {
      this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._onCancel.fire();
    }
  }
  var DX = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Oa = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let oh = class extends hp {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      super(e, Object.assign(Object.assign({}, i.getRawOptions()), { overflowWidgetsDomNode: i.getOverflowWidgetsDomNode() }), {}, n, o, r, a, l, c, d, h, u), this._parentEditor = i, this._overwriteOptions = t, super.updateOptions(this._overwriteOptions), this._register(i.onDidChangeConfiguration((f) => this._onParentConfigurationChanged(f)));
    }
    getParentEditor() {
      return this._parentEditor;
    }
    _onParentConfigurationChanged(e) {
      super.updateOptions(this._parentEditor.getRawOptions()), super.updateOptions(this._overwriteOptions);
    }
    updateOptions(e) {
      Sa(this._overwriteOptions, e, !0), super.updateOptions(this._overwriteOptions);
    }
  };
  oh = DX([
    Oa(3, et),
    Oa(4, St),
    Oa(5, wi),
    Oa(6, Fe),
    Oa(7, jt),
    Oa(8, yi),
    Oa(9, Ts),
    Oa(10, Mn),
    Oa(11, me)
  ], oh);
  class nN {
    constructor(e) {
      this._prefix = e, this._lastId = 0;
    }
    nextId() {
      return this._prefix + ++this._lastId;
    }
  }
  const b3 = new nN("id#"), HM = new H(new tt(0, 122, 204)), xX = {
    showArrow: !0,
    showFrame: !0,
    className: "",
    frameColor: HM,
    arrowColor: HM,
    keepEditorSelection: !1
  }, IX = "vs.editor.contrib.zoneWidget";
  class EX {
    constructor(e, t, i, n, o, r) {
      this.id = "", this.domNode = e, this.afterLineNumber = t, this.afterColumn = i, this.heightInLines = n, this._onDomNodeTop = o, this._onComputedHeight = r;
    }
    onDomNodeTop(e) {
      this._onDomNodeTop(e);
    }
    onComputedHeight(e) {
      this._onComputedHeight(e);
    }
  }
  class NX {
    constructor(e, t) {
      this._id = e, this._domNode = t;
    }
    getId() {
      return this._id;
    }
    getDomNode() {
      return this._domNode;
    }
    getPosition() {
      return null;
    }
  }
  class kC {
    constructor(e) {
      this._editor = e, this._ruleName = kC._IdGenerator.nextId(), this._decorations = [], this._color = null, this._height = -1;
    }
    dispose() {
      this.hide(), O2(this._ruleName);
    }
    set color(e) {
      this._color !== e && (this._color = e, this._updateStyle());
    }
    set height(e) {
      this._height !== e && (this._height = e, this._updateStyle());
    }
    _updateStyle() {
      O2(this._ruleName), Xy(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);
    }
    show(e) {
      e.column === 1 && (e = { lineNumber: e.lineNumber, column: 2 }), this._decorations = this._editor.deltaDecorations(this._decorations, [{ range: D.fromPositions(e), options: { description: "zone-widget-arrow", className: this._ruleName, stickiness: 1 } }]);
    }
    hide() {
      this._editor.deltaDecorations(this._decorations, []);
    }
  }
  kC._IdGenerator = new nN(".arrow-decoration-");
  class TX {
    constructor(e, t = {}) {
      this._arrow = null, this._overlayWidget = null, this._resizeSash = null, this._positionMarkerId = [], this._viewZone = null, this._disposables = new te(), this.container = null, this._isShowing = !1, this.editor = e, this.options = ja(t), Sa(this.options, xX, !1), this.domNode = document.createElement("div"), this.options.isAccessible || (this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setAttribute("role", "presentation")), this._disposables.add(this.editor.onDidLayoutChange((i) => {
        const n = this._getWidth(i);
        this.domNode.style.width = n + "px", this.domNode.style.left = this._getLeft(i) + "px", this._onWidth(n);
      }));
    }
    dispose() {
      this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this._viewZone && this.editor.changeViewZones((e) => {
        this._viewZone && e.removeZone(this._viewZone.id), this._viewZone = null;
      }), this.editor.deltaDecorations(this._positionMarkerId, []), this._positionMarkerId = [], this._disposables.dispose();
    }
    create() {
      this.domNode.classList.add("zone-widget"), this.options.className && this.domNode.classList.add(this.options.className), this.container = document.createElement("div"), this.container.classList.add("zone-widget-container"), this.domNode.appendChild(this.container), this.options.showArrow && (this._arrow = new kC(this.editor), this._disposables.add(this._arrow)), this._fillContainer(this.container), this._initSash(), this._applyStyles();
    }
    style(e) {
      e.frameColor && (this.options.frameColor = e.frameColor), e.arrowColor && (this.options.arrowColor = e.arrowColor), this._applyStyles();
    }
    _applyStyles() {
      if (this.container && this.options.frameColor) {
        let e = this.options.frameColor.toString();
        this.container.style.borderTopColor = e, this.container.style.borderBottomColor = e;
      }
      if (this._arrow && this.options.arrowColor) {
        let e = this.options.arrowColor.toString();
        this._arrow.color = e;
      }
    }
    _getWidth(e) {
      return e.width - e.minimap.minimapWidth - e.verticalScrollbarWidth;
    }
    _getLeft(e) {
      return e.minimap.minimapWidth > 0 && e.minimap.minimapLeft === 0 ? e.minimap.minimapWidth : 0;
    }
    _onViewZoneTop(e) {
      this.domNode.style.top = e + "px";
    }
    _onViewZoneHeight(e) {
      if (this.domNode.style.height = `${e}px`, this.container) {
        let t = e - this._decoratingElementsHeight();
        this.container.style.height = `${t}px`;
        const i = this.editor.getLayoutInfo();
        this._doLayout(t, this._getWidth(i));
      }
      this._resizeSash && this._resizeSash.layout();
    }
    get position() {
      const [e] = this._positionMarkerId;
      if (!e)
        return;
      const t = this.editor.getModel();
      if (!t)
        return;
      const i = t.getDecorationRange(e);
      if (!!i)
        return i.getStartPosition();
    }
    show(e, t) {
      const i = D.isIRange(e) ? D.lift(e) : D.fromPositions(e);
      this._isShowing = !0, this._showImpl(i, t), this._isShowing = !1, this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{ range: i, options: $e.EMPTY }]);
    }
    hide() {
      this._viewZone && (this.editor.changeViewZones((e) => {
        this._viewZone && e.removeZone(this._viewZone.id);
      }), this._viewZone = null), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this._arrow && this._arrow.hide();
    }
    _decoratingElementsHeight() {
      let e = this.editor.getOption(59), t = 0;
      if (this.options.showArrow) {
        let i = Math.round(e / 3);
        t += 2 * i;
      }
      if (this.options.showFrame) {
        let i = Math.round(e / 9);
        t += 2 * i;
      }
      return t;
    }
    _showImpl(e, t) {
      const i = e.getStartPosition(), n = this.editor.getLayoutInfo(), o = this._getWidth(n);
      this.domNode.style.width = `${o}px`, this.domNode.style.left = this._getLeft(n) + "px";
      const r = document.createElement("div");
      r.style.overflow = "hidden";
      const a = this.editor.getOption(59), l = Math.max(12, this.editor.getLayoutInfo().height / a * 0.8);
      t = Math.min(t, l);
      let c = 0, d = 0;
      if (this._arrow && this.options.showArrow && (c = Math.round(a / 3), this._arrow.height = c, this._arrow.show(i)), this.options.showFrame && (d = Math.round(a / 9)), this.editor.changeViewZones((f) => {
        this._viewZone && f.removeZone(this._viewZone.id), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this.domNode.style.top = "-1000px", this._viewZone = new EX(r, i.lineNumber, i.column, t, (g) => this._onViewZoneTop(g), (g) => this._onViewZoneHeight(g)), this._viewZone.id = f.addZone(this._viewZone), this._overlayWidget = new NX(IX + this._viewZone.id, this.domNode), this.editor.addOverlayWidget(this._overlayWidget);
      }), this.container && this.options.showFrame) {
        const f = this.options.frameWidth ? this.options.frameWidth : d;
        this.container.style.borderTopWidth = f + "px", this.container.style.borderBottomWidth = f + "px";
      }
      let h = t * a - this._decoratingElementsHeight();
      this.container && (this.container.style.top = c + "px", this.container.style.height = h + "px", this.container.style.overflow = "hidden"), this._doLayout(h, o), this.options.keepEditorSelection || this.editor.setSelection(e);
      const u = this.editor.getModel();
      if (u) {
        const f = e.endLineNumber + 1;
        f <= u.getLineCount() ? this.revealLine(f, !1) : this.revealLine(u.getLineCount(), !0);
      }
    }
    revealLine(e, t) {
      t ? this.editor.revealLineInCenter(e, 0) : this.editor.revealLine(e, 0);
    }
    setCssClass(e, t) {
      !this.container || (t && this.container.classList.remove(t), this.container.classList.add(e));
    }
    _onWidth(e) {
    }
    _doLayout(e, t) {
    }
    _relayout(e) {
      this._viewZone && this._viewZone.heightInLines !== e && this.editor.changeViewZones((t) => {
        this._viewZone && (this._viewZone.heightInLines = e, t.layoutZone(this._viewZone.id));
      });
    }
    _initSash() {
      if (this._resizeSash)
        return;
      this._resizeSash = this._disposables.add(new Dn(this.domNode, this, { orientation: 1 })), this.options.isResizeable || (this._resizeSash.state = 0);
      let e;
      this._disposables.add(this._resizeSash.onDidStart((t) => {
        this._viewZone && (e = {
          startY: t.startY,
          heightInLines: this._viewZone.heightInLines
        });
      })), this._disposables.add(this._resizeSash.onDidEnd(() => {
        e = void 0;
      })), this._disposables.add(this._resizeSash.onDidChange((t) => {
        if (e) {
          let i = (t.currentY - e.startY) / this.editor.getOption(59), n = i < 0 ? Math.ceil(i) : Math.floor(i), o = e.heightInLines + n;
          o > 5 && o < 35 && this._relayout(o);
        }
      }));
    }
    getHorizontalSashLeft() {
      return 0;
    }
    getHorizontalSashTop() {
      return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
    }
    getHorizontalSashWidth() {
      const e = this.editor.getLayoutInfo();
      return e.width - e.minimap.minimapWidth;
    }
  }
  class MX extends gf {
    constructor(e, t) {
      super(), this._onDidChangeVisibility = this._register(new B()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._element = q(e, J(".monaco-dropdown")), this._label = q(this._element, J(".dropdown-label"));
      let i = t.labelRenderer;
      i || (i = (o) => (o.textContent = t.label || "", null));
      for (const o of [ye.CLICK, ye.MOUSE_DOWN, Bt.Tap])
        this._register(ee(this.element, o, (r) => wt.stop(r, !0)));
      for (const o of [ye.MOUSE_DOWN, Bt.Tap])
        this._register(ee(this._label, o, (r) => {
          r instanceof MouseEvent && r.detail > 1 || (this.visible ? this.hide() : this.show());
        }));
      this._register(ee(this._label, ye.KEY_UP, (o) => {
        const r = new $t(o);
        (r.equals(3) || r.equals(10)) && (wt.stop(o, !0), this.visible ? this.hide() : this.show());
      }));
      const n = i(this._label);
      n && this._register(n), this._register(kt.addTarget(this._label));
    }
    get element() {
      return this._element;
    }
    show() {
      this.visible || (this.visible = !0, this._onDidChangeVisibility.fire(!0));
    }
    hide() {
      this.visible && (this.visible = !1, this._onDidChangeVisibility.fire(!1));
    }
    dispose() {
      super.dispose(), this.hide(), this.boxContainer && (this.boxContainer.remove(), this.boxContainer = void 0), this.contents && (this.contents.remove(), this.contents = void 0), this._label && (this._label.remove(), this._label = void 0);
    }
  }
  class AX extends MX {
    constructor(e, t) {
      super(e, t), this._actions = [], this._contextMenuProvider = t.contextMenuProvider, this.actions = t.actions || [], this.actionProvider = t.actionProvider, this.menuClassName = t.menuClassName || "", this.menuAsChild = !!t.menuAsChild;
    }
    set menuOptions(e) {
      this._menuOptions = e;
    }
    get menuOptions() {
      return this._menuOptions;
    }
    get actions() {
      return this.actionProvider ? this.actionProvider.getActions() : this._actions;
    }
    set actions(e) {
      this._actions = e;
    }
    show() {
      super.show(), this.element.classList.add("active"), this._contextMenuProvider.showContextMenu({
        getAnchor: () => this.element,
        getActions: () => this.actions,
        getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
        getActionViewItem: (e) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(e) : void 0,
        getKeyBinding: (e) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(e) : void 0,
        getMenuClassName: () => this.menuClassName,
        onHide: () => this.onHide(),
        actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
        anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
        domForShadowRoot: this.menuAsChild ? this.element : void 0
      });
    }
    hide() {
      super.hide();
    }
    onHide() {
      this.hide(), this.element.classList.remove("active");
    }
  }
  class v3 extends zr {
    constructor(e, t, i, n = /* @__PURE__ */ Object.create(null)) {
      super(null, e, n), this.actionItem = null, this._onDidChangeVisibility = this._register(new B()), this.menuActionsOrProvider = t, this.contextMenuProvider = i, this.options = n, this.options.actionRunner && (this.actionRunner = this.options.actionRunner);
    }
    render(e) {
      this.actionItem = e;
      const t = (o) => {
        this.element = q(o, J("a.action-label"));
        let r = [];
        return typeof this.options.classNames == "string" ? r = this.options.classNames.split(/\s+/g).filter((a) => !!a) : this.options.classNames && (r = this.options.classNames), r.find((a) => a === "icon") || r.push("codicon"), this.element.classList.add(...r), this.element.setAttribute("role", "button"), this.element.setAttribute("aria-haspopup", "true"), this.element.setAttribute("aria-expanded", "false"), this.element.title = this._action.label || "", null;
      }, i = Array.isArray(this.menuActionsOrProvider), n = {
        contextMenuProvider: this.contextMenuProvider,
        labelRenderer: t,
        menuAsChild: this.options.menuAsChild,
        actions: i ? this.menuActionsOrProvider : void 0,
        actionProvider: i ? void 0 : this.menuActionsOrProvider
      };
      if (this.dropdownMenu = this._register(new AX(e, n)), this._register(this.dropdownMenu.onDidChangeVisibility((o) => {
        var r;
        (r = this.element) === null || r === void 0 || r.setAttribute("aria-expanded", `${o}`), this._onDidChangeVisibility.fire(o);
      })), this.dropdownMenu.menuOptions = {
        actionViewItemProvider: this.options.actionViewItemProvider,
        actionRunner: this.actionRunner,
        getKeyBinding: this.options.keybindingProvider,
        context: this._context
      }, this.options.anchorAlignmentProvider) {
        const o = this;
        this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), { get anchorAlignment() {
          return o.options.anchorAlignmentProvider();
        } });
      }
      this.updateEnabled();
    }
    setActionContext(e) {
      super.setActionContext(e), this.dropdownMenu && (this.dropdownMenu.menuOptions ? this.dropdownMenu.menuOptions.context = e : this.dropdownMenu.menuOptions = { context: e });
    }
    updateEnabled() {
      var e, t;
      const i = !this.getAction().enabled;
      (e = this.actionItem) === null || e === void 0 || e.classList.toggle("disabled", i), (t = this.element) === null || t === void 0 || t.classList.toggle("disabled", i);
    }
  }
  class DC {
    constructor(e, t, i = t) {
      this.modifierLabels = [null], this.modifierLabels[2] = e, this.modifierLabels[1] = t, this.modifierLabels[3] = i;
    }
    toLabel(e, t, i) {
      if (t.length === 0)
        return null;
      const n = [];
      for (let o = 0, r = t.length; o < r; o++) {
        const a = t[o], l = i(a);
        if (l === null)
          return null;
        n[o] = PX(a, l, this.modifierLabels[e]);
      }
      return n.join(" ");
    }
  }
  const sN = new DC({
    ctrlKey: "\u2303",
    shiftKey: "\u21E7",
    altKey: "\u2325",
    metaKey: "\u2318",
    separator: ""
  }, {
    ctrlKey: m({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
    shiftKey: m({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
    altKey: m({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
    metaKey: m({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
    separator: "+"
  }, {
    ctrlKey: m({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
    shiftKey: m({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
    altKey: m({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
    metaKey: m({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
    separator: "+"
  }), RX = new DC({
    ctrlKey: m({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
    shiftKey: m({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
    altKey: m({ key: "optKey.long", comment: ["This is the long form for the Alt/Option key on the keyboard"] }, "Option"),
    metaKey: m({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
    separator: "+"
  }, {
    ctrlKey: m({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
    shiftKey: m({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
    altKey: m({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
    metaKey: m({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
    separator: "+"
  }, {
    ctrlKey: m({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
    shiftKey: m({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
    altKey: m({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
    metaKey: m({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
    separator: "+"
  }), OX = new DC({
    ctrlKey: "Ctrl",
    shiftKey: "Shift",
    altKey: "Alt",
    metaKey: "Cmd",
    separator: "+"
  }, {
    ctrlKey: "Ctrl",
    shiftKey: "Shift",
    altKey: "Alt",
    metaKey: "Super",
    separator: "+"
  });
  new DC({
    ctrlKey: "ctrl",
    shiftKey: "shift",
    altKey: "alt",
    metaKey: "cmd",
    separator: "+"
  }, {
    ctrlKey: "ctrl",
    shiftKey: "shift",
    altKey: "alt",
    metaKey: "win",
    separator: "+"
  }, {
    ctrlKey: "ctrl",
    shiftKey: "shift",
    altKey: "alt",
    metaKey: "meta",
    separator: "+"
  });
  function PX(s, e, t) {
    if (e === null)
      return "";
    const i = [];
    return s.ctrlKey && i.push(t.ctrlKey), s.shiftKey && i.push(t.shiftKey), s.altKey && i.push(t.altKey), s.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
  }
  var oN = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Ur = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, C3 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function FX(s, e, t, i, n, o, r) {
    const a = s.getActions(e);
    return WX(a, t, !1, typeof i == "string" ? (c) => c === i : i, n, o, r), BX(a);
  }
  function BX(s) {
    const e = new te();
    for (const [, t] of s)
      for (const i of t)
        e.add(i);
    return e;
  }
  function WX(s, e, t, i = (a) => a === "navigation", n = Number.MAX_SAFE_INTEGER, o = () => !1, r = !1) {
    let a, l;
    Array.isArray(e) ? (a = e, l = e) : (a = e.primary, l = e.secondary);
    const c = /* @__PURE__ */ new Set();
    for (const [d, h] of s) {
      let u;
      i(d) ? (u = a, u.length > 0 && r && u.push(new mo())) : (u = l, u.length > 0 && u.push(new mo()));
      for (let f of h) {
        t && (f = f instanceof vc && f.alt ? f.alt : f);
        const g = u.push(f);
        f instanceof Tv && c.add({ group: d, action: f, index: g - 1 });
      }
    }
    for (const { group: d, action: h, index: u } of c) {
      const f = i(d) ? a : l, g = h.actions;
      (g.length <= 1 || f.length + g.length - 2 <= n) && o(h, d, f.length) && f.splice(u, 1, ...g);
    }
    if (a !== l && a.length > n) {
      const d = a.splice(n, a.length - n);
      l.unshift(...d, new mo());
    }
  }
  let Nf = class extends up {
    constructor(e, t, i, n, o) {
      super(void 0, e, { icon: !!(e.class || e.item.icon), label: !e.class && !e.item.icon, draggable: t?.draggable }), this._keybindingService = i, this._notificationService = n, this._contextKeyService = o, this._wantsAltCommand = !1, this._itemClassDispose = this._register(new Gn()), this._altKey = vd.getInstance();
    }
    get _menuItemAction() {
      return this._action;
    }
    get _commandAction() {
      return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
    }
    onClick(e) {
      return C3(this, void 0, void 0, function* () {
        e.preventDefault(), e.stopPropagation();
        try {
          yield this.actionRunner.run(this._commandAction, this._context);
        } catch (t) {
          this._notificationService.error(t);
        }
      });
    }
    render(e) {
      super.render(e), e.classList.add("menu-entry"), this._updateItemClass(this._menuItemAction.item);
      let t = !1, i = this._altKey.keyStatus.altKey || (rn || Nn) && this._altKey.keyStatus.shiftKey;
      const n = () => {
        const o = t && i;
        o !== this._wantsAltCommand && (this._wantsAltCommand = o, this.updateLabel(), this.updateTooltip(), this.updateClass());
      };
      this._menuItemAction.alt && this._register(this._altKey.event((o) => {
        i = o.altKey || (rn || Nn) && o.shiftKey, n();
      })), this._register(ee(e, "mouseleave", (o) => {
        t = !1, n();
      })), this._register(ee(e, "mouseenter", (o) => {
        t = !0, n();
      }));
    }
    updateLabel() {
      this.options.label && this.label && (this.label.textContent = this._commandAction.label);
    }
    updateTooltip() {
      if (this.label) {
        const e = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService), t = e && e.getLabel(), i = this._commandAction.tooltip || this._commandAction.label;
        let n = t ? m("titleAndKb", "{0} ({1})", i, t) : i;
        if (!this._wantsAltCommand && this._menuItemAction.alt) {
          const o = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label, r = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService), a = r && r.getLabel(), l = a ? m("titleAndKb", "{0} ({1})", o, a) : o;
          n += `
[${sN.modifierLabels[oo].altKey}] ${l}`;
        }
        this.label.title = n;
      }
    }
    updateClass() {
      this.options.icon && (this._commandAction !== this._menuItemAction ? this._menuItemAction.alt && this._updateItemClass(this._menuItemAction.alt.item) : this._menuItemAction.alt && this._updateItemClass(this._menuItemAction.item));
    }
    _updateItemClass(e) {
      var t;
      this._itemClassDispose.value = void 0;
      const { element: i, label: n } = this;
      if (!i || !n)
        return;
      const o = this._commandAction.checked && ((t = e.toggled) === null || t === void 0 ? void 0 : t.icon) ? e.toggled.icon : e.icon;
      if (!!o)
        if (Tt.isThemeIcon(o)) {
          const r = Tt.asClassNameArray(o);
          n.classList.add(...r), this._itemClassDispose.value = qe(() => {
            n.classList.remove(...r);
          });
        } else
          o.light && n.style.setProperty("--menu-entry-icon-light", jd(o.light)), o.dark && n.style.setProperty("--menu-entry-icon-dark", jd(o.dark)), n.classList.add("icon"), this._itemClassDispose.value = qe(() => {
            n.classList.remove("icon"), n.style.removeProperty("--menu-entry-icon-light"), n.style.removeProperty("--menu-entry-icon-dark");
          });
    }
  };
  Nf = oN([
    Ur(2, ci),
    Ur(3, yi),
    Ur(4, Fe)
  ], Nf);
  let XL = class extends v3 {
    constructor(e, t, i) {
      var n, o;
      const r = Object.assign({}, t ?? /* @__PURE__ */ Object.create(null), {
        menuAsChild: (n = t?.menuAsChild) !== null && n !== void 0 ? n : !1,
        classNames: (o = t?.classNames) !== null && o !== void 0 ? o : Tt.isThemeIcon(e.item.icon) ? Tt.asClassName(e.item.icon) : void 0
      });
      super(e, { getActions: () => e.actions }, i, r);
    }
    render(e) {
      if (super.render(e), this.element) {
        e.classList.add("menu-entry");
        const { icon: t } = this._action.item;
        t && !Tt.isThemeIcon(t) && (this.element.classList.add("icon"), t.light && this.element.style.setProperty("--menu-entry-icon-light", jd(t.light)), t.dark && this.element.style.setProperty("--menu-entry-icon-dark", jd(t.dark)));
      }
    }
  };
  XL = oN([
    Ur(2, Fc)
  ], XL);
  let QL = class extends zr {
    constructor(e, t, i, n, o, r, a, l) {
      var c, d, h;
      super(null, e), this._keybindingService = i, this._notificationService = n, this._contextMenuService = o, this._menuService = r, this._instaService = a, this._storageService = l, this._container = null, this._storageKey = `${e.item.submenu._debugName}_lastActionId`;
      let u, f = l.get(this._storageKey, 1);
      f && (u = e.actions.find((_) => f === _.id)), u || (u = e.actions[0]), this._defaultAction = this._instaService.createInstance(Nf, u, void 0);
      const g = Object.assign({}, t ?? /* @__PURE__ */ Object.create(null), {
        menuAsChild: (c = t?.menuAsChild) !== null && c !== void 0 ? c : !0,
        classNames: (d = t?.classNames) !== null && d !== void 0 ? d : ["codicon", "codicon-chevron-down"],
        actionRunner: (h = t?.actionRunner) !== null && h !== void 0 ? h : new gf()
      });
      this._dropdown = new v3(e, e.actions, this._contextMenuService, g), this._dropdown.actionRunner.onDidRun((_) => {
        _.action instanceof vc && this.update(_.action);
      });
    }
    update(e) {
      this._storageService.store(this._storageKey, e.id, 1, 0), this._defaultAction.dispose(), this._defaultAction = this._instaService.createInstance(Nf, e, void 0), this._defaultAction.actionRunner = new class extends gf {
        runAction(t, i) {
          return C3(this, void 0, void 0, function* () {
            yield t.run(void 0);
          });
        }
      }(), this._container && this._defaultAction.render(RW(this._container, J(".action-container")));
    }
    setActionContext(e) {
      super.setActionContext(e), this._defaultAction.setActionContext(e), this._dropdown.setActionContext(e);
    }
    render(e) {
      this._container = e, super.render(this._container), this._container.classList.add("monaco-dropdown-with-default");
      const t = J(".action-container");
      this._defaultAction.render(q(this._container, t)), this._register(ee(t, ye.KEY_DOWN, (n) => {
        const o = new $t(n);
        o.equals(17) && (this._defaultAction.element.tabIndex = -1, this._dropdown.focus(), o.stopPropagation());
      }));
      const i = J(".dropdown-action-container");
      this._dropdown.render(q(this._container, i)), this._register(ee(i, ye.KEY_DOWN, (n) => {
        var o;
        const r = new $t(n);
        r.equals(15) && (this._defaultAction.element.tabIndex = 0, this._dropdown.setFocusable(!1), (o = this._defaultAction.element) === null || o === void 0 || o.focus(), r.stopPropagation());
      }));
    }
    focus(e) {
      e ? this._dropdown.focus() : (this._defaultAction.element.tabIndex = 0, this._defaultAction.element.focus());
    }
    blur() {
      this._defaultAction.element.tabIndex = -1, this._dropdown.blur(), this._container.blur();
    }
    setFocusable(e) {
      e ? this._defaultAction.element.tabIndex = 0 : (this._defaultAction.element.tabIndex = -1, this._dropdown.setFocusable(!1));
    }
    dispose() {
      this._defaultAction.dispose(), this._dropdown.dispose(), super.dispose();
    }
  };
  QL = oN([
    Ur(2, ci),
    Ur(3, yi),
    Ur(4, Fc),
    Ur(5, Eh),
    Ur(6, et),
    Ur(7, La)
  ], QL);
  function VX(s, e, t) {
    return e instanceof vc ? s.createInstance(Nf, e, void 0) : e instanceof VI ? e.item.rememberDefaultAction ? s.createInstance(QL, e, t) : s.createInstance(XL, e, t) : void 0;
  }
  var w3 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, S3 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const y3 = st("IPeekViewService");
  ht(y3, class {
    constructor() {
      this._widgets = /* @__PURE__ */ new Map();
    }
    addExclusiveWidget(s, e) {
      const t = this._widgets.get(s);
      t && (t.listener.dispose(), t.widget.dispose());
      const i = () => {
        const n = this._widgets.get(s);
        n && n.widget === e && (n.listener.dispose(), this._widgets.delete(s));
      };
      this._widgets.set(s, { widget: e, listener: e.onDidClose(i) });
    }
  });
  var us;
  (function(s) {
    s.inPeekEditor = new ue("inReferenceSearchEditor", !0, m("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek")), s.notInPeekEditor = s.inPeekEditor.toNegated();
  })(us || (us = {}));
  let bp = class {
    constructor(e, t) {
      e instanceof oh && us.inPeekEditor.bindTo(t);
    }
    dispose() {
    }
  };
  bp.ID = "editor.contrib.referenceController";
  bp = w3([
    S3(1, Fe)
  ], bp);
  vt(bp.ID, bp);
  function HX(s) {
    let e = s.get(St).getFocusedCodeEditor();
    return e instanceof oh ? e.getParentEditor() : e;
  }
  const zX = {
    headerBackgroundColor: H.white,
    primaryHeadingColor: H.fromHex("#333333"),
    secondaryHeadingColor: H.fromHex("#6c6c6cb3")
  };
  let M1 = class extends TX {
    constructor(e, t, i) {
      super(e, t), this.instantiationService = i, this._onDidClose = new B(), this.onDidClose = this._onDidClose.event, Sa(this.options, zX, !1);
    }
    dispose() {
      this.disposed || (this.disposed = !0, super.dispose(), this._onDidClose.fire(this));
    }
    style(e) {
      let t = this.options;
      e.headerBackgroundColor && (t.headerBackgroundColor = e.headerBackgroundColor), e.primaryHeadingColor && (t.primaryHeadingColor = e.primaryHeadingColor), e.secondaryHeadingColor && (t.secondaryHeadingColor = e.secondaryHeadingColor), super.style(e);
    }
    _applyStyles() {
      super._applyStyles();
      let e = this.options;
      this._headElement && e.headerBackgroundColor && (this._headElement.style.backgroundColor = e.headerBackgroundColor.toString()), this._primaryHeading && e.primaryHeadingColor && (this._primaryHeading.style.color = e.primaryHeadingColor.toString()), this._secondaryHeading && e.secondaryHeadingColor && (this._secondaryHeading.style.color = e.secondaryHeadingColor.toString()), this._bodyElement && e.frameColor && (this._bodyElement.style.borderColor = e.frameColor.toString());
    }
    _fillContainer(e) {
      this.setCssClass("peekview-widget"), this._headElement = J(".head"), this._bodyElement = J(".body"), this._fillHead(this._headElement), this._fillBody(this._bodyElement), e.appendChild(this._headElement), e.appendChild(this._bodyElement);
    }
    _fillHead(e, t) {
      const i = J(".peekview-title");
      this.options.supportOnTitleClick && (i.classList.add("clickable"), on(i, "click", (r) => this._onTitleClick(r))), q(this._headElement, i), this._fillTitleIcon(i), this._primaryHeading = J("span.filename"), this._secondaryHeading = J("span.dirname"), this._metaHeading = J("span.meta"), q(i, this._primaryHeading, this._secondaryHeading, this._metaHeading);
      const n = J(".peekview-actions");
      q(this._headElement, n);
      const o = this._getActionBarOptions();
      this._actionbarWidget = new ga(n, o), this._disposables.add(this._actionbarWidget), t || this._actionbarWidget.push(new ks("peekview.close", m("label.close", "Close"), p.close.classNames, !0, () => (this.dispose(), Promise.resolve())), { label: !1, icon: !0 });
    }
    _fillTitleIcon(e) {
    }
    _getActionBarOptions() {
      return {
        actionViewItemProvider: VX.bind(void 0, this.instantiationService),
        orientation: 0
      };
    }
    _onTitleClick(e) {
    }
    setTitle(e, t) {
      this._primaryHeading && this._secondaryHeading && (this._primaryHeading.innerText = e, this._primaryHeading.setAttribute("title", e), t ? this._secondaryHeading.innerText = t : Bi(this._secondaryHeading));
    }
    setMetaTitle(e) {
      this._metaHeading && (e ? (this._metaHeading.innerText = e, Vs(this._metaHeading)) : os(this._metaHeading));
    }
    _doLayout(e, t) {
      if (!this._isShowing && e < 0) {
        this.dispose();
        return;
      }
      const i = Math.ceil(this.editor.getOption(59) * 1.2), n = Math.round(e - (i + 2));
      this._doLayoutHead(i, t), this._doLayoutBody(n, t);
    }
    _doLayoutHead(e, t) {
      this._headElement && (this._headElement.style.height = `${e}px`, this._headElement.style.lineHeight = this._headElement.style.height);
    }
    _doLayoutBody(e, t) {
      this._bodyElement && (this._bodyElement.style.height = `${e}px`);
    }
  };
  M1 = w3([
    S3(2, et)
  ], M1);
  const UX = M("peekViewTitle.background", { dark: Re(Zs, 0.1), light: Re(Zs, 0.1), hc: null }, m("peekViewTitleBackground", "Background color of the peek view title area.")), L3 = M("peekViewTitleLabel.foreground", { dark: H.white, light: H.black, hc: H.white }, m("peekViewTitleForeground", "Color of the peek view title.")), k3 = M("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hc: "#FFFFFF99" }, m("peekViewTitleInfoForeground", "Color of the peek view title info.")), $X = M("peekView.border", { dark: Zs, light: Zs, hc: qt }, m("peekViewBorder", "Color of the peek view borders and arrow.")), jX = M("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hc: H.black }, m("peekViewResultsBackground", "Background color of the peek view result list."));
  M("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hc: H.white }, m("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
  M("peekViewResult.fileForeground", { dark: H.white, light: "#1E1E1E", hc: H.white }, m("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
  M("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hc: null }, m("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
  M("peekViewResult.selectionForeground", { dark: H.white, light: "#6C6C6C", hc: H.white }, m("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
  const NS = M("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hc: H.black }, m("peekViewEditorBackground", "Background color of the peek view editor."));
  M("peekViewEditorGutter.background", { dark: NS, light: NS, hc: NS }, m("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
  M("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hc: null }, m("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
  M("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hc: null }, m("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
  M("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hc: Bn }, m("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));
  function pl(s) {
    return s && typeof s.getEditorType == "function" ? s.getEditorType() === g_.ICodeEditor : !1;
  }
  function D3(s) {
    return s && typeof s.getEditorType == "function" ? s.getEditorType() === g_.IDiffEditor : !1;
  }
  function x3(s) {
    return pl(s) ? s : D3(s) ? s.getModifiedEditor() : null;
  }
  class KX {
    constructor(e) {
      this.spliceables = e;
    }
    splice(e, t, i) {
      this.spliceables.forEach((n) => n.splice(e, t, i));
    }
  }
  class Yc extends Error {
    constructor(e, t) {
      super(`ListError [${e}] ${t}`);
    }
  }
  var Ln;
  (function(s) {
    function e(o, r) {
      if (o.start >= r.end || r.start >= o.end)
        return { start: 0, end: 0 };
      const a = Math.max(o.start, r.start), l = Math.min(o.end, r.end);
      return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
    }
    s.intersect = e;
    function t(o) {
      return o.end - o.start <= 0;
    }
    s.isEmpty = t;
    function i(o, r) {
      return !t(e(o, r));
    }
    s.intersects = i;
    function n(o, r) {
      const a = [], l = { start: o.start, end: Math.min(r.start, o.end) }, c = { start: Math.max(r.end, o.start), end: o.end };
      return t(l) || a.push(l), t(c) || a.push(c), a;
    }
    s.relativeComplement = n;
  })(Ln || (Ln = {}));
  function zM(s, e) {
    const t = [];
    for (let i of e) {
      if (s.start >= i.range.end)
        continue;
      if (s.end < i.range.start)
        break;
      const n = Ln.intersect(s, i.range);
      Ln.isEmpty(n) || t.push({
        range: n,
        size: i.size
      });
    }
    return t;
  }
  function JL({ start: s, end: e }, t) {
    return { start: s + t, end: e + t };
  }
  function qX(s) {
    const e = [];
    let t = null;
    for (let i of s) {
      const n = i.range.start, o = i.range.end, r = i.size;
      if (t && r === t.size) {
        t.range.end = o;
        continue;
      }
      t = { range: { start: n, end: o }, size: r }, e.push(t);
    }
    return e;
  }
  function GX(...s) {
    return qX(s.reduce((e, t) => e.concat(t), []));
  }
  class UM {
    constructor() {
      this.groups = [], this._size = 0;
    }
    splice(e, t, i = []) {
      const n = i.length - t, o = zM({ start: 0, end: e }, this.groups), r = zM({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: JL(l.range, n), size: l.size })), a = i.map((l, c) => ({
        range: { start: e + c, end: e + c + 1 },
        size: l.size
      }));
      this.groups = GX(o, a, r), this._size = this.groups.reduce((l, c) => l + c.size * (c.range.end - c.range.start), 0);
    }
    get count() {
      const e = this.groups.length;
      return e ? this.groups[e - 1].range.end : 0;
    }
    get size() {
      return this._size;
    }
    indexAt(e) {
      if (e < 0)
        return -1;
      let t = 0, i = 0;
      for (let n of this.groups) {
        const o = n.range.end - n.range.start, r = i + o * n.size;
        if (e < r)
          return t + Math.floor((e - i) / n.size);
        t += o, i = r;
      }
      return t;
    }
    indexAfter(e) {
      return Math.min(this.indexAt(e) + 1, this.count);
    }
    positionAt(e) {
      if (e < 0)
        return -1;
      let t = 0, i = 0;
      for (let n of this.groups) {
        const o = n.range.end - n.range.start, r = i + o;
        if (e < r)
          return t + (e - i) * n.size;
        t += o * n.size, i = r;
      }
      return -1;
    }
  }
  function ZX(s) {
    try {
      s.parentElement && s.parentElement.removeChild(s);
    } catch {
    }
  }
  class YX {
    constructor(e) {
      this.renderers = e, this.cache = /* @__PURE__ */ new Map();
    }
    alloc(e) {
      let t = this.getTemplateCache(e).pop();
      if (!t) {
        const i = J(".monaco-list-row"), o = this.getRenderer(e).renderTemplate(i);
        t = { domNode: i, templateId: e, templateData: o };
      }
      return t;
    }
    release(e) {
      !e || this.releaseRow(e);
    }
    releaseRow(e) {
      const { domNode: t, templateId: i } = e;
      t && (t.classList.remove("scrolling"), ZX(t)), this.getTemplateCache(i).push(e);
    }
    getTemplateCache(e) {
      let t = this.cache.get(e);
      return t || (t = [], this.cache.set(e, t)), t;
    }
    dispose() {
      this.cache.forEach((e, t) => {
        for (const i of e)
          this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
      }), this.cache.clear();
    }
    getRenderer(e) {
      const t = this.renderers.get(e);
      if (!t)
        throw new Error(`No renderer found for ${e}`);
      return t;
    }
  }
  var Vh = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  };
  const Ir = {
    useShadows: !0,
    verticalScrollMode: 1,
    setRowLineHeight: !0,
    setRowHeight: !0,
    supportDynamicHeights: !1,
    dnd: {
      getDragElements(s) {
        return [s];
      },
      getDragURI() {
        return null;
      },
      onDragStart() {
      },
      onDragOver() {
        return !1;
      },
      drop() {
      }
    },
    horizontalScrolling: !1,
    transformOptimization: !0,
    alwaysConsumeMouseWheel: !0
  };
  class b_ {
    constructor(e) {
      this.elements = e;
    }
    update() {
    }
    getData() {
      return this.elements;
    }
  }
  class XX {
    constructor(e) {
      this.elements = e;
    }
    update() {
    }
    getData() {
      return this.elements;
    }
  }
  class QX {
    constructor() {
      this.types = [], this.files = [];
    }
    update(e) {
      if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
        this.files.splice(0, this.files.length);
        for (let t = 0; t < e.files.length; t++) {
          const i = e.files.item(t);
          i && (i.size || i.type) && this.files.push(i);
        }
      }
    }
    getData() {
      return {
        types: this.types,
        files: this.files
      };
    }
  }
  function JX(s, e) {
    return Array.isArray(s) && Array.isArray(e) ? Gs(s, e) : s === e;
  }
  class eQ {
    constructor(e) {
      e?.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, n) => n, e?.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e?.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e?.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
      };
    }
  }
  class Lr {
    constructor(e, t, i, n = Ir) {
      if (this.virtualDelegate = t, this.domId = `list_id_${++Lr.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new ca(50), this.splicing = !1, this.dragOverAnimationStopDisposable = z.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = z.None, this.onDragLeaveTimeout = z.None, this.disposables = new te(), this._onDidChangeContentHeight = new B(), this._horizontalScrolling = !1, n.horizontalScrolling && n.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      this.items = [], this.itemId = 0, this.rangeMap = new UM();
      for (const r of i)
        this.renderers.set(r.templateId, r);
      this.cache = this.disposables.add(new YX(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof n.mouseSupport == "boolean" ? n.mouseSupport : !0), this._horizontalScrolling = xr(n, (r) => r.horizontalScrolling, Ir.horizontalScrolling), this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.additionalScrollHeight = typeof n.additionalScrollHeight > "u" ? 0 : n.additionalScrollHeight, this.accessibilityProvider = new eQ(n.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", xr(n, (r) => r.transformOptimization, Ir.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)"), this.disposables.add(kt.addTarget(this.rowsContainer)), this.scrollable = new h_({
        forceIntegerValues: !0,
        smoothScrollDuration: xr(n, (r) => r.smoothScrolling, !1) ? 125 : 0,
        scheduleAtNextAnimationFrame: (r) => _r(r)
      }), this.scrollableElement = this.disposables.add(new uE(this.rowsContainer, {
        alwaysConsumeMouseWheel: xr(n, (r) => r.alwaysConsumeMouseWheel, Ir.alwaysConsumeMouseWheel),
        horizontal: 1,
        vertical: xr(n, (r) => r.verticalScrollMode, Ir.verticalScrollMode),
        useShadows: xr(n, (r) => r.useShadows, Ir.useShadows),
        mouseWheelScrollSensitivity: n.mouseWheelScrollSensitivity,
        fastScrollSensitivity: n.fastScrollSensitivity
      }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), this.disposables.add(ee(this.rowsContainer, Bt.Change, (r) => this.onTouchChange(r))), this.disposables.add(ee(this.scrollableElement.getDomNode(), "scroll", (r) => r.target.scrollTop = 0)), this.disposables.add(ee(this.domNode, "dragover", (r) => this.onDragOver(this.toDragEvent(r)))), this.disposables.add(ee(this.domNode, "drop", (r) => this.onDrop(this.toDragEvent(r)))), this.disposables.add(ee(this.domNode, "dragleave", (r) => this.onDragLeave(this.toDragEvent(r)))), this.disposables.add(ee(this.domNode, "dragend", (r) => this.onDragEnd(r))), this.setRowLineHeight = xr(n, (r) => r.setRowLineHeight, Ir.setRowLineHeight), this.setRowHeight = xr(n, (r) => r.setRowHeight, Ir.setRowHeight), this.supportDynamicHeights = xr(n, (r) => r.supportDynamicHeights, Ir.supportDynamicHeights), this.dnd = xr(n, (r) => r.dnd, Ir.dnd), this.layout();
    }
    get contentHeight() {
      return this.rangeMap.size;
    }
    get horizontalScrolling() {
      return this._horizontalScrolling;
    }
    set horizontalScrolling(e) {
      if (e !== this._horizontalScrolling) {
        if (e && this.supportDynamicHeights)
          throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
        if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
          for (const t of this.items)
            this.measureItemWidth(t);
          this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: Ew(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
        } else
          this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
      }
    }
    updateOptions(e) {
      e.additionalScrollHeight !== void 0 && (this.additionalScrollHeight = e.additionalScrollHeight, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling), e.mouseWheelScrollSensitivity !== void 0 && this.scrollableElement.updateOptions({ mouseWheelScrollSensitivity: e.mouseWheelScrollSensitivity }), e.fastScrollSensitivity !== void 0 && this.scrollableElement.updateOptions({ fastScrollSensitivity: e.fastScrollSensitivity });
    }
    splice(e, t, i = []) {
      if (this.splicing)
        throw new Error("Can't run recursive splices.");
      this.splicing = !0;
      try {
        return this._splice(e, t, i);
      } finally {
        this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
      }
    }
    _splice(e, t, i = []) {
      const n = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), o = { start: e, end: e + t }, r = Ln.intersect(n, o), a = /* @__PURE__ */ new Map();
      for (let x = r.end - 1; x >= r.start; x--) {
        const y = this.items[x];
        if (y.dragStartDisposable.dispose(), y.row) {
          let k = a.get(y.templateId);
          k || (k = [], a.set(y.templateId, k));
          const I = this.renderers.get(y.templateId);
          I && I.disposeElement && I.disposeElement(y.element, x, y.row.templateData, y.size), k.push(y.row);
        }
        y.row = null;
      }
      const l = { start: e + t, end: this.items.length }, c = Ln.intersect(l, n), d = Ln.relativeComplement(l, n), h = i.map((x) => ({
        id: String(this.itemId++),
        element: x,
        templateId: this.virtualDelegate.getTemplateId(x),
        size: this.virtualDelegate.getHeight(x),
        width: void 0,
        hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(x),
        lastDynamicHeightWidth: void 0,
        row: null,
        uri: void 0,
        dropTarget: !1,
        dragStartDisposable: z.None,
        checkedDisposable: z.None
      }));
      let u;
      e === 0 && t >= this.items.length ? (this.rangeMap = new UM(), this.rangeMap.splice(0, 0, h), u = this.items, this.items = h) : (this.rangeMap.splice(e, t, h), u = this.items.splice(e, t, ...h));
      const f = i.length - t, g = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), _ = JL(c, f), b = Ln.intersect(g, _);
      for (let x = b.start; x < b.end; x++)
        this.updateItemInDOM(this.items[x], x);
      const C = Ln.relativeComplement(_, g);
      for (const x of C)
        for (let y = x.start; y < x.end; y++)
          this.removeItemFromDOM(y);
      const v = d.map((x) => JL(x, f)), S = [{ start: e, end: e + i.length }, ...v].map((x) => Ln.intersect(g, x)), L = this.getNextToLastElement(S);
      for (const x of S)
        for (let y = x.start; y < x.end; y++) {
          const k = this.items[y], I = a.get(k.templateId), F = I?.pop();
          this.insertItemInDOM(y, L, F);
        }
      for (const x of a.values())
        for (const y of x)
          this.cache.release(y);
      return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), u.map((x) => x.element);
    }
    eventuallyUpdateScrollDimensions() {
      this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = _r(() => {
        this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
      }));
    }
    eventuallyUpdateScrollWidth() {
      if (!this.horizontalScrolling) {
        this.scrollableElementWidthDelayer.cancel();
        return;
      }
      this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
    }
    updateScrollWidth() {
      if (!this.horizontalScrolling)
        return;
      let e = 0;
      for (const t of this.items)
        typeof t.width < "u" && (e = Math.max(e, t.width));
      this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 });
    }
    rerender() {
      if (!!this.supportDynamicHeights) {
        for (const e of this.items)
          e.lastDynamicHeightWidth = void 0;
        this._rerender(this.lastRenderTop, this.lastRenderHeight);
      }
    }
    get length() {
      return this.items.length;
    }
    get renderHeight() {
      return this.scrollableElement.getScrollDimensions().height;
    }
    element(e) {
      return this.items[e].element;
    }
    domElement(e) {
      const t = this.items[e].row;
      return t && t.domNode;
    }
    elementHeight(e) {
      return this.items[e].size;
    }
    elementTop(e) {
      return this.rangeMap.positionAt(e);
    }
    indexAt(e) {
      return this.rangeMap.indexAt(e);
    }
    indexAfter(e) {
      return this.rangeMap.indexAfter(e);
    }
    layout(e, t) {
      let i = {
        height: typeof e == "number" ? e : NW(this.domNode)
      };
      this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
        width: typeof t == "number" ? t : Ew(this.domNode)
      });
    }
    render(e, t, i, n, o, r = !1) {
      const a = this.getRenderRange(t, i), l = Ln.relativeComplement(a, e), c = Ln.relativeComplement(e, a), d = this.getNextToLastElement(l);
      if (r) {
        const h = Ln.intersect(e, a);
        for (let u = h.start; u < h.end; u++)
          this.updateItemInDOM(this.items[u], u);
      }
      for (const h of l)
        for (let u = h.start; u < h.end; u++)
          this.insertItemInDOM(u, d);
      for (const h of c)
        for (let u = h.start; u < h.end; u++)
          this.removeItemFromDOM(u);
      n !== void 0 && (this.rowsContainer.style.left = `-${n}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && o !== void 0 && (this.rowsContainer.style.width = `${Math.max(o, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
    }
    insertItemInDOM(e, t, i) {
      const n = this.items[e];
      n.row || (n.row = i ?? this.cache.alloc(n.templateId));
      const o = this.accessibilityProvider.getRole(n.element) || "listitem";
      n.row.domNode.setAttribute("role", o);
      const r = this.accessibilityProvider.isChecked(n.element);
      if (typeof r == "boolean")
        n.row.domNode.setAttribute("aria-checked", String(!!r));
      else if (r) {
        const c = (d) => n.row.domNode.setAttribute("aria-checked", String(!!d));
        c(r.value), n.checkedDisposable = r.onDidChange(c);
      }
      n.row.domNode.parentElement || (t ? this.rowsContainer.insertBefore(n.row.domNode, t) : this.rowsContainer.appendChild(n.row.domNode)), this.updateItemInDOM(n, e);
      const a = this.renderers.get(n.templateId);
      if (!a)
        throw new Error(`No renderer found for template id ${n.templateId}`);
      a && a.renderElement(n.element, e, n.row.templateData, n.size);
      const l = this.dnd.getDragURI(n.element);
      n.dragStartDisposable.dispose(), n.row.domNode.draggable = !!l, l && (n.dragStartDisposable = ee(n.row.domNode, "dragstart", (c) => this.onDragStart(n.element, l, c))), this.horizontalScrolling && (this.measureItemWidth(n), this.eventuallyUpdateScrollWidth());
    }
    measureItemWidth(e) {
      if (!e.row || !e.row.domNode)
        return;
      e.row.domNode.style.width = Xs ? "-moz-fit-content" : "fit-content", e.width = Ew(e.row.domNode);
      const t = window.getComputedStyle(e.row.domNode);
      t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
    }
    updateItemInDOM(e, t) {
      e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("data-parity", t % 2 === 0 ? "even" : "odd"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
    }
    removeItemFromDOM(e) {
      const t = this.items[e];
      if (t.dragStartDisposable.dispose(), t.checkedDisposable.dispose(), t.row) {
        const i = this.renderers.get(t.templateId);
        i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
      }
      this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
    }
    getScrollTop() {
      return this.scrollableElement.getScrollPosition().scrollTop;
    }
    setScrollTop(e, t) {
      this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
    }
    get scrollTop() {
      return this.getScrollTop();
    }
    set scrollTop(e) {
      this.setScrollTop(e);
    }
    get scrollHeight() {
      return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;
    }
    get onMouseClick() {
      return be.map(this.disposables.add(new xt(this.domNode, "click")).event, (e) => this.toMouseEvent(e));
    }
    get onMouseDblClick() {
      return be.map(this.disposables.add(new xt(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e));
    }
    get onMouseMiddleClick() {
      return be.filter(be.map(this.disposables.add(new xt(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e)), (e) => e.browserEvent.button === 1);
    }
    get onMouseDown() {
      return be.map(this.disposables.add(new xt(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e));
    }
    get onContextMenu() {
      return be.any(be.map(this.disposables.add(new xt(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e)), be.map(this.disposables.add(new xt(this.domNode, Bt.Contextmenu)).event, (e) => this.toGestureEvent(e)));
    }
    get onTouchStart() {
      return be.map(this.disposables.add(new xt(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e));
    }
    get onTap() {
      return be.map(this.disposables.add(new xt(this.rowsContainer, Bt.Tap)).event, (e) => this.toGestureEvent(e));
    }
    toMouseEvent(e) {
      const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
      return { browserEvent: e, index: t, element: n };
    }
    toTouchEvent(e) {
      const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
      return { browserEvent: e, index: t, element: n };
    }
    toGestureEvent(e) {
      const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
      return { browserEvent: e, index: t, element: n };
    }
    toDragEvent(e) {
      const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
      return { browserEvent: e, index: t, element: n };
    }
    onScroll(e) {
      try {
        const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
        this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
      } catch (t) {
        throw console.error("Got bad scroll event:", e), t;
      }
    }
    onTouchChange(e) {
      e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
    }
    onDragStart(e, t, i) {
      if (!i.dataTransfer)
        return;
      const n = this.dnd.getDragElements(e);
      if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(NF.TEXT, t), i.dataTransfer.setDragImage) {
        let o;
        this.dnd.getDragLabel && (o = this.dnd.getDragLabel(n, i)), typeof o > "u" && (o = String(n.length));
        const r = J(".monaco-drag-image");
        r.textContent = o, document.body.appendChild(r), i.dataTransfer.setDragImage(r, -10, -10), setTimeout(() => document.body.removeChild(r), 0);
      }
      this.currentDragData = new b_(n), za.CurrentDragAndDropData = new XX(n), this.dnd.onDragStart && this.dnd.onDragStart(this.currentDragData, i);
    }
    onDragOver(e) {
      if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), za.CurrentDragAndDropData && za.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
        return !1;
      if (!this.currentDragData)
        if (za.CurrentDragAndDropData)
          this.currentDragData = za.CurrentDragAndDropData;
        else {
          if (!e.browserEvent.dataTransfer.types)
            return !1;
          this.currentDragData = new QX();
        }
      const t = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.browserEvent);
      if (this.canDrop = typeof t == "boolean" ? t : t.accept, !this.canDrop)
        return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
      e.browserEvent.dataTransfer.dropEffect = typeof t != "boolean" && t.effect === 0 ? "copy" : "move";
      let i;
      if (typeof t != "boolean" && t.feedback ? i = t.feedback : typeof e.index > "u" ? i = [-1] : i = [e.index], i = Cc(i).filter((n) => n >= -1 && n < this.length).sort((n, o) => n - o), i = i[0] === -1 ? [-1] : i, JX(this.currentDragFeedback, i))
        return !0;
      if (this.currentDragFeedback = i, this.currentDragFeedbackDisposable.dispose(), i[0] === -1)
        this.domNode.classList.add("drop-target"), this.rowsContainer.classList.add("drop-target"), this.currentDragFeedbackDisposable = qe(() => {
          this.domNode.classList.remove("drop-target"), this.rowsContainer.classList.remove("drop-target");
        });
      else {
        for (const n of i) {
          const o = this.items[n];
          o.dropTarget = !0, o.row && o.row.domNode.classList.add("drop-target");
        }
        this.currentDragFeedbackDisposable = qe(() => {
          for (const n of i) {
            const o = this.items[n];
            o.dropTarget = !1, o.row && o.row.domNode.classList.remove("drop-target");
          }
        });
      }
      return !0;
    }
    onDragLeave(e) {
      var t, i;
      this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = $d(() => this.clearDragOverFeedback(), 100), this.currentDragData && ((i = (t = this.dnd).onDragLeave) === null || i === void 0 || i.call(t, this.currentDragData, e.element, e.index, e.browserEvent));
    }
    onDrop(e) {
      if (!this.canDrop)
        return;
      const t = this.currentDragData;
      this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, za.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.browserEvent));
    }
    onDragEnd(e) {
      this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, za.CurrentDragAndDropData = void 0, this.dnd.onDragEnd && this.dnd.onDragEnd(e);
    }
    clearDragOverFeedback() {
      this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = z.None;
    }
    setupDragAndDropScrollTopAnimation(e) {
      if (!this.dragOverAnimationDisposable) {
        const t = mP(this.domNode).top;
        this.dragOverAnimationDisposable = FW(this.animateDragAndDropScrollTop.bind(this, t));
      }
      this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = $d(() => {
        this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
      }, 1e3), this.dragOverMouseY = e.pageY;
    }
    animateDragAndDropScrollTop(e) {
      if (this.dragOverMouseY === void 0)
        return;
      const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
      t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
    }
    teardownDragAndDropScrollTopAnimation() {
      this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }
    getItemIndexFromEventTarget(e) {
      const t = this.scrollableElement.getDomNode();
      let i = e;
      for (; i instanceof HTMLElement && i !== this.rowsContainer && t.contains(i); ) {
        const n = i.getAttribute("data-index");
        if (n) {
          const o = Number(n);
          if (!isNaN(o))
            return o;
        }
        i = i.parentElement;
      }
    }
    getRenderRange(e, t) {
      return {
        start: this.rangeMap.indexAt(e),
        end: this.rangeMap.indexAfter(e + t - 1)
      };
    }
    _rerender(e, t, i) {
      const n = this.getRenderRange(e, t);
      let o, r;
      e === this.elementTop(n.start) ? (o = n.start, r = 0) : n.end - n.start > 1 && (o = n.start + 1, r = this.elementTop(o) - e);
      let a = 0;
      for (; ; ) {
        const l = this.getRenderRange(e, t);
        let c = !1;
        for (let d = l.start; d < l.end; d++) {
          const h = this.probeDynamicHeight(d);
          h !== 0 && this.rangeMap.splice(d, 1, [this.items[d]]), a += h, c = c || h !== 0;
        }
        if (!c) {
          a !== 0 && this.eventuallyUpdateScrollDimensions();
          const d = Ln.relativeComplement(n, l);
          for (const u of d)
            for (let f = u.start; f < u.end; f++)
              this.items[f].row && this.removeItemFromDOM(f);
          const h = Ln.relativeComplement(l, n);
          for (const u of h)
            for (let f = u.start; f < u.end; f++) {
              const g = f + 1, _ = g < this.items.length ? this.items[g].row : null, b = _ ? _.domNode : null;
              this.insertItemInDOM(f, b);
            }
          for (let u = l.start; u < l.end; u++)
            this.items[u].row && this.updateItemInDOM(this.items[u], u);
          if (typeof o == "number") {
            const u = this.scrollable.getFutureScrollPosition().scrollTop - e, f = this.elementTop(o) - r + u;
            this.setScrollTop(f, i);
          }
          this._onDidChangeContentHeight.fire(this.contentHeight);
          return;
        }
      }
    }
    probeDynamicHeight(e) {
      const t = this.items[e];
      if (this.virtualDelegate.getDynamicHeight) {
        const r = this.virtualDelegate.getDynamicHeight(t.element);
        if (r !== null) {
          const a = t.size;
          return t.size = r, t.lastDynamicHeightWidth = this.renderWidth, r - a;
        }
      }
      if (!t.hasDynamicHeight || t.lastDynamicHeightWidth === this.renderWidth || !!this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(t.element))
        return 0;
      const i = t.size;
      if (!this.setRowHeight && t.row) {
        let r = t.row.domNode.offsetHeight;
        return t.size = r, t.lastDynamicHeightWidth = this.renderWidth, r - i;
      }
      const n = this.cache.alloc(t.templateId);
      n.domNode.style.height = "", this.rowsContainer.appendChild(n.domNode);
      const o = this.renderers.get(t.templateId);
      return o && (o.renderElement(t.element, e, n.templateData, void 0), o.disposeElement && o.disposeElement(t.element, e, n.templateData, void 0)), t.size = n.domNode.offsetHeight, this.virtualDelegate.setDynamicHeight && this.virtualDelegate.setDynamicHeight(t.element, t.size), t.lastDynamicHeightWidth = this.renderWidth, this.rowsContainer.removeChild(n.domNode), this.cache.release(n), t.size - i;
    }
    getNextToLastElement(e) {
      const t = e[e.length - 1];
      if (!t)
        return null;
      const i = this.items[t.end];
      return !i || !i.row ? null : i.row.domNode;
    }
    getElementDomId(e) {
      return `${this.domId}_${e}`;
    }
    dispose() {
      if (this.items) {
        for (const e of this.items)
          if (e.row) {
            const t = this.renderers.get(e.row.templateId);
            t && (t.disposeElement && t.disposeElement(e.element, -1, e.row.templateData, void 0), t.disposeTemplate(e.row.templateData));
          }
        this.items = [];
      }
      this.domNode && this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), at(this.disposables);
    }
  }
  Lr.InstanceCount = 0;
  Vh([
    Ai
  ], Lr.prototype, "onMouseClick", null);
  Vh([
    Ai
  ], Lr.prototype, "onMouseDblClick", null);
  Vh([
    Ai
  ], Lr.prototype, "onMouseMiddleClick", null);
  Vh([
    Ai
  ], Lr.prototype, "onMouseDown", null);
  Vh([
    Ai
  ], Lr.prototype, "onContextMenu", null);
  Vh([
    Ai
  ], Lr.prototype, "onTouchStart", null);
  Vh([
    Ai
  ], Lr.prototype, "onTap", null);
  var Hh = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, $M = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class tQ {
    constructor(e) {
      this.trait = e, this.renderedElements = [];
    }
    get templateId() {
      return `template:${this.trait.name}`;
    }
    renderTemplate(e) {
      return e;
    }
    renderElement(e, t, i) {
      const n = this.renderedElements.findIndex((o) => o.templateData === i);
      if (n >= 0) {
        const o = this.renderedElements[n];
        this.trait.unrender(i), o.index = t;
      } else {
        const o = { index: t, templateData: i };
        this.renderedElements.push(o);
      }
      this.trait.renderIndex(t, i);
    }
    splice(e, t, i) {
      const n = [];
      for (const o of this.renderedElements)
        o.index < e ? n.push(o) : o.index >= e + t && n.push({
          index: o.index + i - t,
          templateData: o.templateData
        });
      this.renderedElements = n;
    }
    renderIndexes(e) {
      for (const { index: t, templateData: i } of this.renderedElements)
        e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
    }
    disposeTemplate(e) {
      const t = this.renderedElements.findIndex((i) => i.templateData === e);
      t < 0 || this.renderedElements.splice(t, 1);
    }
  }
  class A1 {
    constructor(e) {
      this._trait = e, this.length = 0, this.indexes = [], this.sortedIndexes = [], this._onChange = new B(), this.onChange = this._onChange.event;
    }
    get name() {
      return this._trait;
    }
    get renderer() {
      return new tQ(this);
    }
    splice(e, t, i) {
      var n;
      t = Math.max(0, Math.min(t, this.length - e));
      const o = i.length - t, r = e + t, a = [
        ...this.sortedIndexes.filter((c) => c < e),
        ...i.map((c, d) => c ? d + e : -1).filter((c) => c !== -1),
        ...this.sortedIndexes.filter((c) => c >= r).map((c) => c + o)
      ], l = this.length + o;
      if (this.sortedIndexes.length > 0 && a.length === 0 && l > 0) {
        const c = (n = this.sortedIndexes.find((d) => d >= e)) !== null && n !== void 0 ? n : l - 1;
        a.push(Math.min(c, l - 1));
      }
      this.renderer.splice(e, t, i.length), this._set(a, a), this.length = l;
    }
    renderIndex(e, t) {
      t.classList.toggle(this._trait, this.contains(e));
    }
    unrender(e) {
      e.classList.remove(this._trait);
    }
    set(e, t) {
      return this._set(e, [...e].sort(KM), t);
    }
    _set(e, t, i) {
      const n = this.indexes, o = this.sortedIndexes;
      this.indexes = e, this.sortedIndexes = t;
      const r = ek(o, e);
      return this.renderer.renderIndexes(r), this._onChange.fire({ indexes: e, browserEvent: i }), n;
    }
    get() {
      return this.indexes;
    }
    contains(e) {
      return UI(this.sortedIndexes, e, KM) >= 0;
    }
    dispose() {
      at(this._onChange);
    }
  }
  Hh([
    Ai
  ], A1.prototype, "renderer", null);
  class iQ extends A1 {
    constructor(e) {
      super("selected"), this.setAriaSelected = e;
    }
    renderIndex(e, t) {
      super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
    }
  }
  class TS {
    constructor(e, t, i) {
      this.trait = e, this.view = t, this.identityProvider = i;
    }
    splice(e, t, i) {
      if (!this.identityProvider)
        return this.trait.splice(e, t, i.map(() => !1));
      const n = this.trait.get().map((r) => this.identityProvider.getId(this.view.element(r)).toString()), o = i.map((r) => n.indexOf(this.identityProvider.getId(r).toString()) > -1);
      this.trait.splice(e, t, o);
    }
  }
  function xc(s) {
    return s.tagName === "INPUT" || s.tagName === "TEXTAREA";
  }
  function Mu(s) {
    return s.classList.contains("monaco-editor") ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : Mu(s.parentElement);
  }
  class I3 {
    constructor(e, t, i) {
      this.list = e, this.view = t, this.disposables = new te(), this.multipleSelectionDisposables = new te(), this.onKeyDown.filter((n) => n.keyCode === 3).on(this.onEnter, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 16).on(this.onUpArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 18).on(this.onDownArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 11).on(this.onPageUpArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 12).on(this.onPageDownArrow, this, this.disposables), this.onKeyDown.filter((n) => n.keyCode === 9).on(this.onEscape, this, this.disposables), i.multipleSelectionSupport !== !1 && this.onKeyDown.filter((n) => (Ye ? n.metaKey : n.ctrlKey) && n.keyCode === 31).on(this.onCtrlA, this, this.multipleSelectionDisposables);
    }
    get onKeyDown() {
      return be.chain(this.disposables.add(new xt(this.view.domNode, "keydown")).event).filter((e) => !xc(e.target)).map((e) => new $t(e));
    }
    updateOptions(e) {
      e.multipleSelectionSupport !== void 0 && (this.multipleSelectionDisposables.clear(), e.multipleSelectionSupport && this.onKeyDown.filter((t) => (Ye ? t.metaKey : t.ctrlKey) && t.keyCode === 31).on(this.onCtrlA, this, this.multipleSelectionDisposables));
    }
    onEnter(e) {
      e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
    }
    onUpArrow(e) {
      e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent);
      const t = this.list.getFocus()[0];
      this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
    }
    onDownArrow(e) {
      e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent);
      const t = this.list.getFocus()[0];
      this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
    }
    onPageUpArrow(e) {
      e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent);
      const t = this.list.getFocus()[0];
      this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
    }
    onPageDownArrow(e) {
      e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent);
      const t = this.list.getFocus()[0];
      this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
    }
    onCtrlA(e) {
      e.preventDefault(), e.stopPropagation(), this.list.setSelection(Vn(this.list.length), e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus();
    }
    onEscape(e) {
      this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
    }
    dispose() {
      this.disposables.dispose(), this.multipleSelectionDisposables.dispose();
    }
  }
  Hh([
    Ai
  ], I3.prototype, "onKeyDown", null);
  var Au;
  (function(s) {
    s[s.Idle = 0] = "Idle", s[s.Typing = 1] = "Typing";
  })(Au || (Au = {}));
  const E3 = new class {
    mightProducePrintableCharacter(s) {
      return s.ctrlKey || s.metaKey || s.altKey ? !1 : s.keyCode >= 31 && s.keyCode <= 56 || s.keyCode >= 21 && s.keyCode <= 30 || s.keyCode >= 93 && s.keyCode <= 102 || s.keyCode >= 80 && s.keyCode <= 90;
    }
  }();
  class nQ {
    constructor(e, t, i, n) {
      this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.delegate = n, this.enabled = !1, this.state = Au.Idle, this.automaticKeyboardNavigation = !0, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new te(), this.disposables = new te(), this.updateOptions(e.options);
    }
    updateOptions(e) {
      (typeof e.enableKeyboardNavigation > "u" ? !0 : !!e.enableKeyboardNavigation) ? this.enable() : this.disable(), typeof e.automaticKeyboardNavigation < "u" && (this.automaticKeyboardNavigation = e.automaticKeyboardNavigation);
    }
    enable() {
      if (this.enabled)
        return;
      const e = be.chain(this.enabledDisposables.add(new xt(this.view.domNode, "keydown")).event).filter((n) => !xc(n.target)).filter(() => this.automaticKeyboardNavigation || this.triggered).map((n) => new $t(n)).filter((n) => this.delegate.mightProducePrintableCharacter(n)).forEach((n) => n.preventDefault()).map((n) => n.browserEvent.key).event, t = be.debounce(e, () => null, 800);
      be.reduce(be.any(e, t), (n, o) => o === null ? null : (n || "") + o)(this.onInput, this, this.enabledDisposables), t(this.onClear, this, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
    }
    disable() {
      !this.enabled || (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
    }
    onClear() {
      var e;
      const t = this.list.getFocus();
      if (t.length > 0 && t[0] === this.previouslyFocused) {
        const i = (e = this.list.options.accessibilityProvider) === null || e === void 0 ? void 0 : e.getAriaLabel(this.list.element(t[0]));
        i && pn(i);
      }
      this.previouslyFocused = -1;
    }
    onInput(e) {
      if (!e) {
        this.state = Au.Idle, this.triggered = !1;
        return;
      }
      const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, n = this.state === Au.Idle ? 1 : 0;
      this.state = Au.Typing;
      for (let o = 0; o < this.list.length; o++) {
        const r = (i + o + n) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(r)), l = a && a.toString();
        if (typeof l > "u" || gC(e, l)) {
          this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
          return;
        }
      }
    }
    dispose() {
      this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
    }
  }
  class sQ {
    constructor(e, t) {
      this.list = e, this.view = t, this.disposables = new te(), be.chain(this.disposables.add(new xt(t.domNode, "keydown")).event).filter((n) => !xc(n.target)).map((n) => new $t(n)).filter((n) => n.keyCode === 2 && !n.ctrlKey && !n.metaKey && !n.shiftKey && !n.altKey).on(this.onTab, this, this.disposables);
    }
    onTab(e) {
      if (e.target !== this.view.domNode)
        return;
      const t = this.list.getFocus();
      if (t.length === 0)
        return;
      const i = this.view.domElement(t[0]);
      if (!i)
        return;
      const n = i.querySelector("[tabIndex]");
      if (!n || !(n instanceof HTMLElement) || n.tabIndex === -1)
        return;
      const o = window.getComputedStyle(n);
      o.visibility === "hidden" || o.display === "none" || (e.preventDefault(), e.stopPropagation(), n.focus());
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  function N3(s) {
    return Ye ? s.browserEvent.metaKey : s.browserEvent.ctrlKey;
  }
  function T3(s) {
    return s.browserEvent.shiftKey;
  }
  function oQ(s) {
    return s instanceof MouseEvent && s.button === 2;
  }
  const jM = {
    isSelectionSingleChangeEvent: N3,
    isSelectionRangeChangeEvent: T3
  };
  class M3 {
    constructor(e) {
      this.list = e, this.disposables = new te(), this._onPointer = new B(), this.onPointer = this._onPointer.event, e.options.multipleSelectionSupport !== !1 && (this.multipleSelectionController = this.list.options.multipleSelectionController || jM), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(kt.addTarget(e.getHTMLElement()))), be.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
    }
    updateOptions(e) {
      e.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, e.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || jM));
    }
    isSelectionSingleChangeEvent(e) {
      return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : !1;
    }
    isSelectionRangeChangeEvent(e) {
      return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : !1;
    }
    isSelectionChangeEvent(e) {
      return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
    }
    onMouseDown(e) {
      Mu(e.browserEvent.target) || document.activeElement !== e.browserEvent.target && this.list.domFocus();
    }
    onContextMenu(e) {
      if (Mu(e.browserEvent.target))
        return;
      const t = typeof e.index > "u" ? [] : [e.index];
      this.list.setFocus(t, e.browserEvent);
    }
    onViewPointer(e) {
      if (!this.mouseSupport || xc(e.browserEvent.target) || Mu(e.browserEvent.target))
        return;
      const t = e.index;
      if (typeof t > "u") {
        this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
        return;
      }
      if (this.isSelectionRangeChangeEvent(e))
        return this.changeSelection(e);
      if (this.isSelectionChangeEvent(e))
        return this.changeSelection(e);
      this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), oQ(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
    }
    onDoubleClick(e) {
      if (xc(e.browserEvent.target) || Mu(e.browserEvent.target) || this.isSelectionChangeEvent(e))
        return;
      const t = this.list.getFocus();
      this.list.setSelection(t, e.browserEvent);
    }
    changeSelection(e) {
      const t = e.index;
      let i = this.list.getAnchor();
      if (this.isSelectionRangeChangeEvent(e)) {
        if (typeof i > "u") {
          const d = this.list.getFocus()[0];
          i = d ?? t, this.list.setAnchor(i);
        }
        const n = Math.min(i, t), o = Math.max(i, t), r = Vn(n, o + 1), a = this.list.getSelection(), l = lQ(ek(a, [i]), i);
        if (l.length === 0)
          return;
        const c = ek(r, cQ(a, l));
        this.list.setSelection(c, e.browserEvent), this.list.setFocus([t], e.browserEvent);
      } else if (this.isSelectionSingleChangeEvent(e)) {
        const n = this.list.getSelection(), o = n.filter((r) => r !== t);
        this.list.setFocus([t]), this.list.setAnchor(t), n.length === o.length ? this.list.setSelection([...o, t], e.browserEvent) : this.list.setSelection(o, e.browserEvent);
      }
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  class A3 {
    constructor(e, t) {
      this.styleElement = e, this.selectorSuffix = t;
    }
    style(e) {
      const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
      e.listBackground && (e.listBackground.isOpaque() ? i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`) : Ye || console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`)), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listActiveSelectionIconForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected .codicon { color: ${e.listActiveSelectionIconForeground}; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveSelectionIconForeground && i.push(`.monaco-list${t} .monaco-list-row.focused .codicon { color:  ${e.listInactiveSelectionIconForeground}; }`), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropBackground} !important; color: inherit !important; }
			`), e.listFilterWidgetBackground && i.push(`.monaco-list-type-filter { background-color: ${e.listFilterWidgetBackground} }`), e.listFilterWidgetOutline && i.push(`.monaco-list-type-filter { border: 1px solid ${e.listFilterWidgetOutline}; }`), e.listFilterWidgetNoMatchesOutline && i.push(`.monaco-list-type-filter.no-matches { border: 1px solid ${e.listFilterWidgetNoMatchesOutline}; }`), e.listMatchesShadow && i.push(`.monaco-list-type-filter { box-shadow: 1px 1px 1px ${e.listMatchesShadow}; }`), e.tableColumnsBorder && i.push(`
				.monaco-table:hover > .monaco-split-view2,
				.monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
			}`), e.tableOddRowsBackgroundColor && i.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${e.tableOddRowsBackgroundColor};
				}
			`), this.styleElement.textContent = i.join(`
`);
    }
  }
  const rQ = {
    listFocusBackground: H.fromHex("#7FB0D0"),
    listActiveSelectionBackground: H.fromHex("#0E639C"),
    listActiveSelectionForeground: H.fromHex("#FFFFFF"),
    listActiveSelectionIconForeground: H.fromHex("#FFFFFF"),
    listFocusAndSelectionBackground: H.fromHex("#094771"),
    listFocusAndSelectionForeground: H.fromHex("#FFFFFF"),
    listInactiveSelectionBackground: H.fromHex("#3F3F46"),
    listInactiveSelectionIconForeground: H.fromHex("#FFFFFF"),
    listHoverBackground: H.fromHex("#2A2D2E"),
    listDropBackground: H.fromHex("#383B3D"),
    treeIndentGuidesStroke: H.fromHex("#a9a9a9"),
    tableColumnsBorder: H.fromHex("#cccccc").transparent(0.2),
    tableOddRowsBackgroundColor: H.fromHex("#cccccc").transparent(0.04)
  }, aQ = {
    keyboardSupport: !0,
    mouseSupport: !0,
    multipleSelectionSupport: !0,
    dnd: {
      getDragURI() {
        return null;
      },
      onDragStart() {
      },
      onDragOver() {
        return !1;
      },
      drop() {
      }
    }
  };
  function lQ(s, e) {
    const t = s.indexOf(e);
    if (t === -1)
      return [];
    const i = [];
    let n = t - 1;
    for (; n >= 0 && s[n] === e - (t - n); )
      i.push(s[n--]);
    for (i.reverse(), n = t; n < s.length && s[n] === e + (n - t); )
      i.push(s[n++]);
    return i;
  }
  function ek(s, e) {
    const t = [];
    let i = 0, n = 0;
    for (; i < s.length || n < e.length; )
      if (i >= s.length)
        t.push(e[n++]);
      else if (n >= e.length)
        t.push(s[i++]);
      else if (s[i] === e[n]) {
        t.push(s[i]), i++, n++;
        continue;
      } else
        s[i] < e[n] ? t.push(s[i++]) : t.push(e[n++]);
    return t;
  }
  function cQ(s, e) {
    const t = [];
    let i = 0, n = 0;
    for (; i < s.length || n < e.length; )
      if (i >= s.length)
        t.push(e[n++]);
      else if (n >= e.length)
        t.push(s[i++]);
      else if (s[i] === e[n]) {
        i++, n++;
        continue;
      } else
        s[i] < e[n] ? t.push(s[i++]) : n++;
    return t;
  }
  const KM = (s, e) => s - e;
  class dQ {
    constructor(e, t) {
      this._templateId = e, this.renderers = t;
    }
    get templateId() {
      return this._templateId;
    }
    renderTemplate(e) {
      return this.renderers.map((t) => t.renderTemplate(e));
    }
    renderElement(e, t, i, n) {
      let o = 0;
      for (const r of this.renderers)
        r.renderElement(e, t, i[o++], n);
    }
    disposeElement(e, t, i, n) {
      let o = 0;
      for (const r of this.renderers)
        r.disposeElement && r.disposeElement(e, t, i[o], n), o += 1;
    }
    disposeTemplate(e) {
      let t = 0;
      for (const i of this.renderers)
        i.disposeTemplate(e[t++]);
    }
  }
  class hQ {
    constructor(e) {
      this.accessibilityProvider = e, this.templateId = "a18n";
    }
    renderTemplate(e) {
      return e;
    }
    renderElement(e, t, i) {
      const n = this.accessibilityProvider.getAriaLabel(e);
      n ? i.setAttribute("aria-label", n) : i.removeAttribute("aria-label");
      const o = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
      typeof o == "number" ? i.setAttribute("aria-level", `${o}`) : i.removeAttribute("aria-level");
    }
    disposeTemplate(e) {
    }
  }
  class uQ {
    constructor(e, t) {
      this.list = e, this.dnd = t;
    }
    getDragElements(e) {
      const t = this.list.getSelectedElements();
      return t.indexOf(e) > -1 ? t : [e];
    }
    getDragURI(e) {
      return this.dnd.getDragURI(e);
    }
    getDragLabel(e, t) {
      if (this.dnd.getDragLabel)
        return this.dnd.getDragLabel(e, t);
    }
    onDragStart(e, t) {
      this.dnd.onDragStart && this.dnd.onDragStart(e, t);
    }
    onDragOver(e, t, i, n) {
      return this.dnd.onDragOver(e, t, i, n);
    }
    onDragLeave(e, t, i, n) {
      var o, r;
      (r = (o = this.dnd).onDragLeave) === null || r === void 0 || r.call(o, e, t, i, n);
    }
    onDragEnd(e) {
      this.dnd.onDragEnd && this.dnd.onDragEnd(e);
    }
    drop(e, t, i, n) {
      this.dnd.drop(e, t, i, n);
    }
  }
  class ka {
    constructor(e, t, i, n, o = aQ) {
      var r;
      this.user = e, this._options = o, this.focus = new A1("focused"), this.anchor = new A1("anchor"), this.eventBufferer = new uI(), this._ariaLabel = "", this.disposables = new te(), this._onDidDispose = new B(), this.onDidDispose = this._onDidDispose.event;
      const a = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (r = this._options.accessibilityProvider) === null || r === void 0 ? void 0 : r.getWidgetRole() : "list";
      this.selection = new iQ(a !== "listbox"), Sa(o, rQ, !1);
      const l = [this.focus.renderer, this.selection.renderer];
      this.accessibilityProvider = o.accessibilityProvider, this.accessibilityProvider && (l.push(new hQ(this.accessibilityProvider)), this.accessibilityProvider.onDidChangeActiveDescendant && this.accessibilityProvider.onDidChangeActiveDescendant(this.onDidChangeActiveDescendant, this, this.disposables)), n = n.map((d) => new dQ(d.templateId, [...l, d]));
      const c = Object.assign(Object.assign({}, o), { dnd: o.dnd && new uQ(this, o.dnd) });
      if (this.view = new Lr(t, i, n, c), this.view.domNode.setAttribute("role", a), o.styleController)
        this.styleController = o.styleController(this.view.domId);
      else {
        const d = Co(this.view.domNode);
        this.styleController = new A3(d, this.view.domId);
      }
      if (this.spliceable = new KX([
        new TS(this.focus, this.view, o.identityProvider),
        new TS(this.selection, this.view, o.identityProvider),
        new TS(this.anchor, this.view, o.identityProvider),
        this.view
      ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.disposables.add(new sQ(this, this.view)), (typeof o.keyboardSupport != "boolean" || o.keyboardSupport) && (this.keyboardController = new I3(this, this.view, o), this.disposables.add(this.keyboardController)), o.keyboardNavigationLabelProvider) {
        const d = o.keyboardNavigationDelegate || E3;
        this.typeLabelController = new nQ(this, this.view, o.keyboardNavigationLabelProvider, d), this.disposables.add(this.typeLabelController);
      }
      this.mouseController = this.createMouseController(o), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), this._options.multipleSelectionSupport !== !1 && this.view.domNode.setAttribute("aria-multiselectable", "true");
    }
    get onDidChangeFocus() {
      return be.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e));
    }
    get onDidChangeSelection() {
      return be.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e));
    }
    get domId() {
      return this.view.domId;
    }
    get onMouseClick() {
      return this.view.onMouseClick;
    }
    get onMouseDblClick() {
      return this.view.onMouseDblClick;
    }
    get onMouseMiddleClick() {
      return this.view.onMouseMiddleClick;
    }
    get onPointer() {
      return this.mouseController.onPointer;
    }
    get onMouseDown() {
      return this.view.onMouseDown;
    }
    get onTouchStart() {
      return this.view.onTouchStart;
    }
    get onTap() {
      return this.view.onTap;
    }
    get onContextMenu() {
      let e = !1;
      const t = be.chain(this.disposables.add(new xt(this.view.domNode, "keydown")).event).map((o) => new $t(o)).filter((o) => e = o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map(mM).filter(() => !1).event, i = be.chain(this.disposables.add(new xt(this.view.domNode, "keyup")).event).forEach(() => e = !1).map((o) => new $t(o)).filter((o) => o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map(mM).map(({ browserEvent: o }) => {
        const r = this.getFocus(), a = r.length ? r[0] : void 0, l = typeof a < "u" ? this.view.element(a) : void 0, c = typeof a < "u" ? this.view.domElement(a) : this.view.domNode;
        return { index: a, element: l, anchor: c, browserEvent: o };
      }).event, n = be.chain(this.view.onContextMenu).filter((o) => !e).map(({ element: o, index: r, browserEvent: a }) => ({ element: o, index: r, anchor: { x: a.pageX + 1, y: a.pageY }, browserEvent: a })).event;
      return be.any(t, i, n);
    }
    get onKeyDown() {
      return this.disposables.add(new xt(this.view.domNode, "keydown")).event;
    }
    get onDidFocus() {
      return be.signal(this.disposables.add(new xt(this.view.domNode, "focus", !0)).event);
    }
    createMouseController(e) {
      return new M3(this);
    }
    updateOptions(e = {}) {
      var t;
      this._options = Object.assign(Object.assign({}, this._options), e), this.typeLabelController && this.typeLabelController.updateOptions(this._options), this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable")), this.mouseController.updateOptions(e), (t = this.keyboardController) === null || t === void 0 || t.updateOptions(e), this.view.updateOptions(e);
    }
    get options() {
      return this._options;
    }
    splice(e, t, i = []) {
      if (e < 0 || e > this.view.length)
        throw new Yc(this.user, `Invalid start index: ${e}`);
      if (t < 0)
        throw new Yc(this.user, `Invalid delete count: ${t}`);
      t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
    }
    rerender() {
      this.view.rerender();
    }
    element(e) {
      return this.view.element(e);
    }
    get length() {
      return this.view.length;
    }
    get contentHeight() {
      return this.view.contentHeight;
    }
    get scrollTop() {
      return this.view.getScrollTop();
    }
    set scrollTop(e) {
      this.view.setScrollTop(e);
    }
    get ariaLabel() {
      return this._ariaLabel;
    }
    set ariaLabel(e) {
      this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
    }
    domFocus() {
      this.view.domNode.focus({ preventScroll: !0 });
    }
    layout(e, t) {
      this.view.layout(e, t);
    }
    setSelection(e, t) {
      for (const i of e)
        if (i < 0 || i >= this.length)
          throw new Yc(this.user, `Invalid index ${i}`);
      this.selection.set(e, t);
    }
    getSelection() {
      return this.selection.get();
    }
    getSelectedElements() {
      return this.getSelection().map((e) => this.view.element(e));
    }
    setAnchor(e) {
      if (typeof e > "u") {
        this.anchor.set([]);
        return;
      }
      if (e < 0 || e >= this.length)
        throw new Yc(this.user, `Invalid index ${e}`);
      this.anchor.set([e]);
    }
    getAnchor() {
      return qP(this.anchor.get(), void 0);
    }
    getAnchorElement() {
      const e = this.getAnchor();
      return typeof e > "u" ? void 0 : this.element(e);
    }
    setFocus(e, t) {
      for (const i of e)
        if (i < 0 || i >= this.length)
          throw new Yc(this.user, `Invalid index ${i}`);
      this.focus.set(e, t);
    }
    focusNext(e = 1, t = !1, i, n) {
      if (this.length === 0)
        return;
      const o = this.focus.get(), r = this.findNextIndex(o.length > 0 ? o[0] + e : 0, t, n);
      r > -1 && this.setFocus([r], i);
    }
    focusPrevious(e = 1, t = !1, i, n) {
      if (this.length === 0)
        return;
      const o = this.focus.get(), r = this.findPreviousIndex(o.length > 0 ? o[0] - e : 0, t, n);
      r > -1 && this.setFocus([r], i);
    }
    focusNextPage(e, t) {
      return $M(this, void 0, void 0, function* () {
        let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
        i = i === 0 ? 0 : i - 1;
        const n = this.view.element(i), o = this.getFocusedElements()[0];
        if (o !== n) {
          const r = this.findPreviousIndex(i, !1, t);
          r > -1 && o !== this.view.element(r) ? this.setFocus([r], e) : this.setFocus([i], e);
        } else {
          const r = this.view.getScrollTop();
          this.view.setScrollTop(r + this.view.renderHeight - this.view.elementHeight(i)), this.view.getScrollTop() !== r && (this.setFocus([]), yield gc(0), yield this.focusNextPage(e, t));
        }
      });
    }
    focusPreviousPage(e, t) {
      return $M(this, void 0, void 0, function* () {
        let i;
        const n = this.view.getScrollTop();
        n === 0 ? i = this.view.indexAt(n) : i = this.view.indexAfter(n - 1);
        const o = this.view.element(i), r = this.getFocusedElements()[0];
        if (r !== o) {
          const a = this.findNextIndex(i, !1, t);
          a > -1 && r !== this.view.element(a) ? this.setFocus([a], e) : this.setFocus([i], e);
        } else {
          const a = n;
          this.view.setScrollTop(n - this.view.renderHeight), this.view.getScrollTop() !== a && (this.setFocus([]), yield gc(0), yield this.focusPreviousPage(e, t));
        }
      });
    }
    focusLast(e, t) {
      if (this.length === 0)
        return;
      const i = this.findPreviousIndex(this.length - 1, !1, t);
      i > -1 && this.setFocus([i], e);
    }
    focusFirst(e, t) {
      this.focusNth(0, e, t);
    }
    focusNth(e, t, i) {
      if (this.length === 0)
        return;
      const n = this.findNextIndex(e, !1, i);
      n > -1 && this.setFocus([n], t);
    }
    findNextIndex(e, t = !1, i) {
      for (let n = 0; n < this.length; n++) {
        if (e >= this.length && !t)
          return -1;
        if (e = e % this.length, !i || i(this.element(e)))
          return e;
        e++;
      }
      return -1;
    }
    findPreviousIndex(e, t = !1, i) {
      for (let n = 0; n < this.length; n++) {
        if (e < 0 && !t)
          return -1;
        if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
          return e;
        e--;
      }
      return -1;
    }
    getFocus() {
      return this.focus.get();
    }
    getFocusedElements() {
      return this.getFocus().map((e) => this.view.element(e));
    }
    reveal(e, t) {
      if (e < 0 || e >= this.length)
        throw new Yc(this.user, `Invalid index ${e}`);
      const i = this.view.getScrollTop(), n = this.view.elementTop(e), o = this.view.elementHeight(e);
      if (zd(t)) {
        const r = o - this.view.renderHeight;
        this.view.setScrollTop(r * vs(t, 0, 1) + n);
      } else {
        const r = n + o, a = i + this.view.renderHeight;
        n < i && r >= a || (n < i || r >= a && o >= this.view.renderHeight ? this.view.setScrollTop(n) : r >= a && this.view.setScrollTop(r - this.view.renderHeight));
      }
    }
    getRelativeTop(e) {
      if (e < 0 || e >= this.length)
        throw new Yc(this.user, `Invalid index ${e}`);
      const t = this.view.getScrollTop(), i = this.view.elementTop(e), n = this.view.elementHeight(e);
      if (i < t || i + n > t + this.view.renderHeight)
        return null;
      const o = n - this.view.renderHeight;
      return Math.abs((t - i) / o);
    }
    getHTMLElement() {
      return this.view.domNode;
    }
    style(e) {
      this.styleController.style(e);
    }
    toListEvent({ indexes: e, browserEvent: t }) {
      return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
    }
    _onFocusChange() {
      const e = this.focus.get();
      this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
    }
    onDidChangeActiveDescendant() {
      var e;
      const t = this.focus.get();
      if (t.length > 0) {
        let i;
        !((e = this.accessibilityProvider) === null || e === void 0) && e.getActiveDescendantId && (i = this.accessibilityProvider.getActiveDescendantId(this.view.element(t[0]))), this.view.domNode.setAttribute("aria-activedescendant", i || this.view.getElementDomId(t[0]));
      } else
        this.view.domNode.removeAttribute("aria-activedescendant");
    }
    _onSelectionChange() {
      const e = this.selection.get();
      this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
    }
    dispose() {
      this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
    }
  }
  Hh([
    Ai
  ], ka.prototype, "onDidChangeFocus", null);
  Hh([
    Ai
  ], ka.prototype, "onDidChangeSelection", null);
  Hh([
    Ai
  ], ka.prototype, "onContextMenu", null);
  Hh([
    Ai
  ], ka.prototype, "onKeyDown", null);
  Hh([
    Ai
  ], ka.prototype, "onDidFocus", null);
  class fQ {
    constructor(e, t) {
      this.renderer = e, this.modelProvider = t;
    }
    get templateId() {
      return this.renderer.templateId;
    }
    renderTemplate(e) {
      return { data: this.renderer.renderTemplate(e), disposable: z.None };
    }
    renderElement(e, t, i, n) {
      if (i.disposable && i.disposable.dispose(), !i.data)
        return;
      const o = this.modelProvider();
      if (o.isResolved(e))
        return this.renderer.renderElement(o.get(e), e, i.data, n);
      const r = new bn(), a = o.resolve(e, r.token);
      i.disposable = { dispose: () => r.cancel() }, this.renderer.renderPlaceholder(e, i.data), a.then((l) => this.renderer.renderElement(l, e, i.data, n));
    }
    disposeTemplate(e) {
      e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
    }
  }
  class gQ {
    constructor(e, t) {
      this.modelProvider = e, this.accessibilityProvider = t;
    }
    getWidgetAriaLabel() {
      return this.accessibilityProvider.getWidgetAriaLabel();
    }
    getAriaLabel(e) {
      const t = this.modelProvider();
      return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
    }
  }
  function mQ(s, e) {
    return Object.assign(Object.assign({}, e), { accessibilityProvider: e.accessibilityProvider && new gQ(s, e.accessibilityProvider) });
  }
  class pQ {
    constructor(e, t, i, n, o = {}) {
      const r = () => this.model, a = n.map((l) => new fQ(l, r));
      this.list = new ka(e, t, i, a, mQ(r, o));
    }
    updateOptions(e) {
      this.list.updateOptions(e);
    }
    getHTMLElement() {
      return this.list.getHTMLElement();
    }
    get onDidFocus() {
      return this.list.onDidFocus;
    }
    get onDidDispose() {
      return this.list.onDidDispose;
    }
    get onMouseDblClick() {
      return be.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
    }
    get onPointer() {
      return be.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
    }
    get onDidChangeSelection() {
      return be.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((n) => this._model.get(n)), indexes: t, browserEvent: i }));
    }
    get model() {
      return this._model;
    }
    set model(e) {
      this._model = e, this.list.splice(0, this.list.length, Vn(e.length));
    }
    getFocus() {
      return this.list.getFocus();
    }
    getSelection() {
      return this.list.getSelection();
    }
    getSelectedElements() {
      return this.getSelection().map((e) => this.model.get(e));
    }
    style(e) {
      this.list.style(e);
    }
    dispose() {
      this.list.dispose();
    }
  }
  const _Q = {
    separatorBorder: H.transparent
  };
  class R3 {
    constructor(e, t, i, n) {
      this.container = e, this.view = t, this.disposable = n, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
    }
    set size(e) {
      this._size = e;
    }
    get size() {
      return this._size;
    }
    get visible() {
      return typeof this._cachedVisibleSize > "u";
    }
    setVisible(e, t) {
      e !== this.visible && (e ? (this.size = vs(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e), this.view.setVisible && this.view.setVisible(e));
    }
    get minimumSize() {
      return this.visible ? this.view.minimumSize : 0;
    }
    get viewMinimumSize() {
      return this.view.minimumSize;
    }
    get maximumSize() {
      return this.visible ? this.view.maximumSize : 0;
    }
    get viewMaximumSize() {
      return this.view.maximumSize;
    }
    get priority() {
      return this.view.priority;
    }
    get snap() {
      return !!this.view.snap;
    }
    set enabled(e) {
      this.container.style.pointerEvents = e ? "" : "none";
    }
    layout(e, t) {
      this.layoutContainer(e), this.view.layout(this.size, e, t);
    }
    dispose() {
      return this.disposable.dispose(), this.view;
    }
  }
  class bQ extends R3 {
    layoutContainer(e) {
      this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
    }
  }
  class vQ extends R3 {
    layoutContainer(e) {
      this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
    }
  }
  var Ua;
  (function(s) {
    s[s.Idle = 0] = "Idle", s[s.Busy = 1] = "Busy";
  })(Ua || (Ua = {}));
  var R1;
  (function(s) {
    s.Distribute = { type: "distribute" };
    function e(i) {
      return { type: "split", index: i };
    }
    s.Split = e;
    function t(i) {
      return { type: "invisible", cachedVisibleSize: i };
    }
    s.Invisible = t;
  })(R1 || (R1 = {}));
  class O3 extends z {
    constructor(e, t = {}) {
      var i, n, o, r, a;
      super(), this.size = 0, this.contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = Ua.Idle, this._onDidSashChange = this._register(new B()), this._onDidSashReset = this._register(new B()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onDidSashChange = this._onDidSashChange.event, this.onDidSashReset = this._onDidSashReset.event, this.orientation = (i = t.orientation) !== null && i !== void 0 ? i : 0, this.inverseAltBehavior = (n = t.inverseAltBehavior) !== null && n !== void 0 ? n : !1, this.proportionalLayout = (o = t.proportionalLayout) !== null && o !== void 0 ? o : !0, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = q(this.el, J(".sash-container")), this.viewContainer = J(".split-view-container"), this.scrollable = new h_({
        forceIntegerValues: !0,
        smoothScrollDuration: 125,
        scheduleAtNextAnimationFrame: _r
      }), this.scrollableElement = this._register(new uE(this.viewContainer, {
        vertical: this.orientation === 0 ? (r = t.scrollbarVisibility) !== null && r !== void 0 ? r : 1 : 2,
        horizontal: this.orientation === 1 ? (a = t.scrollbarVisibility) !== null && a !== void 0 ? a : 1 : 2
      }, this.scrollable)), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((l) => {
        this.viewContainer.scrollTop = l.scrollTop, this.viewContainer.scrollLeft = l.scrollLeft;
      })), q(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || _Q), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((l, c) => {
        const d = Ss(l.visible) || l.visible ? l.size : { type: "invisible", cachedVisibleSize: l.size }, h = l.view;
        this.doAddView(h, d, c, !0);
      }), this.contentSize = this.viewItems.reduce((l, c) => l + c.size, 0), this.saveProportions());
    }
    get orthogonalStartSash() {
      return this._orthogonalStartSash;
    }
    get orthogonalEndSash() {
      return this._orthogonalEndSash;
    }
    get startSnappingEnabled() {
      return this._startSnappingEnabled;
    }
    get endSnappingEnabled() {
      return this._endSnappingEnabled;
    }
    set orthogonalStartSash(e) {
      for (const t of this.sashItems)
        t.sash.orthogonalStartSash = e;
      this._orthogonalStartSash = e;
    }
    set orthogonalEndSash(e) {
      for (const t of this.sashItems)
        t.sash.orthogonalEndSash = e;
      this._orthogonalEndSash = e;
    }
    set startSnappingEnabled(e) {
      this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
    }
    set endSnappingEnabled(e) {
      this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
    }
    style(e) {
      e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
    }
    addView(e, t, i = this.viewItems.length, n) {
      this.doAddView(e, t, i, n);
    }
    layout(e, t) {
      const i = Math.max(this.size, this.contentSize);
      if (this.size = e, this.layoutContext = t, this.proportions)
        for (let n = 0; n < this.viewItems.length; n++) {
          const o = this.viewItems[n];
          o.size = vs(Math.round(this.proportions[n] * e), o.minimumSize, o.maximumSize);
        }
      else {
        const n = Vn(this.viewItems.length), o = n.filter((a) => this.viewItems[a].priority === 1), r = n.filter((a) => this.viewItems[a].priority === 2);
        this.resize(this.viewItems.length - 1, e - i, void 0, o, r);
      }
      this.distributeEmptySpace(), this.layoutViews();
    }
    saveProportions() {
      this.proportionalLayout && this.contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.size / this.contentSize));
    }
    onSashStart({ sash: e, start: t, alt: i }) {
      for (const a of this.viewItems)
        a.enabled = !1;
      const n = this.sashItems.findIndex((a) => a.sash === e), o = ol(ee(document.body, "keydown", (a) => r(this.sashDragState.current, a.altKey)), ee(document.body, "keyup", () => r(this.sashDragState.current, !1))), r = (a, l) => {
        const c = this.viewItems.map((g) => g.size);
        let d = Number.NEGATIVE_INFINITY, h = Number.POSITIVE_INFINITY;
        if (this.inverseAltBehavior && (l = !l), l)
          if (n === this.sashItems.length - 1) {
            const _ = this.viewItems[n];
            d = (_.minimumSize - _.size) / 2, h = (_.maximumSize - _.size) / 2;
          } else {
            const _ = this.viewItems[n + 1];
            d = (_.size - _.maximumSize) / 2, h = (_.size - _.minimumSize) / 2;
          }
        let u, f;
        if (!l) {
          const g = Vn(n, -1), _ = Vn(n + 1, this.viewItems.length), b = g.reduce((k, I) => k + (this.viewItems[I].minimumSize - c[I]), 0), C = g.reduce((k, I) => k + (this.viewItems[I].viewMaximumSize - c[I]), 0), v = _.length === 0 ? Number.POSITIVE_INFINITY : _.reduce((k, I) => k + (c[I] - this.viewItems[I].minimumSize), 0), w = _.length === 0 ? Number.NEGATIVE_INFINITY : _.reduce((k, I) => k + (c[I] - this.viewItems[I].viewMaximumSize), 0), S = Math.max(b, w), L = Math.min(v, C), x = this.findFirstSnapIndex(g), y = this.findFirstSnapIndex(_);
          if (typeof x == "number") {
            const k = this.viewItems[x], I = Math.floor(k.viewMinimumSize / 2);
            u = {
              index: x,
              limitDelta: k.visible ? S - I : S + I,
              size: k.size
            };
          }
          if (typeof y == "number") {
            const k = this.viewItems[y], I = Math.floor(k.viewMinimumSize / 2);
            f = {
              index: y,
              limitDelta: k.visible ? L + I : L - I,
              size: k.size
            };
          }
        }
        this.sashDragState = { start: a, current: a, index: n, sizes: c, minDelta: d, maxDelta: h, alt: l, snapBefore: u, snapAfter: f, disposable: o };
      };
      r(t, i);
    }
    onSashChange({ current: e }) {
      const { index: t, start: i, sizes: n, alt: o, minDelta: r, maxDelta: a, snapBefore: l, snapAfter: c } = this.sashDragState;
      this.sashDragState.current = e;
      const d = e - i, h = this.resize(t, d, n, void 0, void 0, r, a, l, c);
      if (o) {
        const u = t === this.sashItems.length - 1, f = this.viewItems.map((w) => w.size), g = u ? t : t + 1, _ = this.viewItems[g], b = _.size - _.maximumSize, C = _.size - _.minimumSize, v = u ? t - 1 : t + 1;
        this.resize(v, -h, f, void 0, void 0, b, C);
      }
      this.distributeEmptySpace(), this.layoutViews();
    }
    onSashEnd(e) {
      this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
      for (const t of this.viewItems)
        t.enabled = !0;
    }
    onViewChange(e, t) {
      const i = this.viewItems.indexOf(e);
      i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = vs(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
    }
    resizeView(e, t) {
      if (this.state !== Ua.Idle)
        throw new Error("Cant modify splitview");
      if (this.state = Ua.Busy, e < 0 || e >= this.viewItems.length)
        return;
      const i = Vn(this.viewItems.length).filter((a) => a !== e), n = [...i.filter((a) => this.viewItems[a].priority === 1), e], o = i.filter((a) => this.viewItems[a].priority === 2), r = this.viewItems[e];
      t = Math.round(t), t = vs(t, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = t, this.relayout(n, o), this.state = Ua.Idle;
    }
    distributeViewSizes() {
      const e = [];
      let t = 0;
      for (const a of this.viewItems)
        a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
      const i = Math.floor(t / e.length);
      for (const a of e)
        a.size = vs(i, a.minimumSize, a.maximumSize);
      const n = Vn(this.viewItems.length), o = n.filter((a) => this.viewItems[a].priority === 1), r = n.filter((a) => this.viewItems[a].priority === 2);
      this.relayout(o, r);
    }
    getViewSize(e) {
      return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
    }
    doAddView(e, t, i = this.viewItems.length, n) {
      if (this.state !== Ua.Idle)
        throw new Error("Cant modify splitview");
      this.state = Ua.Busy;
      const o = J(".split-view-view");
      i === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(i));
      const r = e.onDidChange((u) => this.onViewChange(d, u)), a = qe(() => this.viewContainer.removeChild(o)), l = ol(r, a);
      let c;
      typeof t == "number" ? c = t : t.type === "split" ? c = this.getViewSize(t.index) / 2 : t.type === "invisible" ? c = { cachedVisibleSize: t.cachedVisibleSize } : c = e.minimumSize;
      const d = this.orientation === 0 ? new bQ(o, e, c, l) : new vQ(o, e, c, l);
      if (this.viewItems.splice(i, 0, d), this.viewItems.length > 1) {
        let u = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash };
        const f = this.orientation === 0 ? new Dn(this.sashContainer, { getHorizontalSashTop: (k) => this.getSashPosition(k), getHorizontalSashWidth: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, u), { orientation: 1 })) : new Dn(this.sashContainer, { getVerticalSashLeft: (k) => this.getSashPosition(k), getVerticalSashHeight: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, u), { orientation: 0 })), g = this.orientation === 0 ? (k) => ({ sash: f, start: k.startY, current: k.currentY, alt: k.altKey }) : (k) => ({ sash: f, start: k.startX, current: k.currentX, alt: k.altKey }), b = be.map(f.onDidStart, g)(this.onSashStart, this), v = be.map(f.onDidChange, g)(this.onSashChange, this), S = be.map(f.onDidEnd, () => this.sashItems.findIndex((k) => k.sash === f))(this.onSashEnd, this), L = f.onDidReset(() => {
          const k = this.sashItems.findIndex((j) => j.sash === f), I = Vn(k, -1), F = Vn(k + 1, this.viewItems.length), R = this.findFirstSnapIndex(I), $ = this.findFirstSnapIndex(F);
          typeof R == "number" && !this.viewItems[R].visible || typeof $ == "number" && !this.viewItems[$].visible || this._onDidSashReset.fire(k);
        }), x = ol(b, v, S, L, f), y = { sash: f, disposable: x };
        this.sashItems.splice(i - 1, 0, y);
      }
      o.appendChild(e.element);
      let h;
      typeof t != "number" && t.type === "split" && (h = [t.index]), n || this.relayout([i], h), this.state = Ua.Idle, !n && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
    }
    relayout(e, t) {
      const i = this.viewItems.reduce((n, o) => n + o.size, 0);
      this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
    }
    resize(e, t, i = this.viewItems.map((d) => d.size), n, o, r = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, c) {
      if (e < 0 || e >= this.viewItems.length)
        return 0;
      const d = Vn(e, -1), h = Vn(e + 1, this.viewItems.length);
      if (o)
        for (const y of o)
          Rw(d, y), Rw(h, y);
      if (n)
        for (const y of n)
          j_(d, y), j_(h, y);
      const u = d.map((y) => this.viewItems[y]), f = d.map((y) => i[y]), g = h.map((y) => this.viewItems[y]), _ = h.map((y) => i[y]), b = d.reduce((y, k) => y + (this.viewItems[k].minimumSize - i[k]), 0), C = d.reduce((y, k) => y + (this.viewItems[k].maximumSize - i[k]), 0), v = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((y, k) => y + (i[k] - this.viewItems[k].minimumSize), 0), w = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((y, k) => y + (i[k] - this.viewItems[k].maximumSize), 0), S = Math.max(b, w, r), L = Math.min(v, C, a);
      let x = !1;
      if (l) {
        const y = this.viewItems[l.index], k = t >= l.limitDelta;
        x = k !== y.visible, y.setVisible(k, l.size);
      }
      if (!x && c) {
        const y = this.viewItems[c.index], k = t < c.limitDelta;
        x = k !== y.visible, y.setVisible(k, c.size);
      }
      if (x)
        return this.resize(e, t, i, n, o, r, a);
      t = vs(t, S, L);
      for (let y = 0, k = t; y < u.length; y++) {
        const I = u[y], F = vs(f[y] + k, I.minimumSize, I.maximumSize);
        k -= F - f[y], I.size = F;
      }
      for (let y = 0, k = t; y < g.length; y++) {
        const I = g[y], F = vs(_[y] - k, I.minimumSize, I.maximumSize);
        k += F - _[y], I.size = F;
      }
      return t;
    }
    distributeEmptySpace(e) {
      const t = this.viewItems.reduce((a, l) => a + l.size, 0);
      let i = this.size - t;
      const n = Vn(this.viewItems.length - 1, -1), o = n.filter((a) => this.viewItems[a].priority === 1), r = n.filter((a) => this.viewItems[a].priority === 2);
      for (const a of r)
        Rw(n, a);
      for (const a of o)
        j_(n, a);
      typeof e == "number" && j_(n, e);
      for (let a = 0; i !== 0 && a < n.length; a++) {
        const l = this.viewItems[n[a]], c = vs(l.size + i, l.minimumSize, l.maximumSize);
        i -= c - l.size, l.size = c;
      }
    }
    layoutViews() {
      this.contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
      let e = 0;
      for (const t of this.viewItems)
        t.layout(e, this.layoutContext), e += t.size;
      this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
    }
    updateScrollableElement() {
      this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
        height: this.size,
        scrollHeight: this.contentSize
      }) : this.scrollableElement.setScrollDimensions({
        width: this.size,
        scrollWidth: this.contentSize
      });
    }
    updateSashEnablement() {
      let e = !1;
      const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
      e = !1;
      const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), n = [...this.viewItems].reverse();
      e = !1;
      const o = n.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
      e = !1;
      const r = n.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
      let a = 0;
      for (let l = 0; l < this.sashItems.length; l++) {
        const { sash: c } = this.sashItems[l];
        a += this.viewItems[l].size;
        const h = !(t[l] && r[l + 1]), u = !(i[l] && o[l + 1]);
        if (h && u) {
          const f = Vn(l, -1), g = Vn(l + 1, this.viewItems.length), _ = this.findFirstSnapIndex(f), b = this.findFirstSnapIndex(g), C = typeof _ == "number" && !this.viewItems[_].visible, v = typeof b == "number" && !this.viewItems[b].visible;
          C && o[l] && (a > 0 || this.startSnappingEnabled) ? c.state = 1 : v && t[l] && (a < this.contentSize || this.endSnappingEnabled) ? c.state = 2 : c.state = 0;
        } else
          h && !u ? c.state = 1 : !h && u ? c.state = 2 : c.state = 3;
      }
    }
    getSashPosition(e) {
      let t = 0;
      for (let i = 0; i < this.sashItems.length; i++)
        if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
          return t;
      return 0;
    }
    findFirstSnapIndex(e) {
      for (const t of e) {
        const i = this.viewItems[t];
        if (!!i.visible && i.snap)
          return t;
      }
      for (const t of e) {
        const i = this.viewItems[t];
        if (i.visible && i.maximumSize - i.minimumSize > 0)
          return;
        if (!i.visible && i.snap)
          return t;
      }
    }
    dispose() {
      super.dispose(), at(this.viewItems), this.viewItems = [], this.sashItems.forEach((e) => e.disposable.dispose()), this.sashItems = [];
    }
  }
  class v_ {
    constructor(e, t, i) {
      this.columns = e, this.getColumnSize = i, this.templateId = v_.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
      const n = new Map(t.map((o) => [o.templateId, o]));
      this.renderers = [];
      for (const o of e) {
        const r = n.get(o.templateId);
        if (!r)
          throw new Error(`Table cell renderer for template id ${o.templateId} not found.`);
        this.renderers.push(r);
      }
    }
    renderTemplate(e) {
      const t = q(e, J(".monaco-table-tr")), i = [], n = [];
      for (let r = 0; r < this.columns.length; r++) {
        const a = this.renderers[r], l = q(t, J(".monaco-table-td", { "data-col-index": r }));
        l.style.width = `${this.getColumnSize(r)}px`, i.push(l), n.push(a.renderTemplate(l));
      }
      const o = { container: e, cellContainers: i, cellTemplateData: n };
      return this.renderedTemplates.add(o), o;
    }
    renderElement(e, t, i, n) {
      for (let o = 0; o < this.columns.length; o++) {
        const a = this.columns[o].project(e);
        this.renderers[o].renderElement(a, t, i.cellTemplateData[o], n);
      }
    }
    disposeElement(e, t, i, n) {
      for (let o = 0; o < this.columns.length; o++) {
        const r = this.renderers[o];
        if (r.disposeElement) {
          const l = this.columns[o].project(e);
          r.disposeElement(l, t, i.cellTemplateData[o], n);
        }
      }
    }
    disposeTemplate(e) {
      for (let t = 0; t < this.columns.length; t++)
        this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
      Bi(e.container), this.renderedTemplates.delete(e);
    }
    layoutColumn(e, t) {
      for (const { cellContainers: i } of this.renderedTemplates)
        i[e].style.width = `${t}px`;
    }
  }
  v_.TemplateId = "row";
  function CQ(s) {
    return {
      getHeight(e) {
        return s.getHeight(e);
      },
      getTemplateId() {
        return v_.TemplateId;
      }
    };
  }
  class wQ {
    constructor(e, t) {
      this.column = e, this.index = t, this._onDidLayout = new B(), this.onDidLayout = this._onDidLayout.event, this.element = J(".monaco-table-th", { "data-col-index": t, title: e.tooltip }, e.label);
    }
    get minimumSize() {
      var e;
      return (e = this.column.minimumWidth) !== null && e !== void 0 ? e : 120;
    }
    get maximumSize() {
      var e;
      return (e = this.column.maximumWidth) !== null && e !== void 0 ? e : Number.POSITIVE_INFINITY;
    }
    get onDidChange() {
      var e;
      return (e = this.column.onDidChangeWidthConstraints) !== null && e !== void 0 ? e : be.None;
    }
    layout(e) {
      this._onDidLayout.fire([this.index, e]);
    }
  }
  class xC {
    constructor(e, t, i, n, o, r) {
      this.virtualDelegate = i, this.domId = `table_id_${++xC.InstanceCount}`, this.disposables = new te(), this.cachedWidth = 0, this.cachedHeight = 0, this.domNode = q(t, J(`.monaco-table.${this.domId}`));
      const a = n.map((d, h) => new wQ(d, h)), l = {
        size: a.reduce((d, h) => d + h.column.weight, 0),
        views: a.map((d) => ({ size: d.column.weight, view: d }))
      };
      this.splitview = this.disposables.add(new O3(this.domNode, {
        orientation: 1,
        scrollbarVisibility: 2,
        getSashOrthogonalSize: () => this.cachedHeight,
        descriptor: l
      })), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
      const c = new v_(n, o, (d) => this.splitview.getViewSize(d));
      this.list = this.disposables.add(new ka(e, this.domNode, CQ(i), [c], r)), be.any(...a.map((d) => d.onDidLayout))(([d, h]) => c.layoutColumn(d, h), null, this.disposables), this.splitview.onDidSashReset((d) => {
        const h = n.reduce((f, g) => f + g.weight, 0), u = n[d].weight / h * this.cachedWidth;
        this.splitview.resizeView(d, u);
      }, null, this.disposables), this.styleElement = Co(this.domNode), this.style({});
    }
    get onDidChangeFocus() {
      return this.list.onDidChangeFocus;
    }
    get onDidChangeSelection() {
      return this.list.onDidChangeSelection;
    }
    get onMouseDblClick() {
      return this.list.onMouseDblClick;
    }
    get onPointer() {
      return this.list.onPointer;
    }
    get onDidFocus() {
      return this.list.onDidFocus;
    }
    get onDidDispose() {
      return this.list.onDidDispose;
    }
    updateOptions(e) {
      this.list.updateOptions(e);
    }
    splice(e, t, i = []) {
      this.list.splice(e, t, i);
    }
    getHTMLElement() {
      return this.domNode;
    }
    style(e) {
      const t = [];
      t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
    }
    getSelectedElements() {
      return this.list.getSelectedElements();
    }
    getSelection() {
      return this.list.getSelection();
    }
    getFocus() {
      return this.list.getFocus();
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  xC.InstanceCount = 0;
  var Lm;
  (function(s) {
    s[s.Unknown = 0] = "Unknown", s[s.Twistie = 1] = "Twistie", s[s.Element = 2] = "Element";
  })(Lm || (Lm = {}));
  class lo extends Error {
    constructor(e, t) {
      super(`TreeError [${e}] ${t}`);
    }
  }
  class rN {
    constructor(e) {
      this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
    }
    map(e) {
      let t = this._map.get(e);
      return t || (t = this.fn(e), this._map.set(e, t)), t;
    }
  }
  class Fl {
    constructor(e, t, i, n) {
      this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = n;
    }
    getOriginalEnd() {
      return this.originalStart + this.originalLength;
    }
    getModifiedEnd() {
      return this.modifiedStart + this.modifiedLength;
    }
  }
  class qM {
    constructor(e) {
      this.source = e;
    }
    getElements() {
      const e = this.source, t = new Int32Array(e.length);
      for (let i = 0, n = e.length; i < n; i++)
        t[i] = e.charCodeAt(i);
      return t;
    }
  }
  function SQ(s, e, t) {
    return new Yr(new qM(s), new qM(e)).ComputeDiff(t).changes;
  }
  class iu {
    static Assert(e, t) {
      if (!e)
        throw new Error(t);
    }
  }
  class nu {
    static Copy(e, t, i, n, o) {
      for (let r = 0; r < o; r++)
        i[n + r] = e[t + r];
    }
    static Copy2(e, t, i, n, o) {
      for (let r = 0; r < o; r++)
        i[n + r] = e[t + r];
    }
  }
  class GM {
    constructor() {
      this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
    }
    MarkNextChange() {
      (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new Fl(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
    }
    AddOriginalElement(e, t) {
      this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
    }
    AddModifiedElement(e, t) {
      this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
    }
    getChanges() {
      return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
    }
    getReverseChanges() {
      return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
    }
  }
  class Yr {
    constructor(e, t, i = null) {
      this.ContinueProcessingPredicate = i, this._originalSequence = e, this._modifiedSequence = t;
      const [n, o, r] = Yr._getElements(e), [a, l, c] = Yr._getElements(t);
      this._hasStrings = r && c, this._originalStringElements = n, this._originalElementsOrHash = o, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
    }
    static _isStringArray(e) {
      return e.length > 0 && typeof e[0] == "string";
    }
    static _getElements(e) {
      const t = e.getElements();
      if (Yr._isStringArray(t)) {
        const i = new Int32Array(t.length);
        for (let n = 0, o = t.length; n < o; n++)
          i[n] = tN(t[n], 0);
        return [t, i, !0];
      }
      return t instanceof Int32Array ? [[], t, !1] : [[], new Int32Array(t), !1];
    }
    ElementsAreEqual(e, t) {
      return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : !0;
    }
    ElementsAreStrictEqual(e, t) {
      if (!this.ElementsAreEqual(e, t))
        return !1;
      const i = Yr._getStrictElement(this._originalSequence, e), n = Yr._getStrictElement(this._modifiedSequence, t);
      return i === n;
    }
    static _getStrictElement(e, t) {
      return typeof e.getStrictElement == "function" ? e.getStrictElement(t) : null;
    }
    OriginalElementsAreEqual(e, t) {
      return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : !0;
    }
    ModifiedElementsAreEqual(e, t) {
      return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : !0;
    }
    ComputeDiff(e) {
      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
    }
    _ComputeDiff(e, t, i, n, o) {
      const r = [!1];
      let a = this.ComputeDiffRecursive(e, t, i, n, r);
      return o && (a = this.PrettifyChanges(a)), {
        quitEarly: r[0],
        changes: a
      };
    }
    ComputeDiffRecursive(e, t, i, n, o) {
      for (o[0] = !1; e <= t && i <= n && this.ElementsAreEqual(e, i); )
        e++, i++;
      for (; t >= e && n >= i && this.ElementsAreEqual(t, n); )
        t--, n--;
      if (e > t || i > n) {
        let h;
        return i <= n ? (iu.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), h = [
          new Fl(e, 0, i, n - i + 1)
        ]) : e <= t ? (iu.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), h = [
          new Fl(e, t - e + 1, i, 0)
        ]) : (iu.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), iu.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), h = []), h;
      }
      const r = [0], a = [0], l = this.ComputeRecursionPoint(e, t, i, n, r, a, o), c = r[0], d = a[0];
      if (l !== null)
        return l;
      if (!o[0]) {
        const h = this.ComputeDiffRecursive(e, c, i, d, o);
        let u = [];
        return o[0] ? u = [
          new Fl(c + 1, t - (c + 1) + 1, d + 1, n - (d + 1) + 1)
        ] : u = this.ComputeDiffRecursive(c + 1, t, d + 1, n, o), this.ConcatenateChanges(h, u);
      }
      return [
        new Fl(e, t - e + 1, i, n - i + 1)
      ];
    }
    WALKTRACE(e, t, i, n, o, r, a, l, c, d, h, u, f, g, _, b, C, v) {
      let w = null, S = null, L = new GM(), x = t, y = i, k = f[0] - b[0] - n, I = -1073741824, F = this.m_forwardHistory.length - 1;
      do {
        const R = k + e;
        R === x || R < y && c[R - 1] < c[R + 1] ? (h = c[R + 1], g = h - k - n, h < I && L.MarkNextChange(), I = h, L.AddModifiedElement(h + 1, g), k = R + 1 - e) : (h = c[R - 1] + 1, g = h - k - n, h < I && L.MarkNextChange(), I = h - 1, L.AddOriginalElement(h, g + 1), k = R - 1 - e), F >= 0 && (c = this.m_forwardHistory[F], e = c[0], x = 1, y = c.length - 1);
      } while (--F >= -1);
      if (w = L.getReverseChanges(), v[0]) {
        let R = f[0] + 1, $ = b[0] + 1;
        if (w !== null && w.length > 0) {
          const j = w[w.length - 1];
          R = Math.max(R, j.getOriginalEnd()), $ = Math.max($, j.getModifiedEnd());
        }
        S = [
          new Fl(R, u - R + 1, $, _ - $ + 1)
        ];
      } else {
        L = new GM(), x = r, y = a, k = f[0] - b[0] - l, I = 1073741824, F = C ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
        do {
          const R = k + o;
          R === x || R < y && d[R - 1] >= d[R + 1] ? (h = d[R + 1] - 1, g = h - k - l, h > I && L.MarkNextChange(), I = h + 1, L.AddOriginalElement(h + 1, g + 1), k = R + 1 - o) : (h = d[R - 1], g = h - k - l, h > I && L.MarkNextChange(), I = h, L.AddModifiedElement(h + 1, g + 1), k = R - 1 - o), F >= 0 && (d = this.m_reverseHistory[F], o = d[0], x = 1, y = d.length - 1);
        } while (--F >= -1);
        S = L.getChanges();
      }
      return this.ConcatenateChanges(w, S);
    }
    ComputeRecursionPoint(e, t, i, n, o, r, a) {
      let l = 0, c = 0, d = 0, h = 0, u = 0, f = 0;
      e--, i--, o[0] = 0, r[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
      const g = t - e + (n - i), _ = g + 1, b = new Int32Array(_), C = new Int32Array(_), v = n - i, w = t - e, S = e - i, L = t - n, y = (w - v) % 2 === 0;
      b[v] = e, C[w] = t, a[0] = !1;
      for (let k = 1; k <= g / 2 + 1; k++) {
        let I = 0, F = 0;
        d = this.ClipDiagonalBound(v - k, k, v, _), h = this.ClipDiagonalBound(v + k, k, v, _);
        for (let $ = d; $ <= h; $ += 2) {
          $ === d || $ < h && b[$ - 1] < b[$ + 1] ? l = b[$ + 1] : l = b[$ - 1] + 1, c = l - ($ - v) - S;
          const j = l;
          for (; l < t && c < n && this.ElementsAreEqual(l + 1, c + 1); )
            l++, c++;
          if (b[$] = l, l + c > I + F && (I = l, F = c), !y && Math.abs($ - w) <= k - 1 && l >= C[$])
            return o[0] = l, r[0] = c, j <= C[$] && 1447 > 0 && k <= 1447 + 1 ? this.WALKTRACE(v, d, h, S, w, u, f, L, b, C, l, t, o, c, n, r, y, a) : null;
        }
        const R = (I - e + (F - i) - k) / 2;
        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(I, R))
          return a[0] = !0, o[0] = I, r[0] = F, R > 0 && 1447 > 0 && k <= 1447 + 1 ? this.WALKTRACE(v, d, h, S, w, u, f, L, b, C, l, t, o, c, n, r, y, a) : (e++, i++, [
            new Fl(e, t - e + 1, i, n - i + 1)
          ]);
        u = this.ClipDiagonalBound(w - k, k, w, _), f = this.ClipDiagonalBound(w + k, k, w, _);
        for (let $ = u; $ <= f; $ += 2) {
          $ === u || $ < f && C[$ - 1] >= C[$ + 1] ? l = C[$ + 1] - 1 : l = C[$ - 1], c = l - ($ - w) - L;
          const j = l;
          for (; l > e && c > i && this.ElementsAreEqual(l, c); )
            l--, c--;
          if (C[$] = l, y && Math.abs($ - v) <= k && l <= b[$])
            return o[0] = l, r[0] = c, j >= b[$] && 1447 > 0 && k <= 1447 + 1 ? this.WALKTRACE(v, d, h, S, w, u, f, L, b, C, l, t, o, c, n, r, y, a) : null;
        }
        if (k <= 1447) {
          let $ = new Int32Array(h - d + 2);
          $[0] = v - d + 1, nu.Copy2(b, d, $, 1, h - d + 1), this.m_forwardHistory.push($), $ = new Int32Array(f - u + 2), $[0] = w - u + 1, nu.Copy2(C, u, $, 1, f - u + 1), this.m_reverseHistory.push($);
        }
      }
      return this.WALKTRACE(v, d, h, S, w, u, f, L, b, C, l, t, o, c, n, r, y, a);
    }
    PrettifyChanges(e) {
      for (let t = 0; t < e.length; t++) {
        const i = e[t], n = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, o = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, r = i.originalLength > 0, a = i.modifiedLength > 0;
        for (; i.originalStart + i.originalLength < n && i.modifiedStart + i.modifiedLength < o && (!r || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); ) {
          const c = this.ElementsAreStrictEqual(i.originalStart, i.modifiedStart);
          if (this.ElementsAreStrictEqual(i.originalStart + i.originalLength, i.modifiedStart + i.modifiedLength) && !c)
            break;
          i.originalStart++, i.modifiedStart++;
        }
        let l = [null];
        if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
          e[t] = l[0], e.splice(t + 1, 1), t--;
          continue;
        }
      }
      for (let t = e.length - 1; t >= 0; t--) {
        const i = e[t];
        let n = 0, o = 0;
        if (t > 0) {
          const h = e[t - 1];
          n = h.originalStart + h.originalLength, o = h.modifiedStart + h.modifiedLength;
        }
        const r = i.originalLength > 0, a = i.modifiedLength > 0;
        let l = 0, c = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
        for (let h = 1; ; h++) {
          const u = i.originalStart - h, f = i.modifiedStart - h;
          if (u < n || f < o || r && !this.OriginalElementsAreEqual(u, u + i.originalLength) || a && !this.ModifiedElementsAreEqual(f, f + i.modifiedLength))
            break;
          const _ = (u === n && f === o ? 5 : 0) + this._boundaryScore(u, i.originalLength, f, i.modifiedLength);
          _ > c && (c = _, l = h);
        }
        i.originalStart -= l, i.modifiedStart -= l;
        const d = [null];
        if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], d)) {
          e[t - 1] = d[0], e.splice(t, 1), t++;
          continue;
        }
      }
      if (this._hasStrings)
        for (let t = 1, i = e.length; t < i; t++) {
          const n = e[t - 1], o = e[t], r = o.originalStart - n.originalStart - n.originalLength, a = n.originalStart, l = o.originalStart + o.originalLength, c = l - a, d = n.modifiedStart, h = o.modifiedStart + o.modifiedLength, u = h - d;
          if (r < 5 && c < 20 && u < 20) {
            const f = this._findBetterContiguousSequence(a, c, d, u, r);
            if (f) {
              const [g, _] = f;
              (g !== n.originalStart + n.originalLength || _ !== n.modifiedStart + n.modifiedLength) && (n.originalLength = g - n.originalStart, n.modifiedLength = _ - n.modifiedStart, o.originalStart = g + r, o.modifiedStart = _ + r, o.originalLength = l - o.originalStart, o.modifiedLength = h - o.modifiedStart);
            }
          }
        }
      return e;
    }
    _findBetterContiguousSequence(e, t, i, n, o) {
      if (t < o || n < o)
        return null;
      const r = e + t - o + 1, a = i + n - o + 1;
      let l = 0, c = 0, d = 0;
      for (let h = e; h < r; h++)
        for (let u = i; u < a; u++) {
          const f = this._contiguousSequenceScore(h, u, o);
          f > 0 && f > l && (l = f, c = h, d = u);
        }
      return l > 0 ? [c, d] : null;
    }
    _contiguousSequenceScore(e, t, i) {
      let n = 0;
      for (let o = 0; o < i; o++) {
        if (!this.ElementsAreEqual(e + o, t + o))
          return 0;
        n += this._originalStringElements[e + o].length;
      }
      return n;
    }
    _OriginalIsBoundary(e) {
      return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
    }
    _OriginalRegionIsBoundary(e, t) {
      if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
        return !0;
      if (t > 0) {
        const i = e + t;
        if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
          return !0;
      }
      return !1;
    }
    _ModifiedIsBoundary(e) {
      return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
    }
    _ModifiedRegionIsBoundary(e, t) {
      if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
        return !0;
      if (t > 0) {
        const i = e + t;
        if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
          return !0;
      }
      return !1;
    }
    _boundaryScore(e, t, i, n) {
      const o = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, r = this._ModifiedRegionIsBoundary(i, n) ? 1 : 0;
      return o + r;
    }
    ConcatenateChanges(e, t) {
      let i = [];
      if (e.length === 0 || t.length === 0)
        return t.length > 0 ? t : e;
      if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
        const n = new Array(e.length + t.length - 1);
        return nu.Copy(e, 0, n, 0, e.length - 1), n[e.length - 1] = i[0], nu.Copy(t, 1, n, e.length, t.length - 1), n;
      } else {
        const n = new Array(e.length + t.length);
        return nu.Copy(e, 0, n, 0, e.length), nu.Copy(t, 0, n, e.length, t.length), n;
      }
    }
    ChangesOverlap(e, t, i) {
      if (iu.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), iu.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
        const n = e.originalStart;
        let o = e.originalLength;
        const r = e.modifiedStart;
        let a = e.modifiedLength;
        return e.originalStart + e.originalLength >= t.originalStart && (o = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new Fl(n, o, r, a), !0;
      } else
        return i[0] = null, !1;
    }
    ClipDiagonalBound(e, t, i, n) {
      if (e >= 0 && e < n)
        return e;
      const o = i, r = n - i - 1, a = t % 2 === 0;
      if (e < 0) {
        const l = o % 2 === 0;
        return a === l ? 0 : 1;
      } else {
        const l = r % 2 === 0;
        return a === l ? n - 1 : n - 2;
      }
    }
  }
  function aN(s) {
    return typeof s == "object" && "visibility" in s && "data" in s;
  }
  function vp(s) {
    switch (s) {
      case !0:
        return 1;
      case !1:
        return 0;
      default:
        return s;
    }
  }
  function MS(s) {
    return typeof s.collapsible == "boolean";
  }
  class yQ {
    constructor(e, t, i, n = {}) {
      this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new uI(), this._onDidChangeCollapseState = new B(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new B(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new B(), this.onDidSplice = this._onDidSplice.event, this.refilterDelayer = new ca(tP), this.collapseByDefault = typeof n.collapseByDefault > "u" ? !1 : n.collapseByDefault, this.filter = n.filter, this.autoExpandSingleChildren = typeof n.autoExpandSingleChildren > "u" ? !1 : n.autoExpandSingleChildren, this.root = {
        parent: void 0,
        element: i,
        children: [],
        depth: 0,
        visibleChildrenCount: 0,
        visibleChildIndex: -1,
        collapsible: !1,
        collapsed: !1,
        renderNodeCount: 0,
        visibility: 1,
        visible: !0,
        filterData: void 0
      };
    }
    splice(e, t, i = rt.empty(), n = {}) {
      if (e.length === 0)
        throw new lo(this.user, "Invalid tree location");
      n.diffIdentityProvider ? this.spliceSmart(n.diffIdentityProvider, e, t, i, n) : this.spliceSimple(e, t, i, n);
    }
    spliceSmart(e, t, i, n, o, r) {
      var a;
      n === void 0 && (n = rt.empty()), r === void 0 && (r = (a = o.diffDepth) !== null && a !== void 0 ? a : 0);
      const { parentNode: l } = this.getParentNodeWithListIndex(t);
      if (!l.lastDiffIds)
        return this.spliceSimple(t, i, n, o);
      const c = [...n], d = t[t.length - 1], h = new Yr({ getElements: () => l.lastDiffIds }, {
        getElements: () => [
          ...l.children.slice(0, d),
          ...c,
          ...l.children.slice(d + i)
        ].map((b) => e.getId(b.element).toString())
      }).ComputeDiff(!1);
      if (h.quitEarly)
        return l.lastDiffIds = void 0, this.spliceSimple(t, i, c, o);
      const u = t.slice(0, -1), f = (b, C, v) => {
        if (r > 0)
          for (let w = 0; w < v; w++)
            b--, C--, this.spliceSmart(e, [...u, b, 0], Number.MAX_SAFE_INTEGER, c[C].children, o, r - 1);
      };
      let g = Math.min(l.children.length, d + i), _ = c.length;
      for (const b of h.changes.sort((C, v) => v.originalStart - C.originalStart))
        f(g, _, g - (b.originalStart + b.originalLength)), g = b.originalStart, _ = b.modifiedStart - d, this.spliceSimple([...u, g], b.originalLength, rt.slice(c, _, _ + b.modifiedLength), o);
      f(g, _, g);
    }
    spliceSimple(e, t, i = rt.empty(), { onDidCreateNode: n, onDidDeleteNode: o, diffIdentityProvider: r }) {
      const { parentNode: a, listIndex: l, revealed: c, visible: d } = this.getParentNodeWithListIndex(e), h = [], u = rt.map(i, (y) => this.createTreeNode(y, a, a.visible ? 1 : 0, c, h, n)), f = e[e.length - 1], g = a.children.length > 0;
      let _ = 0;
      for (let y = f; y >= 0 && y < a.children.length; y--) {
        const k = a.children[y];
        if (k.visible) {
          _ = k.visibleChildIndex;
          break;
        }
      }
      const b = [];
      let C = 0, v = 0;
      for (const y of u)
        b.push(y), v += y.renderNodeCount, y.visible && (y.visibleChildIndex = _ + C++);
      const w = U2(a.children, f, t, b);
      r ? a.lastDiffIds ? U2(a.lastDiffIds, f, t, b.map((y) => r.getId(y.element).toString())) : a.lastDiffIds = a.children.map((y) => r.getId(y.element).toString()) : a.lastDiffIds = void 0;
      let S = 0;
      for (const y of w)
        y.visible && S++;
      if (S !== 0)
        for (let y = f + b.length; y < a.children.length; y++) {
          const k = a.children[y];
          k.visible && (k.visibleChildIndex -= S);
        }
      if (a.visibleChildrenCount += C - S, c && d) {
        const y = w.reduce((k, I) => k + (I.visible ? I.renderNodeCount : 0), 0);
        this._updateAncestorsRenderNodeCount(a, v - y), this.list.splice(l, y, h);
      }
      if (w.length > 0 && o) {
        const y = (k) => {
          o(k), k.children.forEach(y);
        };
        w.forEach(y);
      }
      this._onDidSplice.fire({ insertedNodes: b, deletedNodes: w });
      const L = a.children.length > 0;
      g !== L && this.setCollapsible(e.slice(0, -1), L);
      let x = a;
      for (; x; ) {
        if (x.visibility === 2) {
          this.refilterDelayer.trigger(() => this.refilter());
          break;
        }
        x = x.parent;
      }
    }
    rerender(e) {
      if (e.length === 0)
        throw new lo(this.user, "Invalid tree location");
      const { node: t, listIndex: i, revealed: n } = this.getTreeNodeWithListIndex(e);
      t.visible && n && this.list.splice(i, 1, [t]);
    }
    has(e) {
      return this.hasTreeNode(e);
    }
    getListIndex(e) {
      const { listIndex: t, visible: i, revealed: n } = this.getTreeNodeWithListIndex(e);
      return i && n ? t : -1;
    }
    getListRenderCount(e) {
      return this.getTreeNode(e).renderNodeCount;
    }
    isCollapsible(e) {
      return this.getTreeNode(e).collapsible;
    }
    setCollapsible(e, t) {
      const i = this.getTreeNode(e);
      typeof t > "u" && (t = !i.collapsible);
      const n = { collapsible: t };
      return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, n));
    }
    isCollapsed(e) {
      return this.getTreeNode(e).collapsed;
    }
    setCollapsed(e, t, i) {
      const n = this.getTreeNode(e);
      typeof t > "u" && (t = !n.collapsed);
      const o = { collapsed: t, recursive: i || !1 };
      return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, o));
    }
    _setCollapseState(e, t) {
      const { node: i, listIndex: n, revealed: o } = this.getTreeNodeWithListIndex(e), r = this._setListNodeCollapseState(i, n, o, t);
      if (i !== this.root && this.autoExpandSingleChildren && r && !MS(t) && i.collapsible && !i.collapsed && !t.recursive) {
        let a = -1;
        for (let l = 0; l < i.children.length; l++)
          if (i.children[l].visible)
            if (a > -1) {
              a = -1;
              break;
            } else
              a = l;
        a > -1 && this._setCollapseState([...e, a], t);
      }
      return r;
    }
    _setListNodeCollapseState(e, t, i, n) {
      const o = this._setNodeCollapseState(e, n, !1);
      if (!i || !e.visible || !o)
        return o;
      const r = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = r - (t === -1 ? 0 : 1);
      return this.list.splice(t + 1, l, a.slice(1)), o;
    }
    _setNodeCollapseState(e, t, i) {
      let n;
      if (e === this.root ? n = !1 : (MS(t) ? (n = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (n = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : n = !1, n && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !MS(t) && t.recursive)
        for (const o of e.children)
          n = this._setNodeCollapseState(o, t, !0) || n;
      return n;
    }
    expandTo(e) {
      this.eventBufferer.bufferEvents(() => {
        let t = this.getTreeNode(e);
        for (; t.parent; )
          t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
      });
    }
    refilter() {
      const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
      this.list.splice(0, e, t), this.refilterDelayer.cancel();
    }
    createTreeNode(e, t, i, n, o, r) {
      const a = {
        parent: t,
        element: e.element,
        children: [],
        depth: t.depth + 1,
        visibleChildrenCount: 0,
        visibleChildIndex: -1,
        collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
        collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
        renderNodeCount: 1,
        visibility: 1,
        visible: !0,
        filterData: void 0
      }, l = this._filterNode(a, i);
      a.visibility = l, n && o.push(a);
      const c = e.children || rt.empty(), d = n && l !== 0 && !a.collapsed, h = rt.map(c, (g) => this.createTreeNode(g, a, l, d, o, r));
      let u = 0, f = 1;
      for (const g of h)
        a.children.push(g), f += g.renderNodeCount, g.visible && (g.visibleChildIndex = u++);
      return a.collapsible = a.collapsible || a.children.length > 0, a.visibleChildrenCount = u, a.visible = l === 2 ? u > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = f) : (a.renderNodeCount = 0, n && o.pop()), r && r(a), a;
    }
    updateNodeAfterCollapseChange(e) {
      const t = e.renderNodeCount, i = [];
      return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
    }
    _updateNodeAfterCollapseChange(e, t) {
      if (e.visible === !1)
        return 0;
      if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
        for (const i of e.children)
          e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
      return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
    }
    updateNodeAfterFilterChange(e) {
      const t = e.renderNodeCount, i = [];
      return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
    }
    _updateNodeAfterFilterChange(e, t, i, n = !0) {
      let o;
      if (e !== this.root) {
        if (o = this._filterNode(e, t), o === 0)
          return e.visible = !1, e.renderNodeCount = 0, !1;
        n && i.push(e);
      }
      const r = i.length;
      e.renderNodeCount = e === this.root ? 0 : 1;
      let a = !1;
      if (!e.collapsed || o !== 0) {
        let l = 0;
        for (const c of e.children)
          a = this._updateNodeAfterFilterChange(c, o, i, n && !e.collapsed) || a, c.visible && (c.visibleChildIndex = l++);
        e.visibleChildrenCount = l;
      } else
        e.visibleChildrenCount = 0;
      return e !== this.root && (e.visible = o === 2 ? a : o === 1, e.visibility = o), e.visible ? e.collapsed || (e.renderNodeCount += i.length - r) : (e.renderNodeCount = 0, n && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
    }
    _updateAncestorsRenderNodeCount(e, t) {
      if (t !== 0)
        for (; e; )
          e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
    }
    _filterNode(e, t) {
      const i = this.filter ? this.filter.filter(e.element, t) : 1;
      return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : aN(i) ? (e.filterData = i.data, vp(i.visibility)) : (e.filterData = void 0, vp(i));
    }
    hasTreeNode(e, t = this.root) {
      if (!e || e.length === 0)
        return !0;
      const [i, ...n] = e;
      return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(n, t.children[i]);
    }
    getTreeNode(e, t = this.root) {
      if (!e || e.length === 0)
        return t;
      const [i, ...n] = e;
      if (i < 0 || i > t.children.length)
        throw new lo(this.user, "Invalid tree location");
      return this.getTreeNode(n, t.children[i]);
    }
    getTreeNodeWithListIndex(e) {
      if (e.length === 0)
        return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
      const { parentNode: t, listIndex: i, revealed: n, visible: o } = this.getParentNodeWithListIndex(e), r = e[e.length - 1];
      if (r < 0 || r > t.children.length)
        throw new lo(this.user, "Invalid tree location");
      const a = t.children[r];
      return { node: a, listIndex: i, revealed: n, visible: o && a.visible };
    }
    getParentNodeWithListIndex(e, t = this.root, i = 0, n = !0, o = !0) {
      const [r, ...a] = e;
      if (r < 0 || r > t.children.length)
        throw new lo(this.user, "Invalid tree location");
      for (let l = 0; l < r; l++)
        i += t.children[l].renderNodeCount;
      return n = n && !t.collapsed, o = o && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: n, visible: o } : this.getParentNodeWithListIndex(a, t.children[r], i + 1, n, o);
    }
    getNode(e = []) {
      return this.getTreeNode(e);
    }
    getNodeLocation(e) {
      const t = [];
      let i = e;
      for (; i.parent; )
        t.push(i.parent.children.indexOf(i)), i = i.parent;
      return t.reverse();
    }
    getParentNodeLocation(e) {
      if (e.length !== 0)
        return e.length === 1 ? [] : AV(e)[0];
    }
    getFirstElementChild(e) {
      const t = this.getTreeNode(e);
      if (t.children.length !== 0)
        return t.children[0].element;
    }
  }
  class LQ extends b_ {
    constructor(e) {
      super(e.elements.map((t) => t.element)), this.data = e;
    }
  }
  function AS(s) {
    return s instanceof b_ ? new LQ(s) : s;
  }
  class kQ {
    constructor(e, t) {
      this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = z.None;
    }
    getDragURI(e) {
      return this.dnd.getDragURI(e.element);
    }
    getDragLabel(e, t) {
      if (this.dnd.getDragLabel)
        return this.dnd.getDragLabel(e.map((i) => i.element), t);
    }
    onDragStart(e, t) {
      this.dnd.onDragStart && this.dnd.onDragStart(AS(e), t);
    }
    onDragOver(e, t, i, n, o = !0) {
      const r = this.dnd.onDragOver(AS(e), t && t.element, i, n), a = this.autoExpandNode !== t;
      if (a && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
        return r;
      if (a && typeof r != "boolean" && r.autoExpand && (this.autoExpandDisposable = $d(() => {
        const u = this.modelProvider(), f = u.getNodeLocation(t);
        u.isCollapsed(f) && u.setCollapsed(f, !1), this.autoExpandNode = void 0;
      }, 500)), typeof r == "boolean" || !r.accept || typeof r.bubble > "u" || r.feedback) {
        if (!o) {
          const u = typeof r == "boolean" ? r : r.accept, f = typeof r == "boolean" ? void 0 : r.effect;
          return { accept: u, effect: f, feedback: [i] };
        }
        return r;
      }
      if (r.bubble === 1) {
        const u = this.modelProvider(), f = u.getNodeLocation(t), g = u.getParentNodeLocation(f), _ = u.getNode(g), b = g && u.getListIndex(g);
        return this.onDragOver(e, _, b, n, !1);
      }
      const l = this.modelProvider(), c = l.getNodeLocation(t), d = l.getListIndex(c), h = l.getListRenderCount(c);
      return Object.assign(Object.assign({}, r), { feedback: Vn(d, d + h) });
    }
    drop(e, t, i, n) {
      this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(AS(e), t && t.element, i, n);
    }
    onDragEnd(e) {
      this.dnd.onDragEnd && this.dnd.onDragEnd(e);
    }
  }
  function DQ(s, e) {
    return e && Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(t.element);
      }
    }, dnd: e.dnd && new kQ(s, e.dnd), multipleSelectionController: e.multipleSelectionController && {
      isSelectionSingleChangeEvent(t) {
        return e.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
      },
      isSelectionRangeChangeEvent(t) {
        return e.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
      }
    }, accessibilityProvider: e.accessibilityProvider && Object.assign(Object.assign({}, e.accessibilityProvider), {
      getSetSize(t) {
        const i = s(), n = i.getNodeLocation(t), o = i.getParentNodeLocation(n);
        return i.getNode(o).visibleChildrenCount;
      },
      getPosInSet(t) {
        return t.visibleChildIndex + 1;
      },
      isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
      getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
      getAriaLabel(t) {
        return e.accessibilityProvider.getAriaLabel(t.element);
      },
      getWidgetAriaLabel() {
        return e.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
      getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
    }), keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(t) {
      return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
    } }), enableKeyboardNavigation: e.simpleKeyboardNavigation });
  }
  class lN {
    constructor(e) {
      this.delegate = e;
    }
    getHeight(e) {
      return this.delegate.getHeight(e.element);
    }
    getTemplateId(e) {
      return this.delegate.getTemplateId(e.element);
    }
    hasDynamicHeight(e) {
      return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
    }
    setDynamicHeight(e, t) {
      this.delegate.setDynamicHeight && this.delegate.setDynamicHeight(e.element, t);
    }
  }
  var Cp;
  (function(s) {
    s.None = "none", s.OnHover = "onHover", s.Always = "always";
  })(Cp || (Cp = {}));
  class xQ {
    constructor(e, t = []) {
      this._elements = t, this.onDidChange = be.forEach(e, (i) => this._elements = i);
    }
    get elements() {
      return this._elements;
    }
  }
  class wp {
    constructor(e, t, i, n, o = {}) {
      this.renderer = e, this.modelProvider = t, this.activeNodes = n, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = wp.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.renderedIndentGuides = new iz(), this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = z.None, this.disposables = new te(), this.templateId = e.templateId, this.updateOptions(o), be.map(i, (r) => r.node)(this.onDidChangeNodeTwistieState, this, this.disposables), e.onDidChangeTwistieState && e.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);
    }
    updateOptions(e = {}) {
      if (typeof e.indent < "u" && (this.indent = vs(e.indent, 0, 40)), typeof e.renderIndentGuides < "u") {
        const t = e.renderIndentGuides !== Cp.None;
        if (t !== this.shouldRenderIndentGuides && (this.shouldRenderIndentGuides = t, this.indentGuidesDisposable.dispose(), t)) {
          const i = new te();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
      typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
    }
    renderTemplate(e) {
      const t = q(e, J(".monaco-tl-row")), i = q(t, J(".monaco-tl-indent")), n = q(t, J(".monaco-tl-twistie")), o = q(t, J(".monaco-tl-contents")), r = this.renderer.renderTemplate(o);
      return { container: e, indent: i, twistie: n, indentGuidesDisposable: z.None, templateData: r };
    }
    renderElement(e, t, i, n) {
      typeof n == "number" && (this.renderedNodes.set(e, { templateData: i, height: n }), this.renderedElements.set(e.element, e));
      const o = wp.DefaultIndent + (e.depth - 1) * this.indent;
      i.twistie.style.paddingLeft = `${o}px`, i.indent.style.width = `${o + this.indent - 16}px`, this.renderTwistie(e, i), typeof n == "number" && this.renderIndentGuides(e, i), this.renderer.renderElement(e, t, i.templateData, n);
    }
    disposeElement(e, t, i, n) {
      i.indentGuidesDisposable.dispose(), this.renderer.disposeElement && this.renderer.disposeElement(e, t, i.templateData, n), typeof n == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
    }
    disposeTemplate(e) {
      this.renderer.disposeTemplate(e.templateData);
    }
    onDidChangeTwistieState(e) {
      const t = this.renderedElements.get(e);
      !t || this.onDidChangeNodeTwistieState(t);
    }
    onDidChangeNodeTwistieState(e) {
      const t = this.renderedNodes.get(e);
      !t || (this.renderTwistie(e, t.templateData), this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderIndentGuides(e, t.templateData));
    }
    renderTwistie(e, t) {
      t.twistie.classList.remove(...p.treeItemExpanded.classNamesArray);
      let i = !1;
      this.renderer.renderTwistie && (i = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (i || t.twistie.classList.add(...p.treeItemExpanded.classNamesArray), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded");
    }
    renderIndentGuides(e, t) {
      if (Bi(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
        return;
      const i = new te(), n = this.modelProvider();
      let o = e;
      for (; ; ) {
        const r = n.getNodeLocation(o), a = n.getParentNodeLocation(r);
        if (!a)
          break;
        const l = n.getNode(a), c = J(".indent-guide", { style: `width: ${this.indent}px` });
        this.activeIndentNodes.has(l) && c.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(c) : t.indent.insertBefore(c, t.indent.firstElementChild), this.renderedIndentGuides.add(l, c), i.add(qe(() => this.renderedIndentGuides.delete(l, c))), o = l;
      }
      t.indentGuidesDisposable = i;
    }
    _onDidChangeActiveNodes(e) {
      if (!this.shouldRenderIndentGuides)
        return;
      const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
      e.forEach((n) => {
        const o = i.getNodeLocation(n);
        try {
          const r = i.getParentNodeLocation(o);
          n.collapsible && n.children.length > 0 && !n.collapsed ? t.add(n) : r && t.add(i.getNode(r));
        } catch {
        }
      }), this.activeIndentNodes.forEach((n) => {
        t.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.remove("active"));
      }), t.forEach((n) => {
        this.activeIndentNodes.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.add("active"));
      }), this.activeIndentNodes = t;
    }
    dispose() {
      this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), at(this.disposables);
    }
  }
  wp.DefaultIndent = 8;
  class IQ {
    constructor(e, t, i) {
      this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new te(), e.onWillRefilter(this.reset, this, this.disposables);
    }
    get totalCount() {
      return this._totalCount;
    }
    get matchCount() {
      return this._matchCount;
    }
    set pattern(e) {
      this._pattern = e, this._lowercasePattern = e.toLowerCase();
    }
    filter(e, t) {
      if (this._filter) {
        const o = this._filter.filter(e, t);
        if (this.tree.options.simpleKeyboardNavigation)
          return o;
        let r;
        if (typeof o == "boolean" ? r = o ? 1 : 0 : aN(o) ? r = vp(o.visibility) : r = o, r === 0)
          return !1;
      }
      if (this._totalCount++, this.tree.options.simpleKeyboardNavigation || !this._pattern)
        return this._matchCount++, { data: mr.Default, visibility: !0 };
      const i = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), n = Array.isArray(i) ? i : [i];
      for (const o of n) {
        const r = o && o.toString();
        if (typeof r > "u")
          return { data: mr.Default, visibility: !0 };
        const a = xf(this._pattern, this._lowercasePattern, 0, r, r.toLowerCase(), 0, !0);
        if (a)
          return this._matchCount++, n.length === 1 ? { data: a, visibility: !0 } : { data: { label: r, score: a }, visibility: !0 };
      }
      return this.tree.options.filterOnType ? 2 : { data: mr.Default, visibility: !0 };
    }
    reset() {
      this._totalCount = 0, this._matchCount = 0;
    }
    dispose() {
      at(this.disposables);
    }
  }
  class EQ {
    constructor(e, t, i, n, o) {
      this.tree = e, this.view = i, this.filter = n, this.keyboardNavigationDelegate = o, this._enabled = !1, this._pattern = "", this._empty = !1, this._onDidChangeEmptyState = new B(), this.positionClassName = "ne", this.automaticKeyboardNavigation = !0, this.triggered = !1, this._onDidChangePattern = new B(), this.enabledDisposables = new te(), this.disposables = new te(), this.domNode = J(`.monaco-list-type-filter.${this.positionClassName}`), this.domNode.draggable = !0, this.disposables.add(ee(this.domNode, "dragstart", () => this.onDragStart())), this.messageDomNode = q(i.getHTMLElement(), J(".monaco-list-type-filter-message")), this.labelDomNode = q(this.domNode, J("span.label"));
      const r = q(this.domNode, J(".controls"));
      this._filterOnType = !!e.options.filterOnType, this.filterOnTypeDomNode = q(r, J("input.filter")), this.filterOnTypeDomNode.type = "checkbox", this.filterOnTypeDomNode.checked = this._filterOnType, this.filterOnTypeDomNode.tabIndex = -1, this.updateFilterOnTypeTitleAndIcon(), this.disposables.add(ee(this.filterOnTypeDomNode, "input", () => this.onDidChangeFilterOnType())), this.clearDomNode = q(r, J("button.clear" + p.treeFilterClear.cssSelector)), this.clearDomNode.tabIndex = -1, this.clearDomNode.title = m("clear", "Clear"), this.keyboardNavigationEventFilter = e.options.keyboardNavigationEventFilter, t.onDidSplice(this.onDidSpliceModel, this, this.disposables), this.updateOptions(e.options);
    }
    get enabled() {
      return this._enabled;
    }
    get pattern() {
      return this._pattern;
    }
    get filterOnType() {
      return this._filterOnType;
    }
    updateOptions(e) {
      e.simpleKeyboardNavigation ? this.disable() : this.enable(), typeof e.filterOnType < "u" && (this._filterOnType = !!e.filterOnType, this.filterOnTypeDomNode.checked = this._filterOnType, this.updateFilterOnTypeTitleAndIcon()), typeof e.automaticKeyboardNavigation < "u" && (this.automaticKeyboardNavigation = e.automaticKeyboardNavigation), this.tree.refilter(), this.render(), this.automaticKeyboardNavigation || this.onEventOrInput("");
    }
    enable() {
      if (this._enabled)
        return;
      const e = this.enabledDisposables.add(new xt(this.view.getHTMLElement(), "keydown")), t = be.chain(e.event).filter((n) => !xc(n.target) || n.target === this.filterOnTypeDomNode).filter((n) => n.key !== "Dead" && !/^Media/.test(n.key)).map((n) => new $t(n)).filter(this.keyboardNavigationEventFilter || (() => !0)).filter(() => this.automaticKeyboardNavigation || this.triggered).filter((n) => this.keyboardNavigationDelegate.mightProducePrintableCharacter(n) && !(n.keyCode === 18 || n.keyCode === 16 || n.keyCode === 15 || n.keyCode === 17) || (this.pattern.length > 0 || this.triggered) && (n.keyCode === 9 || n.keyCode === 1) && !n.altKey && !n.ctrlKey && !n.metaKey || n.keyCode === 1 && (Ye ? n.altKey && !n.metaKey : n.ctrlKey) && !n.shiftKey).forEach((n) => {
        n.stopPropagation(), n.preventDefault();
      }).event, i = this.enabledDisposables.add(new xt(this.clearDomNode, "click"));
      be.chain(be.any(t, i.event)).event(this.onEventOrInput, this, this.enabledDisposables), this.filter.pattern = "", this.tree.refilter(), this.render(), this._enabled = !0, this.triggered = !1;
    }
    disable() {
      !this._enabled || (this.domNode.remove(), this.enabledDisposables.clear(), this.tree.refilter(), this.render(), this._enabled = !1, this.triggered = !1);
    }
    onEventOrInput(e) {
      typeof e == "string" ? this.onInput(e) : e instanceof MouseEvent || e.keyCode === 9 || e.keyCode === 1 && (Ye ? e.altKey : e.ctrlKey) ? this.onInput("") : e.keyCode === 1 ? this.onInput(this.pattern.length === 0 ? "" : this.pattern.substr(0, this.pattern.length - 1)) : this.onInput(this.pattern + e.browserEvent.key);
    }
    onInput(e) {
      const t = this.view.getHTMLElement();
      e && !this.domNode.parentElement ? t.append(this.domNode) : !e && this.domNode.parentElement && (this.domNode.remove(), this.tree.domFocus()), this._pattern = e, this._onDidChangePattern.fire(e), this.filter.pattern = e, this.tree.refilter(), e && this.tree.focusNext(0, !0, void 0, (n) => !mr.isDefault(n.filterData));
      const i = this.tree.getFocus();
      if (i.length > 0) {
        const n = i[0];
        this.tree.getRelativeTop(n) === null && this.tree.reveal(n, 0.5);
      }
      this.render(), e || (this.triggered = !1);
    }
    onDragStart() {
      const e = this.view.getHTMLElement(), { left: t } = mn(e), i = e.clientWidth, n = i / 2, o = this.domNode.clientWidth, r = new te();
      let a = this.positionClassName;
      const l = () => {
        switch (a) {
          case "nw":
            this.domNode.style.top = "4px", this.domNode.style.left = "4px";
            break;
          case "ne":
            this.domNode.style.top = "4px", this.domNode.style.left = `${i - o - 6}px`;
            break;
        }
      }, c = (h) => {
        h.preventDefault();
        const u = h.clientX - t;
        h.dataTransfer && (h.dataTransfer.dropEffect = "none"), u < n ? a = "nw" : a = "ne", l();
      }, d = () => {
        this.positionClassName = a, this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`, this.domNode.style.top = "", this.domNode.style.left = "", at(r);
      };
      l(), this.domNode.classList.remove(a), this.domNode.classList.add("dragging"), r.add(qe(() => this.domNode.classList.remove("dragging"))), r.add(ee(document, "dragover", (h) => c(h))), r.add(ee(this.domNode, "dragend", () => d())), za.CurrentDragAndDropData = new YG("vscode-ui"), r.add(qe(() => za.CurrentDragAndDropData = void 0));
    }
    onDidSpliceModel() {
      !this._enabled || this.pattern.length === 0 || (this.tree.refilter(), this.render());
    }
    onDidChangeFilterOnType() {
      this.tree.updateOptions({ filterOnType: this.filterOnTypeDomNode.checked }), this.tree.refilter(), this.tree.domFocus(), this.render(), this.updateFilterOnTypeTitleAndIcon();
    }
    updateFilterOnTypeTitleAndIcon() {
      this.filterOnType ? (this.filterOnTypeDomNode.classList.remove(...p.treeFilterOnTypeOff.classNamesArray), this.filterOnTypeDomNode.classList.add(...p.treeFilterOnTypeOn.classNamesArray), this.filterOnTypeDomNode.title = m("disable filter on type", "Disable Filter on Type")) : (this.filterOnTypeDomNode.classList.remove(...p.treeFilterOnTypeOn.classNamesArray), this.filterOnTypeDomNode.classList.add(...p.treeFilterOnTypeOff.classNamesArray), this.filterOnTypeDomNode.title = m("enable filter on type", "Enable Filter on Type"));
    }
    render() {
      const e = this.filter.totalCount > 0 && this.filter.matchCount === 0;
      this.pattern && this.tree.options.filterOnType && e ? (this.messageDomNode.textContent = m("empty", "No elements found"), this._empty = !0) : (this.messageDomNode.innerText = "", this._empty = !1), this.domNode.classList.toggle("no-matches", e), this.domNode.title = m("found", "Matched {0} out of {1} elements", this.filter.matchCount, this.filter.totalCount), this.labelDomNode.textContent = this.pattern.length > 16 ? "\u2026" + this.pattern.substr(this.pattern.length - 16) : this.pattern, this._onDidChangeEmptyState.fire(this._empty);
    }
    shouldAllowFocus(e) {
      return !this.enabled || !this.pattern || this.filterOnType || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !mr.isDefault(e.filterData);
    }
    dispose() {
      this._enabled && (this.domNode.remove(), this.enabledDisposables.dispose(), this._enabled = !1, this.triggered = !1), this._onDidChangePattern.dispose(), at(this.disposables);
    }
  }
  function ZM(s) {
    let e = Lm.Unknown;
    return R2(s.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = Lm.Twistie : R2(s.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") && (e = Lm.Element), {
      browserEvent: s.browserEvent,
      element: s.element ? s.element.element : null,
      target: e
    };
  }
  function _0(s, e) {
    e(s), s.children.forEach((t) => _0(t, e));
  }
  class RS {
    constructor(e, t) {
      this.getFirstViewElementWithTrait = e, this.identityProvider = t, this.nodes = [], this._onDidChange = new B(), this.onDidChange = this._onDidChange.event;
    }
    get nodeSet() {
      return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
    }
    set(e, t) {
      !t?.__forceEvent && Gs(this.nodes, e) || this._set(e, !1, t);
    }
    _set(e, t, i) {
      if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
        const n = this;
        this._onDidChange.fire({ get elements() {
          return n.get();
        }, browserEvent: i });
      }
    }
    get() {
      return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
    }
    getNodes() {
      return this.nodes;
    }
    has(e) {
      return this.nodeSet.has(e);
    }
    onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
      if (!this.identityProvider) {
        const l = this.createNodeSet(), c = (d) => l.delete(d);
        t.forEach((d) => _0(d, c)), this.set([...l.values()]);
        return;
      }
      const i = /* @__PURE__ */ new Set(), n = (l) => i.add(this.identityProvider.getId(l.element).toString());
      t.forEach((l) => _0(l, n));
      const o = /* @__PURE__ */ new Map(), r = (l) => o.set(this.identityProvider.getId(l.element).toString(), l);
      e.forEach((l) => _0(l, r));
      const a = [];
      for (const l of this.nodes) {
        const c = this.identityProvider.getId(l.element).toString();
        if (!i.has(c))
          a.push(l);
        else {
          const h = o.get(c);
          h && a.push(h);
        }
      }
      if (this.nodes.length > 0 && a.length === 0) {
        const l = this.getFirstViewElementWithTrait();
        l && a.push(l);
      }
      this._set(a, !0);
    }
    createNodeSet() {
      const e = /* @__PURE__ */ new Set();
      for (const t of this.nodes)
        e.add(t);
      return e;
    }
  }
  class NQ extends M3 {
    constructor(e, t) {
      super(e), this.tree = t;
    }
    onViewPointer(e) {
      if (xc(e.browserEvent.target) || Mu(e.browserEvent.target))
        return;
      const t = e.element;
      if (!t)
        return super.onViewPointer(e);
      if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
        return super.onViewPointer(e);
      const i = e.browserEvent.target, n = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16;
      let o = !1;
      if (typeof this.tree.expandOnlyOnTwistieClick == "function" ? o = this.tree.expandOnlyOnTwistieClick(t.element) : o = !!this.tree.expandOnlyOnTwistieClick, o && !n && e.browserEvent.detail !== 2)
        return super.onViewPointer(e);
      if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
        return super.onViewPointer(e);
      if (t.collapsible) {
        const r = this.tree.model, a = r.getNodeLocation(t), l = e.browserEvent.altKey;
        if (this.tree.setFocus([a]), r.setCollapsed(a, void 0, l), o && n)
          return;
      }
      super.onViewPointer(e);
    }
    onDoubleClick(e) {
      e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || super.onDoubleClick(e);
    }
  }
  class TQ extends ka {
    constructor(e, t, i, n, o, r, a, l) {
      super(e, t, i, n, l), this.focusTrait = o, this.selectionTrait = r, this.anchorTrait = a;
    }
    createMouseController(e) {
      return new NQ(this, e.tree);
    }
    splice(e, t, i = []) {
      if (super.splice(e, t, i), i.length === 0)
        return;
      const n = [], o = [];
      let r;
      i.forEach((a, l) => {
        this.focusTrait.has(a) && n.push(e + l), this.selectionTrait.has(a) && o.push(e + l), this.anchorTrait.has(a) && (r = e + l);
      }), n.length > 0 && super.setFocus(Cc([...super.getFocus(), ...n])), o.length > 0 && super.setSelection(Cc([...super.getSelection(), ...o])), typeof r == "number" && super.setAnchor(r);
    }
    setFocus(e, t, i = !1) {
      super.setFocus(e, t), i || this.focusTrait.set(e.map((n) => this.element(n)), t);
    }
    setSelection(e, t, i = !1) {
      super.setSelection(e, t), i || this.selectionTrait.set(e.map((n) => this.element(n)), t);
    }
    setAnchor(e, t = !1) {
      super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
    }
  }
  class P3 {
    constructor(e, t, i, n, o = {}) {
      this._user = e, this._options = o, this.eventBufferer = new uI(), this.disposables = new te(), this._onWillRefilter = new B(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new B();
      const r = new lN(i), a = new E2(), l = new E2(), c = new xQ(l.event);
      this.renderers = n.map((u) => new wp(u, () => this.model, a.event, c, o));
      for (let u of this.renderers)
        this.disposables.add(u);
      let d;
      o.keyboardNavigationLabelProvider && (d = new IQ(this, o.keyboardNavigationLabelProvider, o.filter), o = Object.assign(Object.assign({}, o), { filter: d }), this.disposables.add(d)), this.focus = new RS(() => this.view.getFocusedElements()[0], o.identityProvider), this.selection = new RS(() => this.view.getSelectedElements()[0], o.identityProvider), this.anchor = new RS(() => this.view.getAnchorElement(), o.identityProvider), this.view = new TQ(e, t, r, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, DQ(() => this.model, o)), { tree: this })), this.model = this.createModel(e, this.view, o), a.input = this.model.onDidChangeCollapseState;
      const h = be.forEach(this.model.onDidSplice, (u) => {
        this.eventBufferer.bufferEvents(() => {
          this.focus.onDidModelSplice(u), this.selection.onDidModelSplice(u);
        });
      });
      if (h(() => null, null, this.disposables), l.input = be.chain(be.any(h, this.focus.onDidChange, this.selection.onDidChange)).debounce(() => null, 0).map(() => {
        const u = /* @__PURE__ */ new Set();
        for (const f of this.focus.getNodes())
          u.add(f);
        for (const f of this.selection.getNodes())
          u.add(f);
        return [...u.values()];
      }).event, o.keyboardSupport !== !1) {
        const u = be.chain(this.view.onKeyDown).filter((f) => !xc(f.target)).map((f) => new $t(f));
        u.filter((f) => f.keyCode === 15).on(this.onLeftArrow, this, this.disposables), u.filter((f) => f.keyCode === 17).on(this.onRightArrow, this, this.disposables), u.filter((f) => f.keyCode === 10).on(this.onSpace, this, this.disposables);
      }
      if (o.keyboardNavigationLabelProvider) {
        const u = o.keyboardNavigationDelegate || E3;
        this.typeFilterController = new EQ(this, this.model, this.view, d, u), this.focusNavigationFilter = (f) => this.typeFilterController.shouldAllowFocus(f), this.disposables.add(this.typeFilterController);
      }
      this.styleElement = Co(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === Cp.Always);
    }
    get onDidChangeFocus() {
      return this.eventBufferer.wrapEvent(this.focus.onDidChange);
    }
    get onDidChangeSelection() {
      return this.eventBufferer.wrapEvent(this.selection.onDidChange);
    }
    get onMouseDblClick() {
      return be.map(this.view.onMouseDblClick, ZM);
    }
    get onPointer() {
      return be.map(this.view.onPointer, ZM);
    }
    get onDidFocus() {
      return this.view.onDidFocus;
    }
    get onDidChangeModel() {
      return be.signal(this.model.onDidSplice);
    }
    get onDidChangeCollapseState() {
      return this.model.onDidChangeCollapseState;
    }
    get expandOnDoubleClick() {
      return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
    }
    get expandOnlyOnTwistieClick() {
      return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
    }
    get onDidDispose() {
      return this.view.onDidDispose;
    }
    updateOptions(e = {}) {
      this._options = Object.assign(Object.assign({}, this._options), e);
      for (const t of this.renderers)
        t.updateOptions(e);
      this.view.updateOptions(Object.assign(Object.assign({}, this._options), { enableKeyboardNavigation: this._options.simpleKeyboardNavigation })), this.typeFilterController && this.typeFilterController.updateOptions(this._options), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === Cp.Always);
    }
    get options() {
      return this._options;
    }
    getHTMLElement() {
      return this.view.getHTMLElement();
    }
    get scrollTop() {
      return this.view.scrollTop;
    }
    set scrollTop(e) {
      this.view.scrollTop = e;
    }
    domFocus() {
      this.view.domFocus();
    }
    layout(e, t) {
      this.view.layout(e, t);
    }
    style(e) {
      const t = `.${this.view.domId}`, i = [];
      e.treeIndentGuidesStroke && (i.push(`.monaco-list${t}:hover .monaco-tl-indent > .indent-guide, .monaco-list${t}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeIndentGuidesStroke.transparent(0.4)}; }`), i.push(`.monaco-list${t} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`)), this.styleElement.textContent = i.join(`
`), this.view.style(e);
    }
    getParentElement(e) {
      const t = this.model.getParentNodeLocation(e);
      return this.model.getNode(t).element;
    }
    getFirstElementChild(e) {
      return this.model.getFirstElementChild(e);
    }
    getNode(e) {
      return this.model.getNode(e);
    }
    collapse(e, t = !1) {
      return this.model.setCollapsed(e, !0, t);
    }
    expand(e, t = !1) {
      return this.model.setCollapsed(e, !1, t);
    }
    isCollapsible(e) {
      return this.model.isCollapsible(e);
    }
    setCollapsible(e, t) {
      return this.model.setCollapsible(e, t);
    }
    isCollapsed(e) {
      return this.model.isCollapsed(e);
    }
    refilter() {
      this._onWillRefilter.fire(void 0), this.model.refilter();
    }
    setSelection(e, t) {
      const i = e.map((o) => this.model.getNode(o));
      this.selection.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setSelection(n, t, !0);
    }
    getSelection() {
      return this.selection.get();
    }
    setFocus(e, t) {
      const i = e.map((o) => this.model.getNode(o));
      this.focus.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setFocus(n, t, !0);
    }
    focusNext(e = 1, t = !1, i, n = this.focusNavigationFilter) {
      this.view.focusNext(e, t, i, n);
    }
    getFocus() {
      return this.focus.get();
    }
    reveal(e, t) {
      this.model.expandTo(e);
      const i = this.model.getListIndex(e);
      i !== -1 && this.view.reveal(i, t);
    }
    getRelativeTop(e) {
      const t = this.model.getListIndex(e);
      return t === -1 ? null : this.view.getRelativeTop(t);
    }
    onLeftArrow(e) {
      e.preventDefault(), e.stopPropagation();
      const t = this.view.getFocusedElements();
      if (t.length === 0)
        return;
      const i = t[0], n = this.model.getNodeLocation(i);
      if (!this.model.setCollapsed(n, !0)) {
        const r = this.model.getParentNodeLocation(n);
        if (!r)
          return;
        const a = this.model.getListIndex(r);
        this.view.reveal(a), this.view.setFocus([a]);
      }
    }
    onRightArrow(e) {
      e.preventDefault(), e.stopPropagation();
      const t = this.view.getFocusedElements();
      if (t.length === 0)
        return;
      const i = t[0], n = this.model.getNodeLocation(i);
      if (!this.model.setCollapsed(n, !1)) {
        if (!i.children.some((l) => l.visible))
          return;
        const [r] = this.view.getFocus(), a = r + 1;
        this.view.reveal(a), this.view.setFocus([a]);
      }
    }
    onSpace(e) {
      e.preventDefault(), e.stopPropagation();
      const t = this.view.getFocusedElements();
      if (t.length === 0)
        return;
      const i = t[0], n = this.model.getNodeLocation(i), o = e.browserEvent.altKey;
      this.model.setCollapsed(n, void 0, o);
    }
    dispose() {
      at(this.disposables), this.view.dispose();
    }
  }
  class cN {
    constructor(e, t, i = {}) {
      this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new yQ(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
        compare(n, o) {
          return i.sorter.compare(n.element, o.element);
        }
      }), this.identityProvider = i.identityProvider;
    }
    setChildren(e, t = rt.empty(), i = {}) {
      const n = this.getElementLocation(e);
      this._setChildren(n, this.preserveCollapseState(t), i);
    }
    _setChildren(e, t = rt.empty(), i) {
      const n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = (l) => {
        var c;
        if (l.element === null)
          return;
        const d = l;
        if (n.add(d.element), this.nodes.set(d.element, d), this.identityProvider) {
          const h = this.identityProvider.getId(d.element).toString();
          o.add(h), this.nodesByIdentity.set(h, d);
        }
        (c = i.onDidCreateNode) === null || c === void 0 || c.call(i, d);
      }, a = (l) => {
        var c;
        if (l.element === null)
          return;
        const d = l;
        if (n.has(d.element) || this.nodes.delete(d.element), this.identityProvider) {
          const h = this.identityProvider.getId(d.element).toString();
          o.has(h) || this.nodesByIdentity.delete(h);
        }
        (c = i.onDidDeleteNode) === null || c === void 0 || c.call(i, d);
      };
      this.model.splice([...e, 0], Number.MAX_VALUE, t, Object.assign(Object.assign({}, i), { onDidCreateNode: r, onDidDeleteNode: a }));
    }
    preserveCollapseState(e = rt.empty()) {
      return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), rt.map(e, (t) => {
        let i = this.nodes.get(t.element);
        if (!i && this.identityProvider) {
          const r = this.identityProvider.getId(t.element).toString();
          i = this.nodesByIdentity.get(r);
        }
        if (!i)
          return Object.assign(Object.assign({}, t), { children: this.preserveCollapseState(t.children) });
        const n = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible, o = typeof t.collapsed < "u" ? t.collapsed : i.collapsed;
        return Object.assign(Object.assign({}, t), {
          collapsible: n,
          collapsed: o,
          children: this.preserveCollapseState(t.children)
        });
      });
    }
    rerender(e) {
      const t = this.getElementLocation(e);
      this.model.rerender(t);
    }
    getFirstElementChild(e = null) {
      const t = this.getElementLocation(e);
      return this.model.getFirstElementChild(t);
    }
    has(e) {
      return this.nodes.has(e);
    }
    getListIndex(e) {
      const t = this.getElementLocation(e);
      return this.model.getListIndex(t);
    }
    getListRenderCount(e) {
      const t = this.getElementLocation(e);
      return this.model.getListRenderCount(t);
    }
    isCollapsible(e) {
      const t = this.getElementLocation(e);
      return this.model.isCollapsible(t);
    }
    setCollapsible(e, t) {
      const i = this.getElementLocation(e);
      return this.model.setCollapsible(i, t);
    }
    isCollapsed(e) {
      const t = this.getElementLocation(e);
      return this.model.isCollapsed(t);
    }
    setCollapsed(e, t, i) {
      const n = this.getElementLocation(e);
      return this.model.setCollapsed(n, t, i);
    }
    expandTo(e) {
      const t = this.getElementLocation(e);
      this.model.expandTo(t);
    }
    refilter() {
      this.model.refilter();
    }
    getNode(e = null) {
      if (e === null)
        return this.model.getNode(this.model.rootRef);
      const t = this.nodes.get(e);
      if (!t)
        throw new lo(this.user, `Tree element not found: ${e}`);
      return t;
    }
    getNodeLocation(e) {
      return e.element;
    }
    getParentNodeLocation(e) {
      if (e === null)
        throw new lo(this.user, "Invalid getParentNodeLocation call");
      const t = this.nodes.get(e);
      if (!t)
        throw new lo(this.user, `Tree element not found: ${e}`);
      const i = this.model.getNodeLocation(t), n = this.model.getParentNodeLocation(i);
      return this.model.getNode(n).element;
    }
    getElementLocation(e) {
      if (e === null)
        return [];
      const t = this.nodes.get(e);
      if (!t)
        throw new lo(this.user, `Tree element not found: ${e}`);
      return this.model.getNodeLocation(t);
    }
  }
  function b0(s) {
    const e = [s.element], t = s.incompressible || !1;
    return {
      element: { elements: e, incompressible: t },
      children: rt.map(rt.from(s.children), b0),
      collapsible: s.collapsible,
      collapsed: s.collapsed
    };
  }
  function v0(s) {
    const e = [s.element], t = s.incompressible || !1;
    let i, n;
    for (; [n, i] = rt.consume(rt.from(s.children), 2), !(n.length !== 1 || n[0].incompressible); )
      s = n[0], e.push(s.element);
    return {
      element: { elements: e, incompressible: t },
      children: rt.map(rt.concat(n, i), v0),
      collapsible: s.collapsible,
      collapsed: s.collapsed
    };
  }
  function tk(s, e = 0) {
    let t;
    return e < s.element.elements.length - 1 ? t = [tk(s, e + 1)] : t = rt.map(rt.from(s.children), (i) => tk(i, 0)), e === 0 && s.element.incompressible ? {
      element: s.element.elements[e],
      children: t,
      incompressible: !0,
      collapsible: s.collapsible,
      collapsed: s.collapsed
    } : {
      element: s.element.elements[e],
      children: t,
      collapsible: s.collapsible,
      collapsed: s.collapsed
    };
  }
  function YM(s) {
    return tk(s, 0);
  }
  function F3(s, e, t) {
    return s.element === e ? Object.assign(Object.assign({}, s), { children: t }) : Object.assign(Object.assign({}, s), { children: rt.map(rt.from(s.children), (i) => F3(i, e, t)) });
  }
  const MQ = (s) => ({
    getId(e) {
      return e.elements.map((t) => s.getId(t).toString()).join("\0");
    }
  });
  class AQ {
    constructor(e, t, i = {}) {
      this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new cN(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
    }
    get onDidSplice() {
      return this.model.onDidSplice;
    }
    get onDidChangeCollapseState() {
      return this.model.onDidChangeCollapseState;
    }
    get onDidChangeRenderNodeCount() {
      return this.model.onDidChangeRenderNodeCount;
    }
    setChildren(e, t = rt.empty(), i) {
      const n = i.diffIdentityProvider && MQ(i.diffIdentityProvider);
      if (e === null) {
        const f = rt.map(t, this.enabled ? v0 : b0);
        this._setChildren(null, f, { diffIdentityProvider: n, diffDepth: 1 / 0 });
        return;
      }
      const o = this.nodes.get(e);
      if (!o)
        throw new Error("Unknown compressed tree node");
      const r = this.model.getNode(o), a = this.model.getParentNodeLocation(o), l = this.model.getNode(a), c = YM(r), d = F3(c, e, t), h = (this.enabled ? v0 : b0)(d), u = l.children.map((f) => f === r ? h : f);
      this._setChildren(l.element, u, {
        diffIdentityProvider: n,
        diffDepth: r.depth - l.depth
      });
    }
    setCompressionEnabled(e) {
      if (e === this.enabled)
        return;
      this.enabled = e;
      const i = this.model.getNode().children, n = rt.map(i, YM), o = rt.map(n, e ? v0 : b0);
      this._setChildren(null, o, {
        diffIdentityProvider: this.identityProvider,
        diffDepth: 1 / 0
      });
    }
    _setChildren(e, t, i) {
      const n = /* @__PURE__ */ new Set(), o = (a) => {
        for (const l of a.element.elements)
          n.add(l), this.nodes.set(l, a.element);
      }, r = (a) => {
        for (const l of a.element.elements)
          n.has(l) || this.nodes.delete(l);
      };
      this.model.setChildren(e, t, Object.assign(Object.assign({}, i), { onDidCreateNode: o, onDidDeleteNode: r }));
    }
    has(e) {
      return this.nodes.has(e);
    }
    getListIndex(e) {
      const t = this.getCompressedNode(e);
      return this.model.getListIndex(t);
    }
    getListRenderCount(e) {
      const t = this.getCompressedNode(e);
      return this.model.getListRenderCount(t);
    }
    getNode(e) {
      if (typeof e > "u")
        return this.model.getNode();
      const t = this.getCompressedNode(e);
      return this.model.getNode(t);
    }
    getNodeLocation(e) {
      const t = this.model.getNodeLocation(e);
      return t === null ? null : t.elements[t.elements.length - 1];
    }
    getParentNodeLocation(e) {
      const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
      return i === null ? null : i.elements[i.elements.length - 1];
    }
    getFirstElementChild(e) {
      const t = this.getCompressedNode(e);
      return this.model.getFirstElementChild(t);
    }
    isCollapsible(e) {
      const t = this.getCompressedNode(e);
      return this.model.isCollapsible(t);
    }
    setCollapsible(e, t) {
      const i = this.getCompressedNode(e);
      return this.model.setCollapsible(i, t);
    }
    isCollapsed(e) {
      const t = this.getCompressedNode(e);
      return this.model.isCollapsed(t);
    }
    setCollapsed(e, t, i) {
      const n = this.getCompressedNode(e);
      return this.model.setCollapsed(n, t, i);
    }
    expandTo(e) {
      const t = this.getCompressedNode(e);
      this.model.expandTo(t);
    }
    rerender(e) {
      const t = this.getCompressedNode(e);
      this.model.rerender(t);
    }
    refilter() {
      this.model.refilter();
    }
    getCompressedNode(e) {
      if (e === null)
        return null;
      const t = this.nodes.get(e);
      if (!t)
        throw new lo(this.user, `Tree element not found: ${e}`);
      return t;
    }
  }
  const RQ = (s) => s[s.length - 1];
  class dN {
    constructor(e, t) {
      this.unwrapper = e, this.node = t;
    }
    get element() {
      return this.node.element === null ? null : this.unwrapper(this.node.element);
    }
    get children() {
      return this.node.children.map((e) => new dN(this.unwrapper, e));
    }
    get depth() {
      return this.node.depth;
    }
    get visibleChildrenCount() {
      return this.node.visibleChildrenCount;
    }
    get visibleChildIndex() {
      return this.node.visibleChildIndex;
    }
    get collapsible() {
      return this.node.collapsible;
    }
    get collapsed() {
      return this.node.collapsed;
    }
    get visible() {
      return this.node.visible;
    }
    get filterData() {
      return this.node.filterData;
    }
  }
  function OQ(s, e) {
    return {
      splice(t, i, n) {
        e.splice(t, i, n.map((o) => s.map(o)));
      },
      updateElementHeight(t, i) {
        e.updateElementHeight(t, i);
      }
    };
  }
  function PQ(s, e) {
    return Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(s(t));
      }
    }, sorter: e.sorter && {
      compare(t, i) {
        return e.sorter.compare(t.elements[0], i.elements[0]);
      }
    }, filter: e.filter && {
      filter(t, i) {
        return e.filter.filter(s(t), i);
      }
    } });
  }
  class FQ {
    constructor(e, t, i = {}) {
      this.rootRef = null, this.elementMapper = i.elementMapper || RQ;
      const n = (o) => this.elementMapper(o.elements);
      this.nodeMapper = new rN((o) => new dN(n, o)), this.model = new AQ(e, OQ(this.nodeMapper, t), PQ(n, i));
    }
    get onDidSplice() {
      return be.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
        insertedNodes: e.map((i) => this.nodeMapper.map(i)),
        deletedNodes: t.map((i) => this.nodeMapper.map(i))
      }));
    }
    get onDidChangeCollapseState() {
      return be.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
        node: this.nodeMapper.map(e),
        deep: t
      }));
    }
    get onDidChangeRenderNodeCount() {
      return be.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
    }
    setChildren(e, t = rt.empty(), i = {}) {
      this.model.setChildren(e, t, i);
    }
    setCompressionEnabled(e) {
      this.model.setCompressionEnabled(e);
    }
    has(e) {
      return this.model.has(e);
    }
    getListIndex(e) {
      return this.model.getListIndex(e);
    }
    getListRenderCount(e) {
      return this.model.getListRenderCount(e);
    }
    getNode(e) {
      return this.nodeMapper.map(this.model.getNode(e));
    }
    getNodeLocation(e) {
      return e.element;
    }
    getParentNodeLocation(e) {
      return this.model.getParentNodeLocation(e);
    }
    getFirstElementChild(e) {
      const t = this.model.getFirstElementChild(e);
      return t === null || typeof t > "u" ? t : this.elementMapper(t.elements);
    }
    isCollapsible(e) {
      return this.model.isCollapsible(e);
    }
    setCollapsible(e, t) {
      return this.model.setCollapsible(e, t);
    }
    isCollapsed(e) {
      return this.model.isCollapsed(e);
    }
    setCollapsed(e, t, i) {
      return this.model.setCollapsed(e, t, i);
    }
    expandTo(e) {
      return this.model.expandTo(e);
    }
    rerender(e) {
      return this.model.rerender(e);
    }
    refilter() {
      return this.model.refilter();
    }
    getCompressedTreeNode(e = null) {
      return this.model.getNode(e);
    }
  }
  var BQ = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  };
  class hN extends P3 {
    constructor(e, t, i, n, o = {}) {
      super(e, t, i, n, o), this.user = e;
    }
    get onDidChangeCollapseState() {
      return this.model.onDidChangeCollapseState;
    }
    setChildren(e, t = rt.empty(), i) {
      this.model.setChildren(e, t, i);
    }
    rerender(e) {
      if (e === void 0) {
        this.view.rerender();
        return;
      }
      this.model.rerender(e);
    }
    hasElement(e) {
      return this.model.has(e);
    }
    createModel(e, t, i) {
      return new cN(e, t, i);
    }
  }
  class B3 {
    constructor(e, t) {
      this._compressedTreeNodeProvider = e, this.renderer = t, this.templateId = t.templateId, t.onDidChangeTwistieState && (this.onDidChangeTwistieState = t.onDidChangeTwistieState);
    }
    get compressedTreeNodeProvider() {
      return this._compressedTreeNodeProvider();
    }
    renderTemplate(e) {
      const t = this.renderer.renderTemplate(e);
      return { compressedTreeNode: void 0, data: t };
    }
    renderElement(e, t, i, n) {
      const o = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element);
      o.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, n)) : (i.compressedTreeNode = o, this.renderer.renderCompressedElements(o, t, i.data, n));
    }
    disposeElement(e, t, i, n) {
      i.compressedTreeNode ? this.renderer.disposeCompressedElements && this.renderer.disposeCompressedElements(i.compressedTreeNode, t, i.data, n) : this.renderer.disposeElement && this.renderer.disposeElement(e, t, i.data, n);
    }
    disposeTemplate(e) {
      this.renderer.disposeTemplate(e.data);
    }
    renderTwistie(e, t) {
      return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
    }
  }
  BQ([
    Ai
  ], B3.prototype, "compressedTreeNodeProvider", null);
  function WQ(s, e) {
    return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      getKeyboardNavigationLabel(t) {
        let i;
        try {
          i = s().getCompressedTreeNode(t);
        } catch {
          return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
        }
        return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
      }
    } });
  }
  class W3 extends hN {
    constructor(e, t, i, n, o = {}) {
      const r = () => this, a = n.map((l) => new B3(r, l));
      super(e, t, i, a, WQ(r, o));
    }
    setChildren(e, t = rt.empty(), i) {
      this.model.setChildren(e, t, i);
    }
    createModel(e, t, i) {
      return new FQ(e, t, i);
    }
    updateOptions(e = {}) {
      super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
    }
    getCompressedTreeNode(e = null) {
      return this.model.getCompressedTreeNode(e);
    }
  }
  var Nl = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function OS(s) {
    return Object.assign(Object.assign({}, s), { children: [], refreshPromise: void 0, stale: !0, slow: !1, collapsedByDefault: void 0 });
  }
  function ik(s, e) {
    return e.parent ? e.parent === s ? !0 : ik(s, e.parent) : !1;
  }
  function VQ(s, e) {
    return s === e || ik(s, e) || ik(e, s);
  }
  class uN {
    constructor(e) {
      this.node = e;
    }
    get element() {
      return this.node.element.element;
    }
    get children() {
      return this.node.children.map((e) => new uN(e));
    }
    get depth() {
      return this.node.depth;
    }
    get visibleChildrenCount() {
      return this.node.visibleChildrenCount;
    }
    get visibleChildIndex() {
      return this.node.visibleChildIndex;
    }
    get collapsible() {
      return this.node.collapsible;
    }
    get collapsed() {
      return this.node.collapsed;
    }
    get visible() {
      return this.node.visible;
    }
    get filterData() {
      return this.node.filterData;
    }
  }
  class HQ {
    constructor(e, t, i) {
      this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
    }
    renderTemplate(e) {
      return { templateData: this.renderer.renderTemplate(e) };
    }
    renderElement(e, t, i, n) {
      this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
    }
    renderTwistie(e, t) {
      return e.slow ? (t.classList.add(...p.treeItemLoading.classNamesArray), !0) : (t.classList.remove(...p.treeItemLoading.classNamesArray), !1);
    }
    disposeElement(e, t, i, n) {
      this.renderer.disposeElement && this.renderer.disposeElement(this.nodeMapper.map(e), t, i.templateData, n);
    }
    disposeTemplate(e) {
      this.renderer.disposeTemplate(e.templateData);
    }
    dispose() {
      this.renderedNodes.clear();
    }
  }
  function XM(s) {
    return {
      browserEvent: s.browserEvent,
      elements: s.elements.map((e) => e.element)
    };
  }
  function QM(s) {
    return {
      browserEvent: s.browserEvent,
      element: s.element && s.element.element,
      target: s.target
    };
  }
  class zQ extends b_ {
    constructor(e) {
      super(e.elements.map((t) => t.element)), this.data = e;
    }
  }
  function PS(s) {
    return s instanceof b_ ? new zQ(s) : s;
  }
  class UQ {
    constructor(e) {
      this.dnd = e;
    }
    getDragURI(e) {
      return this.dnd.getDragURI(e.element);
    }
    getDragLabel(e, t) {
      if (this.dnd.getDragLabel)
        return this.dnd.getDragLabel(e.map((i) => i.element), t);
    }
    onDragStart(e, t) {
      this.dnd.onDragStart && this.dnd.onDragStart(PS(e), t);
    }
    onDragOver(e, t, i, n, o = !0) {
      return this.dnd.onDragOver(PS(e), t && t.element, i, n);
    }
    drop(e, t, i, n) {
      this.dnd.drop(PS(e), t && t.element, i, n);
    }
    onDragEnd(e) {
      this.dnd.onDragEnd && this.dnd.onDragEnd(e);
    }
  }
  function V3(s) {
    return s && Object.assign(Object.assign({}, s), { collapseByDefault: !0, identityProvider: s.identityProvider && {
      getId(e) {
        return s.identityProvider.getId(e.element);
      }
    }, dnd: s.dnd && new UQ(s.dnd), multipleSelectionController: s.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return s.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
      },
      isSelectionRangeChangeEvent(e) {
        return s.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
      }
    }, accessibilityProvider: s.accessibilityProvider && Object.assign(Object.assign({}, s.accessibilityProvider), {
      getPosInSet: void 0,
      getSetSize: void 0,
      getRole: s.accessibilityProvider.getRole ? (e) => s.accessibilityProvider.getRole(e.element) : () => "treeitem",
      isChecked: s.accessibilityProvider.isChecked ? (e) => {
        var t;
        return !!(!((t = s.accessibilityProvider) === null || t === void 0) && t.isChecked(e.element));
      } : void 0,
      getAriaLabel(e) {
        return s.accessibilityProvider.getAriaLabel(e.element);
      },
      getWidgetAriaLabel() {
        return s.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: s.accessibilityProvider.getWidgetRole ? () => s.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: s.accessibilityProvider.getAriaLevel && ((e) => s.accessibilityProvider.getAriaLevel(e.element)),
      getActiveDescendantId: s.accessibilityProvider.getActiveDescendantId && ((e) => s.accessibilityProvider.getActiveDescendantId(e.element))
    }), filter: s.filter && {
      filter(e, t) {
        return s.filter.filter(e.element, t);
      }
    }, keyboardNavigationLabelProvider: s.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, s.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {
      return s.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
    } }), sorter: void 0, expandOnlyOnTwistieClick: typeof s.expandOnlyOnTwistieClick > "u" ? void 0 : typeof s.expandOnlyOnTwistieClick != "function" ? s.expandOnlyOnTwistieClick : (e) => s.expandOnlyOnTwistieClick(e.element), additionalScrollHeight: s.additionalScrollHeight });
  }
  function nk(s, e) {
    e(s), s.children.forEach((t) => nk(t, e));
  }
  class H3 {
    constructor(e, t, i, n, o, r = {}) {
      this.user = e, this.dataSource = o, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new B(), this._onDidChangeNodeSlowState = new B(), this.nodeMapper = new rN((a) => new uN(a)), this.disposables = new te(), this.identityProvider = r.identityProvider, this.autoExpandSingleChildren = typeof r.autoExpandSingleChildren > "u" ? !1 : r.autoExpandSingleChildren, this.sorter = r.sorter, this.collapseByDefault = r.collapseByDefault, this.tree = this.createTree(e, t, i, n, r), this.root = OS({
        element: void 0,
        parent: null,
        hasChildren: !0
      }), this.identityProvider && (this.root = Object.assign(Object.assign({}, this.root), { id: null })), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
    }
    get onDidChangeFocus() {
      return be.map(this.tree.onDidChangeFocus, XM);
    }
    get onDidChangeSelection() {
      return be.map(this.tree.onDidChangeSelection, XM);
    }
    get onMouseDblClick() {
      return be.map(this.tree.onMouseDblClick, QM);
    }
    get onPointer() {
      return be.map(this.tree.onPointer, QM);
    }
    get onDidFocus() {
      return this.tree.onDidFocus;
    }
    get onDidChangeModel() {
      return this.tree.onDidChangeModel;
    }
    get onDidChangeCollapseState() {
      return this.tree.onDidChangeCollapseState;
    }
    get onDidDispose() {
      return this.tree.onDidDispose;
    }
    createTree(e, t, i, n, o) {
      const r = new lN(i), a = n.map((c) => new HQ(c, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = V3(o) || {};
      return new hN(e, t, r, a, l);
    }
    updateOptions(e = {}) {
      this.tree.updateOptions(e);
    }
    getHTMLElement() {
      return this.tree.getHTMLElement();
    }
    get scrollTop() {
      return this.tree.scrollTop;
    }
    set scrollTop(e) {
      this.tree.scrollTop = e;
    }
    domFocus() {
      this.tree.domFocus();
    }
    layout(e, t) {
      this.tree.layout(e, t);
    }
    style(e) {
      this.tree.style(e);
    }
    getInput() {
      return this.root.element;
    }
    setInput(e, t) {
      return Nl(this, void 0, void 0, function* () {
        this.refreshPromises.forEach((n) => n.cancel()), this.refreshPromises.clear(), this.root.element = e;
        const i = t && { viewState: t, focus: [], selection: [] };
        yield this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
      });
    }
    _updateChildren(e = this.root.element, t = !0, i = !1, n, o) {
      return Nl(this, void 0, void 0, function* () {
        if (typeof this.root.element > "u")
          throw new lo(this.user, "Tree input not set");
        this.root.refreshPromise && (yield this.root.refreshPromise, yield be.toPromise(this._onDidRender.event));
        const r = this.getDataNode(e);
        if (yield this.refreshAndRenderNode(r, t, n, o), i)
          try {
            this.tree.rerender(r);
          } catch {
          }
      });
    }
    rerender(e) {
      if (e === void 0 || e === this.root.element) {
        this.tree.rerender();
        return;
      }
      const t = this.getDataNode(e);
      this.tree.rerender(t);
    }
    getNode(e = this.root.element) {
      const t = this.getDataNode(e), i = this.tree.getNode(t === this.root ? null : t);
      return this.nodeMapper.map(i);
    }
    collapse(e, t = !1) {
      const i = this.getDataNode(e);
      return this.tree.collapse(i === this.root ? null : i, t);
    }
    expand(e, t = !1) {
      return Nl(this, void 0, void 0, function* () {
        if (typeof this.root.element > "u")
          throw new lo(this.user, "Tree input not set");
        this.root.refreshPromise && (yield this.root.refreshPromise, yield be.toPromise(this._onDidRender.event));
        const i = this.getDataNode(e);
        if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (yield this.root.refreshPromise, yield be.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
          return !1;
        const n = this.tree.expand(i === this.root ? null : i, t);
        return i.refreshPromise && (yield this.root.refreshPromise, yield be.toPromise(this._onDidRender.event)), n;
      });
    }
    setSelection(e, t) {
      const i = e.map((n) => this.getDataNode(n));
      this.tree.setSelection(i, t);
    }
    getSelection() {
      return this.tree.getSelection().map((t) => t.element);
    }
    setFocus(e, t) {
      const i = e.map((n) => this.getDataNode(n));
      this.tree.setFocus(i, t);
    }
    getFocus() {
      return this.tree.getFocus().map((t) => t.element);
    }
    reveal(e, t) {
      this.tree.reveal(this.getDataNode(e), t);
    }
    getParentElement(e) {
      const t = this.tree.getParentElement(this.getDataNode(e));
      return t && t.element;
    }
    getFirstElementChild(e = this.root.element) {
      const t = this.getDataNode(e), i = this.tree.getFirstElementChild(t === this.root ? null : t);
      return i && i.element;
    }
    getDataNode(e) {
      const t = this.nodes.get(e === this.root.element ? null : e);
      if (!t)
        throw new lo(this.user, `Data tree node not found: ${e}`);
      return t;
    }
    refreshAndRenderNode(e, t, i, n) {
      return Nl(this, void 0, void 0, function* () {
        yield this.refreshNode(e, t, i), this.render(e, i, n);
      });
    }
    refreshNode(e, t, i) {
      return Nl(this, void 0, void 0, function* () {
        let n;
        return this.subTreeRefreshPromises.forEach((o, r) => {
          !n && VQ(r, e) && (n = o.then(() => this.refreshNode(e, t, i)));
        }), n || this.doRefreshSubTree(e, t, i);
      });
    }
    doRefreshSubTree(e, t, i) {
      return Nl(this, void 0, void 0, function* () {
        let n;
        e.refreshPromise = new Promise((o) => n = o), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
          e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
        });
        try {
          const o = yield this.doRefreshNode(e, t, i);
          e.stale = !1, yield Ky.settled(o.map((r) => this.doRefreshSubTree(r, t, i)));
        } finally {
          n();
        }
      });
    }
    doRefreshNode(e, t, i) {
      return Nl(this, void 0, void 0, function* () {
        e.hasChildren = !!this.dataSource.hasChildren(e.element);
        let n;
        if (!e.hasChildren)
          n = Promise.resolve(rt.empty());
        else {
          const o = this.doGetChildren(e);
          if (N2(o))
            n = Promise.resolve(o);
          else {
            const r = gc(800);
            r.then(() => {
              e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
            }, (a) => null), n = o.finally(() => r.cancel());
          }
        }
        try {
          const o = yield n;
          return this.setChildren(e, o, t, i);
        } catch (o) {
          if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), va(o))
            return [];
          throw o;
        } finally {
          e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
        }
      });
    }
    doGetChildren(e) {
      let t = this.refreshPromises.get(e);
      if (t)
        return t;
      const i = this.dataSource.getChildren(e.element);
      return N2(i) ? this.processChildren(i) : (t = an(() => Nl(this, void 0, void 0, function* () {
        return this.processChildren(yield i);
      })), this.refreshPromises.set(e, t), t.finally(() => {
        this.refreshPromises.delete(e);
      }));
    }
    _onDidChangeCollapseState({ node: e, deep: t }) {
      e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(We));
    }
    setChildren(e, t, i, n) {
      const o = [...t];
      if (e.children.length === 0 && o.length === 0)
        return [];
      const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
      for (const d of e.children)
        if (r.set(d.element, d), this.identityProvider) {
          const h = this.tree.isCollapsed(d);
          a.set(d.id, { node: d, collapsed: h });
        }
      const l = [], c = o.map((d) => {
        const h = !!this.dataSource.hasChildren(d);
        if (!this.identityProvider) {
          const _ = OS({ element: d, parent: e, hasChildren: h });
          return h && this.collapseByDefault && !this.collapseByDefault(d) && (_.collapsedByDefault = !1, l.push(_)), _;
        }
        const u = this.identityProvider.getId(d).toString(), f = a.get(u);
        if (f) {
          const _ = f.node;
          return r.delete(_.element), this.nodes.delete(_.element), this.nodes.set(d, _), _.element = d, _.hasChildren = h, i ? f.collapsed ? (_.children.forEach((b) => nk(b, (C) => this.nodes.delete(C.element))), _.children.splice(0, _.children.length), _.stale = !0) : l.push(_) : h && this.collapseByDefault && !this.collapseByDefault(d) && (_.collapsedByDefault = !1, l.push(_)), _;
        }
        const g = OS({ element: d, parent: e, id: u, hasChildren: h });
        return n && n.viewState.focus && n.viewState.focus.indexOf(u) > -1 && n.focus.push(g), n && n.viewState.selection && n.viewState.selection.indexOf(u) > -1 && n.selection.push(g), n && n.viewState.expanded && n.viewState.expanded.indexOf(u) > -1 ? l.push(g) : h && this.collapseByDefault && !this.collapseByDefault(d) && (g.collapsedByDefault = !1, l.push(g)), g;
      });
      for (const d of r.values())
        nk(d, (h) => this.nodes.delete(h.element));
      for (const d of c)
        this.nodes.set(d.element, d);
      return e.children.splice(0, e.children.length, ...c), e !== this.root && this.autoExpandSingleChildren && c.length === 1 && l.length === 0 && (c[0].collapsedByDefault = !1, l.push(c[0])), l;
    }
    render(e, t, i) {
      const n = e.children.map((r) => this.asTreeElement(r, t)), o = i && Object.assign(Object.assign({}, i), { diffIdentityProvider: i.diffIdentityProvider && {
        getId(r) {
          return i.diffIdentityProvider.getId(r.element);
        }
      } });
      this.tree.setChildren(e === this.root ? null : e, n, o), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
    }
    asTreeElement(e, t) {
      if (e.stale)
        return {
          element: e,
          collapsible: e.hasChildren,
          collapsed: !0
        };
      let i;
      return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : i = e.collapsedByDefault, e.collapsedByDefault = void 0, {
        element: e,
        children: e.hasChildren ? rt.map(e.children, (n) => this.asTreeElement(n, t)) : [],
        collapsible: e.hasChildren,
        collapsed: i
      };
    }
    processChildren(e) {
      return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
    }
    dispose() {
      this.disposables.dispose();
    }
  }
  class fN {
    constructor(e) {
      this.node = e;
    }
    get element() {
      return {
        elements: this.node.element.elements.map((e) => e.element),
        incompressible: this.node.element.incompressible
      };
    }
    get children() {
      return this.node.children.map((e) => new fN(e));
    }
    get depth() {
      return this.node.depth;
    }
    get visibleChildrenCount() {
      return this.node.visibleChildrenCount;
    }
    get visibleChildIndex() {
      return this.node.visibleChildIndex;
    }
    get collapsible() {
      return this.node.collapsible;
    }
    get collapsed() {
      return this.node.collapsed;
    }
    get visible() {
      return this.node.visible;
    }
    get filterData() {
      return this.node.filterData;
    }
  }
  class $Q {
    constructor(e, t, i, n) {
      this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = n, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
    }
    renderTemplate(e) {
      return { templateData: this.renderer.renderTemplate(e) };
    }
    renderElement(e, t, i, n) {
      this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
    }
    renderCompressedElements(e, t, i, n) {
      this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
    }
    renderTwistie(e, t) {
      return e.slow ? (t.classList.add(...p.treeItemLoading.classNamesArray), !0) : (t.classList.remove(...p.treeItemLoading.classNamesArray), !1);
    }
    disposeElement(e, t, i, n) {
      this.renderer.disposeElement && this.renderer.disposeElement(this.nodeMapper.map(e), t, i.templateData, n);
    }
    disposeCompressedElements(e, t, i, n) {
      this.renderer.disposeCompressedElements && this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
    }
    disposeTemplate(e) {
      this.renderer.disposeTemplate(e.templateData);
    }
    dispose() {
      this.renderedNodes.clear(), this.disposables = at(this.disposables);
    }
  }
  function jQ(s) {
    const e = s && V3(s);
    return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(t) {
      return s.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
    } }) });
  }
  class KQ extends H3 {
    constructor(e, t, i, n, o, r, a = {}) {
      super(e, t, i, o, r, a), this.compressionDelegate = n, this.compressibleNodeMapper = new rN((l) => new fN(l)), this.filter = a.filter;
    }
    createTree(e, t, i, n, o) {
      const r = new lN(i), a = n.map((c) => new $Q(c, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = jQ(o) || {};
      return new W3(e, t, r, a, l);
    }
    asTreeElement(e, t) {
      return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(e.element) }, super.asTreeElement(e, t));
    }
    updateOptions(e = {}) {
      this.tree.updateOptions(e);
    }
    render(e, t) {
      if (!this.identityProvider)
        return super.render(e, t);
      const i = (u) => this.identityProvider.getId(u).toString(), n = (u) => {
        const f = /* @__PURE__ */ new Set();
        for (const g of u) {
          const _ = this.tree.getCompressedTreeNode(g === this.root ? null : g);
          if (!!_.element)
            for (const b of _.element.elements)
              f.add(i(b.element));
        }
        return f;
      }, o = n(this.tree.getSelection()), r = n(this.tree.getFocus());
      super.render(e, t);
      const a = this.getSelection();
      let l = !1;
      const c = this.getFocus();
      let d = !1;
      const h = (u) => {
        const f = u.element;
        if (f)
          for (let g = 0; g < f.elements.length; g++) {
            const _ = i(f.elements[g].element), b = f.elements[f.elements.length - 1].element;
            o.has(_) && a.indexOf(b) === -1 && (a.push(b), l = !0), r.has(_) && c.indexOf(b) === -1 && (c.push(b), d = !0);
          }
        u.children.forEach(h);
      };
      h(this.tree.getCompressedTreeNode(e === this.root ? null : e)), l && this.setSelection(a), d && this.setFocus(c);
    }
    processChildren(e) {
      return this.filter && (e = rt.filter(e, (t) => {
        const i = this.filter.filter(t, 1), n = qQ(i);
        if (n === 2)
          throw new Error("Recursive tree visibility not supported in async data compressed trees");
        return n === 1;
      })), super.processChildren(e);
    }
  }
  function qQ(s) {
    return typeof s == "boolean" ? s ? 1 : 0 : aN(s) ? vp(s.visibility) : vp(s);
  }
  class GQ extends P3 {
    constructor(e, t, i, n, o, r = {}) {
      super(e, t, i, n, r), this.user = e, this.dataSource = o, this.identityProvider = r.identityProvider;
    }
    createModel(e, t, i) {
      return new cN(e, t, i);
    }
  }
  new ue("isMac", Ye, m("isMac", "Whether the operating system is macOS"));
  new ue("isLinux", Nn, m("isLinux", "Whether the operating system is Linux"));
  const IC = new ue("isWindows", rn, m("isWindows", "Whether the operating system is Windows"));
  new ue("isWeb", Pc, m("isWeb", "Whether the platform is a web browser"));
  new ue("isMacNative", Ye && !Pc, m("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
  new ue("isIOS", aa, m("isIOS", "Whether the operating system is iOS"));
  new ue("isDevelopment", !1, !0);
  const z3 = "inputFocus";
  new ue(z3, !1, m("inputFocus", "Whether keyboard focus is inside an input box"));
  function or(s, e) {
    const t = /* @__PURE__ */ Object.create(null);
    for (let i in e) {
      const n = e[i];
      n && (t[i] = Wa(n, s));
    }
    return t;
  }
  function gN(s, e, t) {
    function i() {
      const n = or(s.getColorTheme(), e);
      typeof t == "function" ? t(n) : t.style(n);
    }
    return i(), s.onDidColorThemeChange(i);
  }
  function ZQ(s, e, t) {
    return gN(e, {
      badgeBackground: t?.badgeBackground || rm,
      badgeForeground: t?.badgeForeground || am,
      badgeBorder: qt
    }, s);
  }
  function rh(s, e, t) {
    return gN(e, Object.assign(Object.assign({}, EC), t || {}), s);
  }
  const EC = {
    listFocusBackground: sU,
    listFocusForeground: oU,
    listFocusOutline: rU,
    listActiveSelectionBackground: rc,
    listActiveSelectionForeground: ac,
    listActiveSelectionIconForeground: r0,
    listFocusAndSelectionBackground: rc,
    listFocusAndSelectionForeground: ac,
    listInactiveSelectionBackground: aU,
    listInactiveSelectionIconForeground: cU,
    listInactiveSelectionForeground: lU,
    listInactiveFocusBackground: dU,
    listInactiveFocusOutline: hU,
    listHoverBackground: uU,
    listHoverForeground: fU,
    listDropBackground: gU,
    listSelectionOutline: Bn,
    listHoverOutline: Bn,
    listFilterWidgetBackground: mU,
    listFilterWidgetOutline: pU,
    listFilterWidgetNoMatchesOutline: _U,
    listMatchesShadow: wc,
    treeIndentGuidesStroke: bU,
    tableColumnsBorder: vU,
    tableOddRowsBackgroundColor: CU
  }, YQ = {
    shadowColor: wc,
    borderColor: wU,
    foregroundColor: SU,
    backgroundColor: yU,
    selectionForegroundColor: LU,
    selectionBackgroundColor: kU,
    selectionBorderColor: DU,
    separatorColor: xU,
    scrollbarShadow: sg,
    scrollbarSliderBackground: qu,
    scrollbarSliderHoverBackground: Gu,
    scrollbarSliderActiveBackground: Zu
  };
  function XQ(s, e, t) {
    return gN(e, Object.assign(Object.assign({}, YQ), t), s);
  }
  var Da = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Xe = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Eo = st("listService");
  let sk = class {
    constructor(e) {
      this._themeService = e, this.disposables = new te(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
    }
    get lastFocusedList() {
      return this._lastFocusedWidget;
    }
    setLastFocusedList(e) {
      var t, i;
      e !== this._lastFocusedWidget && ((t = this._lastFocusedWidget) === null || t === void 0 || t.getHTMLElement().classList.remove("last-focused"), this._lastFocusedWidget = e, (i = this._lastFocusedWidget) === null || i === void 0 || i.getHTMLElement().classList.add("last-focused"));
    }
    register(e, t) {
      if (!this._hasCreatedStyleController) {
        this._hasCreatedStyleController = !0;
        const n = new A3(Co(), "");
        this.disposables.add(rh(n, this._themeService));
      }
      if (this.lists.some((n) => n.widget === e))
        throw new Error("Cannot register the same widget multiple times");
      const i = { widget: e, extraContextKeys: t };
      return this.lists.push(i), e.getHTMLElement() === document.activeElement && this.setLastFocusedList(e), ol(e.onDidFocus(() => this.setLastFocusedList(e)), qe(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
        this.lists = this.lists.filter((n) => n !== i), this._lastFocusedWidget === e && this.setLastFocusedList(void 0);
      }));
    }
    dispose() {
      this.disposables.dispose();
    }
  };
  sk = Da([
    Xe(0, jt)
  ], sk);
  const U3 = new ue("listFocus", !0), NC = new ue("listSupportsMultiselect", !0), $3 = ce.and(U3, ce.not(z3)), mN = new ue("listHasSelectionOrFocus", !1), pN = new ue("listDoubleSelection", !1), _N = new ue("listMultiSelection", !1), TC = new ue("listSelectionNavigation", !1), bN = new ue("treeElementCanCollapse", !1), QQ = new ue("treeElementHasParent", !1), vN = new ue("treeElementCanExpand", !1), JQ = new ue("treeElementHasChild", !1), j3 = "listAutomaticKeyboardNavigation";
  function MC(s, e) {
    const t = s.createScoped(e.getHTMLElement());
    return U3.bindTo(t), t;
  }
  const zh = "workbench.list.multiSelectModifier", ok = "workbench.list.openMode", bo = "workbench.list.horizontalScrolling", O1 = "workbench.list.keyboardNavigation", CN = "workbench.list.automaticKeyboardNavigation", Sp = "workbench.tree.indent", P1 = "workbench.tree.renderIndentGuides", Cr = "workbench.list.smoothScrolling", ma = "workbench.list.mouseWheelScrollSensitivity", pa = "workbench.list.fastScrollSensitivity", F1 = "workbench.tree.expandMode";
  function _a(s) {
    return s.getValue(zh) === "alt";
  }
  class eJ extends z {
    constructor(e) {
      super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = _a(e), this.registerListeners();
    }
    registerListeners() {
      this._register(this.configurationService.onDidChangeConfiguration((e) => {
        e.affectsConfiguration(zh) && (this.useAltAsMultipleSelectionModifier = _a(this.configurationService));
      }));
    }
    isSelectionSingleChangeEvent(e) {
      return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : N3(e);
    }
    isSelectionRangeChangeEvent(e) {
      return T3(e);
    }
  }
  function AC(s, e, t) {
    var i;
    const n = new te();
    return [Object.assign(Object.assign({}, s), { keyboardNavigationDelegate: { mightProducePrintableCharacter(r) {
      return t.mightProducePrintableCharacter(r);
    } }, smoothScrolling: Boolean(e.getValue(Cr)), mouseWheelScrollSensitivity: e.getValue(ma), fastScrollSensitivity: e.getValue(pa), multipleSelectionController: (i = s.multipleSelectionController) !== null && i !== void 0 ? i : n.add(new eJ(e)) }), n];
  }
  let rk = class extends ka {
    constructor(e, t, i, n, o, r, a, l, c, d) {
      const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : Boolean(c.getValue(bo)), [u, f] = AC(o, c, d);
      super(e, t, i, n, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, or(l.getColorTheme(), EC)), u), { horizontalScrolling: h })), this.disposables.add(f), this.contextKeyService = MC(r, this), this.themeService = l, this.listSupportsMultiSelect = NC.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), TC.bindTo(this.contextKeyService).set(Boolean(o.selectionNavigation)), this.listHasSelectionOrFocus = mN.bindTo(this.contextKeyService), this.listDoubleSelection = pN.bindTo(this.contextKeyService), this.listMultiSelection = _N.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = _a(c), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), o.overrideStyles && this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
        const _ = this.getSelection(), b = this.getFocus();
        this.contextKeyService.bufferChangeEvents(() => {
          this.listHasSelectionOrFocus.set(_.length > 0 || b.length > 0), this.listMultiSelection.set(_.length > 1), this.listDoubleSelection.set(_.length === 2);
        });
      })), this.disposables.add(this.onDidChangeFocus(() => {
        const _ = this.getSelection(), b = this.getFocus();
        this.listHasSelectionOrFocus.set(_.length > 0 || b.length > 0);
      })), this.disposables.add(c.onDidChangeConfiguration((_) => {
        _.affectsConfiguration(zh) && (this._useAltAsMultipleSelectionModifier = _a(c));
        let b = {};
        if (_.affectsConfiguration(bo) && this.horizontalScrolling === void 0) {
          const C = Boolean(c.getValue(bo));
          b = Object.assign(Object.assign({}, b), { horizontalScrolling: C });
        }
        if (_.affectsConfiguration(Cr)) {
          const C = Boolean(c.getValue(Cr));
          b = Object.assign(Object.assign({}, b), { smoothScrolling: C });
        }
        if (_.affectsConfiguration(ma)) {
          const C = c.getValue(ma);
          b = Object.assign(Object.assign({}, b), { mouseWheelScrollSensitivity: C });
        }
        if (_.affectsConfiguration(pa)) {
          const C = c.getValue(pa);
          b = Object.assign(Object.assign({}, b), { fastScrollSensitivity: C });
        }
        Object.keys(b).length > 0 && this.updateOptions(b);
      })), this.navigator = new K3(this, Object.assign({ configurationService: c }, o)), this.disposables.add(this.navigator);
    }
    updateOptions(e) {
      super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
    }
    updateStyles(e) {
      var t;
      (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = rh(this, this.themeService, e);
    }
    dispose() {
      var e;
      (e = this._styler) === null || e === void 0 || e.dispose(), super.dispose();
    }
  };
  rk = Da([
    Xe(5, Fe),
    Xe(6, Eo),
    Xe(7, jt),
    Xe(8, At),
    Xe(9, ci)
  ], rk);
  let JM = class extends pQ {
    constructor(e, t, i, n, o, r, a, l, c, d) {
      const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : Boolean(c.getValue(bo)), [u, f] = AC(o, c, d);
      super(e, t, i, n, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, or(l.getColorTheme(), EC)), u), { horizontalScrolling: h })), this.disposables = new te(), this.disposables.add(f), this.contextKeyService = MC(r, this), this.themeService = l, this.horizontalScrolling = o.horizontalScrolling, this.listSupportsMultiSelect = NC.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), TC.bindTo(this.contextKeyService).set(Boolean(o.selectionNavigation)), this._useAltAsMultipleSelectionModifier = _a(c), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), o.overrideStyles && this.updateStyles(o.overrideStyles), o.overrideStyles && this.disposables.add(rh(this, l, o.overrideStyles)), this.disposables.add(c.onDidChangeConfiguration((_) => {
        _.affectsConfiguration(zh) && (this._useAltAsMultipleSelectionModifier = _a(c));
        let b = {};
        if (_.affectsConfiguration(bo) && this.horizontalScrolling === void 0) {
          const C = Boolean(c.getValue(bo));
          b = Object.assign(Object.assign({}, b), { horizontalScrolling: C });
        }
        if (_.affectsConfiguration(Cr)) {
          const C = Boolean(c.getValue(Cr));
          b = Object.assign(Object.assign({}, b), { smoothScrolling: C });
        }
        if (_.affectsConfiguration(ma)) {
          const C = c.getValue(ma);
          b = Object.assign(Object.assign({}, b), { mouseWheelScrollSensitivity: C });
        }
        if (_.affectsConfiguration(pa)) {
          const C = c.getValue(pa);
          b = Object.assign(Object.assign({}, b), { fastScrollSensitivity: C });
        }
        Object.keys(b).length > 0 && this.updateOptions(b);
      })), this.navigator = new K3(this, Object.assign({ configurationService: c }, o)), this.disposables.add(this.navigator);
    }
    updateOptions(e) {
      super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
    }
    updateStyles(e) {
      var t;
      (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = rh(this, this.themeService, e);
    }
    dispose() {
      var e;
      (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
    }
  };
  JM = Da([
    Xe(5, Fe),
    Xe(6, Eo),
    Xe(7, jt),
    Xe(8, At),
    Xe(9, ci)
  ], JM);
  let eA = class extends xC {
    constructor(e, t, i, n, o, r, a, l, c, d, h) {
      const u = typeof r.horizontalScrolling < "u" ? r.horizontalScrolling : Boolean(d.getValue(bo)), [f, g] = AC(r, d, h);
      super(e, t, i, n, o, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, or(c.getColorTheme(), EC)), f), { horizontalScrolling: u })), this.disposables.add(g), this.contextKeyService = MC(a, this), this.themeService = c, this.listSupportsMultiSelect = NC.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(r.multipleSelectionSupport !== !1), TC.bindTo(this.contextKeyService).set(Boolean(r.selectionNavigation)), this.listHasSelectionOrFocus = mN.bindTo(this.contextKeyService), this.listDoubleSelection = pN.bindTo(this.contextKeyService), this.listMultiSelection = _N.bindTo(this.contextKeyService), this.horizontalScrolling = r.horizontalScrolling, this._useAltAsMultipleSelectionModifier = _a(d), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), r.overrideStyles && this.updateStyles(r.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
        const b = this.getSelection(), C = this.getFocus();
        this.contextKeyService.bufferChangeEvents(() => {
          this.listHasSelectionOrFocus.set(b.length > 0 || C.length > 0), this.listMultiSelection.set(b.length > 1), this.listDoubleSelection.set(b.length === 2);
        });
      })), this.disposables.add(this.onDidChangeFocus(() => {
        const b = this.getSelection(), C = this.getFocus();
        this.listHasSelectionOrFocus.set(b.length > 0 || C.length > 0);
      })), this.disposables.add(d.onDidChangeConfiguration((b) => {
        b.affectsConfiguration(zh) && (this._useAltAsMultipleSelectionModifier = _a(d));
        let C = {};
        if (b.affectsConfiguration(bo) && this.horizontalScrolling === void 0) {
          const v = Boolean(d.getValue(bo));
          C = Object.assign(Object.assign({}, C), { horizontalScrolling: v });
        }
        if (b.affectsConfiguration(Cr)) {
          const v = Boolean(d.getValue(Cr));
          C = Object.assign(Object.assign({}, C), { smoothScrolling: v });
        }
        if (b.affectsConfiguration(ma)) {
          const v = d.getValue(ma);
          C = Object.assign(Object.assign({}, C), { mouseWheelScrollSensitivity: v });
        }
        if (b.affectsConfiguration(pa)) {
          const v = d.getValue(pa);
          C = Object.assign(Object.assign({}, C), { fastScrollSensitivity: v });
        }
        Object.keys(C).length > 0 && this.updateOptions(C);
      })), this.navigator = new tJ(this, Object.assign({ configurationService: d }, r)), this.disposables.add(this.navigator);
    }
    updateOptions(e) {
      super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
    }
    updateStyles(e) {
      var t;
      (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = rh(this, this.themeService, e);
    }
    dispose() {
      var e;
      (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
    }
  };
  eA = Da([
    Xe(6, Fe),
    Xe(7, Eo),
    Xe(8, jt),
    Xe(9, At),
    Xe(10, ci)
  ], eA);
  class wN extends z {
    constructor(e, t) {
      var i;
      super(), this.widget = e, this._onDidOpen = this._register(new B()), this.onDidOpen = this._onDidOpen.event, this._register(be.filter(this.widget.onDidChangeSelection, (n) => n.browserEvent instanceof KeyboardEvent)((n) => this.onSelectionFromKeyboard(n))), this._register(this.widget.onPointer((n) => this.onPointer(n.element, n.browserEvent))), this._register(this.widget.onMouseDblClick((n) => this.onMouseDblClick(n.element, n.browserEvent))), typeof t?.openOnSingleClick != "boolean" && t?.configurationService ? (this.openOnSingleClick = t?.configurationService.getValue(ok) !== "doubleClick", this._register(t?.configurationService.onDidChangeConfiguration(() => {
        this.openOnSingleClick = t?.configurationService.getValue(ok) !== "doubleClick";
      }))) : this.openOnSingleClick = (i = t?.openOnSingleClick) !== null && i !== void 0 ? i : !0;
    }
    onSelectionFromKeyboard(e) {
      if (e.elements.length !== 1)
        return;
      const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, n = typeof t.pinned == "boolean" ? t.pinned : !i, o = !1;
      this._open(this.getSelectedElement(), i, n, o, e.browserEvent);
    }
    onPointer(e, t) {
      if (!this.openOnSingleClick || t.detail === 2)
        return;
      const n = t.button === 1, o = !0, r = n, a = t.ctrlKey || t.metaKey || t.altKey;
      this._open(e, o, r, a, t);
    }
    onMouseDblClick(e, t) {
      if (!t)
        return;
      const i = t.target;
      if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
        return;
      const o = !1, r = !0, a = t.ctrlKey || t.metaKey || t.altKey;
      this._open(e, o, r, a, t);
    }
    _open(e, t, i, n, o) {
      !e || this._onDidOpen.fire({
        editorOptions: {
          preserveFocus: t,
          pinned: i,
          revealIfVisible: !0
        },
        sideBySide: n,
        element: e,
        browserEvent: o
      });
    }
  }
  class K3 extends wN {
    constructor(e, t) {
      super(e, t), this.widget = e;
    }
    getSelectedElement() {
      return this.widget.getSelectedElements()[0];
    }
  }
  class tJ extends wN {
    constructor(e, t) {
      super(e, t);
    }
    getSelectedElement() {
      return this.widget.getSelectedElements()[0];
    }
  }
  class iJ extends wN {
    constructor(e, t) {
      super(e, t);
    }
    getSelectedElement() {
      var e;
      return (e = this.widget.getSelection()[0]) !== null && e !== void 0 ? e : void 0;
    }
  }
  function nJ(s, e) {
    let t = !1;
    return (i) => {
      if (i.toKeybinding().isModifierKey())
        return !1;
      if (t)
        return t = !1, !1;
      const n = e.softDispatch(i, s);
      return n && n.enterChord ? (t = !0, !1) : (t = !1, !0);
    };
  }
  let tA = class extends hN {
    constructor(e, t, i, n, o, r, a, l, c, d, h) {
      const { options: u, getAutomaticKeyboardNavigation: f, disposable: g } = C_(t, o, r, c, d, h);
      super(e, t, i, n, u), this.disposables.add(g), this.internals = new ah(this, o, f, o.overrideStyles, r, a, l, c, h), this.disposables.add(this.internals);
    }
    updateOptions(e) {
      super.updateOptions(e), this.internals.updateOptions(e);
    }
  };
  tA = Da([
    Xe(5, Fe),
    Xe(6, Eo),
    Xe(7, jt),
    Xe(8, At),
    Xe(9, ci),
    Xe(10, Ts)
  ], tA);
  let iA = class extends W3 {
    constructor(e, t, i, n, o, r, a, l, c, d, h) {
      const { options: u, getAutomaticKeyboardNavigation: f, disposable: g } = C_(t, o, r, c, d, h);
      super(e, t, i, n, u), this.disposables.add(g), this.internals = new ah(this, o, f, o.overrideStyles, r, a, l, c, h), this.disposables.add(this.internals);
    }
    updateOptions(e = {}) {
      super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
    }
  };
  iA = Da([
    Xe(5, Fe),
    Xe(6, Eo),
    Xe(7, jt),
    Xe(8, At),
    Xe(9, ci),
    Xe(10, Ts)
  ], iA);
  let nA = class extends GQ {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      const { options: f, getAutomaticKeyboardNavigation: g, disposable: _ } = C_(t, r, a, d, h, u);
      super(e, t, i, n, o, f), this.disposables.add(_), this.internals = new ah(this, r, g, r.overrideStyles, a, l, c, d, u), this.disposables.add(this.internals);
    }
    updateOptions(e = {}) {
      super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
    }
  };
  nA = Da([
    Xe(6, Fe),
    Xe(7, Eo),
    Xe(8, jt),
    Xe(9, At),
    Xe(10, ci),
    Xe(11, Ts)
  ], nA);
  let ak = class extends H3 {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      const { options: f, getAutomaticKeyboardNavigation: g, disposable: _ } = C_(t, r, a, d, h, u);
      super(e, t, i, n, o, f), this.disposables.add(_), this.internals = new ah(this, r, g, r.overrideStyles, a, l, c, d, u), this.disposables.add(this.internals);
    }
    get onDidOpen() {
      return this.internals.onDidOpen;
    }
    updateOptions(e = {}) {
      super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
    }
  };
  ak = Da([
    Xe(6, Fe),
    Xe(7, Eo),
    Xe(8, jt),
    Xe(9, At),
    Xe(10, ci),
    Xe(11, Ts)
  ], ak);
  let sA = class extends KQ {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u, f) {
      const { options: g, getAutomaticKeyboardNavigation: _, disposable: b } = C_(t, a, l, h, u, f);
      super(e, t, i, n, o, r, g), this.disposables.add(b), this.internals = new ah(this, a, _, a.overrideStyles, l, c, d, h, f), this.disposables.add(this.internals);
    }
    updateOptions(e) {
      super.updateOptions(e), this.internals.updateOptions(e);
    }
  };
  sA = Da([
    Xe(7, Fe),
    Xe(8, Eo),
    Xe(9, jt),
    Xe(10, At),
    Xe(11, ci),
    Xe(12, Ts)
  ], sA);
  function C_(s, e, t, i, n, o) {
    var r;
    const a = () => {
      let g = Boolean(t.getContextKeyValue(j3));
      return g && (g = Boolean(i.getValue(CN))), g;
    }, l = o.isScreenReaderOptimized(), c = e.simpleKeyboardNavigation || l ? "simple" : i.getValue(O1), d = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : Boolean(i.getValue(bo)), [h, u] = AC(e, i, n), f = e.additionalScrollHeight;
    return {
      getAutomaticKeyboardNavigation: a,
      disposable: u,
      options: Object.assign(Object.assign({
        keyboardSupport: !1
      }, h), { indent: typeof i.getValue(Sp) == "number" ? i.getValue(Sp) : void 0, renderIndentGuides: i.getValue(P1), smoothScrolling: Boolean(i.getValue(Cr)), automaticKeyboardNavigation: a(), simpleKeyboardNavigation: c === "simple", filterOnType: c === "filter", horizontalScrolling: d, keyboardNavigationEventFilter: nJ(s, n), additionalScrollHeight: f, hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements, expandOnlyOnTwistieClick: (r = e.expandOnlyOnTwistieClick) !== null && r !== void 0 ? r : i.getValue(F1) === "doubleClick" })
    };
  }
  let ah = class {
    constructor(e, t, i, n, o, r, a, l, c) {
      this.tree = e, this.themeService = a, this.disposables = [], this.contextKeyService = MC(o, e), this.listSupportsMultiSelect = NC.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(t.multipleSelectionSupport !== !1), TC.bindTo(this.contextKeyService).set(Boolean(t.selectionNavigation)), this.hasSelectionOrFocus = mN.bindTo(this.contextKeyService), this.hasDoubleSelection = pN.bindTo(this.contextKeyService), this.hasMultiSelection = _N.bindTo(this.contextKeyService), this.treeElementCanCollapse = bN.bindTo(this.contextKeyService), this.treeElementHasParent = QQ.bindTo(this.contextKeyService), this.treeElementCanExpand = vN.bindTo(this.contextKeyService), this.treeElementHasChild = JQ.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = _a(l);
      const h = /* @__PURE__ */ new Set();
      h.add(j3);
      const u = () => {
        const _ = c.isScreenReaderOptimized() ? "simple" : l.getValue(O1);
        e.updateOptions({
          simpleKeyboardNavigation: _ === "simple",
          filterOnType: _ === "filter"
        });
      };
      this.updateStyleOverrides(n);
      const f = () => {
        const g = e.getFocus()[0];
        if (!g)
          return;
        const _ = e.getNode(g);
        this.treeElementCanCollapse.set(_.collapsible && !_.collapsed), this.treeElementHasParent.set(!!e.getParentElement(g)), this.treeElementCanExpand.set(_.collapsible && _.collapsed), this.treeElementHasChild.set(!!e.getFirstElementChild(g));
      };
      this.disposables.push(this.contextKeyService, r.register(e), e.onDidChangeSelection(() => {
        const g = e.getSelection(), _ = e.getFocus();
        this.contextKeyService.bufferChangeEvents(() => {
          this.hasSelectionOrFocus.set(g.length > 0 || _.length > 0), this.hasMultiSelection.set(g.length > 1), this.hasDoubleSelection.set(g.length === 2);
        });
      }), e.onDidChangeFocus(() => {
        const g = e.getSelection(), _ = e.getFocus();
        this.hasSelectionOrFocus.set(g.length > 0 || _.length > 0), f();
      }), e.onDidChangeCollapseState(f), e.onDidChangeModel(f), l.onDidChangeConfiguration((g) => {
        let _ = {};
        if (g.affectsConfiguration(zh) && (this._useAltAsMultipleSelectionModifier = _a(l)), g.affectsConfiguration(Sp)) {
          const b = l.getValue(Sp);
          _ = Object.assign(Object.assign({}, _), { indent: b });
        }
        if (g.affectsConfiguration(P1)) {
          const b = l.getValue(P1);
          _ = Object.assign(Object.assign({}, _), { renderIndentGuides: b });
        }
        if (g.affectsConfiguration(Cr)) {
          const b = Boolean(l.getValue(Cr));
          _ = Object.assign(Object.assign({}, _), { smoothScrolling: b });
        }
        if (g.affectsConfiguration(O1) && u(), g.affectsConfiguration(CN) && (_ = Object.assign(Object.assign({}, _), { automaticKeyboardNavigation: i() })), g.affectsConfiguration(bo) && t.horizontalScrolling === void 0) {
          const b = Boolean(l.getValue(bo));
          _ = Object.assign(Object.assign({}, _), { horizontalScrolling: b });
        }
        if (g.affectsConfiguration(F1) && t.expandOnlyOnTwistieClick === void 0 && (_ = Object.assign(Object.assign({}, _), { expandOnlyOnTwistieClick: l.getValue(F1) === "doubleClick" })), g.affectsConfiguration(ma)) {
          const b = l.getValue(ma);
          _ = Object.assign(Object.assign({}, _), { mouseWheelScrollSensitivity: b });
        }
        if (g.affectsConfiguration(pa)) {
          const b = l.getValue(pa);
          _ = Object.assign(Object.assign({}, _), { fastScrollSensitivity: b });
        }
        Object.keys(_).length > 0 && e.updateOptions(_);
      }), this.contextKeyService.onDidChangeContext((g) => {
        g.affectsSome(h) && e.updateOptions({ automaticKeyboardNavigation: i() });
      }), c.onDidChangeScreenReaderOptimized(() => u())), this.navigator = new iJ(e, Object.assign({ configurationService: l }, t)), this.disposables.push(this.navigator);
    }
    get onDidOpen() {
      return this.navigator.onDidOpen;
    }
    updateOptions(e) {
      e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
    }
    updateStyleOverrides(e) {
      at(this.styler), this.styler = e ? rh(this.tree, this.themeService, e) : z.None;
    }
    dispose() {
      this.disposables = at(this.disposables), at(this.styler), this.styler = void 0;
    }
  };
  ah = Da([
    Xe(4, Fe),
    Xe(5, Eo),
    Xe(6, jt),
    Xe(7, At),
    Xe(8, Ts)
  ], ah);
  const sJ = Si.as(Oh.Configuration);
  sJ.registerConfiguration({
    id: "workbench",
    order: 7,
    title: m("workbenchConfigurationTitle", "Workbench"),
    type: "object",
    properties: {
      [zh]: {
        type: "string",
        enum: ["ctrlCmd", "alt"],
        enumDescriptions: [
          m("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
          m("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
        ],
        default: "ctrlCmd",
        description: m({
          key: "multiSelectModifier",
          comment: [
            "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
            "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
          ]
        }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
      },
      [ok]: {
        type: "string",
        enum: ["singleClick", "doubleClick"],
        default: "singleClick",
        description: m({
          key: "openModeModifier",
          comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
        }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
      },
      [bo]: {
        type: "boolean",
        default: !1,
        description: m("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
      },
      [Sp]: {
        type: "number",
        default: 8,
        minimum: 4,
        maximum: 40,
        description: m("tree indent setting", "Controls tree indentation in pixels.")
      },
      [P1]: {
        type: "string",
        enum: ["none", "onHover", "always"],
        default: "onHover",
        description: m("render tree indent guides", "Controls whether the tree should render indent guides.")
      },
      [Cr]: {
        type: "boolean",
        default: !1,
        description: m("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
      },
      [ma]: {
        type: "number",
        default: 1,
        description: m("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
      },
      [pa]: {
        type: "number",
        default: 5,
        description: m("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
      },
      [O1]: {
        type: "string",
        enum: ["simple", "highlight", "filter"],
        enumDescriptions: [
          m("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
          m("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
          m("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
        ],
        default: "highlight",
        description: m("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter.")
      },
      [CN]: {
        type: "boolean",
        default: !0,
        markdownDescription: m("automatic keyboard navigation setting", "Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut.")
      },
      [F1]: {
        type: "string",
        enum: ["singleClick", "doubleClick"],
        default: "singleClick",
        description: m("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
      }
    }
  });
  var oJ = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Ic {
    constructor(e, t, i, n) {
      this.isProviderFirst = e, this.parent = t, this.link = i, this._rangeCallback = n, this.id = b3.nextId();
    }
    get uri() {
      return this.link.uri;
    }
    get range() {
      var e, t;
      return (t = (e = this._range) !== null && e !== void 0 ? e : this.link.targetSelectionRange) !== null && t !== void 0 ? t : this.link.range;
    }
    set range(e) {
      this._range = e, this._rangeCallback(this);
    }
    get ariaMessage() {
      var e;
      const t = (e = this.parent.getPreview(this)) === null || e === void 0 ? void 0 : e.preview(this.range);
      return t ? m({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "symbol in {0} on line {1} at column {2}, {3}", ko(this.uri), this.range.startLineNumber, this.range.startColumn, t.value) : m("aria.oneReference", "symbol in {0} on line {1} at column {2}", ko(this.uri), this.range.startLineNumber, this.range.startColumn);
    }
  }
  class rJ {
    constructor(e) {
      this._modelReference = e;
    }
    dispose() {
      this._modelReference.dispose();
    }
    preview(e, t = 8) {
      const i = this._modelReference.object.textEditorModel;
      if (!i)
        return;
      const { startLineNumber: n, startColumn: o, endLineNumber: r, endColumn: a } = e, l = i.getWordUntilPosition({ lineNumber: n, column: o - t }), c = new D(n, l.startColumn, n, o), d = new D(r, a, r, 1073741824), h = i.getValueInRange(c).replace(/^\s+/, ""), u = i.getValueInRange(e), f = i.getValueInRange(d).replace(/\s+$/, "");
      return {
        value: h + u + f,
        highlight: { start: h.length, end: h.length + u.length }
      };
    }
  }
  class yp {
    constructor(e, t) {
      this.parent = e, this.uri = t, this.children = [], this._previews = new $n();
    }
    dispose() {
      at(this._previews.values()), this._previews.clear();
    }
    getPreview(e) {
      return this._previews.get(e.uri);
    }
    get ariaMessage() {
      const e = this.children.length;
      return e === 1 ? m("aria.fileReferences.1", "1 symbol in {0}, full path {1}", ko(this.uri), this.uri.fsPath) : m("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", e, ko(this.uri), this.uri.fsPath);
    }
    resolve(e) {
      return oJ(this, void 0, void 0, function* () {
        if (this._previews.size !== 0)
          return this;
        for (let t of this.children)
          if (!this._previews.has(t.uri))
            try {
              const i = yield e.createModelReference(t.uri);
              this._previews.set(t.uri, new rJ(i));
            } catch (i) {
              We(i);
            }
        return this;
      });
    }
  }
  class xs {
    constructor(e, t) {
      this.groups = [], this.references = [], this._onDidChangeReferenceRange = new B(), this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event, this._links = e, this._title = t;
      const [i] = e;
      e.sort(xs._compareReferences);
      let n;
      for (let o of e)
        if ((!n || !Wt.isEqual(n.uri, o.uri, !0)) && (n = new yp(this, o.uri), this.groups.push(n)), n.children.length === 0 || xs._compareReferences(o, n.children[n.children.length - 1]) !== 0) {
          const r = new Ic(i === o, n, o, (a) => this._onDidChangeReferenceRange.fire(a));
          this.references.push(r), n.children.push(r);
        }
    }
    dispose() {
      at(this.groups), this._onDidChangeReferenceRange.dispose(), this.groups.length = 0;
    }
    clone() {
      return new xs(this._links, this._title);
    }
    get title() {
      return this._title;
    }
    get isEmpty() {
      return this.groups.length === 0;
    }
    get ariaMessage() {
      return this.isEmpty ? m("aria.result.0", "No results found") : this.references.length === 1 ? m("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath) : this.groups.length === 1 ? m("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath) : m("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
    }
    nextOrPreviousReference(e, t) {
      let { parent: i } = e, n = i.children.indexOf(e), o = i.children.length, r = i.parent.groups.length;
      return r === 1 || t && n + 1 < o || !t && n > 0 ? (t ? n = (n + 1) % o : n = (n + o - 1) % o, i.children[n]) : (n = i.parent.groups.indexOf(i), t ? (n = (n + 1) % r, i.parent.groups[n].children[0]) : (n = (n + r - 1) % r, i.parent.groups[n].children[i.parent.groups[n].children.length - 1]));
    }
    nearestReference(e, t) {
      const i = this.references.map((n, o) => ({
        idx: o,
        prefixLen: pf(n.uri.toString(), e.toString()),
        offsetDist: Math.abs(n.range.startLineNumber - t.lineNumber) * 100 + Math.abs(n.range.startColumn - t.column)
      })).sort((n, o) => n.prefixLen > o.prefixLen ? -1 : n.prefixLen < o.prefixLen ? 1 : n.offsetDist < o.offsetDist ? -1 : n.offsetDist > o.offsetDist ? 1 : 0)[0];
      if (i)
        return this.references[i.idx];
    }
    referenceAt(e, t) {
      for (const i of this.references)
        if (i.uri.toString() === e.toString() && D.containsPosition(i.range, t))
          return i;
    }
    firstReference() {
      for (const e of this.references)
        if (e.isProviderFirst)
          return e;
      return this.references[0];
    }
    static _compareReferences(e, t) {
      return Wt.compare(e.uri, t.uri) || D.compareRangesUsingStarts(e.range, t.range);
    }
  }
  const aJ = {
    badgeBackground: H.fromHex("#4D4D4D"),
    badgeForeground: H.fromHex("#FFFFFF")
  };
  class lk {
    constructor(e, t) {
      this.count = 0, this.options = t || /* @__PURE__ */ Object.create(null), Sa(this.options, aJ, !1), this.badgeBackground = this.options.badgeBackground, this.badgeForeground = this.options.badgeForeground, this.badgeBorder = this.options.badgeBorder, this.element = q(e, J(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
    }
    setCount(e) {
      this.count = e, this.render();
    }
    setTitleFormat(e) {
      this.titleFormat = e, this.render();
    }
    render() {
      this.element.textContent = uo(this.countFormat, this.count), this.element.title = uo(this.titleFormat, this.count), this.applyStyles();
    }
    style(e) {
      this.badgeBackground = e.badgeBackground, this.badgeForeground = e.badgeForeground, this.badgeBorder = e.badgeBorder, this.applyStyles();
    }
    applyStyles() {
      if (this.element) {
        const e = this.badgeBackground ? this.badgeBackground.toString() : "", t = this.badgeForeground ? this.badgeForeground.toString() : "", i = this.badgeBorder ? this.badgeBorder.toString() : "";
        this.element.style.backgroundColor = e, this.element.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
      }
    }
  }
  class lh {
    constructor(e, t) {
      var i;
      this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.supportIcons = (i = t?.supportIcons) !== null && i !== void 0 ? i : !1, this.domNode = q(e, J("span.monaco-highlighted-label"));
    }
    get element() {
      return this.domNode;
    }
    set(e, t = [], i = "", n) {
      e || (e = ""), n && (e = lh.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && po(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
    }
    render() {
      const e = [];
      let t = 0;
      for (const i of this.highlights) {
        if (i.end === i.start)
          continue;
        if (t < i.start) {
          const r = this.text.substring(t, i.start);
          e.push(J("span", void 0, ...this.supportIcons ? Pd(r) : [r])), t = i.end;
        }
        const n = this.text.substring(i.start, i.end), o = J("span.highlight", void 0, ...this.supportIcons ? Pd(n) : [n]);
        i.extraClasses && o.classList.add(...i.extraClasses), e.push(o), t = i.end;
      }
      if (t < this.text.length) {
        const i = this.text.substring(t);
        e.push(J("span", void 0, ...this.supportIcons ? Pd(i) : [i]));
      }
      pc(this.domNode, ...e), this.title ? this.domNode.title = this.title : this.domNode.removeAttribute("title"), this.didEverRender = !0;
    }
    static escapeNewLines(e, t) {
      let i = 0, n = 0;
      return e.replace(/\r\n|\r|\n/g, (o, r) => {
        n = o === `\r
` ? -1 : 0, r += i;
        for (const a of t)
          a.end <= r || (a.start >= r && (a.start += n), a.end >= r && (a.end += n));
        return i += n, "\u23CE";
      });
    }
  }
  var ck = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function lJ(s, e) {
    vo(e) ? s.title = $E(e) : e?.markdownNotSupportedFallback ? s.title = e.markdownNotSupportedFallback : s.removeAttribute("title");
  }
  class cJ {
    constructor(e, t, i) {
      this.hoverDelegate = e, this.target = t, this.fadeInAnimation = i;
    }
    update(e, t) {
      var i;
      return ck(this, void 0, void 0, function* () {
        if (this._cancellationTokenSource && (this._cancellationTokenSource.dispose(!0), this._cancellationTokenSource = void 0), this.isDisposed)
          return;
        let n;
        if (e === void 0 || vo(e) || e instanceof HTMLElement)
          n = e;
        else if (!B0(e.markdown))
          n = (i = e.markdown) !== null && i !== void 0 ? i : e.markdownNotSupportedFallback;
        else {
          this._hoverWidget || this.show(m("iconLabel.loading", "Loading..."), t), this._cancellationTokenSource = new bn();
          const o = this._cancellationTokenSource.token;
          if (n = yield e.markdown(o), n === void 0 && (n = e.markdownNotSupportedFallback), this.isDisposed || o.isCancellationRequested)
            return;
        }
        this.show(n, t);
      });
    }
    show(e, t) {
      const i = this._hoverWidget;
      if (this.hasContent(e)) {
        const n = {
          content: e,
          target: this.target,
          showPointer: this.hoverDelegate.placement === "element",
          hoverPosition: 2,
          skipFadeInAnimation: !this.fadeInAnimation || !!i
        };
        this._hoverWidget = this.hoverDelegate.showHover(n, t);
      }
      i?.dispose();
    }
    hasContent(e) {
      return e ? ZF(e) ? !!e.value : !0 : !1;
    }
    get isDisposed() {
      var e;
      return (e = this._hoverWidget) === null || e === void 0 ? void 0 : e.isDisposed;
    }
    dispose() {
      var e, t;
      (e = this._hoverWidget) === null || e === void 0 || e.dispose(), (t = this._cancellationTokenSource) === null || t === void 0 || t.dispose(!0), this._cancellationTokenSource = void 0;
    }
  }
  function dJ(s, e, t) {
    let i, n;
    const o = (d, h) => {
      var u;
      d && (n?.dispose(), n = void 0), h && (i?.dispose(), i = void 0), (u = s.onDidHideHover) === null || u === void 0 || u.call(s);
    }, r = (d, h, u) => new Ns(() => ck(this, void 0, void 0, function* () {
      (!n || n.isDisposed) && (n = new cJ(s, u || e, d > 0), yield n.update(t, h));
    }), d), a = () => {
      if (i)
        return;
      const d = new te(), h = (g) => o(!1, g.fromElement === e);
      d.add(ee(e, ye.MOUSE_LEAVE, h, !0));
      const u = () => o(!0, !0);
      d.add(ee(e, ye.MOUSE_DOWN, u, !0));
      const f = {
        targetElements: [e],
        dispose: () => {
        }
      };
      if (s.placement === void 0 || s.placement === "mouse") {
        const g = (_) => f.x = _.x + 10;
        d.add(ee(e, ye.MOUSE_MOVE, g, !0));
      }
      d.add(r(s.delay, !1, f)), i = d;
    }, l = ee(e, ye.MOUSE_OVER, a, !0);
    return {
      show: (d) => {
        o(!1, !0), r(0, d);
      },
      hide: () => {
        o(!0, !0);
      },
      update: (d) => ck(this, void 0, void 0, function* () {
        t = d, yield n?.update(t);
      }),
      dispose: () => {
        l.dispose(), o(!0, !0);
      }
    };
  }
  class FS {
    constructor(e) {
      this._element = e;
    }
    get element() {
      return this._element;
    }
    set textContent(e) {
      this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
    }
    set className(e) {
      this.disposed || e === this._className || (this._className = e, this._element.className = e);
    }
    set empty(e) {
      this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
    }
    dispose() {
      this.disposed = !0;
    }
  }
  class B1 extends z {
    constructor(e, t) {
      super(), this.customHovers = /* @__PURE__ */ new Map(), this.domNode = this._register(new FS(q(e, J(".monaco-icon-label")))), this.labelContainer = q(this.domNode.element, J(".monaco-icon-label-container"));
      const i = q(this.labelContainer, J("span.monaco-icon-name-container"));
      this.descriptionContainer = this._register(new FS(q(this.labelContainer, J("span.monaco-icon-description-container")))), t?.supportHighlights || t?.supportIcons ? this.nameNode = new fJ(i, !!t.supportIcons) : this.nameNode = new hJ(i), t?.supportDescriptionHighlights ? this.descriptionNodeFactory = () => new lh(q(this.descriptionContainer.element, J("span.label-description")), { supportIcons: !!t.supportIcons }) : this.descriptionNodeFactory = () => this._register(new FS(q(this.descriptionContainer.element, J("span.label-description")))), this.hoverDelegate = t?.hoverDelegate;
    }
    get element() {
      return this.domNode.element;
    }
    setLabel(e, t, i) {
      const n = ["monaco-icon-label"];
      i && (i.extraClasses && n.push(...i.extraClasses), i.italic && n.push("italic"), i.strikethrough && n.push("strikethrough")), this.domNode.className = n.join(" "), this.setupHover(i?.descriptionTitle ? this.labelContainer : this.element, i?.title), this.nameNode.setLabel(e, i), (t || this.descriptionNode) && (this.descriptionNode || (this.descriptionNode = this.descriptionNodeFactory()), this.descriptionNode instanceof lh ? (this.descriptionNode.set(t || "", i ? i.descriptionMatches : void 0), this.setupHover(this.descriptionNode.element, i?.descriptionTitle)) : (this.descriptionNode.textContent = t || "", this.setupHover(this.descriptionNode.element, i?.descriptionTitle || ""), this.descriptionNode.empty = !t));
    }
    setupHover(e, t) {
      const i = this.customHovers.get(e);
      if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
        e.removeAttribute("title");
        return;
      }
      if (!this.hoverDelegate)
        lJ(e, t);
      else {
        const n = dJ(this.hoverDelegate, e, t);
        n && this.customHovers.set(e, n);
      }
    }
    dispose() {
      super.dispose();
      for (const e of this.customHovers.values())
        e.dispose();
      this.customHovers.clear();
    }
  }
  class hJ {
    constructor(e) {
      this.container = e, this.label = void 0, this.singleLabel = void 0;
    }
    setLabel(e, t) {
      if (!(this.label === e && po(this.options, t)))
        if (this.label = e, this.options = t, typeof e == "string")
          this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = q(this.container, J("a.label-name", { id: t?.domId }))), this.singleLabel.textContent = e;
        else {
          this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
          for (let i = 0; i < e.length; i++) {
            const n = e[i], o = t?.domId && `${t?.domId}_${i}`;
            q(this.container, J("a.label-name", { id: o, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, n)), i < e.length - 1 && q(this.container, J("span.label-separator", void 0, t?.separator || "/"));
          }
        }
    }
  }
  function uJ(s, e, t) {
    if (!t)
      return;
    let i = 0;
    return s.map((n) => {
      const o = { start: i, end: i + n.length }, r = t.map((a) => Ln.intersect(o, a)).filter((a) => !Ln.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
      return i = o.end + e.length, r;
    });
  }
  class fJ {
    constructor(e, t) {
      this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
    }
    setLabel(e, t) {
      if (!(this.label === e && po(this.options, t)))
        if (this.label = e, this.options = t, typeof e == "string")
          this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = new lh(q(this.container, J("a.label-name", { id: t?.domId })), { supportIcons: this.supportIcons })), this.singleLabel.set(e, t?.matches, void 0, t?.labelEscapeNewLines);
        else {
          this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
          const i = t?.separator || "/", n = uJ(e, i, t?.matches);
          for (let o = 0; o < e.length; o++) {
            const r = e[o], a = n ? n[o] : void 0, l = t?.domId && `${t?.domId}_${o}`, c = J("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": o, role: "treeitem" });
            new lh(q(this.container, c), { supportIcons: this.supportIcons }).set(r, a, void 0, t?.labelEscapeNewLines), o < e.length - 1 && q(c, J("span.label-separator", void 0, i));
          }
        }
    }
  }
  function q3(s) {
    if (!s)
      return;
    typeof s == "string" && (s = Ee.file(s));
    const e = ko(s) || (s.scheme === ze.file ? s.fsPath : s.path);
    return rn && yq(e) ? dk(e) : e;
  }
  function dk(s, e) {
    return _F(s, e) ? s.charAt(0).toUpperCase() + s.slice(1) : s;
  }
  const w_ = st("labelService");
  var RC = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Lp = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let hk = class {
    constructor(e) {
      this._resolverService = e;
    }
    hasChildren(e) {
      return e instanceof xs || e instanceof yp;
    }
    getChildren(e) {
      if (e instanceof xs)
        return e.groups;
      if (e instanceof yp)
        return e.resolve(this._resolverService).then((t) => t.children);
      throw new Error("bad tree");
    }
  };
  hk = RC([
    Lp(0, fs)
  ], hk);
  class gJ {
    getHeight() {
      return 23;
    }
    getTemplateId(e) {
      return e instanceof yp ? kp.id : S_.id;
    }
  }
  let uk = class {
    constructor(e) {
      this._keybindingService = e;
    }
    getKeyboardNavigationLabel(e) {
      var t;
      if (e instanceof Ic) {
        const i = (t = e.parent.getPreview(e)) === null || t === void 0 ? void 0 : t.preview(e.range);
        if (i)
          return i.value;
      }
      return ko(e.uri);
    }
  };
  uk = RC([
    Lp(0, ci)
  ], uk);
  class mJ {
    getId(e) {
      return e instanceof Ic ? e.id : e.uri;
    }
  }
  let fk = class extends z {
    constructor(e, t, i) {
      super(), this._uriLabel = t;
      const n = document.createElement("div");
      n.classList.add("reference-file"), this.file = this._register(new B1(n, { supportHighlights: !0 })), this.badge = new lk(q(n, J(".count"))), this._register(ZQ(this.badge, i)), e.appendChild(n);
    }
    set(e, t) {
      let i = hC(e.uri);
      this.file.setLabel(q3(e.uri), this._uriLabel.getUriLabel(i, { relative: !0 }), { title: this._uriLabel.getUriLabel(e.uri), matches: t });
      const n = e.children.length;
      this.badge.setCount(n), n > 1 ? this.badge.setTitleFormat(m("referencesCount", "{0} references", n)) : this.badge.setTitleFormat(m("referenceCount", "{0} reference", n));
    }
  };
  fk = RC([
    Lp(1, w_),
    Lp(2, jt)
  ], fk);
  let kp = class G3 {
    constructor(e) {
      this._instantiationService = e, this.templateId = G3.id;
    }
    renderTemplate(e) {
      return this._instantiationService.createInstance(fk, e);
    }
    renderElement(e, t, i) {
      i.set(e.element, pC(e.filterData));
    }
    disposeTemplate(e) {
      e.dispose();
    }
  };
  kp.id = "FileReferencesRenderer";
  kp = RC([
    Lp(0, et)
  ], kp);
  class pJ {
    constructor(e) {
      this.label = new lh(e);
    }
    set(e, t) {
      var i;
      const n = (i = e.parent.getPreview(e)) === null || i === void 0 ? void 0 : i.preview(e.range);
      if (!n || !n.value)
        this.label.set(`${ko(e.uri)}:${e.range.startLineNumber + 1}:${e.range.startColumn + 1}`);
      else {
        const { value: o, highlight: r } = n;
        t && !mr.isDefault(t) ? (this.label.element.classList.toggle("referenceMatch", !1), this.label.set(o, pC(t))) : (this.label.element.classList.toggle("referenceMatch", !0), this.label.set(o, [r]));
      }
    }
  }
  class S_ {
    constructor() {
      this.templateId = S_.id;
    }
    renderTemplate(e) {
      return new pJ(e);
    }
    renderElement(e, t, i) {
      i.set(e.element, e.filterData);
    }
    disposeTemplate() {
    }
  }
  S_.id = "OneReferenceRenderer";
  class _J {
    getWidgetAriaLabel() {
      return m("treeAriaLabel", "References");
    }
    getAriaLabel(e) {
      return e.ariaMessage;
    }
  }
  var bJ = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Pa = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, oA = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class OC {
    constructor(e, t) {
      this._editor = e, this._model = t, this._decorations = /* @__PURE__ */ new Map(), this._decorationIgnoreSet = /* @__PURE__ */ new Set(), this._callOnDispose = new te(), this._callOnModelChange = new te(), this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged())), this._onModelChanged();
    }
    dispose() {
      this._callOnModelChange.dispose(), this._callOnDispose.dispose(), this.removeDecorations();
    }
    _onModelChanged() {
      this._callOnModelChange.clear();
      const e = this._editor.getModel();
      if (!!e) {
        for (let t of this._model.references)
          if (t.uri.toString() === e.uri.toString()) {
            this._addDecorations(t.parent);
            return;
          }
      }
    }
    _addDecorations(e) {
      if (!this._editor.hasModel())
        return;
      this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
      const t = [], i = [];
      for (let o = 0, r = e.children.length; o < r; o++) {
        let a = e.children[o];
        this._decorationIgnoreSet.has(a.id) || a.uri.toString() === this._editor.getModel().uri.toString() && (t.push({
          range: a.range,
          options: OC.DecorationOptions
        }), i.push(o));
      }
      const n = this._editor.deltaDecorations([], t);
      for (let o = 0; o < n.length; o++)
        this._decorations.set(n[o], e.children[i[o]]);
    }
    _onDecorationChanged() {
      const e = [], t = this._editor.getModel();
      if (!!t) {
        for (let [i, n] of this._decorations) {
          const o = t.getDecorationRange(i);
          if (!o)
            continue;
          let r = !1;
          if (!D.equalsRange(o, n.range)) {
            if (D.spansMultipleLines(o))
              r = !0;
            else {
              const a = n.range.endColumn - n.range.startColumn, l = o.endColumn - o.startColumn;
              a !== l && (r = !0);
            }
            r ? (this._decorationIgnoreSet.add(n.id), e.push(i)) : n.range = o;
          }
        }
        for (let i = 0, n = e.length; i < n; i++)
          this._decorations.delete(e[i]);
        this._editor.deltaDecorations(e, []);
      }
    }
    removeDecorations() {
      this._editor.deltaDecorations([...this._decorations.keys()], []), this._decorations.clear();
    }
  }
  OC.DecorationOptions = $e.register({
    description: "reference-decoration",
    stickiness: 1,
    className: "reference-decoration"
  });
  class vJ {
    constructor() {
      this.ratio = 0.7, this.heightInLines = 18;
    }
    static fromJSON(e) {
      let t, i;
      try {
        const n = JSON.parse(e);
        t = n.ratio, i = n.heightInLines;
      } catch {
      }
      return {
        ratio: t || 0.7,
        heightInLines: i || 18
      };
    }
  }
  class CJ extends ak {
  }
  let gk = class extends M1 {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      super(e, { showFrame: !1, showArrow: !0, isResizeable: !0, isAccessible: !0, supportOnTitleClick: !0 }, r), this._defaultTreeKeyboardSupport = t, this.layoutData = i, this._textModelResolverService = o, this._instantiationService = r, this._peekViewService = a, this._uriLabel = l, this._undoRedoService = c, this._keybindingService = d, this._languageService = h, this._languageConfigurationService = u, this._disposeOnNewModel = new te(), this._callOnDispose = new te(), this._onDidSelectReference = new B(), this.onDidSelectReference = this._onDidSelectReference.event, this._dim = new Et(0, 0), this._applyTheme(n.getColorTheme()), this._callOnDispose.add(n.onDidColorThemeChange(this._applyTheme.bind(this))), this._peekViewService.addExclusiveWidget(e, this), this.create();
    }
    dispose() {
      this.setModel(void 0), this._callOnDispose.dispose(), this._disposeOnNewModel.dispose(), at(this._preview), at(this._previewNotAvailableMessage), at(this._tree), at(this._previewModelReference), this._splitView.dispose(), super.dispose();
    }
    _applyTheme(e) {
      const t = e.getColor($X) || H.transparent;
      this.style({
        arrowColor: t,
        frameColor: t,
        headerBackgroundColor: e.getColor(UX) || H.transparent,
        primaryHeadingColor: e.getColor(L3),
        secondaryHeadingColor: e.getColor(k3)
      });
    }
    show(e) {
      this.editor.revealRangeInCenterIfOutsideViewport(e, 0), super.show(e, this.layoutData.heightInLines || 18);
    }
    focusOnReferenceTree() {
      this._tree.domFocus();
    }
    focusOnPreviewEditor() {
      this._preview.focus();
    }
    isPreviewEditorFocused() {
      return this._preview.hasTextFocus();
    }
    _onTitleClick(e) {
      this._preview && this._preview.getModel() && this._onDidSelectReference.fire({
        element: this._getFocusedReference(),
        kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
        source: "title"
      });
    }
    _fillBody(e) {
      this.setCssClass("reference-zone-widget"), this._messageContainer = q(e, J("div.messages")), os(this._messageContainer), this._splitView = new O3(e, { orientation: 1 }), this._previewContainer = q(e, J("div.preview.inline"));
      let t = {
        scrollBeyondLastLine: !1,
        scrollbar: {
          verticalScrollbarSize: 14,
          horizontal: "auto",
          useShadows: !0,
          verticalHasArrows: !1,
          horizontalHasArrows: !1,
          alwaysConsumeMouseWheel: !1
        },
        overviewRulerLanes: 2,
        fixedOverflowWidgets: !0,
        minimap: {
          enabled: !1
        }
      };
      this._preview = this._instantiationService.createInstance(oh, this._previewContainer, t, this.editor), os(this._previewContainer), this._previewNotAvailableMessage = new gl(m("missingPreviewMessage", "no preview available"), ya, gl.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService), this._treeContainer = q(e, J("div.ref-tree.inline"));
      const i = {
        keyboardSupport: this._defaultTreeKeyboardSupport,
        accessibilityProvider: new _J(),
        keyboardNavigationLabelProvider: this._instantiationService.createInstance(uk),
        identityProvider: new mJ(),
        openOnSingleClick: !0,
        selectionNavigation: !0,
        overrideStyles: {
          listBackground: jX
        }
      };
      this._defaultTreeKeyboardSupport && this._callOnDispose.add(on(this._treeContainer, "keydown", (o) => {
        o.equals(9) && (this._keybindingService.dispatchEvent(o, o.target), o.stopPropagation());
      }, !0)), this._tree = this._instantiationService.createInstance(CJ, "ReferencesWidget", this._treeContainer, new gJ(), [
        this._instantiationService.createInstance(kp),
        this._instantiationService.createInstance(S_)
      ], this._instantiationService.createInstance(hk), i), this._splitView.addView({
        onDidChange: be.None,
        element: this._previewContainer,
        minimumSize: 200,
        maximumSize: Number.MAX_VALUE,
        layout: (o) => {
          this._preview.layout({ height: this._dim.height, width: o });
        }
      }, R1.Distribute), this._splitView.addView({
        onDidChange: be.None,
        element: this._treeContainer,
        minimumSize: 100,
        maximumSize: Number.MAX_VALUE,
        layout: (o) => {
          this._treeContainer.style.height = `${this._dim.height}px`, this._treeContainer.style.width = `${o}px`, this._tree.layout(this._dim.height, o);
        }
      }, R1.Distribute), this._disposables.add(this._splitView.onDidSashChange(() => {
        this._dim.width && (this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width);
      }, void 0));
      let n = (o, r) => {
        o instanceof Ic && (r === "show" && this._revealReference(o, !1), this._onDidSelectReference.fire({ element: o, kind: r, source: "tree" }));
      };
      this._tree.onDidOpen((o) => {
        o.sideBySide ? n(o.element, "side") : o.editorOptions.pinned ? n(o.element, "goto") : n(o.element, "show");
      }), os(this._treeContainer);
    }
    _onWidth(e) {
      this._dim && this._doLayoutBody(this._dim.height, e);
    }
    _doLayoutBody(e, t) {
      super._doLayoutBody(e, t), this._dim = new Et(t, e), this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines, this._splitView.layout(t), this._splitView.resizeView(0, t * this.layoutData.ratio);
    }
    setSelection(e) {
      return this._revealReference(e, !0).then(() => {
        !this._model || (this._tree.setSelection([e]), this._tree.setFocus([e]));
      });
    }
    setModel(e) {
      return this._disposeOnNewModel.clear(), this._model = e, this._model ? this._onNewModel() : Promise.resolve();
    }
    _onNewModel() {
      return this._model ? this._model.isEmpty ? (this.setTitle(""), this._messageContainer.innerText = m("noResults", "No results"), Vs(this._messageContainer), Promise.resolve(void 0)) : (os(this._messageContainer), this._decorationsManager = new OC(this._preview, this._model), this._disposeOnNewModel.add(this._decorationsManager), this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((e) => this._tree.rerender(e))), this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
        const { event: t, target: i } = e;
        if (t.detail !== 2)
          return;
        const n = this._getFocusedReference();
        !n || this._onDidSelectReference.fire({
          element: { uri: n.uri, range: i.range },
          kind: t.ctrlKey || t.metaKey || t.altKey ? "side" : "open",
          source: "editor"
        });
      })), this.container.classList.add("results-loaded"), Vs(this._treeContainer), Vs(this._previewContainer), this._splitView.layout(this._dim.width), this.focusOnReferenceTree(), this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model)) : Promise.resolve(void 0);
    }
    _getFocusedReference() {
      const [e] = this._tree.getFocus();
      if (e instanceof Ic)
        return e;
      if (e instanceof yp && e.children.length > 0)
        return e.children[0];
    }
    revealReference(e) {
      return oA(this, void 0, void 0, function* () {
        yield this._revealReference(e, !1), this._onDidSelectReference.fire({ element: e, kind: "goto", source: "tree" });
      });
    }
    _revealReference(e, t) {
      return oA(this, void 0, void 0, function* () {
        if (this._revealedReference === e)
          return;
        this._revealedReference = e, e.uri.scheme !== ze.inMemory ? this.setTitle(Lq(e.uri), this._uriLabel.getUriLabel(hC(e.uri))) : this.setTitle(m("peekView.alternateTitle", "References"));
        const i = this._textModelResolverService.createModelReference(e.uri);
        this._tree.getInput() === e.parent ? this._tree.reveal(e) : (t && this._tree.reveal(e.parent), yield this._tree.expand(e.parent), this._tree.reveal(e));
        const n = yield i;
        if (!this._model) {
          n.dispose();
          return;
        }
        at(this._previewModelReference);
        const o = n.object;
        if (o) {
          const r = this._preview.getModel() === o.textEditorModel ? 0 : 1, a = D.lift(e.range).collapseToStart();
          this._previewModelReference = n, this._preview.setModel(o.textEditorModel), this._preview.setSelection(a), this._preview.revealRangeInCenter(a, r);
        } else
          this._preview.setModel(this._previewNotAvailableMessage), n.dispose();
      });
    }
  };
  gk = bJ([
    Pa(3, jt),
    Pa(4, fs),
    Pa(5, et),
    Pa(6, y3),
    Pa(7, w_),
    Pa(8, uC),
    Pa(9, ci),
    Pa(10, Jt),
    Pa(11, Mn)
  ], gk);
  var wJ = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, su = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, rA = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const Uh = new ue("referenceSearchVisible", !1, m("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
  let Ec = class mk {
    constructor(e, t, i, n, o, r, a, l) {
      this._defaultTreeKeyboardSupport = e, this._editor = t, this._editorService = n, this._notificationService = o, this._instantiationService = r, this._storageService = a, this._configurationService = l, this._disposables = new te(), this._requestIdPool = 0, this._ignoreModelChangeEvent = !1, this._referenceSearchVisible = Uh.bindTo(i);
    }
    static get(e) {
      return e.getContribution(mk.ID);
    }
    dispose() {
      var e, t;
      this._referenceSearchVisible.reset(), this._disposables.dispose(), (e = this._widget) === null || e === void 0 || e.dispose(), (t = this._model) === null || t === void 0 || t.dispose(), this._widget = void 0, this._model = void 0;
    }
    toggleWidget(e, t, i) {
      let n;
      if (this._widget && (n = this._widget.position), this.closeWidget(), !!n && e.containsPosition(n))
        return;
      this._peekMode = i, this._referenceSearchVisible.set(!0), this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
        this.closeWidget();
      })), this._disposables.add(this._editor.onDidChangeModel(() => {
        this._ignoreModelChangeEvent || this.closeWidget();
      }));
      const o = "peekViewLayout", r = vJ.fromJSON(this._storageService.get(o, 0, "{}"));
      this._widget = this._instantiationService.createInstance(gk, this._editor, this._defaultTreeKeyboardSupport, r), this._widget.setTitle(m("labelLoading", "Loading...")), this._widget.show(e), this._disposables.add(this._widget.onDidClose(() => {
        t.cancel(), this._widget && (this._storageService.store(o, JSON.stringify(this._widget.layoutData), 0, 1), this._widget = void 0), this.closeWidget();
      })), this._disposables.add(this._widget.onDidSelectReference((l) => {
        let { element: c, kind: d } = l;
        if (!!c)
          switch (d) {
            case "open":
              (l.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) && this.openReference(c, !1, !1);
              break;
            case "side":
              this.openReference(c, !0, !1);
              break;
            case "goto":
              i ? this._gotoReference(c) : this.openReference(c, !1, !0);
              break;
          }
      }));
      const a = ++this._requestIdPool;
      t.then((l) => {
        var c;
        if (a !== this._requestIdPool || !this._widget) {
          l.dispose();
          return;
        }
        return (c = this._model) === null || c === void 0 || c.dispose(), this._model = l, this._widget.setModel(this._model).then(() => {
          if (this._widget && this._model && this._editor.hasModel()) {
            this._model.isEmpty ? this._widget.setMetaTitle("") : this._widget.setMetaTitle(m("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
            let d = this._editor.getModel().uri, h = new V(e.startLineNumber, e.startColumn), u = this._model.nearestReference(d, h);
            if (u)
              return this._widget.setSelection(u).then(() => {
                this._widget && this._editor.getOption(77) === "editor" && this._widget.focusOnPreviewEditor();
              });
          }
        });
      }, (l) => {
        this._notificationService.error(l);
      });
    }
    changeFocusBetweenPreviewAndReferences() {
      !this._widget || (this._widget.isPreviewEditorFocused() ? this._widget.focusOnReferenceTree() : this._widget.focusOnPreviewEditor());
    }
    goToNextOrPreviousReference(e) {
      return rA(this, void 0, void 0, function* () {
        if (!this._editor.hasModel() || !this._model || !this._widget)
          return;
        const t = this._widget.position;
        if (!t)
          return;
        const i = this._model.nearestReference(this._editor.getModel().uri, t);
        if (!i)
          return;
        const n = this._model.nextOrPreviousReference(i, e), o = this._editor.hasTextFocus(), r = this._widget.isPreviewEditorFocused();
        yield this._widget.setSelection(n), yield this._gotoReference(n), o ? this._editor.focus() : this._widget && r && this._widget.focusOnPreviewEditor();
      });
    }
    revealReference(e) {
      return rA(this, void 0, void 0, function* () {
        !this._editor.hasModel() || !this._model || !this._widget || (yield this._widget.revealReference(e));
      });
    }
    closeWidget(e = !0) {
      var t, i;
      (t = this._widget) === null || t === void 0 || t.dispose(), (i = this._model) === null || i === void 0 || i.dispose(), this._referenceSearchVisible.reset(), this._disposables.clear(), this._widget = void 0, this._model = void 0, e && this._editor.focus(), this._requestIdPool += 1;
    }
    _gotoReference(e) {
      this._widget && this._widget.hide(), this._ignoreModelChangeEvent = !0;
      const t = D.lift(e.range).collapseToStart();
      return this._editorService.openCodeEditor({
        resource: e.uri,
        options: { selection: t, selectionSource: "code.jump" }
      }, this._editor).then((i) => {
        var n;
        if (this._ignoreModelChangeEvent = !1, !i || !this._widget) {
          this.closeWidget();
          return;
        }
        if (this._editor === i)
          this._widget.show(t), this._widget.focusOnReferenceTree();
        else {
          const o = mk.get(i), r = this._model.clone();
          this.closeWidget(), i.focus(), o?.toggleWidget(t, an((a) => Promise.resolve(r)), (n = this._peekMode) !== null && n !== void 0 ? n : !1);
        }
      }, (i) => {
        this._ignoreModelChangeEvent = !1, We(i);
      });
    }
    openReference(e, t, i) {
      t || this.closeWidget();
      const { uri: n, range: o } = e;
      this._editorService.openCodeEditor({
        resource: n,
        options: { selection: o, selectionSource: "code.jump", pinned: i }
      }, this._editor, t);
    }
  };
  Ec.ID = "editor.contrib.referencesController";
  Ec = wJ([
    su(2, Fe),
    su(3, St),
    su(4, yi),
    su(5, et),
    su(6, La),
    su(7, At)
  ], Ec);
  function $h(s, e) {
    const t = HX(s);
    if (!t)
      return;
    const i = Ec.get(t);
    i && e(i);
  }
  Zn.registerCommandAndKeybindingRule({
    id: "togglePeekWidgetFocus",
    weight: 100,
    primary: Qi(2089, 60),
    when: ce.or(Uh, us.inPeekEditor),
    handler(s) {
      $h(s, (e) => {
        e.changeFocusBetweenPreviewAndReferences();
      });
    }
  });
  Zn.registerCommandAndKeybindingRule({
    id: "goToNextReference",
    weight: 100 - 10,
    primary: 62,
    secondary: [70],
    when: ce.or(Uh, us.inPeekEditor),
    handler(s) {
      $h(s, (e) => {
        e.goToNextOrPreviousReference(!0);
      });
    }
  });
  Zn.registerCommandAndKeybindingRule({
    id: "goToPreviousReference",
    weight: 100 - 10,
    primary: 1086,
    secondary: [1094],
    when: ce.or(Uh, us.inPeekEditor),
    handler(s) {
      $h(s, (e) => {
        e.goToNextOrPreviousReference(!1);
      });
    }
  });
  lt.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
  lt.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
  lt.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
  lt.registerCommand("closeReferenceSearch", (s) => $h(s, (e) => e.closeWidget()));
  Zn.registerKeybindingRule({
    id: "closeReferenceSearch",
    weight: 100 - 101,
    primary: 9,
    secondary: [1033],
    when: ce.and(us.inPeekEditor, ce.not("config.editor.stablePeek"))
  });
  Zn.registerKeybindingRule({
    id: "closeReferenceSearch",
    weight: 200 + 50,
    primary: 9,
    secondary: [1033],
    when: ce.and(Uh, ce.not("config.editor.stablePeek"))
  });
  Zn.registerCommandAndKeybindingRule({
    id: "revealReference",
    weight: 200,
    primary: 3,
    mac: {
      primary: 3,
      secondary: [2066]
    },
    when: ce.and(Uh, $3, bN.negate(), vN.negate()),
    handler(s) {
      var e;
      const i = (e = s.get(Eo).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
      Array.isArray(i) && i[0] instanceof Ic && $h(s, (n) => n.revealReference(i[0]));
    }
  });
  Zn.registerCommandAndKeybindingRule({
    id: "openReferenceToSide",
    weight: 100,
    primary: 2051,
    mac: {
      primary: 259
    },
    when: ce.and(Uh, $3, bN.negate(), vN.negate()),
    handler(s) {
      var e;
      const i = (e = s.get(Eo).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
      Array.isArray(i) && i[0] instanceof Ic && $h(s, (n) => n.openReference(i[0], !0, !0));
    }
  });
  lt.registerCommand("openReference", (s) => {
    var e;
    const i = (e = s.get(Eo).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
    Array.isArray(i) && i[0] instanceof Ic && $h(s, (n) => n.openReference(i[0], !1, !0));
  });
  var Z3 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Yg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const SN = new ue("hasSymbols", !1, m("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only.")), PC = st("ISymbolNavigationService");
  let pk = class {
    constructor(e, t, i, n) {
      this._editorService = t, this._notificationService = i, this._keybindingService = n, this._currentModel = void 0, this._currentIdx = -1, this._ignoreEditorChange = !1, this._ctxHasSymbols = SN.bindTo(e);
    }
    reset() {
      var e, t;
      this._ctxHasSymbols.reset(), (e = this._currentState) === null || e === void 0 || e.dispose(), (t = this._currentMessage) === null || t === void 0 || t.dispose(), this._currentModel = void 0, this._currentIdx = -1;
    }
    put(e) {
      const t = e.parent.parent;
      if (t.references.length <= 1) {
        this.reset();
        return;
      }
      this._currentModel = t, this._currentIdx = t.references.indexOf(e), this._ctxHasSymbols.set(!0), this._showMessage();
      const i = new _k(this._editorService), n = i.onDidChange((o) => {
        if (this._ignoreEditorChange)
          return;
        const r = this._editorService.getActiveCodeEditor();
        if (!r)
          return;
        const a = r.getModel(), l = r.getPosition();
        if (!a || !l)
          return;
        let c = !1, d = !1;
        for (const h of t.references)
          if (bF(h.uri, a.uri))
            c = !0, d = d || D.containsPosition(h.range, l);
          else if (c)
            break;
        (!c || !d) && this.reset();
      });
      this._currentState = ol(i, n);
    }
    revealNext(e) {
      if (!this._currentModel)
        return Promise.resolve();
      this._currentIdx += 1, this._currentIdx %= this._currentModel.references.length;
      const t = this._currentModel.references[this._currentIdx];
      return this._showMessage(), this._ignoreEditorChange = !0, this._editorService.openCodeEditor({
        resource: t.uri,
        options: {
          selection: D.collapseToStart(t.range),
          selectionRevealType: 3
        }
      }, e).finally(() => {
        this._ignoreEditorChange = !1;
      });
    }
    _showMessage() {
      var e;
      (e = this._currentMessage) === null || e === void 0 || e.dispose();
      const t = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult"), i = t ? m("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, t.getLabel()) : m("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
      this._currentMessage = this._notificationService.status(i);
    }
  };
  pk = Z3([
    Yg(0, Fe),
    Yg(1, St),
    Yg(2, yi),
    Yg(3, ci)
  ], pk);
  ht(PC, pk, !0);
  se(new class extends wn {
    constructor() {
      super({
        id: "editor.gotoNextSymbolFromResult",
        precondition: SN,
        kbOpts: {
          weight: 100,
          primary: 70
        }
      });
    }
    runEditorCommand(s, e) {
      return s.get(PC).revealNext(e);
    }
  }());
  Zn.registerCommandAndKeybindingRule({
    id: "editor.gotoNextSymbolFromResult.cancel",
    weight: 100,
    when: SN,
    primary: 9,
    handler(s) {
      s.get(PC).reset();
    }
  });
  let _k = class {
    constructor(e) {
      this._listener = /* @__PURE__ */ new Map(), this._disposables = new te(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._disposables.add(e.onCodeEditorRemove(this._onDidRemoveEditor, this)), this._disposables.add(e.onCodeEditorAdd(this._onDidAddEditor, this)), e.listCodeEditors().forEach(this._onDidAddEditor, this);
    }
    dispose() {
      this._disposables.dispose(), this._onDidChange.dispose(), at(this._listener.values());
    }
    _onDidAddEditor(e) {
      this._listener.set(e, ol(e.onDidChangeCursorPosition((t) => this._onDidChange.fire({ editor: e })), e.onDidChangeModelContent((t) => this._onDidChange.fire({ editor: e }))));
    }
    _onDidRemoveEditor(e) {
      var t;
      (t = this._listener.get(e)) === null || t === void 0 || t.dispose(), this._listener.delete(e);
    }
  };
  _k = Z3([
    Yg(0, St)
  ], _k);
  var Y3 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function y_(s, e, t, i) {
    const o = t.ordered(s).map((r) => Promise.resolve(i(r, s, e)).then(void 0, (a) => {
      Xi(a);
    }));
    return Promise.all(o).then((r) => {
      const a = [];
      for (let l of r)
        Array.isArray(l) ? a.push(...l) : l && a.push(l);
      return a;
    });
  }
  function yN(s, e, t, i) {
    return y_(e, t, s, (n, o, r) => n.provideDefinition(o, r, i));
  }
  function X3(s, e, t, i) {
    return y_(e, t, s, (n, o, r) => n.provideDeclaration(o, r, i));
  }
  function Q3(s, e, t, i) {
    return y_(e, t, s, (n, o, r) => n.provideImplementation(o, r, i));
  }
  function J3(s, e, t, i) {
    return y_(e, t, s, (n, o, r) => n.provideTypeDefinition(o, r, i));
  }
  function FC(s, e, t, i, n) {
    return y_(e, t, s, (o, r, a) => Y3(this, void 0, void 0, function* () {
      const l = yield o.provideReferences(r, a, { includeDeclaration: !0 }, n);
      if (!i || !l || l.length !== 2)
        return l;
      const c = yield o.provideReferences(r, a, { includeDeclaration: !1 }, n);
      return c && c.length === 1 ? c : l;
    }));
  }
  function L_(s) {
    return Y3(this, void 0, void 0, function* () {
      const e = yield s(), t = new xs(e, ""), i = t.references.map((n) => n.link);
      return t.dispose(), i;
    });
  }
  wa("_executeDefinitionProvider", (s, e, t) => {
    const i = s.get(me), n = yN(i.definitionProvider, e, t, Je.None);
    return L_(() => n);
  });
  wa("_executeTypeDefinitionProvider", (s, e, t) => {
    const i = s.get(me), n = J3(i.typeDefinitionProvider, e, t, Je.None);
    return L_(() => n);
  });
  wa("_executeDeclarationProvider", (s, e, t) => {
    const i = s.get(me), n = X3(i.declarationProvider, e, t, Je.None);
    return L_(() => n);
  });
  wa("_executeReferenceProvider", (s, e, t) => {
    const i = s.get(me), n = FC(i.referenceProvider, e, t, !1, Je.None);
    return L_(() => n);
  });
  wa("_executeImplementationProvider", (s, e, t) => {
    const i = s.get(me), n = Q3(i.implementationProvider, e, t, Je.None);
    return L_(() => n);
  });
  var qo = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, BS, WS, VS, HS, zS, US, $S, jS;
  qs.appendMenuItem(A.EditorContext, {
    submenu: A.EditorContextPeek,
    title: m("peek.submenu", "Peek"),
    group: "navigation",
    order: 100
  });
  const e7 = /* @__PURE__ */ new Set();
  function kr(s) {
    const e = new s();
    return VP(e), e7.add(e.id), e;
  }
  class Dp {
    constructor(e, t) {
      this.model = e, this.position = t;
    }
    static is(e) {
      return !e || typeof e != "object" ? !1 : !!(e instanceof Dp || V.isIPosition(e.position) && e.model);
    }
  }
  class jh extends ge {
    constructor(e, t) {
      super(t), this.configuration = e;
    }
    run(e, t, i) {
      if (!t.hasModel())
        return Promise.resolve(void 0);
      const n = e.get(yi), o = e.get(St), r = e.get(Bc), a = e.get(PC), l = e.get(me), c = t.getModel(), d = t.getPosition(), h = Dp.is(i) ? i : new Dp(c, d), u = new mp(t, 5), f = CI(this._getLocationModel(l, h.model, h.position, u.token), u.token).then((g) => qo(this, void 0, void 0, function* () {
        var _;
        if (!g || u.token.isCancellationRequested)
          return;
        pn(g.ariaMessage);
        let b;
        if (g.referenceAt(c.uri, d)) {
          const v = this._getAlternativeCommand(t);
          v !== this.id && e7.has(v) && (b = t.getAction(v));
        }
        const C = g.references.length;
        if (C === 0) {
          if (!this.configuration.muteMessage) {
            const v = c.getWordAtPosition(d);
            (_ = eo.get(t)) === null || _ === void 0 || _.showMessage(this._getNoResultFoundMessage(v), d);
          }
        } else if (C === 1 && b)
          b.run();
        else
          return this._onResult(o, a, t, g);
      }), (g) => {
        n.error(g);
      }).finally(() => {
        u.dispose();
      });
      return r.showWhile(f, 250), f;
    }
    _onResult(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        const o = this._getGoToPreference(i);
        if (!(i instanceof oh) && (this.configuration.openInPeek || o === "peek" && n.references.length > 1))
          this._openInPeek(i, n);
        else {
          const r = n.firstReference(), a = n.references.length > 1 && o === "gotoAndPeek", l = yield this._openReference(i, e, r, this.configuration.openToSide, !a);
          a && l ? this._openInPeek(l, n) : n.dispose(), o === "goto" && t.put(r);
        }
      });
    }
    _openReference(e, t, i, n, o) {
      return qo(this, void 0, void 0, function* () {
        let r;
        if (rj(i) && (r = i.targetSelectionRange), r || (r = i.range), !r)
          return;
        const a = yield t.openCodeEditor({
          resource: i.uri,
          options: {
            selection: D.collapseToStart(r),
            selectionRevealType: 3,
            selectionSource: "code.jump"
          }
        }, e, n);
        if (!!a) {
          if (o) {
            const l = a.getModel(), c = a.deltaDecorations([], [{ range: r, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
            setTimeout(() => {
              a.getModel() === l && a.deltaDecorations(c, []);
            }, 350);
          }
          return a;
        }
      });
    }
    _openInPeek(e, t) {
      const i = Ec.get(e);
      i && e.hasModel() ? i.toggleWidget(e.getSelection(), an((n) => Promise.resolve(t)), this.configuration.openInPeek) : t.dispose();
    }
  }
  class k_ extends jh {
    _getLocationModel(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        return new xs(yield yN(e.definitionProvider, t, i, n), m("def.title", "Definitions"));
      });
    }
    _getNoResultFoundMessage(e) {
      return e && e.word ? m("noResultWord", "No definition found for '{0}'", e.word) : m("generic.noResults", "No definition found");
    }
    _getAlternativeCommand(e) {
      return e.getOption(51).alternativeDefinitionCommand;
    }
    _getGoToPreference(e) {
      return e.getOption(51).multipleDefinitions;
    }
  }
  const t7 = Pc && !mI ? 2118 : 70;
  kr((BS = class bk extends k_ {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !1,
        muteMessage: !1
      }, {
        id: bk.id,
        label: m("actions.goToDecl.label", "Go to Definition"),
        alias: "Go to Definition",
        precondition: ce.and(T.hasDefinitionProvider, T.isInWalkThroughSnippet.toNegated()),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: t7,
          weight: 100
        },
        contextMenuOpts: {
          group: "navigation",
          order: 1.1
        }
      }), lt.registerCommandAlias("editor.action.goToDeclaration", bk.id);
    }
  }, BS.id = "editor.action.revealDefinition", BS));
  kr((WS = class vk extends k_ {
    constructor() {
      super({
        openToSide: !0,
        openInPeek: !1,
        muteMessage: !1
      }, {
        id: vk.id,
        label: m("actions.goToDeclToSide.label", "Open Definition to the Side"),
        alias: "Open Definition to the Side",
        precondition: ce.and(T.hasDefinitionProvider, T.isInWalkThroughSnippet.toNegated()),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, t7),
          weight: 100
        }
      }), lt.registerCommandAlias("editor.action.openDeclarationToTheSide", vk.id);
    }
  }, WS.id = "editor.action.revealDefinitionAside", WS));
  kr((VS = class Ck extends k_ {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !0,
        muteMessage: !1
      }, {
        id: Ck.id,
        label: m("actions.previewDecl.label", "Peek Definition"),
        alias: "Peek Definition",
        precondition: ce.and(T.hasDefinitionProvider, us.notInPeekEditor, T.isInWalkThroughSnippet.toNegated()),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 582,
          linux: { primary: 3140 },
          weight: 100
        },
        contextMenuOpts: {
          menuId: A.EditorContextPeek,
          group: "peek",
          order: 2
        }
      }), lt.registerCommandAlias("editor.action.previewDeclaration", Ck.id);
    }
  }, VS.id = "editor.action.peekDefinition", VS));
  class i7 extends jh {
    _getLocationModel(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        return new xs(yield X3(e.declarationProvider, t, i, n), m("decl.title", "Declarations"));
      });
    }
    _getNoResultFoundMessage(e) {
      return e && e.word ? m("decl.noResultWord", "No declaration found for '{0}'", e.word) : m("decl.generic.noResults", "No declaration found");
    }
    _getAlternativeCommand(e) {
      return e.getOption(51).alternativeDeclarationCommand;
    }
    _getGoToPreference(e) {
      return e.getOption(51).multipleDeclarations;
    }
  }
  kr((HS = class n7 extends i7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !1,
        muteMessage: !1
      }, {
        id: n7.id,
        label: m("actions.goToDeclaration.label", "Go to Declaration"),
        alias: "Go to Declaration",
        precondition: ce.and(T.hasDeclarationProvider, T.isInWalkThroughSnippet.toNegated()),
        contextMenuOpts: {
          group: "navigation",
          order: 1.3
        }
      });
    }
    _getNoResultFoundMessage(e) {
      return e && e.word ? m("decl.noResultWord", "No declaration found for '{0}'", e.word) : m("decl.generic.noResults", "No declaration found");
    }
  }, HS.id = "editor.action.revealDeclaration", HS));
  kr(class extends i7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !0,
        muteMessage: !1
      }, {
        id: "editor.action.peekDeclaration",
        label: m("actions.peekDecl.label", "Peek Declaration"),
        alias: "Peek Declaration",
        precondition: ce.and(T.hasDeclarationProvider, us.notInPeekEditor, T.isInWalkThroughSnippet.toNegated()),
        contextMenuOpts: {
          menuId: A.EditorContextPeek,
          group: "peek",
          order: 3
        }
      });
    }
  });
  class s7 extends jh {
    _getLocationModel(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        return new xs(yield J3(e.typeDefinitionProvider, t, i, n), m("typedef.title", "Type Definitions"));
      });
    }
    _getNoResultFoundMessage(e) {
      return e && e.word ? m("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", e.word) : m("goToTypeDefinition.generic.noResults", "No type definition found");
    }
    _getAlternativeCommand(e) {
      return e.getOption(51).alternativeTypeDefinitionCommand;
    }
    _getGoToPreference(e) {
      return e.getOption(51).multipleTypeDefinitions;
    }
  }
  kr((zS = class o7 extends s7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !1,
        muteMessage: !1
      }, {
        id: o7.ID,
        label: m("actions.goToTypeDefinition.label", "Go to Type Definition"),
        alias: "Go to Type Definition",
        precondition: ce.and(T.hasTypeDefinitionProvider, T.isInWalkThroughSnippet.toNegated()),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 0,
          weight: 100
        },
        contextMenuOpts: {
          group: "navigation",
          order: 1.4
        }
      });
    }
  }, zS.ID = "editor.action.goToTypeDefinition", zS));
  kr((US = class r7 extends s7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !0,
        muteMessage: !1
      }, {
        id: r7.ID,
        label: m("actions.peekTypeDefinition.label", "Peek Type Definition"),
        alias: "Peek Type Definition",
        precondition: ce.and(T.hasTypeDefinitionProvider, us.notInPeekEditor, T.isInWalkThroughSnippet.toNegated()),
        contextMenuOpts: {
          menuId: A.EditorContextPeek,
          group: "peek",
          order: 4
        }
      });
    }
  }, US.ID = "editor.action.peekTypeDefinition", US));
  class a7 extends jh {
    _getLocationModel(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        return new xs(yield Q3(e.implementationProvider, t, i, n), m("impl.title", "Implementations"));
      });
    }
    _getNoResultFoundMessage(e) {
      return e && e.word ? m("goToImplementation.noResultWord", "No implementation found for '{0}'", e.word) : m("goToImplementation.generic.noResults", "No implementation found");
    }
    _getAlternativeCommand(e) {
      return e.getOption(51).alternativeImplementationCommand;
    }
    _getGoToPreference(e) {
      return e.getOption(51).multipleImplementations;
    }
  }
  kr(($S = class l7 extends a7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !1,
        muteMessage: !1
      }, {
        id: l7.ID,
        label: m("actions.goToImplementation.label", "Go to Implementations"),
        alias: "Go to Implementations",
        precondition: ce.and(T.hasImplementationProvider, T.isInWalkThroughSnippet.toNegated()),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2118,
          weight: 100
        },
        contextMenuOpts: {
          group: "navigation",
          order: 1.45
        }
      });
    }
  }, $S.ID = "editor.action.goToImplementation", $S));
  kr((jS = class c7 extends a7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !0,
        muteMessage: !1
      }, {
        id: c7.ID,
        label: m("actions.peekImplementation.label", "Peek Implementations"),
        alias: "Peek Implementations",
        precondition: ce.and(T.hasImplementationProvider, us.notInPeekEditor, T.isInWalkThroughSnippet.toNegated()),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3142,
          weight: 100
        },
        contextMenuOpts: {
          menuId: A.EditorContextPeek,
          group: "peek",
          order: 5
        }
      });
    }
  }, jS.ID = "editor.action.peekImplementation", jS));
  class d7 extends jh {
    _getNoResultFoundMessage(e) {
      return e ? m("references.no", "No references found for '{0}'", e.word) : m("references.noGeneric", "No references found");
    }
    _getAlternativeCommand(e) {
      return e.getOption(51).alternativeReferenceCommand;
    }
    _getGoToPreference(e) {
      return e.getOption(51).multipleReferences;
    }
  }
  kr(class extends d7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !1,
        muteMessage: !1
      }, {
        id: "editor.action.goToReferences",
        label: m("goToReferences.label", "Go to References"),
        alias: "Go to References",
        precondition: ce.and(T.hasReferenceProvider, us.notInPeekEditor, T.isInWalkThroughSnippet.toNegated()),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1094,
          weight: 100
        },
        contextMenuOpts: {
          group: "navigation",
          order: 1.45
        }
      });
    }
    _getLocationModel(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        return new xs(yield FC(e.referenceProvider, t, i, !0, n), m("ref.title", "References"));
      });
    }
  });
  kr(class extends d7 {
    constructor() {
      super({
        openToSide: !1,
        openInPeek: !0,
        muteMessage: !1
      }, {
        id: "editor.action.referenceSearch.trigger",
        label: m("references.action.label", "Peek References"),
        alias: "Peek References",
        precondition: ce.and(T.hasReferenceProvider, us.notInPeekEditor, T.isInWalkThroughSnippet.toNegated()),
        contextMenuOpts: {
          menuId: A.EditorContextPeek,
          group: "peek",
          order: 6
        }
      });
    }
    _getLocationModel(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        return new xs(yield FC(e.referenceProvider, t, i, !1, n), m("ref.title", "References"));
      });
    }
  });
  class SJ extends jh {
    constructor(e, t, i) {
      super(e, {
        id: "editor.action.goToLocation",
        label: m("label.generic", "Go to Any Symbol"),
        alias: "Go to Any Symbol",
        precondition: ce.and(us.notInPeekEditor, T.isInWalkThroughSnippet.toNegated())
      }), this._references = t, this._gotoMultipleBehaviour = i;
    }
    _getLocationModel(e, t, i, n) {
      return qo(this, void 0, void 0, function* () {
        return new xs(this._references, m("generic.title", "Locations"));
      });
    }
    _getNoResultFoundMessage(e) {
      return e && m("generic.noResult", "No results for '{0}'", e.word) || "";
    }
    _getGoToPreference(e) {
      var t;
      return (t = this._gotoMultipleBehaviour) !== null && t !== void 0 ? t : e.getOption(51).multipleReferences;
    }
    _getAlternativeCommand() {
      return "";
    }
  }
  lt.registerCommand({
    id: "editor.action.goToLocations",
    description: {
      description: "Go to locations from a position in a file",
      args: [
        { name: "uri", description: "The text document in which to start", constraint: Ee },
        { name: "position", description: "The position at which to start", constraint: V.isIPosition },
        { name: "locations", description: "An array of locations.", constraint: Array },
        { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" },
        { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
      ]
    },
    handler: (s, e, t, i, n, o, r) => qo(void 0, void 0, void 0, function* () {
      Nt(Ee.isUri(e)), Nt(V.isIPosition(t)), Nt(Array.isArray(i)), Nt(typeof n > "u" || typeof n == "string"), Nt(typeof r > "u" || typeof r == "boolean");
      const a = s.get(St), l = yield a.openCodeEditor({ resource: e }, a.getFocusedCodeEditor());
      if (pl(l))
        return l.setPosition(t), l.revealPositionInCenterIfOutsideViewport(t, 0), l.invokeWithinContext((c) => {
          const d = new class extends SJ {
            _getNoResultFoundMessage(h) {
              return o || super._getNoResultFoundMessage(h);
            }
          }({
            muteMessage: !Boolean(o),
            openInPeek: Boolean(r),
            openToSide: !1
          }, i, n);
          c.get(et).invokeFunction(d.run.bind(d), l);
        });
    })
  });
  lt.registerCommand({
    id: "editor.action.peekLocations",
    description: {
      description: "Peek locations from a position in a file",
      args: [
        { name: "uri", description: "The text document in which to start", constraint: Ee },
        { name: "position", description: "The position at which to start", constraint: V.isIPosition },
        { name: "locations", description: "An array of locations.", constraint: Array },
        { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" }
      ]
    },
    handler: (s, e, t, i, n) => qo(void 0, void 0, void 0, function* () {
      s.get(wi).executeCommand("editor.action.goToLocations", e, t, i, n, void 0, !0);
    })
  });
  lt.registerCommand({
    id: "editor.action.findReferences",
    handler: (s, e, t) => {
      Nt(Ee.isUri(e)), Nt(V.isIPosition(t));
      const i = s.get(me), n = s.get(St);
      return n.openCodeEditor({ resource: e }, n.getFocusedCodeEditor()).then((o) => {
        if (!pl(o) || !o.hasModel())
          return;
        const r = Ec.get(o);
        if (!r)
          return;
        const a = an((c) => FC(i.referenceProvider, o.getModel(), V.lift(t), !1, c).then((d) => new xs(d, m("ref.title", "References")))), l = new D(t.lineNumber, t.column, t.lineNumber, t.column);
        return Promise.resolve(r.toggleWidget(l, a, !1));
      });
    }
  });
  lt.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
  qs.appendMenuItems([
    {
      id: A.MenubarGoMenu,
      item: {
        command: {
          id: "editor.action.revealDefinition",
          title: m({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
        },
        group: "4_symbol_nav",
        order: 2
      }
    },
    {
      id: A.MenubarGoMenu,
      item: {
        command: {
          id: "editor.action.revealDeclaration",
          title: m({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
        },
        group: "4_symbol_nav",
        order: 3
      }
    },
    {
      id: A.MenubarGoMenu,
      item: {
        command: {
          id: "editor.action.goToTypeDefinition",
          title: m({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
        },
        group: "4_symbol_nav",
        order: 3
      }
    },
    {
      id: A.MenubarGoMenu,
      item: {
        command: {
          id: "editor.action.goToImplementation",
          title: m({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
        },
        group: "4_symbol_nav",
        order: 4
      }
    },
    {
      id: A.MenubarGoMenu,
      item: {
        command: {
          id: "editor.action.goToReferences",
          title: m({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
        },
        group: "4_symbol_nav",
        order: 5
      }
    }
  ]);
  var yJ = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, KS = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let ch = class Xg {
    constructor(e, t, i, n) {
      this.textModelResolverService = t, this.languageService = i, this.languageFeaturesService = n, this.toUnhook = new te(), this.toUnhookForKeyboard = new te(), this.linkDecorations = [], this.currentWordAtPosition = null, this.previousPromise = null, this.editor = e;
      let o = new iN(e);
      this.toUnhook.add(o), this.toUnhook.add(o.onMouseMoveOrRelevantKeyDown(([r, a]) => {
        this.startFindDefinitionFromMouse(r, ys(a));
      })), this.toUnhook.add(o.onExecute((r) => {
        this.isEnabled(r) && this.gotoDefinition(r.target.position, r.hasSideBySideModifier).then(() => {
          this.removeLinkDecorations();
        }, (a) => {
          this.removeLinkDecorations(), We(a);
        });
      })), this.toUnhook.add(o.onCancel(() => {
        this.removeLinkDecorations(), this.currentWordAtPosition = null;
      }));
    }
    static get(e) {
      return e.getContribution(Xg.ID);
    }
    startFindDefinitionFromCursor(e) {
      return this.startFindDefinition(e).then(() => {
        this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
          this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear();
        })), this.toUnhookForKeyboard.add(this.editor.onKeyDown((t) => {
          t && (this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear());
        }));
      });
    }
    startFindDefinitionFromMouse(e, t) {
      if (e.target.type === 9 && this.linkDecorations.length > 0)
        return;
      if (!this.editor.hasModel() || !this.isEnabled(e, t)) {
        this.currentWordAtPosition = null, this.removeLinkDecorations();
        return;
      }
      const i = e.target.position;
      this.startFindDefinition(i);
    }
    startFindDefinition(e) {
      var t;
      this.toUnhookForKeyboard.clear();
      const i = e ? (t = this.editor.getModel()) === null || t === void 0 ? void 0 : t.getWordAtPosition(e) : null;
      if (!i)
        return this.currentWordAtPosition = null, this.removeLinkDecorations(), Promise.resolve(0);
      if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === i.startColumn && this.currentWordAtPosition.endColumn === i.endColumn && this.currentWordAtPosition.word === i.word)
        return Promise.resolve(0);
      this.currentWordAtPosition = i;
      let n = new gp(this.editor, 15);
      return this.previousPromise && (this.previousPromise.cancel(), this.previousPromise = null), this.previousPromise = an((o) => this.findDefinition(e, o)), this.previousPromise.then((o) => {
        if (!o || !o.length || !n.validate(this.editor)) {
          this.removeLinkDecorations();
          return;
        }
        if (o.length > 1)
          this.addDecoration(new D(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn), new Us().appendText(m("multipleResults", "Click to show {0} definitions.", o.length)));
        else {
          let r = o[0];
          if (!r.uri)
            return;
          this.textModelResolverService.createModelReference(r.uri).then((a) => {
            if (!a.object || !a.object.textEditorModel) {
              a.dispose();
              return;
            }
            const { object: { textEditorModel: l } } = a, { startLineNumber: c } = r.range;
            if (c < 1 || c > l.getLineCount()) {
              a.dispose();
              return;
            }
            const d = this.getPreviewValue(l, c, r);
            let h;
            r.originSelectionRange ? h = D.lift(r.originSelectionRange) : h = new D(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn);
            const u = this.languageService.guessLanguageIdByFilepathOrFirstLine(l.uri);
            this.addDecoration(h, new Us().appendCodeblock(u || "", d)), a.dispose();
          });
        }
      }).then(void 0, We);
    }
    getPreviewValue(e, t, i) {
      let n = i.targetSelectionRange ? i.range : this.getPreviewRangeBasedOnBrackets(e, t);
      return n.endLineNumber - n.startLineNumber >= Xg.MAX_SOURCE_PREVIEW_LINES && (n = this.getPreviewRangeBasedOnIndentation(e, t)), this.stripIndentationFromPreviewRange(e, t, n);
    }
    stripIndentationFromPreviewRange(e, t, i) {
      let o = e.getLineFirstNonWhitespaceColumn(t);
      for (let a = t + 1; a < i.endLineNumber; a++) {
        const l = e.getLineFirstNonWhitespaceColumn(a);
        o = Math.min(o, l);
      }
      return e.getValueInRange(i).replace(new RegExp(`^\\s{${o - 1}}`, "gm"), "").trim();
    }
    getPreviewRangeBasedOnIndentation(e, t) {
      const i = e.getLineFirstNonWhitespaceColumn(t), n = Math.min(e.getLineCount(), t + Xg.MAX_SOURCE_PREVIEW_LINES);
      let o = t + 1;
      for (; o < n; o++) {
        let r = e.getLineFirstNonWhitespaceColumn(o);
        if (i === r)
          break;
      }
      return new D(t, 1, o + 1, 1);
    }
    getPreviewRangeBasedOnBrackets(e, t) {
      const i = Math.min(e.getLineCount(), t + Xg.MAX_SOURCE_PREVIEW_LINES), n = [];
      let o = !0, r = e.bracketPairs.findNextBracket(new V(t, 1));
      for (; r !== null; ) {
        if (n.length === 0)
          n.push(r);
        else {
          const d = n[n.length - 1];
          if (d.open[0] === r.open[0] && d.isOpen && !r.isOpen ? n.pop() : n.push(r), n.length === 0)
            if (o)
              o = !1;
            else
              return new D(t, 1, r.range.endLineNumber + 1, 1);
        }
        const a = e.getLineMaxColumn(t);
        let l = r.range.endLineNumber, c = r.range.endColumn;
        if (a === r.range.endColumn && (l++, c = 1), l > i)
          return new D(t, 1, i + 1, 1);
        r = e.bracketPairs.findNextBracket(new V(l, c));
      }
      return new D(t, 1, i + 1, 1);
    }
    addDecoration(e, t) {
      const i = {
        range: e,
        options: {
          description: "goto-definition-link",
          inlineClassName: "goto-definition-link",
          hoverMessage: t
        }
      };
      this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, [i]);
    }
    removeLinkDecorations() {
      this.linkDecorations.length > 0 && (this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, []));
    }
    isEnabled(e, t) {
      return this.editor.hasModel() && e.isNoneOrSingleMouseDown && e.target.type === 6 && (e.hasTriggerModifier || (t ? t.keyCodeIsTriggerKey : !1)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
    }
    findDefinition(e, t) {
      const i = this.editor.getModel();
      return i ? yN(this.languageFeaturesService.definitionProvider, i, e, t) : Promise.resolve(null);
    }
    gotoDefinition(e, t) {
      return this.editor.setPosition(e), this.editor.invokeWithinContext((i) => {
        const n = !t && this.editor.getOption(78) && !this.isInPeekEditor(i);
        return new k_({ openToSide: t, openInPeek: n, muteMessage: !0 }, { alias: "", label: "", id: "", precondition: void 0 }).run(i, this.editor);
      });
    }
    isInPeekEditor(e) {
      const t = e.get(Fe);
      return us.inPeekEditor.getValue(t);
    }
    dispose() {
      this.toUnhook.dispose();
    }
  };
  ch.ID = "editor.contrib.gotodefinitionatposition";
  ch.MAX_SOURCE_PREVIEW_LINES = 8;
  ch = yJ([
    KS(1, fs),
    KS(2, Jt),
    KS(3, me)
  ], ch);
  vt(ch.ID, ch);
  Vt((s, e) => {
    const t = s.getColor(sE);
    t && e.addRule(`.monaco-editor .goto-definition-link { color: ${t} !important; }`);
  });
  const pb = J;
  class h7 extends z {
    constructor() {
      super(), this.containerDomNode = document.createElement("div"), this.containerDomNode.className = "monaco-hover", this.containerDomNode.tabIndex = 0, this.containerDomNode.setAttribute("role", "tooltip"), this.contentsDomNode = document.createElement("div"), this.contentsDomNode.className = "monaco-hover-content", this.scrollbar = this._register(new u_(this.contentsDomNode, {
        consumeMouseWheelIfScrollbarIsNeeded: !0
      })), this.containerDomNode.appendChild(this.scrollbar.getDomNode());
    }
    onContentsChanged() {
      this.scrollbar.scanDomNode();
    }
  }
  class LN extends z {
    constructor(e, t, i) {
      super(), this.actionContainer = q(e, pb("div.action-container")), this.actionContainer.setAttribute("tabindex", "0"), this.action = q(this.actionContainer, pb("a.action")), this.action.setAttribute("role", "button"), t.iconClass && q(this.action, pb(`span.icon.${t.iconClass}`));
      const n = q(this.action, pb("span"));
      n.textContent = i ? `${t.label} (${i})` : t.label, this._register(ee(this.actionContainer, ye.CLICK, (o) => {
        o.stopPropagation(), o.preventDefault(), t.run(this.actionContainer);
      })), this._register(ee(this.actionContainer, ye.KEY_UP, (o) => {
        new $t(o).equals(3) && (o.stopPropagation(), o.preventDefault(), t.run(this.actionContainer));
      })), this.setEnabled(!0);
    }
    static render(e, t, i) {
      return new LN(e, t, i);
    }
    setEnabled(e) {
      e ? (this.actionContainer.classList.remove("disabled"), this.actionContainer.removeAttribute("aria-disabled")) : (this.actionContainer.classList.add("disabled"), this.actionContainer.setAttribute("aria-disabled", "true"));
    }
  }
  var LJ = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, kJ = globalThis && globalThis.__asyncValues || function(s) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = s[Symbol.asyncIterator], t;
    return e ? e.call(s) : (s = typeof __values == "function" ? __values(s) : s[Symbol.iterator](), t = {}, i("next"), i("throw"), i("return"), t[Symbol.asyncIterator] = function() {
      return this;
    }, t);
    function i(o) {
      t[o] = s[o] && function(r) {
        return new Promise(function(a, l) {
          r = s[o](r), n(a, l, r.done, r.value);
        });
      };
    }
    function n(o, r, a, l) {
      Promise.resolve(l).then(function(c) {
        o({ value: c, done: a });
      }, r);
    }
  };
  class DJ {
    constructor(e, t, i) {
      this.value = e, this.isComplete = t, this.hasLoadingMessage = i;
    }
  }
  class u7 extends z {
    constructor(e, t) {
      super(), this._editor = e, this._computer = t, this._onResult = this._register(new B()), this.onResult = this._onResult.event, this._firstWaitScheduler = this._register(new It(() => this._triggerAsyncComputation(), 0)), this._secondWaitScheduler = this._register(new It(() => this._triggerSyncComputation(), 0)), this._loadingMessageScheduler = this._register(new It(() => this._triggerLoadingMessage(), 0)), this._state = 0, this._asyncIterable = null, this._asyncIterableDone = !1, this._result = [];
    }
    dispose() {
      this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), super.dispose();
    }
    get _hoverTime() {
      return this._editor.getOption(53).delay;
    }
    get _firstWaitTime() {
      return this._hoverTime / 2;
    }
    get _secondWaitTime() {
      return this._hoverTime - this._firstWaitTime;
    }
    get _loadingMessageTime() {
      return 3 * this._hoverTime;
    }
    _setState(e, t = !0) {
      this._state = e, t && this._fireResult();
    }
    _triggerAsyncComputation() {
      this._setState(2), this._secondWaitScheduler.schedule(this._secondWaitTime), this._computer.computeAsync ? (this._asyncIterableDone = !1, this._asyncIterable = nW((e) => this._computer.computeAsync(e)), LJ(this, void 0, void 0, function* () {
        var e, t;
        try {
          try {
            for (var i = kJ(this._asyncIterable), n; n = yield i.next(), !n.done; ) {
              const o = n.value;
              o && (this._result.push(o), this._fireResult());
            }
          } catch (o) {
            e = { error: o };
          } finally {
            try {
              n && !n.done && (t = i.return) && (yield t.call(i));
            } finally {
              if (e)
                throw e.error;
            }
          }
          this._asyncIterableDone = !0, (this._state === 3 || this._state === 4) && this._setState(0);
        } catch (o) {
          We(o);
        }
      })) : this._asyncIterableDone = !0;
    }
    _triggerSyncComputation() {
      this._computer.computeSync && (this._result = this._result.concat(this._computer.computeSync())), this._setState(this._asyncIterableDone ? 0 : 3);
    }
    _triggerLoadingMessage() {
      this._state === 3 && this._setState(4);
    }
    _fireResult() {
      if (this._state === 1 || this._state === 2)
        return;
      const e = this._state === 0, t = this._state === 4;
      this._onResult.fire(new DJ(this._result.slice(0), e, t));
    }
    start(e) {
      if (e === 0)
        this._state === 0 && (this._setState(1), this._firstWaitScheduler.schedule(this._firstWaitTime), this._loadingMessageScheduler.schedule(this._loadingMessageTime));
      else
        switch (this._state) {
          case 0:
            this._triggerAsyncComputation(), this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
            break;
          case 2:
            this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
            break;
        }
    }
    cancel() {
      this._firstWaitScheduler.cancel(), this._secondWaitScheduler.cancel(), this._loadingMessageScheduler.cancel(), this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), this._result = [], this._setState(0, !1);
    }
  }
  class qS {
    constructor(e, t) {
      this.priority = e, this.range = t, this.type = 1;
    }
    equals(e) {
      return e.type === 1 && this.range.equalsRange(e.range);
    }
    canAdoptVisibleHover(e, t) {
      return e.type === 1 && t.lineNumber === this.range.startLineNumber;
    }
  }
  class C0 {
    constructor(e, t, i) {
      this.priority = e, this.owner = t, this.range = i, this.type = 2;
    }
    equals(e) {
      return e.type === 2 && this.owner === e.owner;
    }
    canAdoptVisibleHover(e, t) {
      return e.type === 2 && this.owner === e.owner;
    }
  }
  const Kh = new class {
    constructor() {
      this._participants = [];
    }
    register(e) {
      this._participants.push(e);
    }
    getAll() {
      return this._participants;
    }
  }();
  class Wo {
    constructor() {
      this.value = "", this.pos = 0;
    }
    static isDigitCharacter(e) {
      return e >= 48 && e <= 57;
    }
    static isVariableCharacter(e) {
      return e === 95 || e >= 97 && e <= 122 || e >= 65 && e <= 90;
    }
    text(e) {
      this.value = e, this.pos = 0;
    }
    tokenText(e) {
      return this.value.substr(e.pos, e.len);
    }
    next() {
      if (this.pos >= this.value.length)
        return { type: 14, pos: this.pos, len: 0 };
      let e = this.pos, t = 0, i = this.value.charCodeAt(e), n;
      if (n = Wo._table[i], typeof n == "number")
        return this.pos += 1, { type: n, pos: e, len: 1 };
      if (Wo.isDigitCharacter(i)) {
        n = 8;
        do
          t += 1, i = this.value.charCodeAt(e + t);
        while (Wo.isDigitCharacter(i));
        return this.pos += t, { type: n, pos: e, len: t };
      }
      if (Wo.isVariableCharacter(i)) {
        n = 9;
        do
          i = this.value.charCodeAt(e + ++t);
        while (Wo.isVariableCharacter(i) || Wo.isDigitCharacter(i));
        return this.pos += t, { type: n, pos: e, len: t };
      }
      n = 10;
      do
        t += 1, i = this.value.charCodeAt(e + t);
      while (!isNaN(i) && typeof Wo._table[i] > "u" && !Wo.isDigitCharacter(i) && !Wo.isVariableCharacter(i));
      return this.pos += t, { type: n, pos: e, len: t };
    }
  }
  Wo._table = {
    [36]: 0,
    [58]: 1,
    [44]: 2,
    [123]: 3,
    [125]: 4,
    [92]: 5,
    [47]: 6,
    [124]: 7,
    [43]: 11,
    [45]: 12,
    [63]: 13
  };
  class cg {
    constructor() {
      this._children = [];
    }
    appendChild(e) {
      return e instanceof ws && this._children[this._children.length - 1] instanceof ws ? this._children[this._children.length - 1].value += e.value : (e.parent = this, this._children.push(e)), this;
    }
    replace(e, t) {
      const { parent: i } = e, n = i.children.indexOf(e), o = i.children.slice(0);
      o.splice(n, 1, ...t), i._children = o, function r(a, l) {
        for (const c of a)
          c.parent = l, r(c.children, c);
      }(t, i);
    }
    get children() {
      return this._children;
    }
    get snippet() {
      let e = this;
      for (; ; ) {
        if (!e)
          return;
        if (e instanceof BC)
          return e;
        e = e.parent;
      }
    }
    toString() {
      return this.children.reduce((e, t) => e + t.toString(), "");
    }
    len() {
      return 0;
    }
  }
  class ws extends cg {
    constructor(e) {
      super(), this.value = e;
    }
    toString() {
      return this.value;
    }
    len() {
      return this.value.length;
    }
    clone() {
      return new ws(this.value);
    }
  }
  class f7 extends cg {
  }
  class Ho extends f7 {
    constructor(e) {
      super(), this.index = e;
    }
    static compareByIndex(e, t) {
      return e.index === t.index ? 0 : e.isFinalTabstop ? 1 : t.isFinalTabstop || e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
    }
    get isFinalTabstop() {
      return this.index === 0;
    }
    get choice() {
      return this._children.length === 1 && this._children[0] instanceof D_ ? this._children[0] : void 0;
    }
    clone() {
      let e = new Ho(this.index);
      return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
    }
  }
  class D_ extends cg {
    constructor() {
      super(...arguments), this.options = [];
    }
    appendChild(e) {
      return e instanceof ws && (e.parent = this, this.options.push(e)), this;
    }
    toString() {
      return this.options[0].value;
    }
    len() {
      return this.options[0].len();
    }
    clone() {
      let e = new D_();
      return this.options.forEach(e.appendChild, e), e;
    }
  }
  class kN extends cg {
    constructor() {
      super(...arguments), this.regexp = new RegExp("");
    }
    resolve(e) {
      const t = this;
      let i = !1, n = e.replace(this.regexp, function() {
        return i = !0, t._replace(Array.prototype.slice.call(arguments, 0, -2));
      });
      return !i && this._children.some((o) => o instanceof rr && Boolean(o.elseValue)) && (n = this._replace([])), n;
    }
    _replace(e) {
      let t = "";
      for (const i of this._children)
        if (i instanceof rr) {
          let n = e[i.index] || "";
          n = i.resolve(n), t += n;
        } else
          t += i.toString();
      return t;
    }
    toString() {
      return "";
    }
    clone() {
      let e = new kN();
      return e.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")), e._children = this.children.map((t) => t.clone()), e;
    }
  }
  class rr extends cg {
    constructor(e, t, i, n) {
      super(), this.index = e, this.shorthandName = t, this.ifValue = i, this.elseValue = n;
    }
    resolve(e) {
      return this.shorthandName === "upcase" ? e ? e.toLocaleUpperCase() : "" : this.shorthandName === "downcase" ? e ? e.toLocaleLowerCase() : "" : this.shorthandName === "capitalize" ? e ? e[0].toLocaleUpperCase() + e.substr(1) : "" : this.shorthandName === "pascalcase" ? e ? this._toPascalCase(e) : "" : this.shorthandName === "camelcase" ? e ? this._toCamelCase(e) : "" : Boolean(e) && typeof this.ifValue == "string" ? this.ifValue : !Boolean(e) && typeof this.elseValue == "string" ? this.elseValue : e || "";
    }
    _toPascalCase(e) {
      const t = e.match(/[a-z0-9]+/gi);
      return t ? t.map((i) => i.charAt(0).toUpperCase() + i.substr(1).toLowerCase()).join("") : e;
    }
    _toCamelCase(e) {
      const t = e.match(/[a-z0-9]+/gi);
      return t ? t.map((i, n) => n === 0 ? i.toLowerCase() : i.charAt(0).toUpperCase() + i.substr(1).toLowerCase()).join("") : e;
    }
    clone() {
      return new rr(this.index, this.shorthandName, this.ifValue, this.elseValue);
    }
  }
  class xp extends f7 {
    constructor(e) {
      super(), this.name = e;
    }
    resolve(e) {
      let t = e.resolve(this);
      return this.transform && (t = this.transform.resolve(t || "")), t !== void 0 ? (this._children = [new ws(t)], !0) : !1;
    }
    clone() {
      const e = new xp(this.name);
      return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
    }
  }
  function aA(s, e) {
    const t = [...s];
    for (; t.length > 0; ) {
      const i = t.shift();
      if (!e(i))
        break;
      t.unshift(...i.children);
    }
  }
  class BC extends cg {
    get placeholderInfo() {
      if (!this._placeholders) {
        let e = [], t;
        this.walk(function(i) {
          return i instanceof Ho && (e.push(i), t = !t || t.index < i.index ? i : t), !0;
        }), this._placeholders = { all: e, last: t };
      }
      return this._placeholders;
    }
    get placeholders() {
      const { all: e } = this.placeholderInfo;
      return e;
    }
    offset(e) {
      let t = 0, i = !1;
      return this.walk((n) => n === e ? (i = !0, !1) : (t += n.len(), !0)), i ? t : -1;
    }
    fullLen(e) {
      let t = 0;
      return aA([e], (i) => (t += i.len(), !0)), t;
    }
    enclosingPlaceholders(e) {
      let t = [], { parent: i } = e;
      for (; i; )
        i instanceof Ho && t.push(i), i = i.parent;
      return t;
    }
    resolveVariables(e) {
      return this.walk((t) => (t instanceof xp && t.resolve(e) && (this._placeholders = void 0), !0)), this;
    }
    appendChild(e) {
      return this._placeholders = void 0, super.appendChild(e);
    }
    replace(e, t) {
      return this._placeholders = void 0, super.replace(e, t);
    }
    clone() {
      let e = new BC();
      return this._children = this.children.map((t) => t.clone()), e;
    }
    walk(e) {
      aA(this.children, e);
    }
  }
  class WC {
    constructor() {
      this._scanner = new Wo(), this._token = { type: 14, pos: 0, len: 0 };
    }
    static escape(e) {
      return e.replace(/\$|}|\\/g, "\\$&");
    }
    static guessNeedsClipboard(e) {
      return /\${?CLIPBOARD/.test(e);
    }
    parse(e, t, i) {
      this._scanner.text(e), this._token = this._scanner.next();
      const n = new BC();
      for (; this._parse(n); )
        ;
      const o = /* @__PURE__ */ new Map(), r = [];
      let a = 0;
      n.walk((l) => (l instanceof Ho && (a += 1, l.isFinalTabstop ? o.set(0, void 0) : !o.has(l.index) && l.children.length > 0 ? o.set(l.index, l.children) : r.push(l)), !0));
      for (const l of r) {
        const c = o.get(l.index);
        if (c) {
          const d = new Ho(l.index);
          d.transform = l.transform;
          for (const h of c)
            d.appendChild(h.clone());
          n.replace(l, [d]);
        }
      }
      return i || (i = a > 0 && t), !o.has(0) && i && n.appendChild(new Ho(0)), n;
    }
    _accept(e, t) {
      if (e === void 0 || this._token.type === e) {
        let i = t ? this._scanner.tokenText(this._token) : !0;
        return this._token = this._scanner.next(), i;
      }
      return !1;
    }
    _backTo(e) {
      return this._scanner.pos = e.pos + e.len, this._token = e, !1;
    }
    _until(e) {
      const t = this._token;
      for (; this._token.type !== e; ) {
        if (this._token.type === 14)
          return !1;
        if (this._token.type === 5) {
          const n = this._scanner.next();
          if (n.type !== 0 && n.type !== 4 && n.type !== 5)
            return !1;
        }
        this._token = this._scanner.next();
      }
      const i = this._scanner.value.substring(t.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
      return this._token = this._scanner.next(), i;
    }
    _parse(e) {
      return this._parseEscaped(e) || this._parseTabstopOrVariableName(e) || this._parseComplexPlaceholder(e) || this._parseComplexVariable(e) || this._parseAnything(e);
    }
    _parseEscaped(e) {
      let t;
      return (t = this._accept(5, !0)) ? (t = this._accept(0, !0) || this._accept(4, !0) || this._accept(5, !0) || t, e.appendChild(new ws(t)), !0) : !1;
    }
    _parseTabstopOrVariableName(e) {
      let t;
      const i = this._token;
      return this._accept(0) && (t = this._accept(9, !0) || this._accept(8, !0)) ? (e.appendChild(/^\d+$/.test(t) ? new Ho(Number(t)) : new xp(t)), !0) : this._backTo(i);
    }
    _parseComplexPlaceholder(e) {
      let t;
      const i = this._token;
      if (!(this._accept(0) && this._accept(3) && (t = this._accept(8, !0))))
        return this._backTo(i);
      const o = new Ho(Number(t));
      if (this._accept(1))
        for (; ; ) {
          if (this._accept(4))
            return e.appendChild(o), !0;
          if (!this._parse(o))
            return e.appendChild(new ws("${" + t + ":")), o.children.forEach(e.appendChild, e), !0;
        }
      else if (o.index > 0 && this._accept(7)) {
        const r = new D_();
        for (; ; ) {
          if (this._parseChoiceElement(r)) {
            if (this._accept(2))
              continue;
            if (this._accept(7) && (o.appendChild(r), this._accept(4)))
              return e.appendChild(o), !0;
          }
          return this._backTo(i), !1;
        }
      } else
        return this._accept(6) ? this._parseTransform(o) ? (e.appendChild(o), !0) : (this._backTo(i), !1) : this._accept(4) ? (e.appendChild(o), !0) : this._backTo(i);
    }
    _parseChoiceElement(e) {
      const t = this._token, i = [];
      for (; !(this._token.type === 2 || this._token.type === 7); ) {
        let n;
        if ((n = this._accept(5, !0)) ? n = this._accept(2, !0) || this._accept(7, !0) || this._accept(5, !0) || n : n = this._accept(void 0, !0), !n)
          return this._backTo(t), !1;
        i.push(n);
      }
      return i.length === 0 ? (this._backTo(t), !1) : (e.appendChild(new ws(i.join(""))), !0);
    }
    _parseComplexVariable(e) {
      let t;
      const i = this._token;
      if (!(this._accept(0) && this._accept(3) && (t = this._accept(9, !0))))
        return this._backTo(i);
      const o = new xp(t);
      if (this._accept(1))
        for (; ; ) {
          if (this._accept(4))
            return e.appendChild(o), !0;
          if (!this._parse(o))
            return e.appendChild(new ws("${" + t + ":")), o.children.forEach(e.appendChild, e), !0;
        }
      else
        return this._accept(6) ? this._parseTransform(o) ? (e.appendChild(o), !0) : (this._backTo(i), !1) : this._accept(4) ? (e.appendChild(o), !0) : this._backTo(i);
    }
    _parseTransform(e) {
      let t = new kN(), i = "", n = "";
      for (; !this._accept(6); ) {
        let o;
        if (o = this._accept(5, !0)) {
          o = this._accept(6, !0) || o, i += o;
          continue;
        }
        if (this._token.type !== 14) {
          i += this._accept(void 0, !0);
          continue;
        }
        return !1;
      }
      for (; !this._accept(6); ) {
        let o;
        if (o = this._accept(5, !0)) {
          o = this._accept(5, !0) || this._accept(6, !0) || o, t.appendChild(new ws(o));
          continue;
        }
        if (!(this._parseFormatString(t) || this._parseAnything(t)))
          return !1;
      }
      for (; !this._accept(4); ) {
        if (this._token.type !== 14) {
          n += this._accept(void 0, !0);
          continue;
        }
        return !1;
      }
      try {
        t.regexp = new RegExp(i, n);
      } catch {
        return !1;
      }
      return e.transform = t, !0;
    }
    _parseFormatString(e) {
      const t = this._token;
      if (!this._accept(0))
        return !1;
      let i = !1;
      this._accept(3) && (i = !0);
      let n = this._accept(8, !0);
      if (n)
        if (i) {
          if (this._accept(4))
            return e.appendChild(new rr(Number(n))), !0;
          if (!this._accept(1))
            return this._backTo(t), !1;
        } else
          return e.appendChild(new rr(Number(n))), !0;
      else
        return this._backTo(t), !1;
      if (this._accept(6)) {
        let o = this._accept(9, !0);
        return !o || !this._accept(4) ? (this._backTo(t), !1) : (e.appendChild(new rr(Number(n), o)), !0);
      } else if (this._accept(11)) {
        let o = this._until(4);
        if (o)
          return e.appendChild(new rr(Number(n), void 0, o, void 0)), !0;
      } else if (this._accept(12)) {
        let o = this._until(4);
        if (o)
          return e.appendChild(new rr(Number(n), void 0, void 0, o)), !0;
      } else if (this._accept(13)) {
        let o = this._until(1);
        if (o) {
          let r = this._until(4);
          if (r)
            return e.appendChild(new rr(Number(n), void 0, o, r)), !0;
        }
      } else {
        let o = this._until(4);
        if (o)
          return e.appendChild(new rr(Number(n), void 0, void 0, o)), !0;
      }
      return this._backTo(t), !1;
    }
    _parseAnything(e) {
      return this._token.type !== 14 ? (e.appendChild(new ws(this._scanner.tokenText(this._token))), this._accept(void 0), !0) : !1;
    }
  }
  const xJ = {
    inputActiveOptionBorder: H.fromHex("#007ACC00"),
    inputActiveOptionForeground: H.fromHex("#FFFFFF"),
    inputActiveOptionBackground: H.fromHex("#0E639C50")
  };
  class x_ extends Qo {
    constructor(e) {
      super(), this._onChange = this._register(new B()), this.onChange = this._onChange.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._opts = Object.assign(Object.assign({}, xJ), e), this._checked = this._opts.isChecked;
      const t = ["monaco-custom-checkbox"];
      this._opts.icon && t.push(...Un.asClassNameArray(this._opts.icon)), this._opts.actionClassName && t.push(...this._opts.actionClassName.split(" ")), this._checked && t.push("checked"), this.domNode = document.createElement("div"), this.domNode.title = this._opts.title, this.domNode.classList.add(...t), this._opts.notFocusable || (this.domNode.tabIndex = 0), this.domNode.setAttribute("role", "checkbox"), this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.setAttribute("aria-label", this._opts.title), this.applyStyles(), this.onclick(this.domNode, (i) => {
        this.enabled && (this.checked = !this._checked, this._onChange.fire(!1), i.preventDefault());
      }), this.ignoreGesture(this.domNode), this.onkeydown(this.domNode, (i) => {
        if (i.keyCode === 10 || i.keyCode === 3) {
          this.checked = !this._checked, this._onChange.fire(!0), i.preventDefault();
          return;
        }
        this._onKeyDown.fire(i);
      });
    }
    get enabled() {
      return this.domNode.getAttribute("aria-disabled") !== "true";
    }
    focus() {
      this.domNode.focus();
    }
    get checked() {
      return this._checked;
    }
    set checked(e) {
      this._checked = e, this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.classList.toggle("checked", this._checked), this.applyStyles();
    }
    width() {
      return 2 + 2 + 2 + 16;
    }
    style(e) {
      e.inputActiveOptionBorder && (this._opts.inputActiveOptionBorder = e.inputActiveOptionBorder), e.inputActiveOptionForeground && (this._opts.inputActiveOptionForeground = e.inputActiveOptionForeground), e.inputActiveOptionBackground && (this._opts.inputActiveOptionBackground = e.inputActiveOptionBackground), this.applyStyles();
    }
    applyStyles() {
      this.domNode && (this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : "", this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground ? this._opts.inputActiveOptionForeground.toString() : "inherit", this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground ? this._opts.inputActiveOptionBackground.toString() : "");
    }
    enable() {
      this.domNode.setAttribute("aria-disabled", String(!1));
    }
    disable() {
      this.domNode.setAttribute("aria-disabled", String(!0));
    }
  }
  const IJ = m("caseDescription", "Match Case"), EJ = m("wordsDescription", "Match Whole Word"), NJ = m("regexDescription", "Use Regular Expression");
  class g7 extends x_ {
    constructor(e) {
      super({
        icon: p.caseSensitive,
        title: IJ + e.appendTitle,
        isChecked: e.isChecked,
        inputActiveOptionBorder: e.inputActiveOptionBorder,
        inputActiveOptionForeground: e.inputActiveOptionForeground,
        inputActiveOptionBackground: e.inputActiveOptionBackground
      });
    }
  }
  class m7 extends x_ {
    constructor(e) {
      super({
        icon: p.wholeWord,
        title: EJ + e.appendTitle,
        isChecked: e.isChecked,
        inputActiveOptionBorder: e.inputActiveOptionBorder,
        inputActiveOptionForeground: e.inputActiveOptionForeground,
        inputActiveOptionBackground: e.inputActiveOptionBackground
      });
    }
  }
  class p7 extends x_ {
    constructor(e) {
      super({
        icon: p.regex,
        title: NJ + e.appendTitle,
        isChecked: e.isChecked,
        inputActiveOptionBorder: e.inputActiveOptionBorder,
        inputActiveOptionForeground: e.inputActiveOptionForeground,
        inputActiveOptionBackground: e.inputActiveOptionBackground
      });
    }
  }
  function TJ(s, e = {}) {
    const t = DN(e);
    return t.textContent = s, t;
  }
  function _7(s, e = {}) {
    const t = DN(e);
    return b7(t, AJ(s, !!e.renderCodeSegments), e.actionHandler, e.renderCodeSegments), t;
  }
  function DN(s) {
    const e = s.inline ? "span" : "div", t = document.createElement(e);
    return s.className && (t.className = s.className), t;
  }
  class MJ {
    constructor(e) {
      this.source = e, this.index = 0;
    }
    eos() {
      return this.index >= this.source.length;
    }
    next() {
      const e = this.peek();
      return this.advance(), e;
    }
    peek() {
      return this.source[this.index];
    }
    advance() {
      this.index++;
    }
  }
  function b7(s, e, t, i) {
    let n;
    if (e.type === 2)
      n = document.createTextNode(e.content || "");
    else if (e.type === 3)
      n = document.createElement("b");
    else if (e.type === 4)
      n = document.createElement("i");
    else if (e.type === 7 && i)
      n = document.createElement("code");
    else if (e.type === 5 && t) {
      const o = document.createElement("a");
      t.disposables.add(on(o, "click", (r) => {
        t.callback(String(e.index), r);
      })), n = o;
    } else
      e.type === 8 ? n = document.createElement("br") : e.type === 1 && (n = s);
    n && s !== n && s.appendChild(n), n && Array.isArray(e.children) && e.children.forEach((o) => {
      b7(n, o, t, i);
    });
  }
  function AJ(s, e) {
    const t = {
      type: 1,
      children: []
    };
    let i = 0, n = t;
    const o = [], r = new MJ(s);
    for (; !r.eos(); ) {
      let a = r.next();
      const l = a === "\\" && wk(r.peek(), e) !== 0;
      if (l && (a = r.next()), !l && RJ(a, e) && a === r.peek()) {
        r.advance(), n.type === 2 && (n = o.pop());
        const c = wk(a, e);
        if (n.type === c || n.type === 5 && c === 6)
          n = o.pop();
        else {
          const d = {
            type: c,
            children: []
          };
          c === 5 && (d.index = i, i++), n.children.push(d), o.push(n), n = d;
        }
      } else if (a === `
`)
        n.type === 2 && (n = o.pop()), n.children.push({
          type: 8
        });
      else if (n.type !== 2) {
        const c = {
          type: 2,
          content: a
        };
        n.children.push(c), o.push(n), n = c;
      } else
        n.content += a;
    }
    return n.type === 2 && (n = o.pop()), t;
  }
  function RJ(s, e) {
    return wk(s, e) !== 0;
  }
  function wk(s, e) {
    switch (s) {
      case "*":
        return 3;
      case "_":
        return 4;
      case "[":
        return 5;
      case "]":
        return 6;
      case "`":
        return e ? 7 : 0;
      default:
        return 0;
    }
  }
  class OJ {
    constructor(e, t = 0, i = e.length, n = t - 1) {
      this.items = e, this.start = t, this.end = i, this.index = n;
    }
    current() {
      return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
    }
    next() {
      return this.index = Math.min(this.index + 1, this.end), this.current();
    }
    previous() {
      return this.index = Math.max(this.index - 1, this.start - 1), this.current();
    }
    first() {
      return this.index = this.start, this.current();
    }
    last() {
      return this.index = this.end - 1, this.current();
    }
  }
  class PJ {
    constructor(e = [], t = 10) {
      this._initialize(e), this._limit = t, this._onChange();
    }
    getHistory() {
      return this._elements;
    }
    add(e) {
      this._history.delete(e), this._history.add(e), this._onChange();
    }
    next() {
      return this._currentPosition() !== this._elements.length - 1 ? this._navigator.next() : null;
    }
    previous() {
      return this._currentPosition() !== 0 ? this._navigator.previous() : null;
    }
    current() {
      return this._navigator.current();
    }
    first() {
      return this._navigator.first();
    }
    last() {
      return this._navigator.last();
    }
    has(e) {
      return this._history.has(e);
    }
    _onChange() {
      this._reduceToLimit();
      const e = this._elements;
      this._navigator = new OJ(e, 0, e.length, e.length);
    }
    _reduceToLimit() {
      const e = this._elements;
      e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
    }
    _currentPosition() {
      const e = this._navigator.current();
      return e ? this._elements.indexOf(e) : -1;
    }
    _initialize(e) {
      this._history = /* @__PURE__ */ new Set();
      for (const t of e)
        this._history.add(t);
    }
    get _elements() {
      const e = [];
      return this._history.forEach((t) => e.push(t)), e;
    }
  }
  const Ng = J, FJ = {
    inputBackground: H.fromHex("#3C3C3C"),
    inputForeground: H.fromHex("#CCCCCC"),
    inputValidationInfoBorder: H.fromHex("#55AAFF"),
    inputValidationInfoBackground: H.fromHex("#063B49"),
    inputValidationWarningBorder: H.fromHex("#B89500"),
    inputValidationWarningBackground: H.fromHex("#352A05"),
    inputValidationErrorBorder: H.fromHex("#BE1100"),
    inputValidationErrorBackground: H.fromHex("#5A1D1D")
  };
  class v7 extends Qo {
    constructor(e, t, i) {
      var n;
      super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new B()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i || /* @__PURE__ */ Object.create(null), Sa(this.options, FJ, !1), this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = (n = this.options.tooltip) !== null && n !== void 0 ? n : this.placeholder || "", this.ariaLabel = this.options.ariaLabel || "", this.inputBackground = this.options.inputBackground, this.inputForeground = this.options.inputForeground, this.inputBorder = this.options.inputBorder, this.inputValidationInfoBorder = this.options.inputValidationInfoBorder, this.inputValidationInfoBackground = this.options.inputValidationInfoBackground, this.inputValidationInfoForeground = this.options.inputValidationInfoForeground, this.inputValidationWarningBorder = this.options.inputValidationWarningBorder, this.inputValidationWarningBackground = this.options.inputValidationWarningBackground, this.inputValidationWarningForeground = this.options.inputValidationWarningForeground, this.inputValidationErrorBorder = this.options.inputValidationErrorBorder, this.inputValidationErrorBackground = this.options.inputValidationErrorBackground, this.inputValidationErrorForeground = this.options.inputValidationErrorForeground, this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = q(e, Ng(".monaco-inputbox.idle"));
      let o = this.options.flexibleHeight ? "textarea" : "input", r = q(this.element, Ng(".ibwrapper"));
      if (this.input = q(r, Ng(o + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
        this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = q(r, Ng("div.mirror")), this.mirror.innerText = "\xA0", this.scrollableElement = new X5(this.element, { vertical: 1 }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), q(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((c) => this.input.scrollTop = c.scrollTop));
        const a = this._register(new xt(document, "selectionchange")), l = be.filter(a.event, () => {
          const c = document.getSelection();
          return c?.anchorNode === r;
        });
        this._register(l(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
      } else
        this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
      this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && !this.options.showPlaceholderOnFocus && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this.ignoreGesture(this.input), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new ga(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
    }
    onBlur() {
      this._hideMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", "");
    }
    onFocus() {
      this._showMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", this.placeholder || "");
    }
    setPlaceHolder(e) {
      this.placeholder = e, this.input.setAttribute("placeholder", e);
    }
    setTooltip(e) {
      this.tooltip = e, this.input.title = e;
    }
    setAriaLabel(e) {
      this.ariaLabel = e, e ? this.input.setAttribute("aria-label", this.ariaLabel) : this.input.removeAttribute("aria-label");
    }
    getAriaLabel() {
      return this.ariaLabel;
    }
    get inputElement() {
      return this.input;
    }
    get value() {
      return this.input.value;
    }
    set value(e) {
      this.input.value !== e && (this.input.value = e, this.onValueChange());
    }
    get height() {
      return typeof this.cachedHeight == "number" ? this.cachedHeight : Yy(this.element);
    }
    focus() {
      this.input.focus();
    }
    blur() {
      this.input.blur();
    }
    hasFocus() {
      return document.activeElement === this.input;
    }
    select(e = null) {
      this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
    }
    isSelectionAtEnd() {
      return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
    }
    enable() {
      this.input.removeAttribute("disabled");
    }
    disable() {
      this.blur(), this.input.disabled = !0, this._hideMessage();
    }
    get width() {
      return Bo(this.input);
    }
    set width(e) {
      if (this.options.flexibleHeight && this.options.flexibleWidth) {
        let t = 0;
        if (this.mirror) {
          const i = parseFloat(this.mirror.style.paddingLeft || "") || 0, n = parseFloat(this.mirror.style.paddingRight || "") || 0;
          t = i + n;
        }
        this.input.style.width = e - t + "px";
      } else
        this.input.style.width = e + "px";
      this.mirror && (this.mirror.style.width = e + "px");
    }
    set paddingRight(e) {
      this.input.style.width = `calc(100% - ${e}px)`, this.mirror && (this.mirror.style.paddingRight = e + "px");
    }
    updateScrollDimensions() {
      if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
        return;
      const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
      this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
    }
    showMessage(e, t) {
      this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
      const i = this.stylesForType(this.message.type);
      this.element.style.border = i.border ? `1px solid ${i.border}` : "", (this.hasFocus() || t) && this._showMessage();
    }
    hideMessage() {
      this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
    }
    validate() {
      let e = null;
      return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e?.type;
    }
    stylesForType(e) {
      switch (e) {
        case 1:
          return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground };
        case 2:
          return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground };
        default:
          return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground };
      }
    }
    classForType(e) {
      switch (e) {
        case 1:
          return "info";
        case 2:
          return "warning";
        default:
          return "error";
      }
    }
    _showMessage() {
      if (!this.contextViewProvider || !this.message)
        return;
      let e, t = () => e.style.width = Bo(this.element) + "px";
      this.contextViewProvider.showContextView({
        getAnchor: () => this.element,
        anchorAlignment: 1,
        render: (n) => {
          if (!this.message)
            return null;
          e = q(n, Ng(".monaco-inputbox-container")), t();
          const o = {
            inline: !0,
            className: "monaco-inputbox-message"
          }, r = this.message.formatContent ? _7(this.message.content, o) : TJ(this.message.content, o);
          r.classList.add(this.classForType(this.message.type));
          const a = this.stylesForType(this.message.type);
          return r.style.backgroundColor = a.background ? a.background.toString() : "", r.style.color = a.foreground ? a.foreground.toString() : "", r.style.border = a.border ? `1px solid ${a.border}` : "", q(e, r), null;
        },
        onHide: () => {
          this.state = "closed";
        },
        layout: t
      });
      let i;
      this.message.type === 3 ? i = m("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = m("alertWarningMessage", "Warning: {0}", this.message.content) : i = m("alertInfoMessage", "Info: {0}", this.message.content), pn(i), this.state = "open";
    }
    _hideMessage() {
      !this.contextViewProvider || (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
    }
    onValueChange() {
      this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
    }
    updateMirror() {
      if (!this.mirror)
        return;
      const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
      (e + i).replace(/\u000c/g, "") ? this.mirror.textContent = e + i : this.mirror.innerText = "\xA0", this.layout();
    }
    style(e) {
      this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoForeground = e.inputValidationInfoForeground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningForeground = e.inputValidationWarningForeground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorForeground = e.inputValidationErrorForeground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles();
    }
    applyStyles() {
      const e = this.inputBackground ? this.inputBackground.toString() : "", t = this.inputForeground ? this.inputForeground.toString() : "", i = this.inputBorder ? this.inputBorder.toString() : "";
      this.element.style.backgroundColor = e, this.element.style.color = t, this.input.style.backgroundColor = "inherit", this.input.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
    }
    layout() {
      if (!this.mirror)
        return;
      const e = this.cachedContentHeight;
      this.cachedContentHeight = Yy(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
    }
    insertAtCursor(e) {
      const t = this.inputElement, i = t.selectionStart, n = t.selectionEnd, o = t.value;
      i !== null && n !== null && (this.value = o.substr(0, i) + e + o.substr(n), t.setSelectionRange(i + 1, i + 1), this.layout());
    }
    dispose() {
      this._hideMessage(), this.message = null, this.actionbar && this.actionbar.dispose(), super.dispose();
    }
  }
  class C7 extends v7 {
    constructor(e, t, i) {
      const n = m({ key: "history.inputbox.hint", comment: ["Text will be prefixed with \u21C5 plus a single space, then used as a hint where input field keeps history"] }, "for history"), o = ` or \u21C5 ${n}`, r = ` (\u21C5 ${n})`;
      super(e, t, i), this.history = new PJ(i.history, 100);
      const a = () => {
        if (i.showHistoryHint && i.showHistoryHint() && !this.placeholder.endsWith(o) && !this.placeholder.endsWith(r) && this.history.getHistory().length) {
          const l = this.placeholder.endsWith(")") ? o : r, c = this.placeholder + l;
          i.showPlaceholderOnFocus && document.activeElement !== this.input ? this.placeholder = c : this.setPlaceHolder(c);
        }
      };
      this.observer = new MutationObserver((l, c) => {
        l.forEach((d) => {
          d.target.textContent || a();
        });
      }), this.observer.observe(this.input, { attributeFilter: ["class"] }), this.onfocus(this.input, () => a()), this.onblur(this.input, () => {
        const l = (c) => {
          if (this.placeholder.endsWith(c)) {
            const d = this.placeholder.slice(0, this.placeholder.length - c.length);
            return i.showPlaceholderOnFocus ? this.placeholder = d : this.setPlaceHolder(d), !0;
          } else
            return !1;
        };
        l(r) || l(o);
      });
    }
    dispose() {
      super.dispose(), this.observer && (this.observer.disconnect(), this.observer = void 0);
    }
    addToHistory() {
      this.value && this.value !== this.getCurrentValue() && this.history.add(this.value);
    }
    showNextValue() {
      this.history.has(this.value) || this.addToHistory();
      let e = this.getNextValue();
      e && (e = e === this.value ? this.getNextValue() : e), e && (this.value = e, U0(this.value));
    }
    showPreviousValue() {
      this.history.has(this.value) || this.addToHistory();
      let e = this.getPreviousValue();
      e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, U0(this.value));
    }
    getCurrentValue() {
      let e = this.history.current();
      return e || (e = this.history.last(), this.history.next()), e;
    }
    getPreviousValue() {
      return this.history.previous() || this.history.first();
    }
    getNextValue() {
      return this.history.next() || this.history.last();
    }
  }
  const BJ = m("defaultLabel", "input");
  class WJ extends Qo {
    constructor(e, t, i, n) {
      super(), this._showOptionButtons = i, this.fixFocusOnOptionClickEnabled = !0, this.imeSessionInProgress = !1, this._onDidOptionChange = this._register(new B()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new B()), this.onMouseDown = this._onMouseDown.event, this._onInput = this._register(new B()), this._onKeyUp = this._register(new B()), this._onCaseSensitiveKeyDown = this._register(new B()), this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event, this._onRegexKeyDown = this._register(new B()), this.onRegexKeyDown = this._onRegexKeyDown.event, this._lastHighlightFindOptions = 0, this.contextViewProvider = t, this.placeholder = n.placeholder || "", this.validation = n.validation, this.label = n.label || BJ, this.inputActiveOptionBorder = n.inputActiveOptionBorder, this.inputActiveOptionForeground = n.inputActiveOptionForeground, this.inputActiveOptionBackground = n.inputActiveOptionBackground, this.inputBackground = n.inputBackground, this.inputForeground = n.inputForeground, this.inputBorder = n.inputBorder, this.inputValidationInfoBorder = n.inputValidationInfoBorder, this.inputValidationInfoBackground = n.inputValidationInfoBackground, this.inputValidationInfoForeground = n.inputValidationInfoForeground, this.inputValidationWarningBorder = n.inputValidationWarningBorder, this.inputValidationWarningBackground = n.inputValidationWarningBackground, this.inputValidationWarningForeground = n.inputValidationWarningForeground, this.inputValidationErrorBorder = n.inputValidationErrorBorder, this.inputValidationErrorBackground = n.inputValidationErrorBackground, this.inputValidationErrorForeground = n.inputValidationErrorForeground;
      const o = n.appendCaseSensitiveLabel || "", r = n.appendWholeWordsLabel || "", a = n.appendRegexLabel || "", l = n.history || [], c = !!n.flexibleHeight, d = !!n.flexibleWidth, h = n.flexibleMaxHeight;
      this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new C7(this.domNode, this.contextViewProvider, {
        placeholder: this.placeholder || "",
        ariaLabel: this.label || "",
        validationOptions: {
          validation: this.validation
        },
        inputBackground: this.inputBackground,
        inputForeground: this.inputForeground,
        inputBorder: this.inputBorder,
        inputValidationInfoBackground: this.inputValidationInfoBackground,
        inputValidationInfoForeground: this.inputValidationInfoForeground,
        inputValidationInfoBorder: this.inputValidationInfoBorder,
        inputValidationWarningBackground: this.inputValidationWarningBackground,
        inputValidationWarningForeground: this.inputValidationWarningForeground,
        inputValidationWarningBorder: this.inputValidationWarningBorder,
        inputValidationErrorBackground: this.inputValidationErrorBackground,
        inputValidationErrorForeground: this.inputValidationErrorForeground,
        inputValidationErrorBorder: this.inputValidationErrorBorder,
        history: l,
        showHistoryHint: n.showHistoryHint,
        flexibleHeight: c,
        flexibleWidth: d,
        flexibleMaxHeight: h
      })), this.regex = this._register(new p7({
        appendTitle: a,
        isChecked: !1,
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      })), this._register(this.regex.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.regex.onKeyDown((f) => {
        this._onRegexKeyDown.fire(f);
      })), this.wholeWords = this._register(new m7({
        appendTitle: r,
        isChecked: !1,
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      })), this._register(this.wholeWords.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this.caseSensitive = this._register(new g7({
        appendTitle: o,
        isChecked: !1,
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      })), this._register(this.caseSensitive.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.caseSensitive.onKeyDown((f) => {
        this._onCaseSensitiveKeyDown.fire(f);
      })), this._showOptionButtons && (this.inputBox.paddingRight = this.caseSensitive.width() + this.wholeWords.width() + this.regex.width());
      let u = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
      this.onkeydown(this.domNode, (f) => {
        if (f.equals(15) || f.equals(17) || f.equals(9)) {
          let g = u.indexOf(document.activeElement);
          if (g >= 0) {
            let _ = -1;
            f.equals(17) ? _ = (g + 1) % u.length : f.equals(15) && (g === 0 ? _ = u.length - 1 : _ = g - 1), f.equals(9) ? (u[g].blur(), this.inputBox.focus()) : _ >= 0 && u[_].focus(), wt.stop(f, !0);
          }
        }
      }), this.controls = document.createElement("div"), this.controls.className = "controls", this.controls.style.display = this._showOptionButtons ? "block" : "none", this.controls.appendChild(this.caseSensitive.domNode), this.controls.appendChild(this.wholeWords.domNode), this.controls.appendChild(this.regex.domNode), this.domNode.appendChild(this.controls), e && e.appendChild(this.domNode), this._register(ee(this.inputBox.inputElement, "compositionstart", (f) => {
        this.imeSessionInProgress = !0;
      })), this._register(ee(this.inputBox.inputElement, "compositionend", (f) => {
        this.imeSessionInProgress = !1, this._onInput.fire();
      })), this.onkeydown(this.inputBox.inputElement, (f) => this._onKeyDown.fire(f)), this.onkeyup(this.inputBox.inputElement, (f) => this._onKeyUp.fire(f)), this.oninput(this.inputBox.inputElement, (f) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (f) => this._onMouseDown.fire(f));
    }
    enable() {
      this.domNode.classList.remove("disabled"), this.inputBox.enable(), this.regex.enable(), this.wholeWords.enable(), this.caseSensitive.enable();
    }
    disable() {
      this.domNode.classList.add("disabled"), this.inputBox.disable(), this.regex.disable(), this.wholeWords.disable(), this.caseSensitive.disable();
    }
    setFocusInputOnOptionClick(e) {
      this.fixFocusOnOptionClickEnabled = e;
    }
    setEnabled(e) {
      e ? this.enable() : this.disable();
    }
    getValue() {
      return this.inputBox.value;
    }
    setValue(e) {
      this.inputBox.value !== e && (this.inputBox.value = e);
    }
    style(e) {
      this.inputActiveOptionBorder = e.inputActiveOptionBorder, this.inputActiveOptionForeground = e.inputActiveOptionForeground, this.inputActiveOptionBackground = e.inputActiveOptionBackground, this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoForeground = e.inputValidationInfoForeground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningForeground = e.inputValidationWarningForeground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorForeground = e.inputValidationErrorForeground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles();
    }
    applyStyles() {
      if (this.domNode) {
        const e = {
          inputActiveOptionBorder: this.inputActiveOptionBorder,
          inputActiveOptionForeground: this.inputActiveOptionForeground,
          inputActiveOptionBackground: this.inputActiveOptionBackground
        };
        this.regex.style(e), this.wholeWords.style(e), this.caseSensitive.style(e);
        const t = {
          inputBackground: this.inputBackground,
          inputForeground: this.inputForeground,
          inputBorder: this.inputBorder,
          inputValidationInfoBackground: this.inputValidationInfoBackground,
          inputValidationInfoForeground: this.inputValidationInfoForeground,
          inputValidationInfoBorder: this.inputValidationInfoBorder,
          inputValidationWarningBackground: this.inputValidationWarningBackground,
          inputValidationWarningForeground: this.inputValidationWarningForeground,
          inputValidationWarningBorder: this.inputValidationWarningBorder,
          inputValidationErrorBackground: this.inputValidationErrorBackground,
          inputValidationErrorForeground: this.inputValidationErrorForeground,
          inputValidationErrorBorder: this.inputValidationErrorBorder
        };
        this.inputBox.style(t);
      }
    }
    select() {
      this.inputBox.select();
    }
    focus() {
      this.inputBox.focus();
    }
    getCaseSensitive() {
      return this.caseSensitive.checked;
    }
    setCaseSensitive(e) {
      this.caseSensitive.checked = e;
    }
    getWholeWords() {
      return this.wholeWords.checked;
    }
    setWholeWords(e) {
      this.wholeWords.checked = e;
    }
    getRegex() {
      return this.regex.checked;
    }
    setRegex(e) {
      this.regex.checked = e, this.validate();
    }
    focusOnCaseSensitive() {
      this.caseSensitive.focus();
    }
    highlightFindOptions() {
      this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions), this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions, this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
    }
    validate() {
      this.inputBox.validate();
    }
    clearMessage() {
      this.inputBox.hideMessage();
    }
  }
  const VJ = m("defaultLabel", "input"), HJ = m("label.preserveCaseCheckbox", "Preserve Case");
  class zJ extends x_ {
    constructor(e) {
      super({
        icon: p.preserveCase,
        title: HJ + e.appendTitle,
        isChecked: e.isChecked,
        inputActiveOptionBorder: e.inputActiveOptionBorder,
        inputActiveOptionForeground: e.inputActiveOptionForeground,
        inputActiveOptionBackground: e.inputActiveOptionBackground
      });
    }
  }
  class UJ extends Qo {
    constructor(e, t, i, n) {
      super(), this._showOptionButtons = i, this.fixFocusOnOptionClickEnabled = !0, this.cachedOptionsWidth = 0, this._onDidOptionChange = this._register(new B()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new B()), this._onInput = this._register(new B()), this._onKeyUp = this._register(new B()), this._onPreserveCaseKeyDown = this._register(new B()), this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event, this.contextViewProvider = t, this.placeholder = n.placeholder || "", this.validation = n.validation, this.label = n.label || VJ, this.inputActiveOptionBorder = n.inputActiveOptionBorder, this.inputActiveOptionForeground = n.inputActiveOptionForeground, this.inputActiveOptionBackground = n.inputActiveOptionBackground, this.inputBackground = n.inputBackground, this.inputForeground = n.inputForeground, this.inputBorder = n.inputBorder, this.inputValidationInfoBorder = n.inputValidationInfoBorder, this.inputValidationInfoBackground = n.inputValidationInfoBackground, this.inputValidationInfoForeground = n.inputValidationInfoForeground, this.inputValidationWarningBorder = n.inputValidationWarningBorder, this.inputValidationWarningBackground = n.inputValidationWarningBackground, this.inputValidationWarningForeground = n.inputValidationWarningForeground, this.inputValidationErrorBorder = n.inputValidationErrorBorder, this.inputValidationErrorBackground = n.inputValidationErrorBackground, this.inputValidationErrorForeground = n.inputValidationErrorForeground;
      const o = n.appendPreserveCaseLabel || "", r = n.history || [], a = !!n.flexibleHeight, l = !!n.flexibleWidth, c = n.flexibleMaxHeight;
      this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new C7(this.domNode, this.contextViewProvider, {
        ariaLabel: this.label || "",
        placeholder: this.placeholder || "",
        validationOptions: {
          validation: this.validation
        },
        inputBackground: this.inputBackground,
        inputForeground: this.inputForeground,
        inputBorder: this.inputBorder,
        inputValidationInfoBackground: this.inputValidationInfoBackground,
        inputValidationInfoForeground: this.inputValidationInfoForeground,
        inputValidationInfoBorder: this.inputValidationInfoBorder,
        inputValidationWarningBackground: this.inputValidationWarningBackground,
        inputValidationWarningForeground: this.inputValidationWarningForeground,
        inputValidationWarningBorder: this.inputValidationWarningBorder,
        inputValidationErrorBackground: this.inputValidationErrorBackground,
        inputValidationErrorForeground: this.inputValidationErrorForeground,
        inputValidationErrorBorder: this.inputValidationErrorBorder,
        history: r,
        showHistoryHint: n.showHistoryHint,
        flexibleHeight: a,
        flexibleWidth: l,
        flexibleMaxHeight: c
      })), this.preserveCase = this._register(new zJ({
        appendTitle: o,
        isChecked: !1,
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      })), this._register(this.preserveCase.onChange((u) => {
        this._onDidOptionChange.fire(u), !u && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.preserveCase.onKeyDown((u) => {
        this._onPreserveCaseKeyDown.fire(u);
      })), this._showOptionButtons ? this.cachedOptionsWidth = this.preserveCase.width() : this.cachedOptionsWidth = 0;
      let d = [this.preserveCase.domNode];
      this.onkeydown(this.domNode, (u) => {
        if (u.equals(15) || u.equals(17) || u.equals(9)) {
          let f = d.indexOf(document.activeElement);
          if (f >= 0) {
            let g = -1;
            u.equals(17) ? g = (f + 1) % d.length : u.equals(15) && (f === 0 ? g = d.length - 1 : g = f - 1), u.equals(9) ? (d[f].blur(), this.inputBox.focus()) : g >= 0 && d[g].focus(), wt.stop(u, !0);
          }
        }
      });
      let h = document.createElement("div");
      h.className = "controls", h.style.display = this._showOptionButtons ? "block" : "none", h.appendChild(this.preserveCase.domNode), this.domNode.appendChild(h), e && e.appendChild(this.domNode), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
    }
    enable() {
      this.domNode.classList.remove("disabled"), this.inputBox.enable(), this.preserveCase.enable();
    }
    disable() {
      this.domNode.classList.add("disabled"), this.inputBox.disable(), this.preserveCase.disable();
    }
    setEnabled(e) {
      e ? this.enable() : this.disable();
    }
    style(e) {
      this.inputActiveOptionBorder = e.inputActiveOptionBorder, this.inputActiveOptionForeground = e.inputActiveOptionForeground, this.inputActiveOptionBackground = e.inputActiveOptionBackground, this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoForeground = e.inputValidationInfoForeground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningForeground = e.inputValidationWarningForeground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorForeground = e.inputValidationErrorForeground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles();
    }
    applyStyles() {
      if (this.domNode) {
        const e = {
          inputActiveOptionBorder: this.inputActiveOptionBorder,
          inputActiveOptionForeground: this.inputActiveOptionForeground,
          inputActiveOptionBackground: this.inputActiveOptionBackground
        };
        this.preserveCase.style(e);
        const t = {
          inputBackground: this.inputBackground,
          inputForeground: this.inputForeground,
          inputBorder: this.inputBorder,
          inputValidationInfoBackground: this.inputValidationInfoBackground,
          inputValidationInfoForeground: this.inputValidationInfoForeground,
          inputValidationInfoBorder: this.inputValidationInfoBorder,
          inputValidationWarningBackground: this.inputValidationWarningBackground,
          inputValidationWarningForeground: this.inputValidationWarningForeground,
          inputValidationWarningBorder: this.inputValidationWarningBorder,
          inputValidationErrorBackground: this.inputValidationErrorBackground,
          inputValidationErrorForeground: this.inputValidationErrorForeground,
          inputValidationErrorBorder: this.inputValidationErrorBorder
        };
        this.inputBox.style(t);
      }
    }
    select() {
      this.inputBox.select();
    }
    focus() {
      this.inputBox.focus();
    }
    getPreserveCase() {
      return this.preserveCase.checked;
    }
    setPreserveCase(e) {
      this.preserveCase.checked = e;
    }
    focusOnPreserve() {
      this.preserveCase.focus();
    }
    validate() {
      this.inputBox && this.inputBox.validate();
    }
    set width(e) {
      this.inputBox.paddingRight = this.cachedOptionsWidth, this.inputBox.width = e, this.domNode.style.width = e + "px";
    }
    dispose() {
      super.dispose();
    }
  }
  var w7 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, S7 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const xN = new ue("suggestWidgetVisible", !1, m("suggestWidgetVisible", "Whether suggestion are visible")), Ip = "historyNavigationWidget", y7 = "historyNavigationForwardsEnabled", L7 = "historyNavigationBackwardsEnabled";
  function $J(s, e, t) {
    new ue(t, e).bindTo(s);
  }
  function jJ(s, e) {
    return s.createScoped(e.target);
  }
  function k7(s, e) {
    return s.getContext(document.activeElement).getValue(e);
  }
  function D7(s, e) {
    const t = jJ(s, e);
    $J(t, e, Ip);
    const i = new ue(y7, !0).bindTo(t), n = new ue(L7, !0).bindTo(t);
    return {
      scopedContextKeyService: t,
      historyNavigationForwardsEnablement: i,
      historyNavigationBackwardsEnablement: n
    };
  }
  let Sk = class extends WJ {
    constructor(e, t, i, n, o = !1) {
      super(e, t, o, i), this._register(D7(n, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);
    }
  };
  Sk = w7([
    S7(3, Fe)
  ], Sk);
  let yk = class extends UJ {
    constructor(e, t, i, n, o = !1) {
      super(e, t, o, i), this._register(D7(n, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);
    }
  };
  yk = w7([
    S7(3, Fe)
  ], yk);
  Zn.registerCommandAndKeybindingRule({
    id: "history.showPrevious",
    weight: 200,
    when: ce.and(ce.has(Ip), ce.equals(L7, !0), xN.isEqualTo(!1)),
    primary: 16,
    secondary: [528],
    handler: (s) => {
      const e = k7(s.get(Fe), Ip);
      e && e.historyNavigator.showPreviousValue();
    }
  });
  Zn.registerCommandAndKeybindingRule({
    id: "history.showNext",
    weight: 200,
    when: ce.and(ce.has(Ip), ce.equals(y7, !0), xN.isEqualTo(!1)),
    primary: 18,
    secondary: [530],
    handler: (s) => {
      const e = k7(s.get(Fe), Ip);
      e && e.historyNavigator.showNextValue();
    }
  });
  var km = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const ot = {
    Visible: xN,
    DetailsVisible: new ue("suggestWidgetDetailsVisible", !1, m("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
    MultipleSuggestions: new ue("suggestWidgetMultipleSuggestions", !1, m("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
    MakesTextEdit: new ue("suggestionMakesTextEdit", !0, m("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
    AcceptSuggestionsOnEnter: new ue("acceptSuggestionOnEnter", !0, m("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
    HasInsertAndReplaceRange: new ue("suggestionHasInsertAndReplaceRange", !1, m("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
    InsertMode: new ue("suggestionInsertMode", void 0, { type: "string", description: m("suggestionInsertMode", "Whether the default behaviour is to insert or replace") }),
    CanResolve: new ue("suggestionCanResolve", !1, m("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
  }, Nc = new A("suggestWidgetStatusBar");
  class KJ {
    constructor(e, t, i, n) {
      this.position = e, this.completion = t, this.container = i, this.provider = n, this.isInvalid = !1, this.score = mr.Default, this.distance = 0, this.textLabel = typeof t.label == "string" ? t.label : t.label.label, this.labelLow = this.textLabel.toLowerCase(), this.isInvalid = !this.textLabel, this.sortTextLow = t.sortText && t.sortText.toLowerCase(), this.filterTextLow = t.filterText && t.filterText.toLowerCase(), D.isIRange(t.range) ? (this.editStart = new V(t.range.startLineNumber, t.range.startColumn), this.editInsertEnd = new V(t.range.endLineNumber, t.range.endColumn), this.editReplaceEnd = new V(t.range.endLineNumber, t.range.endColumn), this.isInvalid = this.isInvalid || D.spansMultipleLines(t.range) || t.range.startLineNumber !== e.lineNumber) : (this.editStart = new V(t.range.insert.startLineNumber, t.range.insert.startColumn), this.editInsertEnd = new V(t.range.insert.endLineNumber, t.range.insert.endColumn), this.editReplaceEnd = new V(t.range.replace.endLineNumber, t.range.replace.endColumn), this.isInvalid = this.isInvalid || D.spansMultipleLines(t.range.insert) || D.spansMultipleLines(t.range.replace) || t.range.insert.startLineNumber !== e.lineNumber || t.range.replace.startLineNumber !== e.lineNumber || t.range.insert.startColumn !== t.range.replace.startColumn), typeof n.resolveCompletionItem != "function" && (this._resolveCache = Promise.resolve(), this._isResolved = !0);
    }
    get isResolved() {
      return !!this._isResolved;
    }
    resolve(e) {
      return km(this, void 0, void 0, function* () {
        if (!this._resolveCache) {
          const t = e.onCancellationRequested(() => {
            this._resolveCache = void 0, this._isResolved = !1;
          });
          this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, e)).then((i) => {
            Object.assign(this.completion, i), this._isResolved = !0, t.dispose();
          }, (i) => {
            va(i) && (this._resolveCache = void 0, this._isResolved = !1);
          });
        }
        return this._resolveCache;
      });
    }
  }
  class W1 {
    constructor(e = 2, t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = !0) {
      this.snippetSortOrder = e, this.kindFilter = t, this.providerFilter = i, this.showDeprecated = n;
    }
  }
  W1.default = new W1();
  let qJ;
  function GJ() {
    return qJ;
  }
  class ZJ {
    constructor(e, t, i, n) {
      this.items = e, this.needsClipboard = t, this.durations = i, this.disposable = n;
    }
  }
  function x7(s, e, t, i = W1.default, n = { triggerKind: 0 }, o = Je.None) {
    return km(this, void 0, void 0, function* () {
      const r = new hs(!0);
      t = t.clone();
      const a = e.getWordAtPosition(t), l = a ? new D(t.lineNumber, a.startColumn, t.lineNumber, a.endColumn) : D.fromPositions(t), c = { replace: l, insert: l.setEndPosition(t.lineNumber, t.column) }, d = [], h = new te(), u = [];
      let f = !1;
      const g = (b, C, v) => {
        var w, S, L;
        let x = !1;
        if (!C)
          return x;
        for (let y of C.suggestions)
          if (!i.kindFilter.has(y.kind)) {
            if (!i.showDeprecated && ((w = y?.tags) === null || w === void 0 ? void 0 : w.includes(1)))
              continue;
            y.range || (y.range = c), y.sortText || (y.sortText = typeof y.label == "string" ? y.label : y.label.label), !f && y.insertTextRules && y.insertTextRules & 4 && (f = WC.guessNeedsClipboard(y.insertText)), d.push(new KJ(t, y, C, b)), x = !0;
          }
        return lI(C) && h.add(C), u.push({
          providerName: (S = b._debugDisplayName) !== null && S !== void 0 ? S : "unknown_provider",
          elapsedProvider: (L = C.duration) !== null && L !== void 0 ? L : -1,
          elapsedOverall: v.elapsed()
        }), x;
      }, _ = (() => km(this, void 0, void 0, function* () {
      }))();
      for (let b of s.orderedGroups(e)) {
        let C = !1;
        if (yield Promise.all(b.map((v) => km(this, void 0, void 0, function* () {
          if (!(i.providerFilter.size > 0 && !i.providerFilter.has(v)))
            try {
              const w = new hs(!0), S = yield v.provideCompletionItems(e, t, n, o);
              C = g(v, S, w) || C;
            } catch (w) {
              Xi(w);
            }
        }))), C || o.isCancellationRequested)
          break;
      }
      return yield _, o.isCancellationRequested ? (h.dispose(), Promise.reject(aI())) : new ZJ(d.sort(I7(i.snippetSortOrder)), f, { entries: u, elapsed: r.elapsed() }, h);
    });
  }
  function IN(s, e) {
    if (s.sortTextLow && e.sortTextLow) {
      if (s.sortTextLow < e.sortTextLow)
        return -1;
      if (s.sortTextLow > e.sortTextLow)
        return 1;
    }
    return s.completion.label < e.completion.label ? -1 : s.completion.label > e.completion.label ? 1 : s.completion.kind - e.completion.kind;
  }
  function YJ(s, e) {
    if (s.completion.kind !== e.completion.kind) {
      if (s.completion.kind === 27)
        return -1;
      if (e.completion.kind === 27)
        return 1;
    }
    return IN(s, e);
  }
  function XJ(s, e) {
    if (s.completion.kind !== e.completion.kind) {
      if (s.completion.kind === 27)
        return 1;
      if (e.completion.kind === 27)
        return -1;
    }
    return IN(s, e);
  }
  const VC = /* @__PURE__ */ new Map();
  VC.set(0, YJ);
  VC.set(2, XJ);
  VC.set(1, IN);
  function I7(s) {
    return VC.get(s);
  }
  lt.registerCommand("_executeCompletionItemProvider", (s, ...e) => km(void 0, void 0, void 0, function* () {
    const [t, i, n, o] = e;
    Nt(Ee.isUri(t)), Nt(V.isIPosition(i)), Nt(typeof n == "string" || !n), Nt(typeof o == "number" || !o);
    const { completionProvider: r } = s.get(me), a = yield s.get(fs).createModelReference(t);
    try {
      const l = {
        incomplete: !1,
        suggestions: []
      }, c = [], d = yield x7(r, a.object.textEditorModel, V.lift(i), void 0, { triggerCharacter: n, triggerKind: n ? 1 : 0 });
      for (const h of d.items)
        c.length < (o ?? 0) && c.push(h.resolve(Je.None)), l.incomplete = l.incomplete || h.container.incomplete, l.suggestions.push(h.completion);
      try {
        return yield Promise.all(c), l;
      } finally {
        setTimeout(() => d.disposable.dispose(), 100);
      }
    } finally {
      a.dispose();
    }
  }));
  let _b, GS = [];
  function QJ(s, e, t) {
    const { completionProvider: i } = s.get(me);
    _b || (_b = new class {
      provideCompletionItems() {
        let o = { suggestions: GS.slice(0) };
        return GS.length = 0, o;
      }
    }(), i.register("*", _b)), setTimeout(() => {
      var n;
      GS.push(...t), (n = e.getContribution("editor.contrib.suggestController")) === null || n === void 0 || n.triggerSuggest((/* @__PURE__ */ new Set()).add(_b));
    }, 0);
  }
  var EN = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, V1 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const lA = J;
  let H1 = class E7 extends z {
    constructor(e, t, i) {
      super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._widget = this._register(this._instantiationService.createInstance(Fd, this._editor)), this._decorationsChangerListener = this._register(new JJ(this._editor)), this._messages = [], this._messagesAreComplete = !1, this._participants = [];
      for (const n of Kh.getAll())
        this._participants.push(this._instantiationService.createInstance(n, this._editor));
      this._participants.sort((n, o) => n.hoverOrdinal - o.hoverOrdinal), this._computer = new z1(this._editor, this._participants), this._hoverOperation = this._register(new u7(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
        this._withResult(n.value, n.isComplete, n.hasLoadingMessage);
      })), this._register(this._decorationsChangerListener.onDidChangeModelDecorations(() => this._onModelDecorationsChanged())), this._register(on(this._widget.getDomNode(), "keydown", (n) => {
        n.equals(9) && this.hide();
      })), this._register(Yt.onDidChange(() => {
        this._widget.position && this._computer.anchor && this._messages.length > 0 && (this._widget.clear(), this._renderMessages(this._computer.anchor, this._messages));
      }));
    }
    _onModelDecorationsChanged() {
      this._widget.position && (this._hoverOperation.cancel(), this._widget.isColorPickerVisible || this._hoverOperation.start(0));
    }
    maybeShowAt(e) {
      const t = [];
      for (const n of this._participants)
        if (n.suggestHoverAnchor) {
          const o = n.suggestHoverAnchor(e);
          o && t.push(o);
        }
      const i = e.target;
      if (i.type === 6 && t.push(new qS(0, i.range)), i.type === 7) {
        const n = this._editor.getOption(44).typicalHalfwidthCharacterWidth / 2;
        !i.detail.isAfterLines && typeof i.detail.horizontalDistanceToText == "number" && i.detail.horizontalDistanceToText < n && t.push(new qS(0, i.range));
      }
      return t.length === 0 ? !1 : (t.sort((n, o) => o.priority - n.priority), this._startShowingAt(t[0], 0, !1), !0);
    }
    startShowingAtRange(e, t, i) {
      this._startShowingAt(new qS(0, e), t, i);
    }
    _startShowingAt(e, t, i) {
      if (!(this._computer.anchor && this._computer.anchor.equals(e))) {
        if (this._hoverOperation.cancel(), this._widget.position)
          if (!this._computer.anchor || !e.canAdoptVisibleHover(this._computer.anchor, this._widget.position))
            this.hide();
          else {
            const n = this._messages.filter((o) => o.isValidForHoverAnchor(e));
            if (n.length === 0)
              this.hide();
            else {
              if (n.length === this._messages.length && this._messagesAreComplete)
                return;
              this._renderMessages(e, n);
            }
          }
        this._computer.anchor = e, this._computer.shouldFocus = i, this._hoverOperation.start(t);
      }
    }
    hide() {
      this._computer.anchor = null, this._hoverOperation.cancel(), this._widget.hide();
    }
    isColorPickerVisible() {
      return this._widget.isColorPickerVisible;
    }
    _addLoadingMessage(e) {
      if (this._computer.anchor) {
        for (const t of this._participants)
          if (t.createLoadingMessage) {
            const i = t.createLoadingMessage(this._computer.anchor);
            if (i)
              return e.slice(0).concat([i]);
          }
      }
      return e;
    }
    _withResult(e, t, i) {
      this._messages = i ? this._addLoadingMessage(e) : e, this._messagesAreComplete = t, this._computer.anchor && this._messages.length > 0 ? this._renderMessages(this._computer.anchor, this._messages) : t && this.hide();
    }
    _renderMessages(e, t) {
      let i = 1073741824, n = t[0].range, o = null;
      for (const h of t)
        i = Math.min(i, h.range.startColumn), n = D.plusRange(n, h.range), h.forceShowAtRange && (o = h.range);
      const r = new te(), a = r.add(new Lk(this._keybindingService)), l = document.createDocumentFragment();
      let c = null;
      const d = {
        fragment: l,
        statusBar: a,
        setColorPicker: (h) => c = h,
        onContentsChanged: () => this._widget.onContentsChanged(),
        hide: () => this.hide()
      };
      for (const h of this._participants) {
        const u = t.filter((f) => f.owner === h);
        u.length > 0 && r.add(h.renderHoverParts(d, u));
      }
      if (a.hasContent && l.appendChild(a.hoverElement), l.hasChildNodes()) {
        if (n) {
          const h = this._decorationsChangerListener.deltaDecorations([], [{
            range: n,
            options: E7._DECORATION_OPTIONS
          }]);
          r.add(qe(() => {
            this._decorationsChangerListener.deltaDecorations(h, []);
          }));
        }
        this._widget.showAt(l, new eee(c, o ? o.getStartPosition() : new V(e.range.startLineNumber, i), o || n, this._editor.getOption(53).above, this._computer.shouldFocus, r));
      } else
        r.dispose();
    }
  };
  H1._DECORATION_OPTIONS = $e.register({
    description: "content-hover-highlight",
    className: "hoverHighlight"
  });
  H1 = EN([
    V1(1, et),
    V1(2, ci)
  ], H1);
  class JJ extends z {
    constructor(e) {
      super(), this._editor = e, this._onDidChangeModelDecorations = this._register(new B()), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._isChangingDecorations = !1, this._register(this._editor.onDidChangeModelDecorations((t) => {
        this._isChangingDecorations || this._onDidChangeModelDecorations.fire(t);
      }));
    }
    deltaDecorations(e, t) {
      try {
        return this._isChangingDecorations = !0, this._editor.deltaDecorations(e, t);
      } finally {
        this._isChangingDecorations = !1;
      }
    }
  }
  class eee {
    constructor(e, t, i, n, o, r) {
      this.colorPicker = e, this.showAtPosition = t, this.showAtRange = i, this.preferAbove = n, this.stoleFocus = o, this.disposables = r;
    }
  }
  let Fd = class N7 extends z {
    constructor(e, t) {
      super(), this._editor = e, this._contextKeyService = t, this.allowEditorOverflow = !0, this._hoverVisibleKey = T.hoverVisible.bindTo(this._contextKeyService), this._hover = this._register(new h7()), this._visibleData = null, this._register(this._editor.onDidLayoutChange(() => this._layout())), this._register(this._editor.onDidChangeConfiguration((i) => {
        i.hasChanged(44) && this._updateFont();
      })), this._setVisibleData(null), this._layout(), this._editor.addContentWidget(this);
    }
    get position() {
      var e, t;
      return (t = (e = this._visibleData) === null || e === void 0 ? void 0 : e.showAtPosition) !== null && t !== void 0 ? t : null;
    }
    get isColorPickerVisible() {
      var e;
      return Boolean((e = this._visibleData) === null || e === void 0 ? void 0 : e.colorPicker);
    }
    dispose() {
      this._editor.removeContentWidget(this), this._visibleData && this._visibleData.disposables.dispose(), super.dispose();
    }
    getId() {
      return N7.ID;
    }
    getDomNode() {
      return this._hover.containerDomNode;
    }
    getPosition() {
      if (!this._visibleData)
        return null;
      let e = this._visibleData.preferAbove;
      return !e && this._contextKeyService.getContextKeyValue(ot.Visible.key) && (e = !0), {
        position: this._visibleData.showAtPosition,
        range: this._visibleData.showAtRange,
        preference: e ? [1, 2] : [2, 1]
      };
    }
    _setVisibleData(e) {
      this._visibleData && this._visibleData.disposables.dispose(), this._visibleData = e, this._hoverVisibleKey.set(!!this._visibleData), this._hover.containerDomNode.classList.toggle("hidden", !this._visibleData);
    }
    _layout() {
      const e = Math.max(this._editor.getLayoutInfo().height / 4, 250), { fontSize: t, lineHeight: i } = this._editor.getOption(44);
      this._hover.contentsDomNode.style.fontSize = `${t}px`, this._hover.contentsDomNode.style.lineHeight = `${i / t}`, this._hover.contentsDomNode.style.maxHeight = `${e}px`, this._hover.contentsDomNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;
    }
    _updateFont() {
      Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((t) => this._editor.applyFontInfo(t));
    }
    showAt(e, t) {
      this._setVisibleData(t), this._hover.contentsDomNode.textContent = "", this._hover.contentsDomNode.appendChild(e), this._hover.contentsDomNode.style.paddingBottom = "", this._updateFont(), this._editor.layoutContentWidget(this), this.onContentsChanged(), this._editor.render(), this._editor.layoutContentWidget(this), this.onContentsChanged(), t.stoleFocus && this._hover.containerDomNode.focus(), t.colorPicker && t.colorPicker.layout();
    }
    hide() {
      if (this._visibleData) {
        const e = this._visibleData.stoleFocus;
        this._setVisibleData(null), this._editor.layoutContentWidget(this), e && this._editor.focus();
      }
    }
    onContentsChanged() {
      this._hover.onContentsChanged();
      const e = this._hover.scrollbar.getScrollDimensions();
      if (e.scrollWidth > e.width) {
        const i = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;
        this._hover.contentsDomNode.style.paddingBottom !== i && (this._hover.contentsDomNode.style.paddingBottom = i, this._editor.layoutContentWidget(this), this._hover.onContentsChanged());
      }
    }
    clear() {
      this._hover.contentsDomNode.textContent = "";
    }
  };
  Fd.ID = "editor.contrib.contentHoverWidget";
  Fd = EN([
    V1(1, Fe)
  ], Fd);
  let Lk = class extends z {
    constructor(e) {
      super(), this._keybindingService = e, this._hasContent = !1, this.hoverElement = lA("div.hover-row.status-bar"), this.actionsElement = q(this.hoverElement, lA("div.actions"));
    }
    get hasContent() {
      return this._hasContent;
    }
    addAction(e) {
      const t = this._keybindingService.lookupKeybinding(e.commandId), i = t ? t.getLabel() : null;
      return this._hasContent = !0, this._register(LN.render(this.actionsElement, e, i));
    }
    append(e) {
      const t = q(this.actionsElement, e);
      return this._hasContent = !0, t;
    }
  };
  Lk = EN([
    V1(0, ci)
  ], Lk);
  class z1 {
    constructor(e, t) {
      this._editor = e, this._participants = t, this._anchor = null, this._shouldFocus = !1;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      this._anchor = e;
    }
    get shouldFocus() {
      return this._shouldFocus;
    }
    set shouldFocus(e) {
      this._shouldFocus = e;
    }
    static _getLineDecorations(e, t) {
      if (t.type !== 1)
        return [];
      const i = e.getModel(), n = t.range.startLineNumber, o = i.getLineMaxColumn(n);
      return e.getLineDecorations(n).filter((r) => {
        if (r.options.isWholeLine)
          return !0;
        const a = r.range.startLineNumber === n ? r.range.startColumn : 1, l = r.range.endLineNumber === n ? r.range.endColumn : o;
        if (r.options.showIfCollapsed) {
          if (a > t.range.startColumn + 1 || t.range.endColumn - 1 > l)
            return !1;
        } else if (a > t.range.startColumn || t.range.endColumn > l)
          return !1;
        return !0;
      });
    }
    computeAsync(e) {
      const t = this._anchor;
      if (!this._editor.hasModel() || !t)
        return vi.EMPTY;
      const i = z1._getLineDecorations(this._editor, t);
      return vi.merge(this._participants.map((n) => n.computeAsync ? n.computeAsync(t, i, e) : vi.EMPTY));
    }
    computeSync() {
      if (!this._editor.hasModel() || !this._anchor)
        return [];
      const e = z1._getLineDecorations(this._editor, this._anchor);
      let t = [];
      for (const i of this._participants)
        t = t.concat(i.computeSync(this._anchor, e));
      return Nh(t);
    }
  }
  /*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */
  function tee(s) {
    if (Array.isArray(s)) {
      for (var e = 0, t = Array(s.length); e < s.length; e++)
        t[e] = s[e];
      return t;
    } else
      return Array.from(s);
  }
  var iee = Object.hasOwnProperty, cA = Object.setPrototypeOf, nee = Object.isFrozen, see = Object.getPrototypeOf, oee = Object.getOwnPropertyDescriptor, Is = Object.freeze, _l = Object.seal, ree = Object.create, T7 = typeof Reflect < "u" && Reflect, U1 = T7.apply, kk = T7.construct;
  U1 || (U1 = function(e, t, i) {
    return e.apply(t, i);
  });
  Is || (Is = function(e) {
    return e;
  });
  _l || (_l = function(e) {
    return e;
  });
  kk || (kk = function(e, t) {
    return new (Function.prototype.bind.apply(e, [null].concat(tee(t))))();
  });
  var aee = wr(Array.prototype.forEach), dA = wr(Array.prototype.pop), Tg = wr(Array.prototype.push), sd = wr(String.prototype.toLowerCase), hA = wr(String.prototype.match), Tl = wr(String.prototype.replace), lee = wr(String.prototype.indexOf), cee = wr(String.prototype.trim), Fa = wr(RegExp.prototype.test), uA = dee(TypeError);
  function wr(s) {
    return function(e) {
      for (var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
        i[n - 1] = arguments[n];
      return U1(s, e, i);
    };
  }
  function dee(s) {
    return function() {
      for (var e = arguments.length, t = Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      return kk(s, t);
    };
  }
  function Lt(s, e) {
    cA && cA(s, null);
    for (var t = e.length; t--; ) {
      var i = e[t];
      if (typeof i == "string") {
        var n = sd(i);
        n !== i && (nee(e) || (e[t] = n), i = n);
      }
      s[i] = !0;
    }
    return s;
  }
  function Xc(s) {
    var e = ree(null), t = void 0;
    for (t in s)
      U1(iee, s, [t]) && (e[t] = s[t]);
    return e;
  }
  function bb(s, e) {
    for (; s !== null; ) {
      var t = oee(s, e);
      if (t) {
        if (t.get)
          return wr(t.get);
        if (typeof t.value == "function")
          return wr(t.value);
      }
      s = see(s);
    }
    function i(n) {
      return console.warn("fallback value for", n), null;
    }
    return i;
  }
  var fA = Is(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), ZS = Is(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), YS = Is(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), hee = Is(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), XS = Is(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), uee = Is(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), gA = Is(["#text"]), mA = Is(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), QS = Is(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), pA = Is(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), vb = Is(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), fee = _l(/\{\{[\s\S]*|[\s\S]*\}\}/gm), gee = _l(/<%[\s\S]*|[\s\S]*%>/gm), mee = _l(/^data-[\-\w.\u00B7-\uFFFF]/), pee = _l(/^aria-[\-\w]+$/), _ee = _l(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), bee = _l(/^(?:\w+script|data):/i), vee = _l(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), Qg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
    return typeof s;
  } : function(s) {
    return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
  };
  function Er(s) {
    if (Array.isArray(s)) {
      for (var e = 0, t = Array(s.length); e < s.length; e++)
        t[e] = s[e];
      return t;
    } else
      return Array.from(s);
  }
  var Cee = function() {
    return typeof window > "u" ? null : window;
  }, wee = function(e, t) {
    if ((typeof e > "u" ? "undefined" : Qg(e)) !== "object" || typeof e.createPolicy != "function")
      return null;
    var i = null, n = "data-tt-policy-suffix";
    t.currentScript && t.currentScript.hasAttribute(n) && (i = t.currentScript.getAttribute(n));
    var o = "dompurify" + (i ? "#" + i : "");
    try {
      return e.createPolicy(o, {
        createHTML: function(a) {
          return a;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + o + " could not be created."), null;
    }
  };
  function M7() {
    var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Cee(), e = function(Z) {
      return M7(Z);
    };
    if (e.version = "2.3.1", e.removed = [], !s || !s.document || s.document.nodeType !== 9)
      return e.isSupported = !1, e;
    var t = s.document, i = s.document, n = s.DocumentFragment, o = s.HTMLTemplateElement, r = s.Node, a = s.Element, l = s.NodeFilter, c = s.NamedNodeMap, d = c === void 0 ? s.NamedNodeMap || s.MozNamedAttrMap : c, h = s.Text, u = s.Comment, f = s.DOMParser, g = s.trustedTypes, _ = a.prototype, b = bb(_, "cloneNode"), C = bb(_, "nextSibling"), v = bb(_, "childNodes"), w = bb(_, "parentNode");
    if (typeof o == "function") {
      var S = i.createElement("template");
      S.content && S.content.ownerDocument && (i = S.content.ownerDocument);
    }
    var L = wee(g, t), x = L && ti ? L.createHTML("") : "", y = i, k = y.implementation, I = y.createNodeIterator, F = y.createDocumentFragment, R = y.getElementsByTagName, $ = t.importNode, j = {};
    try {
      j = Xc(i).documentMode ? i.documentMode : {};
    } catch {
    }
    var le = {};
    e.isSupported = typeof w == "function" && k && typeof k.createHTMLDocument < "u" && j !== 9;
    var he = fee, Ce = gee, Ne = mee, xe = pee, Ve = bee, Ct = vee, bt = _ee, ve = null, pe = Lt({}, [].concat(Er(fA), Er(ZS), Er(YS), Er(XS), Er(gA))), ft = null, Hi = Lt({}, [].concat(Er(mA), Er(QS), Er(pA), Er(vb))), Ri = null, ms = null, Ao = !0, Ia = !0, Ro = !1, Y = !1, G = !1, de = !1, Ae = !1, yt = !1, mi = !1, ei = !0, ti = !1, Ei = !0, K = !0, U = !1, O = {}, E = null, N = Lt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), W = null, P = Lt({}, ["audio", "video", "img", "source", "image", "track"]), Q = null, re = Lt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Me = "http://www.w3.org/1998/Math/MathML", ke = "http://www.w3.org/2000/svg", je = "http://www.w3.org/1999/xhtml", Ke = je, Ht = !1, pt = null, Oe = i.createElement("form"), Ni = function(Z) {
      pt && pt === Z || ((!Z || (typeof Z > "u" ? "undefined" : Qg(Z)) !== "object") && (Z = {}), Z = Xc(Z), ve = "ALLOWED_TAGS" in Z ? Lt({}, Z.ALLOWED_TAGS) : pe, ft = "ALLOWED_ATTR" in Z ? Lt({}, Z.ALLOWED_ATTR) : Hi, Q = "ADD_URI_SAFE_ATTR" in Z ? Lt(Xc(re), Z.ADD_URI_SAFE_ATTR) : re, W = "ADD_DATA_URI_TAGS" in Z ? Lt(Xc(P), Z.ADD_DATA_URI_TAGS) : P, E = "FORBID_CONTENTS" in Z ? Lt({}, Z.FORBID_CONTENTS) : N, Ri = "FORBID_TAGS" in Z ? Lt({}, Z.FORBID_TAGS) : {}, ms = "FORBID_ATTR" in Z ? Lt({}, Z.FORBID_ATTR) : {}, O = "USE_PROFILES" in Z ? Z.USE_PROFILES : !1, Ao = Z.ALLOW_ARIA_ATTR !== !1, Ia = Z.ALLOW_DATA_ATTR !== !1, Ro = Z.ALLOW_UNKNOWN_PROTOCOLS || !1, Y = Z.SAFE_FOR_TEMPLATES || !1, G = Z.WHOLE_DOCUMENT || !1, yt = Z.RETURN_DOM || !1, mi = Z.RETURN_DOM_FRAGMENT || !1, ei = Z.RETURN_DOM_IMPORT !== !1, ti = Z.RETURN_TRUSTED_TYPE || !1, Ae = Z.FORCE_BODY || !1, Ei = Z.SANITIZE_DOM !== !1, K = Z.KEEP_CONTENT !== !1, U = Z.IN_PLACE || !1, bt = Z.ALLOWED_URI_REGEXP || bt, Ke = Z.NAMESPACE || je, Y && (Ia = !1), mi && (yt = !0), O && (ve = Lt({}, [].concat(Er(gA))), ft = [], O.html === !0 && (Lt(ve, fA), Lt(ft, mA)), O.svg === !0 && (Lt(ve, ZS), Lt(ft, QS), Lt(ft, vb)), O.svgFilters === !0 && (Lt(ve, YS), Lt(ft, QS), Lt(ft, vb)), O.mathMl === !0 && (Lt(ve, XS), Lt(ft, pA), Lt(ft, vb))), Z.ADD_TAGS && (ve === pe && (ve = Xc(ve)), Lt(ve, Z.ADD_TAGS)), Z.ADD_ATTR && (ft === Hi && (ft = Xc(ft)), Lt(ft, Z.ADD_ATTR)), Z.ADD_URI_SAFE_ATTR && Lt(Q, Z.ADD_URI_SAFE_ATTR), Z.FORBID_CONTENTS && (E === N && (E = Xc(E)), Lt(E, Z.FORBID_CONTENTS)), K && (ve["#text"] = !0), G && Lt(ve, ["html", "head", "body"]), ve.table && (Lt(ve, ["tbody"]), delete Ri.tbody), Is && Is(Z), pt = Z);
    }, di = Lt({}, ["mi", "mo", "mn", "ms", "mtext"]), to = Lt({}, ["foreignobject", "desc", "title", "annotation-xml"]), ii = Lt({}, ZS);
    Lt(ii, YS), Lt(ii, hee);
    var Ji = Lt({}, XS);
    Lt(Ji, uee);
    var qc = function(Z) {
      var Se = w(Z);
      (!Se || !Se.tagName) && (Se = {
        namespaceURI: je,
        tagName: "template"
      });
      var He = sd(Z.tagName), ni = sd(Se.tagName);
      if (Z.namespaceURI === ke)
        return Se.namespaceURI === je ? He === "svg" : Se.namespaceURI === Me ? He === "svg" && (ni === "annotation-xml" || di[ni]) : Boolean(ii[He]);
      if (Z.namespaceURI === Me)
        return Se.namespaceURI === je ? He === "math" : Se.namespaceURI === ke ? He === "math" && to[ni] : Boolean(Ji[He]);
      if (Z.namespaceURI === je) {
        if (Se.namespaceURI === ke && !to[ni] || Se.namespaceURI === Me && !di[ni])
          return !1;
        var Qn = Lt({}, ["title", "style", "font", "a", "script"]);
        return !Ji[He] && (Qn[He] || !ii[He]);
      }
      return !1;
    }, As = function(Z) {
      Tg(e.removed, { element: Z });
      try {
        Z.parentNode.removeChild(Z);
      } catch {
        try {
          Z.outerHTML = x;
        } catch {
          Z.remove();
        }
      }
    }, Jo = function(Z, Se) {
      try {
        Tg(e.removed, {
          attribute: Se.getAttributeNode(Z),
          from: Se
        });
      } catch {
        Tg(e.removed, {
          attribute: null,
          from: Se
        });
      }
      if (Se.removeAttribute(Z), Z === "is" && !ft[Z])
        if (yt || mi)
          try {
            As(Se);
          } catch {
          }
        else
          try {
            Se.setAttribute(Z, "");
          } catch {
          }
    }, Ll = function(Z) {
      var Se = void 0, He = void 0;
      if (Ae)
        Z = "<remove></remove>" + Z;
      else {
        var ni = hA(Z, /^[\r\n\t ]+/);
        He = ni && ni[0];
      }
      var Qn = L ? L.createHTML(Z) : Z;
      if (Ke === je)
        try {
          Se = new f().parseFromString(Qn, "text/html");
        } catch {
        }
      if (!Se || !Se.documentElement) {
        Se = k.createDocument(Ke, "template", null);
        try {
          Se.documentElement.innerHTML = Ht ? "" : Qn;
        } catch {
        }
      }
      var Jn = Se.body || Se.documentElement;
      return Z && He && Jn.insertBefore(i.createTextNode(He), Jn.childNodes[0] || null), Ke === je ? R.call(Se, G ? "html" : "body")[0] : G ? Se.documentElement : Jn;
    }, Ea = function(Z) {
      return I.call(Z.ownerDocument || Z, Z, l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT, null, !1);
    }, Gh = function(Z) {
      return Z instanceof h || Z instanceof u ? !1 : typeof Z.nodeName != "string" || typeof Z.textContent != "string" || typeof Z.removeChild != "function" || !(Z.attributes instanceof d) || typeof Z.removeAttribute != "function" || typeof Z.setAttribute != "function" || typeof Z.namespaceURI != "string" || typeof Z.insertBefore != "function";
    }, kl = function(Z) {
      return (typeof r > "u" ? "undefined" : Qg(r)) === "object" ? Z instanceof r : Z && (typeof Z > "u" ? "undefined" : Qg(Z)) === "object" && typeof Z.nodeType == "number" && typeof Z.nodeName == "string";
    }, er = function(Z, Se, He) {
      !le[Z] || aee(le[Z], function(ni) {
        ni.call(e, Se, He, pt);
      });
    }, pg = function(Z) {
      var Se = void 0;
      if (er("beforeSanitizeElements", Z, null), Gh(Z) || hA(Z.nodeName, /[\u0080-\uFFFF]/))
        return As(Z), !0;
      var He = sd(Z.nodeName);
      if (er("uponSanitizeElement", Z, {
        tagName: He,
        allowedTags: ve
      }), !kl(Z.firstElementChild) && (!kl(Z.content) || !kl(Z.content.firstElementChild)) && Fa(/<[/\w]/g, Z.innerHTML) && Fa(/<[/\w]/g, Z.textContent) || He === "select" && Fa(/<template/i, Z.innerHTML))
        return As(Z), !0;
      if (!ve[He] || Ri[He]) {
        if (K && !E[He]) {
          var ni = w(Z) || Z.parentNode, Qn = v(Z) || Z.childNodes;
          if (Qn && ni)
            for (var Jn = Qn.length, es = Jn - 1; es >= 0; --es)
              ni.insertBefore(b(Qn[es], !0), C(Z));
        }
        return As(Z), !0;
      }
      return Z instanceof a && !qc(Z) || (He === "noscript" || He === "noembed") && Fa(/<\/no(script|embed)/i, Z.innerHTML) ? (As(Z), !0) : (Y && Z.nodeType === 3 && (Se = Z.textContent, Se = Tl(Se, he, " "), Se = Tl(Se, Ce, " "), Z.textContent !== Se && (Tg(e.removed, { element: Z.cloneNode() }), Z.textContent = Se)), er("afterSanitizeElements", Z, null), !1);
    }, B_ = function(Z, Se, He) {
      if (Ei && (Se === "id" || Se === "name") && (He in i || He in Oe))
        return !1;
      if (!(Ia && !ms[Se] && Fa(Ne, Se))) {
        if (!(Ao && Fa(xe, Se))) {
          if (!ft[Se] || ms[Se])
            return !1;
          if (!Q[Se]) {
            if (!Fa(bt, Tl(He, Ct, ""))) {
              if (!((Se === "src" || Se === "xlink:href" || Se === "href") && Z !== "script" && lee(He, "data:") === 0 && W[Z])) {
                if (!(Ro && !Fa(Ve, Tl(He, Ct, "")))) {
                  if (He)
                    return !1;
                }
              }
            }
          }
        }
      }
      return !0;
    }, b2 = function(Z) {
      var Se = void 0, He = void 0, ni = void 0, Qn = void 0;
      er("beforeSanitizeAttributes", Z, null);
      var Jn = Z.attributes;
      if (!!Jn) {
        var es = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: ft
        };
        for (Qn = Jn.length; Qn--; ) {
          Se = Jn[Qn];
          var Na = Se, _g = Na.name, v2 = Na.namespaceURI;
          if (He = cee(Se.value), ni = sd(_g), es.attrName = ni, es.attrValue = He, es.keepAttr = !0, es.forceKeepAttr = void 0, er("uponSanitizeAttribute", Z, es), He = es.attrValue, !es.forceKeepAttr && (Jo(_g, Z), !!es.keepAttr)) {
            if (Fa(/\/>/i, He)) {
              Jo(_g, Z);
              continue;
            }
            Y && (He = Tl(He, he, " "), He = Tl(He, Ce, " "));
            var Z6 = Z.nodeName.toLowerCase();
            if (!!B_(Z6, ni, He))
              try {
                v2 ? Z.setAttributeNS(v2, _g, He) : Z.setAttribute(_g, He), dA(e.removed);
              } catch {
              }
          }
        }
        er("afterSanitizeAttributes", Z, null);
      }
    }, G6 = function Ge(Z) {
      var Se = void 0, He = Ea(Z);
      for (er("beforeSanitizeShadowDOM", Z, null); Se = He.nextNode(); )
        er("uponSanitizeShadowNode", Se, null), !pg(Se) && (Se.content instanceof n && Ge(Se.content), b2(Se));
      er("afterSanitizeShadowDOM", Z, null);
    };
    return e.sanitize = function(Ge, Z) {
      var Se = void 0, He = void 0, ni = void 0, Qn = void 0, Jn = void 0;
      if (Ht = !Ge, Ht && (Ge = "<!-->"), typeof Ge != "string" && !kl(Ge)) {
        if (typeof Ge.toString != "function")
          throw uA("toString is not a function");
        if (Ge = Ge.toString(), typeof Ge != "string")
          throw uA("dirty is not a string, aborting");
      }
      if (!e.isSupported) {
        if (Qg(s.toStaticHTML) === "object" || typeof s.toStaticHTML == "function") {
          if (typeof Ge == "string")
            return s.toStaticHTML(Ge);
          if (kl(Ge))
            return s.toStaticHTML(Ge.outerHTML);
        }
        return Ge;
      }
      if (de || Ni(Z), e.removed = [], typeof Ge == "string" && (U = !1), !U)
        if (Ge instanceof r)
          Se = Ll("<!---->"), He = Se.ownerDocument.importNode(Ge, !0), He.nodeType === 1 && He.nodeName === "BODY" || He.nodeName === "HTML" ? Se = He : Se.appendChild(He);
        else {
          if (!yt && !Y && !G && Ge.indexOf("<") === -1)
            return L && ti ? L.createHTML(Ge) : Ge;
          if (Se = Ll(Ge), !Se)
            return yt ? null : x;
        }
      Se && Ae && As(Se.firstChild);
      for (var es = Ea(U ? Ge : Se); ni = es.nextNode(); )
        ni.nodeType === 3 && ni === Qn || pg(ni) || (ni.content instanceof n && G6(ni.content), b2(ni), Qn = ni);
      if (Qn = null, U)
        return Ge;
      if (yt) {
        if (mi)
          for (Jn = F.call(Se.ownerDocument); Se.firstChild; )
            Jn.appendChild(Se.firstChild);
        else
          Jn = Se;
        return ei && (Jn = $.call(t, Jn, !0)), Jn;
      }
      var Na = G ? Se.outerHTML : Se.innerHTML;
      return Y && (Na = Tl(Na, he, " "), Na = Tl(Na, Ce, " ")), L && ti ? L.createHTML(Na) : Na;
    }, e.setConfig = function(Ge) {
      Ni(Ge), de = !0;
    }, e.clearConfig = function() {
      pt = null, de = !1;
    }, e.isValidAttribute = function(Ge, Z, Se) {
      pt || Ni({});
      var He = sd(Ge), ni = sd(Z);
      return B_(He, ni, Se);
    }, e.addHook = function(Ge, Z) {
      typeof Z == "function" && (le[Ge] = le[Ge] || [], Tg(le[Ge], Z));
    }, e.removeHook = function(Ge) {
      le[Ge] && dA(le[Ge]);
    }, e.removeHooks = function(Ge) {
      le[Ge] && (le[Ge] = []);
    }, e.removeAllHooks = function() {
      le = {};
    }, e;
  }
  var xa = M7();
  xa.version;
  xa.isSupported;
  const See = xa.sanitize;
  xa.setConfig;
  xa.clearConfig;
  xa.isValidAttribute;
  const _A = xa.addHook, bA = xa.removeHook;
  xa.removeHooks;
  xa.removeAllHooks;
  let A7 = {};
  (function() {
    function s(e, t) {
      t(A7);
    }
    s.amd = !0, function(e, t) {
      typeof Dv == "object" && typeof q6 < "u" ? t(Dv) : typeof s == "function" && s.amd ? s(["exports"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.marked = {}));
    }(this, function(e) {
      function t(K, U) {
        for (var O = 0; O < U.length; O++) {
          var E = U[O];
          E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(K, E.key, E);
        }
      }
      function i(K, U, O) {
        return U && t(K.prototype, U), O && t(K, O), Object.defineProperty(K, "prototype", {
          writable: !1
        }), K;
      }
      function n(K, U) {
        if (!!K) {
          if (typeof K == "string")
            return o(K, U);
          var O = Object.prototype.toString.call(K).slice(8, -1);
          if (O === "Object" && K.constructor && (O = K.constructor.name), O === "Map" || O === "Set")
            return Array.from(K);
          if (O === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(O))
            return o(K, U);
        }
      }
      function o(K, U) {
        (U == null || U > K.length) && (U = K.length);
        for (var O = 0, E = new Array(U); O < U; O++)
          E[O] = K[O];
        return E;
      }
      function r(K, U) {
        var O = typeof Symbol < "u" && K[Symbol.iterator] || K["@@iterator"];
        if (O)
          return (O = O.call(K)).next.bind(O);
        if (Array.isArray(K) || (O = n(K)) || U && K && typeof K.length == "number") {
          O && (K = O);
          var E = 0;
          return function() {
            return E >= K.length ? {
              done: !0
            } : {
              done: !1,
              value: K[E++]
            };
          };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      function a() {
        return {
          baseUrl: null,
          breaks: !1,
          extensions: null,
          gfm: !0,
          headerIds: !0,
          headerPrefix: "",
          highlight: null,
          langPrefix: "language-",
          mangle: !0,
          pedantic: !1,
          renderer: null,
          sanitize: !1,
          sanitizer: null,
          silent: !1,
          smartLists: !1,
          smartypants: !1,
          tokenizer: null,
          walkTokens: null,
          xhtml: !1
        };
      }
      e.defaults = a();
      function l(K) {
        e.defaults = K;
      }
      var c = /[&<>"']/, d = /[&<>"']/g, h = /[<>"']|&(?!#?\w+;)/, u = /[<>"']|&(?!#?\w+;)/g, f = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, g = function(U) {
        return f[U];
      };
      function _(K, U) {
        if (U) {
          if (c.test(K))
            return K.replace(d, g);
        } else if (h.test(K))
          return K.replace(u, g);
        return K;
      }
      var b = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
      function C(K) {
        return K.replace(b, function(U, O) {
          return O = O.toLowerCase(), O === "colon" ? ":" : O.charAt(0) === "#" ? O.charAt(1) === "x" ? String.fromCharCode(parseInt(O.substring(2), 16)) : String.fromCharCode(+O.substring(1)) : "";
        });
      }
      var v = /(^|[^\[])\^/g;
      function w(K, U) {
        K = K.source || K, U = U || "";
        var O = {
          replace: function(N, W) {
            return W = W.source || W, W = W.replace(v, "$1"), K = K.replace(N, W), O;
          },
          getRegex: function() {
            return new RegExp(K, U);
          }
        };
        return O;
      }
      var S = /[^\w:]/g, L = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
      function x(K, U, O) {
        if (K) {
          var E;
          try {
            E = decodeURIComponent(C(O)).replace(S, "").toLowerCase();
          } catch {
            return null;
          }
          if (E.indexOf("javascript:") === 0 || E.indexOf("vbscript:") === 0 || E.indexOf("data:") === 0)
            return null;
        }
        U && !L.test(O) && (O = R(U, O));
        try {
          O = encodeURI(O).replace(/%25/g, "%");
        } catch {
          return null;
        }
        return O;
      }
      var y = {}, k = /^[^:]+:\/*[^/]*$/, I = /^([^:]+:)[\s\S]*$/, F = /^([^:]+:\/*[^/]*)[\s\S]*$/;
      function R(K, U) {
        y[" " + K] || (k.test(K) ? y[" " + K] = K + "/" : y[" " + K] = he(K, "/", !0)), K = y[" " + K];
        var O = K.indexOf(":") === -1;
        return U.substring(0, 2) === "//" ? O ? U : K.replace(I, "$1") + U : U.charAt(0) === "/" ? O ? U : K.replace(F, "$1") + U : K + U;
      }
      var $ = {
        exec: function() {
        }
      };
      function j(K) {
        for (var U = 1, O, E; U < arguments.length; U++) {
          O = arguments[U];
          for (E in O)
            Object.prototype.hasOwnProperty.call(O, E) && (K[E] = O[E]);
        }
        return K;
      }
      function le(K, U) {
        var O = K.replace(/\|/g, function(W, P, Q) {
          for (var re = !1, Me = P; --Me >= 0 && Q[Me] === "\\"; )
            re = !re;
          return re ? "|" : " |";
        }), E = O.split(/ \|/), N = 0;
        if (E[0].trim() || E.shift(), E[E.length - 1].trim() || E.pop(), E.length > U)
          E.splice(U);
        else
          for (; E.length < U; )
            E.push("");
        for (; N < E.length; N++)
          E[N] = E[N].trim().replace(/\\\|/g, "|");
        return E;
      }
      function he(K, U, O) {
        var E = K.length;
        if (E === 0)
          return "";
        for (var N = 0; N < E; ) {
          var W = K.charAt(E - N - 1);
          if (W === U && !O)
            N++;
          else if (W !== U && O)
            N++;
          else
            break;
        }
        return K.substr(0, E - N);
      }
      function Ce(K, U) {
        if (K.indexOf(U[1]) === -1)
          return -1;
        for (var O = K.length, E = 0, N = 0; N < O; N++)
          if (K[N] === "\\")
            N++;
          else if (K[N] === U[0])
            E++;
          else if (K[N] === U[1] && (E--, E < 0))
            return N;
        return -1;
      }
      function Ne(K) {
        K && K.sanitize && !K.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
      function xe(K, U) {
        if (U < 1)
          return "";
        for (var O = ""; U > 1; )
          U & 1 && (O += K), U >>= 1, K += K;
        return O + K;
      }
      function Ve(K, U, O, E) {
        var N = U.href, W = U.title ? _(U.title) : null, P = K[1].replace(/\\([\[\]])/g, "$1");
        if (K[0].charAt(0) !== "!") {
          E.state.inLink = !0;
          var Q = {
            type: "link",
            raw: O,
            href: N,
            title: W,
            text: P,
            tokens: E.inlineTokens(P, [])
          };
          return E.state.inLink = !1, Q;
        } else
          return {
            type: "image",
            raw: O,
            href: N,
            title: W,
            text: _(P)
          };
      }
      function Ct(K, U) {
        var O = K.match(/^(\s+)(?:```)/);
        if (O === null)
          return U;
        var E = O[1];
        return U.split(`
`).map(function(N) {
          var W = N.match(/^\s+/);
          if (W === null)
            return N;
          var P = W[0];
          return P.length >= E.length ? N.slice(E.length) : N;
        }).join(`
`);
      }
      var bt = /* @__PURE__ */ function() {
        function K(O) {
          this.options = O || e.defaults;
        }
        var U = K.prototype;
        return U.space = function(E) {
          var N = this.rules.block.newline.exec(E);
          if (N && N[0].length > 0)
            return {
              type: "space",
              raw: N[0]
            };
        }, U.code = function(E) {
          var N = this.rules.block.code.exec(E);
          if (N) {
            var W = N[0].replace(/^ {1,4}/gm, "");
            return {
              type: "code",
              raw: N[0],
              codeBlockStyle: "indented",
              text: this.options.pedantic ? W : he(W, `
`)
            };
          }
        }, U.fences = function(E) {
          var N = this.rules.block.fences.exec(E);
          if (N) {
            var W = N[0], P = Ct(W, N[3] || "");
            return {
              type: "code",
              raw: W,
              lang: N[2] ? N[2].trim() : N[2],
              text: P
            };
          }
        }, U.heading = function(E) {
          var N = this.rules.block.heading.exec(E);
          if (N) {
            var W = N[2].trim();
            if (/#$/.test(W)) {
              var P = he(W, "#");
              (this.options.pedantic || !P || / $/.test(P)) && (W = P.trim());
            }
            var Q = {
              type: "heading",
              raw: N[0],
              depth: N[1].length,
              text: W,
              tokens: []
            };
            return this.lexer.inline(Q.text, Q.tokens), Q;
          }
        }, U.hr = function(E) {
          var N = this.rules.block.hr.exec(E);
          if (N)
            return {
              type: "hr",
              raw: N[0]
            };
        }, U.blockquote = function(E) {
          var N = this.rules.block.blockquote.exec(E);
          if (N) {
            var W = N[0].replace(/^ *> ?/gm, "");
            return {
              type: "blockquote",
              raw: N[0],
              tokens: this.lexer.blockTokens(W, []),
              text: W
            };
          }
        }, U.list = function(E) {
          var N = this.rules.block.list.exec(E);
          if (N) {
            var W, P, Q, re, Me, ke, je, Ke, Ht, pt, Oe, Ni, di = N[1].trim(), to = di.length > 1, ii = {
              type: "list",
              raw: "",
              ordered: to,
              start: to ? +di.slice(0, -1) : "",
              loose: !1,
              items: []
            };
            di = to ? "\\d{1,9}\\" + di.slice(-1) : "\\" + di, this.options.pedantic && (di = to ? di : "[*+-]");
            for (var Ji = new RegExp("^( {0,3}" + di + ")((?: [^\\n]*)?(?:\\n|$))"); E && (Ni = !1, !(!(N = Ji.exec(E)) || this.rules.block.hr.test(E))); ) {
              if (W = N[0], E = E.substring(W.length), Ke = N[2].split(`
`, 1)[0], Ht = E.split(`
`, 1)[0], this.options.pedantic ? (re = 2, Oe = Ke.trimLeft()) : (re = N[2].search(/[^ ]/), re = re > 4 ? 1 : re, Oe = Ke.slice(re), re += N[1].length), ke = !1, !Ke && /^ *$/.test(Ht) && (W += Ht + `
`, E = E.substring(Ht.length + 1), Ni = !0), !Ni)
                for (var qc = new RegExp("^ {0," + Math.min(3, re - 1) + "}(?:[*+-]|\\d{1,9}[.)])"); E && (pt = E.split(`
`, 1)[0], Ke = pt, this.options.pedantic && (Ke = Ke.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !qc.test(Ke)); ) {
                  if (Ke.search(/[^ ]/) >= re || !Ke.trim())
                    Oe += `
` + Ke.slice(re);
                  else if (!ke)
                    Oe += `
` + Ke;
                  else
                    break;
                  !ke && !Ke.trim() && (ke = !0), W += pt + `
`, E = E.substring(pt.length + 1);
                }
              ii.loose || (je ? ii.loose = !0 : /\n *\n *$/.test(W) && (je = !0)), this.options.gfm && (P = /^\[[ xX]\] /.exec(Oe), P && (Q = P[0] !== "[ ] ", Oe = Oe.replace(/^\[[ xX]\] +/, ""))), ii.items.push({
                type: "list_item",
                raw: W,
                task: !!P,
                checked: Q,
                loose: !1,
                text: Oe
              }), ii.raw += W;
            }
            ii.items[ii.items.length - 1].raw = W.trimRight(), ii.items[ii.items.length - 1].text = Oe.trimRight(), ii.raw = ii.raw.trimRight();
            var As = ii.items.length;
            for (Me = 0; Me < As; Me++) {
              this.lexer.state.top = !1, ii.items[Me].tokens = this.lexer.blockTokens(ii.items[Me].text, []);
              var Jo = ii.items[Me].tokens.filter(function(Ea) {
                return Ea.type === "space";
              }), Ll = Jo.every(function(Ea) {
                for (var Gh = Ea.raw.split(""), kl = 0, er = r(Gh), pg; !(pg = er()).done; ) {
                  var B_ = pg.value;
                  if (B_ === `
` && (kl += 1), kl > 1)
                    return !0;
                }
                return !1;
              });
              !ii.loose && Jo.length && Ll && (ii.loose = !0, ii.items[Me].loose = !0);
            }
            return ii;
          }
        }, U.html = function(E) {
          var N = this.rules.block.html.exec(E);
          if (N) {
            var W = {
              type: "html",
              raw: N[0],
              pre: !this.options.sanitizer && (N[1] === "pre" || N[1] === "script" || N[1] === "style"),
              text: N[0]
            };
            return this.options.sanitize && (W.type = "paragraph", W.text = this.options.sanitizer ? this.options.sanitizer(N[0]) : _(N[0]), W.tokens = [], this.lexer.inline(W.text, W.tokens)), W;
          }
        }, U.def = function(E) {
          var N = this.rules.block.def.exec(E);
          if (N) {
            N[3] && (N[3] = N[3].substring(1, N[3].length - 1));
            var W = N[1].toLowerCase().replace(/\s+/g, " ");
            return {
              type: "def",
              tag: W,
              raw: N[0],
              href: N[2],
              title: N[3]
            };
          }
        }, U.table = function(E) {
          var N = this.rules.block.table.exec(E);
          if (N) {
            var W = {
              type: "table",
              header: le(N[1]).map(function(je) {
                return {
                  text: je
                };
              }),
              align: N[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
              rows: N[3] ? N[3].replace(/\n[ \t]*$/, "").split(`
`) : []
            };
            if (W.header.length === W.align.length) {
              W.raw = N[0];
              var P = W.align.length, Q, re, Me, ke;
              for (Q = 0; Q < P; Q++)
                /^ *-+: *$/.test(W.align[Q]) ? W.align[Q] = "right" : /^ *:-+: *$/.test(W.align[Q]) ? W.align[Q] = "center" : /^ *:-+ *$/.test(W.align[Q]) ? W.align[Q] = "left" : W.align[Q] = null;
              for (P = W.rows.length, Q = 0; Q < P; Q++)
                W.rows[Q] = le(W.rows[Q], W.header.length).map(function(je) {
                  return {
                    text: je
                  };
                });
              for (P = W.header.length, re = 0; re < P; re++)
                W.header[re].tokens = [], this.lexer.inlineTokens(W.header[re].text, W.header[re].tokens);
              for (P = W.rows.length, re = 0; re < P; re++)
                for (ke = W.rows[re], Me = 0; Me < ke.length; Me++)
                  ke[Me].tokens = [], this.lexer.inlineTokens(ke[Me].text, ke[Me].tokens);
              return W;
            }
          }
        }, U.lheading = function(E) {
          var N = this.rules.block.lheading.exec(E);
          if (N) {
            var W = {
              type: "heading",
              raw: N[0],
              depth: N[2].charAt(0) === "=" ? 1 : 2,
              text: N[1],
              tokens: []
            };
            return this.lexer.inline(W.text, W.tokens), W;
          }
        }, U.paragraph = function(E) {
          var N = this.rules.block.paragraph.exec(E);
          if (N) {
            var W = {
              type: "paragraph",
              raw: N[0],
              text: N[1].charAt(N[1].length - 1) === `
` ? N[1].slice(0, -1) : N[1],
              tokens: []
            };
            return this.lexer.inline(W.text, W.tokens), W;
          }
        }, U.text = function(E) {
          var N = this.rules.block.text.exec(E);
          if (N) {
            var W = {
              type: "text",
              raw: N[0],
              text: N[0],
              tokens: []
            };
            return this.lexer.inline(W.text, W.tokens), W;
          }
        }, U.escape = function(E) {
          var N = this.rules.inline.escape.exec(E);
          if (N)
            return {
              type: "escape",
              raw: N[0],
              text: _(N[1])
            };
        }, U.tag = function(E) {
          var N = this.rules.inline.tag.exec(E);
          if (N)
            return !this.lexer.state.inLink && /^<a /i.test(N[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(N[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(N[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(N[0]) && (this.lexer.state.inRawBlock = !1), {
              type: this.options.sanitize ? "text" : "html",
              raw: N[0],
              inLink: this.lexer.state.inLink,
              inRawBlock: this.lexer.state.inRawBlock,
              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(N[0]) : _(N[0]) : N[0]
            };
        }, U.link = function(E) {
          var N = this.rules.inline.link.exec(E);
          if (N) {
            var W = N[2].trim();
            if (!this.options.pedantic && /^</.test(W)) {
              if (!/>$/.test(W))
                return;
              var P = he(W.slice(0, -1), "\\");
              if ((W.length - P.length) % 2 === 0)
                return;
            } else {
              var Q = Ce(N[2], "()");
              if (Q > -1) {
                var re = N[0].indexOf("!") === 0 ? 5 : 4, Me = re + N[1].length + Q;
                N[2] = N[2].substring(0, Q), N[0] = N[0].substring(0, Me).trim(), N[3] = "";
              }
            }
            var ke = N[2], je = "";
            if (this.options.pedantic) {
              var Ke = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(ke);
              Ke && (ke = Ke[1], je = Ke[3]);
            } else
              je = N[3] ? N[3].slice(1, -1) : "";
            return ke = ke.trim(), /^</.test(ke) && (this.options.pedantic && !/>$/.test(W) ? ke = ke.slice(1) : ke = ke.slice(1, -1)), Ve(N, {
              href: ke && ke.replace(this.rules.inline._escapes, "$1"),
              title: je && je.replace(this.rules.inline._escapes, "$1")
            }, N[0], this.lexer);
          }
        }, U.reflink = function(E, N) {
          var W;
          if ((W = this.rules.inline.reflink.exec(E)) || (W = this.rules.inline.nolink.exec(E))) {
            var P = (W[2] || W[1]).replace(/\s+/g, " ");
            if (P = N[P.toLowerCase()], !P || !P.href) {
              var Q = W[0].charAt(0);
              return {
                type: "text",
                raw: Q,
                text: Q
              };
            }
            return Ve(W, P, W[0], this.lexer);
          }
        }, U.emStrong = function(E, N, W) {
          W === void 0 && (W = "");
          var P = this.rules.inline.emStrong.lDelim.exec(E);
          if (!!P && !(P[3] && W.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))) {
            var Q = P[1] || P[2] || "";
            if (!Q || Q && (W === "" || this.rules.inline.punctuation.exec(W))) {
              var re = P[0].length - 1, Me, ke, je = re, Ke = 0, Ht = P[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
              for (Ht.lastIndex = 0, N = N.slice(-1 * E.length + re); (P = Ht.exec(N)) != null; )
                if (Me = P[1] || P[2] || P[3] || P[4] || P[5] || P[6], !!Me) {
                  if (ke = Me.length, P[3] || P[4]) {
                    je += ke;
                    continue;
                  } else if ((P[5] || P[6]) && re % 3 && !((re + ke) % 3)) {
                    Ke += ke;
                    continue;
                  }
                  if (je -= ke, !(je > 0)) {
                    if (ke = Math.min(ke, ke + je + Ke), Math.min(re, ke) % 2) {
                      var pt = E.slice(1, re + P.index + ke);
                      return {
                        type: "em",
                        raw: E.slice(0, re + P.index + ke + 1),
                        text: pt,
                        tokens: this.lexer.inlineTokens(pt, [])
                      };
                    }
                    var Oe = E.slice(2, re + P.index + ke - 1);
                    return {
                      type: "strong",
                      raw: E.slice(0, re + P.index + ke + 1),
                      text: Oe,
                      tokens: this.lexer.inlineTokens(Oe, [])
                    };
                  }
                }
            }
          }
        }, U.codespan = function(E) {
          var N = this.rules.inline.code.exec(E);
          if (N) {
            var W = N[2].replace(/\n/g, " "), P = /[^ ]/.test(W), Q = /^ /.test(W) && / $/.test(W);
            return P && Q && (W = W.substring(1, W.length - 1)), W = _(W, !0), {
              type: "codespan",
              raw: N[0],
              text: W
            };
          }
        }, U.br = function(E) {
          var N = this.rules.inline.br.exec(E);
          if (N)
            return {
              type: "br",
              raw: N[0]
            };
        }, U.del = function(E) {
          var N = this.rules.inline.del.exec(E);
          if (N)
            return {
              type: "del",
              raw: N[0],
              text: N[2],
              tokens: this.lexer.inlineTokens(N[2], [])
            };
        }, U.autolink = function(E, N) {
          var W = this.rules.inline.autolink.exec(E);
          if (W) {
            var P, Q;
            return W[2] === "@" ? (P = _(this.options.mangle ? N(W[1]) : W[1]), Q = "mailto:" + P) : (P = _(W[1]), Q = P), {
              type: "link",
              raw: W[0],
              text: P,
              href: Q,
              tokens: [{
                type: "text",
                raw: P,
                text: P
              }]
            };
          }
        }, U.url = function(E, N) {
          var W;
          if (W = this.rules.inline.url.exec(E)) {
            var P, Q;
            if (W[2] === "@")
              P = _(this.options.mangle ? N(W[0]) : W[0]), Q = "mailto:" + P;
            else {
              var re;
              do
                re = W[0], W[0] = this.rules.inline._backpedal.exec(W[0])[0];
              while (re !== W[0]);
              P = _(W[0]), W[1] === "www." ? Q = "http://" + P : Q = P;
            }
            return {
              type: "link",
              raw: W[0],
              text: P,
              href: Q,
              tokens: [{
                type: "text",
                raw: P,
                text: P
              }]
            };
          }
        }, U.inlineText = function(E, N) {
          var W = this.rules.inline.text.exec(E);
          if (W) {
            var P;
            return this.lexer.state.inRawBlock ? P = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(W[0]) : _(W[0]) : W[0] : P = _(this.options.smartypants ? N(W[0]) : W[0]), {
              type: "text",
              raw: W[0],
              text: P
            };
          }
        }, K;
      }(), ve = {
        newline: /^(?: *(?:\n|$))+/,
        code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
        fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
        hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
        heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
        blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
        list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
        html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
        def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
        table: $,
        lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
        _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
        text: /^[^\n]+/
      };
      ve._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/, ve._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/, ve.def = w(ve.def).replace("label", ve._label).replace("title", ve._title).getRegex(), ve.bullet = /(?:[*+-]|\d{1,9}[.)])/, ve.listItemStart = w(/^( *)(bull) */).replace("bull", ve.bullet).getRegex(), ve.list = w(ve.list).replace(/bull/g, ve.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + ve.def.source + ")").getRegex(), ve._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", ve._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, ve.html = w(ve.html, "i").replace("comment", ve._comment).replace("tag", ve._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), ve.paragraph = w(ve._paragraph).replace("hr", ve.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ve._tag).getRegex(), ve.blockquote = w(ve.blockquote).replace("paragraph", ve.paragraph).getRegex(), ve.normal = j({}, ve), ve.gfm = j({}, ve.normal, {
        table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      }), ve.gfm.table = w(ve.gfm.table).replace("hr", ve.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ve._tag).getRegex(), ve.gfm.paragraph = w(ve._paragraph).replace("hr", ve.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", ve.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ve._tag).getRegex(), ve.pedantic = j({}, ve.normal, {
        html: w(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", ve._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: $,
        paragraph: w(ve.normal._paragraph).replace("hr", ve.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", ve.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
      });
      var pe = {
        escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
        autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
        url: $,
        tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
        link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
        reflink: /^!?\[(label)\]\[(ref)\]/,
        nolink: /^!?\[(ref)\](?:\[\])?/,
        reflinkSearch: "reflink|nolink(?!\\()",
        emStrong: {
          lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
          rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
          rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        },
        code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
        br: /^( {2,}|\\)\n(?!\s*$)/,
        del: $,
        text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
        punctuation: /^([\spunctuation])/
      };
      pe._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", pe.punctuation = w(pe.punctuation).replace(/punctuation/g, pe._punctuation).getRegex(), pe.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, pe.escapedEmSt = /\\\*|\\_/g, pe._comment = w(ve._comment).replace("(?:-->|$)", "-->").getRegex(), pe.emStrong.lDelim = w(pe.emStrong.lDelim).replace(/punct/g, pe._punctuation).getRegex(), pe.emStrong.rDelimAst = w(pe.emStrong.rDelimAst, "g").replace(/punct/g, pe._punctuation).getRegex(), pe.emStrong.rDelimUnd = w(pe.emStrong.rDelimUnd, "g").replace(/punct/g, pe._punctuation).getRegex(), pe._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, pe._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, pe._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, pe.autolink = w(pe.autolink).replace("scheme", pe._scheme).replace("email", pe._email).getRegex(), pe._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, pe.tag = w(pe.tag).replace("comment", pe._comment).replace("attribute", pe._attribute).getRegex(), pe._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, pe._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, pe._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, pe.link = w(pe.link).replace("label", pe._label).replace("href", pe._href).replace("title", pe._title).getRegex(), pe.reflink = w(pe.reflink).replace("label", pe._label).replace("ref", ve._label).getRegex(), pe.nolink = w(pe.nolink).replace("ref", ve._label).getRegex(), pe.reflinkSearch = w(pe.reflinkSearch, "g").replace("reflink", pe.reflink).replace("nolink", pe.nolink).getRegex(), pe.normal = j({}, pe), pe.pedantic = j({}, pe.normal, {
        strong: {
          start: /^__|\*\*/,
          middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          endAst: /\*\*(?!\*)/g,
          endUnd: /__(?!_)/g
        },
        em: {
          start: /^_|\*/,
          middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
          endAst: /\*(?!\*)/g,
          endUnd: /_(?!_)/g
        },
        link: w(/^!?\[(label)\]\((.*?)\)/).replace("label", pe._label).getRegex(),
        reflink: w(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", pe._label).getRegex()
      }), pe.gfm = j({}, pe.normal, {
        escape: w(pe.escape).replace("])", "~|])").getRegex(),
        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
      }), pe.gfm.url = w(pe.gfm.url, "i").replace("email", pe.gfm._extended_email).getRegex(), pe.breaks = j({}, pe.gfm, {
        br: w(pe.br).replace("{2,}", "*").getRegex(),
        text: w(pe.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
      });
      function ft(K) {
        return K.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
      }
      function Hi(K) {
        var U = "", O, E, N = K.length;
        for (O = 0; O < N; O++)
          E = K.charCodeAt(O), Math.random() > 0.5 && (E = "x" + E.toString(16)), U += "&#" + E + ";";
        return U;
      }
      var Ri = /* @__PURE__ */ function() {
        function K(O) {
          this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = O || e.defaults, this.options.tokenizer = this.options.tokenizer || new bt(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
            inLink: !1,
            inRawBlock: !1,
            top: !0
          };
          var E = {
            block: ve.normal,
            inline: pe.normal
          };
          this.options.pedantic ? (E.block = ve.pedantic, E.inline = pe.pedantic) : this.options.gfm && (E.block = ve.gfm, this.options.breaks ? E.inline = pe.breaks : E.inline = pe.gfm), this.tokenizer.rules = E;
        }
        K.lex = function(E, N) {
          var W = new K(N);
          return W.lex(E);
        }, K.lexInline = function(E, N) {
          var W = new K(N);
          return W.inlineTokens(E);
        };
        var U = K.prototype;
        return U.lex = function(E) {
          E = E.replace(/\r\n|\r/g, `
`).replace(/\t/g, "    "), this.blockTokens(E, this.tokens);
          for (var N; N = this.inlineQueue.shift(); )
            this.inlineTokens(N.src, N.tokens);
          return this.tokens;
        }, U.blockTokens = function(E, N) {
          var W = this;
          N === void 0 && (N = []), this.options.pedantic && (E = E.replace(/^ +$/gm, ""));
          for (var P, Q, re, Me; E; )
            if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(je) {
              return (P = je.call({
                lexer: W
              }, E, N)) ? (E = E.substring(P.raw.length), N.push(P), !0) : !1;
            }))) {
              if (P = this.tokenizer.space(E)) {
                E = E.substring(P.raw.length), P.raw.length === 1 && N.length > 0 ? N[N.length - 1].raw += `
` : N.push(P);
                continue;
              }
              if (P = this.tokenizer.code(E)) {
                E = E.substring(P.raw.length), Q = N[N.length - 1], Q && (Q.type === "paragraph" || Q.type === "text") ? (Q.raw += `
` + P.raw, Q.text += `
` + P.text, this.inlineQueue[this.inlineQueue.length - 1].src = Q.text) : N.push(P);
                continue;
              }
              if (P = this.tokenizer.fences(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.heading(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.hr(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.blockquote(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.list(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.html(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.def(E)) {
                E = E.substring(P.raw.length), Q = N[N.length - 1], Q && (Q.type === "paragraph" || Q.type === "text") ? (Q.raw += `
` + P.raw, Q.text += `
` + P.raw, this.inlineQueue[this.inlineQueue.length - 1].src = Q.text) : this.tokens.links[P.tag] || (this.tokens.links[P.tag] = {
                  href: P.href,
                  title: P.title
                });
                continue;
              }
              if (P = this.tokenizer.table(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.lheading(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (re = E, this.options.extensions && this.options.extensions.startBlock && function() {
                var je = 1 / 0, Ke = E.slice(1), Ht = void 0;
                W.options.extensions.startBlock.forEach(function(pt) {
                  Ht = pt.call({
                    lexer: this
                  }, Ke), typeof Ht == "number" && Ht >= 0 && (je = Math.min(je, Ht));
                }), je < 1 / 0 && je >= 0 && (re = E.substring(0, je + 1));
              }(), this.state.top && (P = this.tokenizer.paragraph(re))) {
                Q = N[N.length - 1], Me && Q.type === "paragraph" ? (Q.raw += `
` + P.raw, Q.text += `
` + P.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = Q.text) : N.push(P), Me = re.length !== E.length, E = E.substring(P.raw.length);
                continue;
              }
              if (P = this.tokenizer.text(E)) {
                E = E.substring(P.raw.length), Q = N[N.length - 1], Q && Q.type === "text" ? (Q.raw += `
` + P.raw, Q.text += `
` + P.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = Q.text) : N.push(P);
                continue;
              }
              if (E) {
                var ke = "Infinite loop on byte: " + E.charCodeAt(0);
                if (this.options.silent) {
                  console.error(ke);
                  break;
                } else
                  throw new Error(ke);
              }
            }
          return this.state.top = !0, N;
        }, U.inline = function(E, N) {
          this.inlineQueue.push({
            src: E,
            tokens: N
          });
        }, U.inlineTokens = function(E, N) {
          var W = this;
          N === void 0 && (N = []);
          var P, Q, re, Me = E, ke, je, Ke;
          if (this.tokens.links) {
            var Ht = Object.keys(this.tokens.links);
            if (Ht.length > 0)
              for (; (ke = this.tokenizer.rules.inline.reflinkSearch.exec(Me)) != null; )
                Ht.includes(ke[0].slice(ke[0].lastIndexOf("[") + 1, -1)) && (Me = Me.slice(0, ke.index) + "[" + xe("a", ke[0].length - 2) + "]" + Me.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
          }
          for (; (ke = this.tokenizer.rules.inline.blockSkip.exec(Me)) != null; )
            Me = Me.slice(0, ke.index) + "[" + xe("a", ke[0].length - 2) + "]" + Me.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          for (; (ke = this.tokenizer.rules.inline.escapedEmSt.exec(Me)) != null; )
            Me = Me.slice(0, ke.index) + "++" + Me.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          for (; E; )
            if (je || (Ke = ""), je = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(Oe) {
              return (P = Oe.call({
                lexer: W
              }, E, N)) ? (E = E.substring(P.raw.length), N.push(P), !0) : !1;
            }))) {
              if (P = this.tokenizer.escape(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.tag(E)) {
                E = E.substring(P.raw.length), Q = N[N.length - 1], Q && P.type === "text" && Q.type === "text" ? (Q.raw += P.raw, Q.text += P.text) : N.push(P);
                continue;
              }
              if (P = this.tokenizer.link(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.reflink(E, this.tokens.links)) {
                E = E.substring(P.raw.length), Q = N[N.length - 1], Q && P.type === "text" && Q.type === "text" ? (Q.raw += P.raw, Q.text += P.text) : N.push(P);
                continue;
              }
              if (P = this.tokenizer.emStrong(E, Me, Ke)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.codespan(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.br(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.del(E)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (P = this.tokenizer.autolink(E, Hi)) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (!this.state.inLink && (P = this.tokenizer.url(E, Hi))) {
                E = E.substring(P.raw.length), N.push(P);
                continue;
              }
              if (re = E, this.options.extensions && this.options.extensions.startInline && function() {
                var Oe = 1 / 0, Ni = E.slice(1), di = void 0;
                W.options.extensions.startInline.forEach(function(to) {
                  di = to.call({
                    lexer: this
                  }, Ni), typeof di == "number" && di >= 0 && (Oe = Math.min(Oe, di));
                }), Oe < 1 / 0 && Oe >= 0 && (re = E.substring(0, Oe + 1));
              }(), P = this.tokenizer.inlineText(re, ft)) {
                E = E.substring(P.raw.length), P.raw.slice(-1) !== "_" && (Ke = P.raw.slice(-1)), je = !0, Q = N[N.length - 1], Q && Q.type === "text" ? (Q.raw += P.raw, Q.text += P.text) : N.push(P);
                continue;
              }
              if (E) {
                var pt = "Infinite loop on byte: " + E.charCodeAt(0);
                if (this.options.silent) {
                  console.error(pt);
                  break;
                } else
                  throw new Error(pt);
              }
            }
          return N;
        }, i(K, null, [{
          key: "rules",
          get: function() {
            return {
              block: ve,
              inline: pe
            };
          }
        }]), K;
      }(), ms = /* @__PURE__ */ function() {
        function K(O) {
          this.options = O || e.defaults;
        }
        var U = K.prototype;
        return U.code = function(E, N, W) {
          var P = (N || "").match(/\S*/)[0];
          if (this.options.highlight) {
            var Q = this.options.highlight(E, P);
            Q != null && Q !== E && (W = !0, E = Q);
          }
          return E = E.replace(/\n$/, "") + `
`, P ? '<pre><code class="' + this.options.langPrefix + _(P, !0) + '">' + (W ? E : _(E, !0)) + `</code></pre>
` : "<pre><code>" + (W ? E : _(E, !0)) + `</code></pre>
`;
        }, U.blockquote = function(E) {
          return `<blockquote>
` + E + `</blockquote>
`;
        }, U.html = function(E) {
          return E;
        }, U.heading = function(E, N, W, P) {
          return this.options.headerIds ? "<h" + N + ' id="' + this.options.headerPrefix + P.slug(W) + '">' + E + "</h" + N + `>
` : "<h" + N + ">" + E + "</h" + N + `>
`;
        }, U.hr = function() {
          return this.options.xhtml ? `<hr/>
` : `<hr>
`;
        }, U.list = function(E, N, W) {
          var P = N ? "ol" : "ul", Q = N && W !== 1 ? ' start="' + W + '"' : "";
          return "<" + P + Q + `>
` + E + "</" + P + `>
`;
        }, U.listitem = function(E) {
          return "<li>" + E + `</li>
`;
        }, U.checkbox = function(E) {
          return "<input " + (E ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
        }, U.paragraph = function(E) {
          return "<p>" + E + `</p>
`;
        }, U.table = function(E, N) {
          return N && (N = "<tbody>" + N + "</tbody>"), `<table>
<thead>
` + E + `</thead>
` + N + `</table>
`;
        }, U.tablerow = function(E) {
          return `<tr>
` + E + `</tr>
`;
        }, U.tablecell = function(E, N) {
          var W = N.header ? "th" : "td", P = N.align ? "<" + W + ' align="' + N.align + '">' : "<" + W + ">";
          return P + E + "</" + W + `>
`;
        }, U.strong = function(E) {
          return "<strong>" + E + "</strong>";
        }, U.em = function(E) {
          return "<em>" + E + "</em>";
        }, U.codespan = function(E) {
          return "<code>" + E + "</code>";
        }, U.br = function() {
          return this.options.xhtml ? "<br/>" : "<br>";
        }, U.del = function(E) {
          return "<del>" + E + "</del>";
        }, U.link = function(E, N, W) {
          if (E = x(this.options.sanitize, this.options.baseUrl, E), E === null)
            return W;
          var P = '<a href="' + _(E) + '"';
          return N && (P += ' title="' + N + '"'), P += ">" + W + "</a>", P;
        }, U.image = function(E, N, W) {
          if (E = x(this.options.sanitize, this.options.baseUrl, E), E === null)
            return W;
          var P = '<img src="' + E + '" alt="' + W + '"';
          return N && (P += ' title="' + N + '"'), P += this.options.xhtml ? "/>" : ">", P;
        }, U.text = function(E) {
          return E;
        }, K;
      }(), Ao = /* @__PURE__ */ function() {
        function K() {
        }
        var U = K.prototype;
        return U.strong = function(E) {
          return E;
        }, U.em = function(E) {
          return E;
        }, U.codespan = function(E) {
          return E;
        }, U.del = function(E) {
          return E;
        }, U.html = function(E) {
          return E;
        }, U.text = function(E) {
          return E;
        }, U.link = function(E, N, W) {
          return "" + W;
        }, U.image = function(E, N, W) {
          return "" + W;
        }, U.br = function() {
          return "";
        }, K;
      }(), Ia = /* @__PURE__ */ function() {
        function K() {
          this.seen = {};
        }
        var U = K.prototype;
        return U.serialize = function(E) {
          return E.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
        }, U.getNextSafeSlug = function(E, N) {
          var W = E, P = 0;
          if (this.seen.hasOwnProperty(W)) {
            P = this.seen[E];
            do
              P++, W = E + "-" + P;
            while (this.seen.hasOwnProperty(W));
          }
          return N || (this.seen[E] = P, this.seen[W] = 0), W;
        }, U.slug = function(E, N) {
          N === void 0 && (N = {});
          var W = this.serialize(E);
          return this.getNextSafeSlug(W, N.dryrun);
        }, K;
      }(), Ro = /* @__PURE__ */ function() {
        function K(O) {
          this.options = O || e.defaults, this.options.renderer = this.options.renderer || new ms(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new Ao(), this.slugger = new Ia();
        }
        K.parse = function(E, N) {
          var W = new K(N);
          return W.parse(E);
        }, K.parseInline = function(E, N) {
          var W = new K(N);
          return W.parseInline(E);
        };
        var U = K.prototype;
        return U.parse = function(E, N) {
          N === void 0 && (N = !0);
          var W = "", P, Q, re, Me, ke, je, Ke, Ht, pt, Oe, Ni, di, to, ii, Ji, qc, As, Jo, Ll, Ea = E.length;
          for (P = 0; P < Ea; P++) {
            if (Oe = E[P], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[Oe.type] && (Ll = this.options.extensions.renderers[Oe.type].call({
              parser: this
            }, Oe), Ll !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(Oe.type))) {
              W += Ll || "";
              continue;
            }
            switch (Oe.type) {
              case "space":
                continue;
              case "hr": {
                W += this.renderer.hr();
                continue;
              }
              case "heading": {
                W += this.renderer.heading(this.parseInline(Oe.tokens), Oe.depth, C(this.parseInline(Oe.tokens, this.textRenderer)), this.slugger);
                continue;
              }
              case "code": {
                W += this.renderer.code(Oe.text, Oe.lang, Oe.escaped);
                continue;
              }
              case "table": {
                for (Ht = "", Ke = "", Me = Oe.header.length, Q = 0; Q < Me; Q++)
                  Ke += this.renderer.tablecell(this.parseInline(Oe.header[Q].tokens), {
                    header: !0,
                    align: Oe.align[Q]
                  });
                for (Ht += this.renderer.tablerow(Ke), pt = "", Me = Oe.rows.length, Q = 0; Q < Me; Q++) {
                  for (je = Oe.rows[Q], Ke = "", ke = je.length, re = 0; re < ke; re++)
                    Ke += this.renderer.tablecell(this.parseInline(je[re].tokens), {
                      header: !1,
                      align: Oe.align[re]
                    });
                  pt += this.renderer.tablerow(Ke);
                }
                W += this.renderer.table(Ht, pt);
                continue;
              }
              case "blockquote": {
                pt = this.parse(Oe.tokens), W += this.renderer.blockquote(pt);
                continue;
              }
              case "list": {
                for (Ni = Oe.ordered, di = Oe.start, to = Oe.loose, Me = Oe.items.length, pt = "", Q = 0; Q < Me; Q++)
                  Ji = Oe.items[Q], qc = Ji.checked, As = Ji.task, ii = "", Ji.task && (Jo = this.renderer.checkbox(qc), to ? Ji.tokens.length > 0 && Ji.tokens[0].type === "paragraph" ? (Ji.tokens[0].text = Jo + " " + Ji.tokens[0].text, Ji.tokens[0].tokens && Ji.tokens[0].tokens.length > 0 && Ji.tokens[0].tokens[0].type === "text" && (Ji.tokens[0].tokens[0].text = Jo + " " + Ji.tokens[0].tokens[0].text)) : Ji.tokens.unshift({
                    type: "text",
                    text: Jo
                  }) : ii += Jo), ii += this.parse(Ji.tokens, to), pt += this.renderer.listitem(ii, As, qc);
                W += this.renderer.list(pt, Ni, di);
                continue;
              }
              case "html": {
                W += this.renderer.html(Oe.text);
                continue;
              }
              case "paragraph": {
                W += this.renderer.paragraph(this.parseInline(Oe.tokens));
                continue;
              }
              case "text": {
                for (pt = Oe.tokens ? this.parseInline(Oe.tokens) : Oe.text; P + 1 < Ea && E[P + 1].type === "text"; )
                  Oe = E[++P], pt += `
` + (Oe.tokens ? this.parseInline(Oe.tokens) : Oe.text);
                W += N ? this.renderer.paragraph(pt) : pt;
                continue;
              }
              default: {
                var Gh = 'Token with "' + Oe.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(Gh);
                  return;
                } else
                  throw new Error(Gh);
              }
            }
          }
          return W;
        }, U.parseInline = function(E, N) {
          N = N || this.renderer;
          var W = "", P, Q, re, Me = E.length;
          for (P = 0; P < Me; P++) {
            if (Q = E[P], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[Q.type] && (re = this.options.extensions.renderers[Q.type].call({
              parser: this
            }, Q), re !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(Q.type))) {
              W += re || "";
              continue;
            }
            switch (Q.type) {
              case "escape": {
                W += N.text(Q.text);
                break;
              }
              case "html": {
                W += N.html(Q.text);
                break;
              }
              case "link": {
                W += N.link(Q.href, Q.title, this.parseInline(Q.tokens, N));
                break;
              }
              case "image": {
                W += N.image(Q.href, Q.title, Q.text);
                break;
              }
              case "strong": {
                W += N.strong(this.parseInline(Q.tokens, N));
                break;
              }
              case "em": {
                W += N.em(this.parseInline(Q.tokens, N));
                break;
              }
              case "codespan": {
                W += N.codespan(Q.text);
                break;
              }
              case "br": {
                W += N.br();
                break;
              }
              case "del": {
                W += N.del(this.parseInline(Q.tokens, N));
                break;
              }
              case "text": {
                W += N.text(Q.text);
                break;
              }
              default: {
                var ke = 'Token with "' + Q.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(ke);
                  return;
                } else
                  throw new Error(ke);
              }
            }
          }
          return W;
        }, K;
      }();
      function Y(K, U, O) {
        if (typeof K > "u" || K === null)
          throw new Error("marked(): input parameter is undefined or null");
        if (typeof K != "string")
          throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(K) + ", string expected");
        if (typeof U == "function" && (O = U, U = null), U = j({}, Y.defaults, U || {}), Ne(U), O) {
          var E = U.highlight, N;
          try {
            N = Ri.lex(K, U);
          } catch (re) {
            return O(re);
          }
          var W = function(Me) {
            var ke;
            if (!Me)
              try {
                U.walkTokens && Y.walkTokens(N, U.walkTokens), ke = Ro.parse(N, U);
              } catch (je) {
                Me = je;
              }
            return U.highlight = E, Me ? O(Me) : O(null, ke);
          };
          if (!E || E.length < 3 || (delete U.highlight, !N.length))
            return W();
          var P = 0;
          Y.walkTokens(N, function(re) {
            re.type === "code" && (P++, setTimeout(function() {
              E(re.text, re.lang, function(Me, ke) {
                if (Me)
                  return W(Me);
                ke != null && ke !== re.text && (re.text = ke, re.escaped = !0), P--, P === 0 && W();
              });
            }, 0));
          }), P === 0 && W();
          return;
        }
        try {
          var Q = Ri.lex(K, U);
          return U.walkTokens && Y.walkTokens(Q, U.walkTokens), Ro.parse(Q, U);
        } catch (re) {
          if (re.message += `
Please report this to https://github.com/markedjs/marked.`, U.silent)
            return "<p>An error occurred:</p><pre>" + _(re.message + "", !0) + "</pre>";
          throw re;
        }
      }
      Y.options = Y.setOptions = function(K) {
        return j(Y.defaults, K), l(Y.defaults), Y;
      }, Y.getDefaults = a, Y.defaults = e.defaults, Y.use = function() {
        for (var K = arguments.length, U = new Array(K), O = 0; O < K; O++)
          U[O] = arguments[O];
        var E = j.apply(void 0, [{}].concat(U)), N = Y.defaults.extensions || {
          renderers: {},
          childTokens: {}
        }, W;
        U.forEach(function(P) {
          if (P.extensions && (W = !0, P.extensions.forEach(function(re) {
            if (!re.name)
              throw new Error("extension name required");
            if (re.renderer) {
              var Me = N.renderers ? N.renderers[re.name] : null;
              Me ? N.renderers[re.name] = function() {
                for (var ke = arguments.length, je = new Array(ke), Ke = 0; Ke < ke; Ke++)
                  je[Ke] = arguments[Ke];
                var Ht = re.renderer.apply(this, je);
                return Ht === !1 && (Ht = Me.apply(this, je)), Ht;
              } : N.renderers[re.name] = re.renderer;
            }
            if (re.tokenizer) {
              if (!re.level || re.level !== "block" && re.level !== "inline")
                throw new Error("extension level must be 'block' or 'inline'");
              N[re.level] ? N[re.level].unshift(re.tokenizer) : N[re.level] = [re.tokenizer], re.start && (re.level === "block" ? N.startBlock ? N.startBlock.push(re.start) : N.startBlock = [re.start] : re.level === "inline" && (N.startInline ? N.startInline.push(re.start) : N.startInline = [re.start]));
            }
            re.childTokens && (N.childTokens[re.name] = re.childTokens);
          })), P.renderer && function() {
            var re = Y.defaults.renderer || new ms(), Me = function(Ke) {
              var Ht = re[Ke];
              re[Ke] = function() {
                for (var pt = arguments.length, Oe = new Array(pt), Ni = 0; Ni < pt; Ni++)
                  Oe[Ni] = arguments[Ni];
                var di = P.renderer[Ke].apply(re, Oe);
                return di === !1 && (di = Ht.apply(re, Oe)), di;
              };
            };
            for (var ke in P.renderer)
              Me(ke);
            E.renderer = re;
          }(), P.tokenizer && function() {
            var re = Y.defaults.tokenizer || new bt(), Me = function(Ke) {
              var Ht = re[Ke];
              re[Ke] = function() {
                for (var pt = arguments.length, Oe = new Array(pt), Ni = 0; Ni < pt; Ni++)
                  Oe[Ni] = arguments[Ni];
                var di = P.tokenizer[Ke].apply(re, Oe);
                return di === !1 && (di = Ht.apply(re, Oe)), di;
              };
            };
            for (var ke in P.tokenizer)
              Me(ke);
            E.tokenizer = re;
          }(), P.walkTokens) {
            var Q = Y.defaults.walkTokens;
            E.walkTokens = function(re) {
              P.walkTokens.call(this, re), Q && Q.call(this, re);
            };
          }
          W && (E.extensions = N), Y.setOptions(E);
        });
      }, Y.walkTokens = function(K, U) {
        for (var O = function() {
          var P = N.value;
          switch (U.call(Y, P), P.type) {
            case "table": {
              for (var Q = r(P.header), re; !(re = Q()).done; ) {
                var Me = re.value;
                Y.walkTokens(Me.tokens, U);
              }
              for (var ke = r(P.rows), je; !(je = ke()).done; )
                for (var Ke = je.value, Ht = r(Ke), pt; !(pt = Ht()).done; ) {
                  var Oe = pt.value;
                  Y.walkTokens(Oe.tokens, U);
                }
              break;
            }
            case "list": {
              Y.walkTokens(P.items, U);
              break;
            }
            default:
              Y.defaults.extensions && Y.defaults.extensions.childTokens && Y.defaults.extensions.childTokens[P.type] ? Y.defaults.extensions.childTokens[P.type].forEach(function(Ni) {
                Y.walkTokens(P[Ni], U);
              }) : P.tokens && Y.walkTokens(P.tokens, U);
          }
        }, E = r(K), N; !(N = E()).done; )
          O();
      }, Y.parseInline = function(K, U) {
        if (typeof K > "u" || K === null)
          throw new Error("marked.parseInline(): input parameter is undefined or null");
        if (typeof K != "string")
          throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(K) + ", string expected");
        U = j({}, Y.defaults, U || {}), Ne(U);
        try {
          var O = Ri.lexInline(K, U);
          return U.walkTokens && Y.walkTokens(O, U.walkTokens), Ro.parseInline(O, U);
        } catch (E) {
          if (E.message += `
Please report this to https://github.com/markedjs/marked.`, U.silent)
            return "<p>An error occurred:</p><pre>" + _(E.message + "", !0) + "</pre>";
          throw E;
        }
      }, Y.Parser = Ro, Y.parser = Ro.parse, Y.Renderer = ms, Y.TextRenderer = Ao, Y.Lexer = Ri, Y.lexer = Ri.lex, Y.Tokenizer = bt, Y.Slugger = Ia, Y.parse = Y;
      var G = Y.options, de = Y.setOptions, Ae = Y.use, yt = Y.walkTokens, mi = Y.parseInline, ei = Y, ti = Ro.parse, Ei = Ri.lex;
      e.Lexer = Ri, e.Parser = Ro, e.Renderer = ms, e.Slugger = Ia, e.TextRenderer = Ao, e.Tokenizer = bt, e.getDefaults = a, e.lexer = Ei, e.marked = Y, e.options = G, e.parse = ei, e.parseInline = mi, e.parser = ti, e.setOptions = de, e.use = Ae, e.walkTokens = yt, Object.defineProperty(e, "__esModule", { value: !0 });
    });
  })();
  var vA = A7 || Dv;
  function Dk(s) {
    let e = JSON.parse(s);
    return e = xk(e), e;
  }
  function xk(s, e = 0) {
    if (!s || e > 200)
      return s;
    if (typeof s == "object") {
      switch (s.$mid) {
        case 1:
          return Ee.revive(s);
        case 2:
          return new RegExp(s.source, s.flags);
        case 14:
          return new Date(s.source);
      }
      if (s instanceof jv || s instanceof Uint8Array)
        return s;
      if (Array.isArray(s))
        for (let t = 0; t < s.length; ++t)
          s[t] = xk(s[t], e + 1);
      else
        for (const t in s)
          Object.hasOwnProperty.call(s, t) && (s[t] = xk(s[t], e + 1));
    }
    return s;
  }
  function yee(s, e = {}, t = {}) {
    var i;
    const n = new te();
    let o = !1;
    const r = n.add(new bn()), a = DN(e), l = function(C) {
      let v;
      try {
        v = Dk(decodeURIComponent(C));
      } catch {
      }
      return v ? (v = uH(v, (w) => {
        if (s.uris && s.uris[w])
          return Ee.revive(s.uris[w]);
      }), encodeURIComponent(JSON.stringify(v))) : C;
    }, c = function(C, v) {
      const w = s.uris && s.uris[C];
      let S = Ee.revive(w);
      return v ? C.startsWith(ze.data + ":") ? C : (S || (S = Ee.parse(C)), dP.asBrowserUri(S).toString(!0)) : !S || Ee.parse(C).toString() === S.toString() ? C : (S.query && (S = S.with({ query: l(S.query) })), S.toString());
    };
    let d;
    const h = new Promise((C) => d = C), u = new vA.Renderer();
    if (u.image = (C, v, w) => {
      let S = [], L = [];
      return C && ({ href: C, dimensions: S } = YZ(C), L.push(`src="${C}"`)), w && L.push(`alt="${w}"`), v && L.push(`title="${v}"`), S.length && (L = L.concat(S)), "<img " + L.join(" ") + ">";
    }, u.link = (C, v, w) => typeof C != "string" ? "" : (C === w && (w = wS(w)), C = c(C, !1), s.baseUri && (C = JS(Ee.from(s.baseUri), C)), v = typeof v == "string" ? wS(v) : "", C = wS(C), !C || /^data:|javascript:/i.test(C) || /^command:/i.test(C) && !s.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(C) ? w : (C = C.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;"), `<a data-href="${C}" title="${v || C}">${w}</a>`)), u.paragraph = (C) => `<p>${C}</p>`, e.codeBlockRenderer && (u.code = (C, v) => {
      const w = e.codeBlockRenderer(v ?? "", C), S = b3.nextId();
      return CI(Promise.all([w, h]), r.token).then((L) => {
        var x;
        if (!o && L) {
          const y = a.querySelector(`div[data-code="${S}"]`);
          y && pc(y, L[0]), (x = e.asyncRenderCallback) === null || x === void 0 || x.call(e);
        }
      }).catch(() => {
      }), `<div class="code" data-code="${S}">${II(C)}</div>`;
    }), e.actionHandler) {
      const C = e.actionHandler.disposables.add(new xt(a, "click")), v = e.actionHandler.disposables.add(new xt(a, "auxclick"));
      e.actionHandler.disposables.add(be.any(C.event, v.event)((w) => {
        const S = new ho(w);
        if (!S.leftButton && !S.middleButton)
          return;
        let L = S.target;
        if (!(L.tagName !== "A" && (L = L.parentElement, !L || L.tagName !== "A")))
          try {
            let x = L.dataset.href;
            x && (s.baseUri && (x = JS(Ee.from(s.baseUri), x)), e.actionHandler.callback(x, S));
          } catch (x) {
            We(x);
          } finally {
            S.preventDefault();
          }
      }));
    }
    s.supportHtml || (t.sanitizer = (C) => (s.isTrusted ? C.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0) ? C : "", t.sanitize = !0, t.silent = !0), t.renderer = u;
    let f = (i = s.value) !== null && i !== void 0 ? i : "";
    f.length > 1e5 && (f = `${f.substr(0, 1e5)}\u2026`), s.supportThemeIcons && (f = KZ(f));
    let g = vA.parse(f, t);
    s.supportThemeIcons && (g = Pd(g).map((v) => typeof v == "string" ? v : v.outerHTML).join(""));
    const b = new DOMParser().parseFromString(CA(s, g), "text/html");
    if (b.body.querySelectorAll("img").forEach((C) => {
      const v = C.getAttribute("src");
      if (v) {
        let w = v;
        try {
          s.baseUri && (w = JS(Ee.from(s.baseUri), w));
        } catch {
        }
        C.src = c(w, !0);
      }
    }), a.innerHTML = CA(s, b.body.innerHTML), d(), e.asyncRenderCallback)
      for (const C of a.getElementsByTagName("img")) {
        const v = n.add(ee(C, "load", () => {
          v.dispose(), e.asyncRenderCallback();
        }));
      }
    return {
      element: a,
      dispose: () => {
        o = !0, r.cancel(), n.dispose();
      }
    };
  }
  function JS(s, e) {
    return /^\w[\w\d+.-]*:/.test(e) ? e : s.path.endsWith("/") ? jT(s, e).toString() : jT(hC(s), e).toString();
  }
  function CA(s, e) {
    const { config: t, allowedSchemes: i } = Lee(s);
    _A("uponSanitizeAttribute", (o, r) => {
      if (r.attrName === "style" || r.attrName === "class") {
        if (o.tagName === "SPAN") {
          if (r.attrName === "style") {
            r.keepAttr = /^(color\:#[0-9a-fA-F]+;)?(background-color\:#[0-9a-fA-F]+;)?$/.test(r.attrValue);
            return;
          } else if (r.attrName === "class") {
            r.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(r.attrValue);
            return;
          }
        }
        r.keepAttr = !1;
        return;
      }
    });
    const n = document.createElement("a");
    _A("afterSanitizeAttributes", (o) => {
      for (const r of ["href", "src"])
        o.hasAttribute(r) && (n.href = o.getAttribute(r), i.includes(n.protocol.replace(/:$/, "")) || o.removeAttribute(r));
    });
    try {
      return See(e, Object.assign(Object.assign({}, t), { RETURN_TRUSTED_TYPE: !0 }));
    } finally {
      bA("uponSanitizeAttribute"), bA("afterSanitizeAttributes");
    }
  }
  function Lee(s) {
    const e = [
      ze.http,
      ze.https,
      ze.mailto,
      ze.data,
      ze.file,
      ze.vscodeFileResource,
      ze.vscodeRemote,
      ze.vscodeRemoteResource
    ];
    return s.isTrusted && e.push(ze.command), {
      config: {
        ALLOWED_TAGS: ["ul", "li", "p", "b", "i", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"],
        ALLOWED_ATTR: ["href", "data-href", "target", "title", "src", "alt", "class", "style", "data-code", "width", "height", "align"],
        ALLOW_UNKNOWN_PROTOCOLS: !0
      },
      allowedSchemes: e
    };
  }
  var wA = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const No = st("openerService"), kee = Object.freeze({
    _serviceBrand: void 0,
    registerOpener() {
      return z.None;
    },
    registerValidator() {
      return z.None;
    },
    registerExternalUriResolver() {
      return z.None;
    },
    setDefaultExternalOpener() {
    },
    registerExternalOpener() {
      return z.None;
    },
    open() {
      return wA(this, void 0, void 0, function* () {
        return !1;
      });
    },
    resolveExternalUri(s) {
      return wA(this, void 0, void 0, function* () {
        return { resolved: s, dispose() {
        } };
      });
    }
  });
  function R7(s, e) {
    return Ee.isUri(s) ? Su(s.scheme, e) : TI(s, e + ":");
  }
  function SA(s, ...e) {
    return e.some((t) => R7(s, t));
  }
  function Dee(s) {
    let e;
    const t = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(s.fragment);
    return t && (e = {
      startLineNumber: parseInt(t[1]),
      startColumn: t[2] ? parseInt(t[2]) : 1,
      endLineNumber: t[4] ? parseInt(t[4]) : void 0,
      endColumn: t[4] ? t[5] ? parseInt(t[5]) : 1 : void 0
    }, s = s.with({ fragment: "" })), { selection: e, uri: s };
  }
  var xee = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, yA = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Iee = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, ey;
  let bl = class O7 {
    constructor(e, t, i) {
      this._options = e, this._languageService = t, this._openerService = i, this._onDidRenderAsync = new B(), this.onDidRenderAsync = this._onDidRenderAsync.event;
    }
    dispose() {
      this._onDidRenderAsync.dispose();
    }
    render(e, t, i) {
      if (!e)
        return { element: document.createElement("span"), dispose: () => {
        } };
      const n = new te();
      return {
        element: n.add(yee(e, Object.assign(Object.assign({}, this._getRenderOptions(e, n)), t), i)).element,
        dispose: () => n.dispose()
      };
    }
    _getRenderOptions(e, t) {
      return {
        codeBlockRenderer: (i, n) => Iee(this, void 0, void 0, function* () {
          var o, r, a;
          let l;
          i ? l = this._languageService.getLanguageIdByLanguageName(i) : this._options.editor && (l = (o = this._options.editor.getModel()) === null || o === void 0 ? void 0 : o.getLanguageId()), l || (l = ya);
          const c = yield zK(this._languageService, n, l), d = document.createElement("span");
          if (d.innerHTML = (a = (r = O7._ttpTokenizer) === null || r === void 0 ? void 0 : r.createHTML(c)) !== null && a !== void 0 ? a : c, this._options.editor) {
            const h = this._options.editor.getOption(44);
            En(d, h);
          } else
            this._options.codeBlockFontFamily && (d.style.fontFamily = this._options.codeBlockFontFamily);
          return d;
        }),
        asyncRenderCallback: () => this._onDidRenderAsync.fire(),
        actionHandler: {
          callback: (i) => this._openerService.open(i, { fromUserGesture: !0, allowContributedOpeners: !0, allowCommands: e.isTrusted }).catch(We),
          disposables: t
        }
      };
    }
  };
  bl._ttpTokenizer = (ey = window.trustedTypes) === null || ey === void 0 ? void 0 : ey.createPolicy("tokenizeToString", {
    createHTML(s) {
      return s;
    }
  });
  bl = xee([
    yA(1, Jt),
    yA(2, No)
  ], bl);
  const LA = J;
  class sf extends z {
    constructor(e, t, i = kee) {
      super(), this._renderDisposeables = this._register(new te()), this._editor = e, this._isVisible = !1, this._messages = [], this._hover = this._register(new h7()), this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible), this._markdownRenderer = this._register(new bl({ editor: this._editor }, t, i)), this._computer = new Eee(this._editor), this._hoverOperation = this._register(new u7(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
        this._withResult(n.value);
      })), this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged())), this._register(this._editor.onDidChangeConfiguration((n) => {
        n.hasChanged(44) && this._updateFont();
      })), this._editor.addOverlayWidget(this);
    }
    dispose() {
      this._editor.removeOverlayWidget(this), super.dispose();
    }
    getId() {
      return sf.ID;
    }
    getDomNode() {
      return this._hover.containerDomNode;
    }
    getPosition() {
      return null;
    }
    _updateFont() {
      Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((t) => this._editor.applyFontInfo(t));
    }
    _onModelDecorationsChanged() {
      this._isVisible && (this._hoverOperation.cancel(), this._hoverOperation.start(0));
    }
    startShowingAt(e) {
      this._computer.lineNumber !== e && (this._hoverOperation.cancel(), this.hide(), this._computer.lineNumber = e, this._hoverOperation.start(0));
    }
    hide() {
      this._computer.lineNumber = -1, this._hoverOperation.cancel(), this._isVisible && (this._isVisible = !1, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
    }
    _withResult(e) {
      this._messages = e, this._messages.length > 0 ? this._renderMessages(this._computer.lineNumber, this._messages) : this.hide();
    }
    _renderMessages(e, t) {
      this._renderDisposeables.clear();
      const i = document.createDocumentFragment();
      for (const n of t) {
        const o = LA("div.hover-row.markdown-hover"), r = q(o, LA("div.hover-contents")), a = this._renderDisposeables.add(this._markdownRenderer.render(n.value));
        r.appendChild(a.element), i.appendChild(o);
      }
      this._updateContents(i), this._showAt(e);
    }
    _updateContents(e) {
      this._hover.contentsDomNode.textContent = "", this._hover.contentsDomNode.appendChild(e), this._updateFont();
    }
    _showAt(e) {
      this._isVisible || (this._isVisible = !0, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
      const t = this._editor.getLayoutInfo(), i = this._editor.getTopForLineNumber(e), n = this._editor.getScrollTop(), o = this._editor.getOption(59), r = this._hover.containerDomNode.clientHeight, a = i - n - (r - o) / 2;
      this._hover.containerDomNode.style.left = `${t.glyphMarginLeft + t.glyphMarginWidth}px`, this._hover.containerDomNode.style.top = `${Math.max(Math.round(a), 0)}px`;
    }
  }
  sf.ID = "editor.contrib.modesGlyphHoverWidget";
  class Eee {
    constructor(e) {
      this._editor = e, this._lineNumber = -1;
    }
    get lineNumber() {
      return this._lineNumber;
    }
    set lineNumber(e) {
      this._lineNumber = e;
    }
    computeSync() {
      const e = (n) => ({
        value: n
      }), t = this._editor.getLineDecorations(this._lineNumber), i = [];
      if (!t)
        return i;
      for (const n of t) {
        if (!n.options.glyphMarginClassName)
          continue;
        const o = n.options.glyphMarginHoverMessage;
        !o || If(o) || i.push(...jI(o).map(e));
      }
      return i;
    }
  }
  var Nee = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Tee {
    constructor(e, t, i) {
      this.provider = e, this.hover = t, this.ordinal = i;
    }
  }
  function Mee(s, e, t, i, n) {
    return Nee(this, void 0, void 0, function* () {
      try {
        const o = yield Promise.resolve(s.provideHover(t, i, n));
        if (o && Ree(o))
          return new Tee(s, o, e);
      } catch (o) {
        Xi(o);
      }
    });
  }
  function NN(s, e, t, i) {
    const o = s.ordered(e).map((r, a) => Mee(r, a, e, t, i));
    return vi.fromPromises(o).coalesce();
  }
  function Aee(s, e, t, i) {
    return NN(s, e, t, i).map((n) => n.hover).toPromise();
  }
  wa("_executeHoverProvider", (s, e, t) => {
    const i = s.get(me);
    return Aee(i.hoverProvider, e, t, Je.None);
  });
  function Ree(s) {
    const e = typeof s.range < "u", t = typeof s.contents < "u" && s.contents && s.contents.length > 0;
    return e && t;
  }
  var Oee = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Cb = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const kA = J;
  class nl {
    constructor(e, t, i, n) {
      this.owner = e, this.range = t, this.contents = i, this.ordinal = n;
    }
    isValidForHoverAnchor(e) {
      return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
    }
  }
  let $1 = class {
    constructor(e, t, i, n, o) {
      this._editor = e, this._languageService = t, this._openerService = i, this._configurationService = n, this._languageFeaturesService = o, this.hoverOrdinal = 2;
    }
    createLoadingMessage(e) {
      return new nl(this, e.range, [new Us().appendText(m("modesContentHover.loading", "Loading..."))], 2e3);
    }
    computeSync(e, t) {
      if (!this._editor.hasModel() || e.type !== 1)
        return [];
      const i = this._editor.getModel(), n = e.range.startLineNumber, o = i.getLineMaxColumn(n), r = [];
      let a = 1e3;
      const l = i.getLineLength(n), c = i.getLanguageIdAtPosition(e.range.startLineNumber, e.range.startColumn), d = this._configurationService.getValue("editor.maxTokenizationLineLength", {
        overrideIdentifier: c
      });
      typeof d == "number" && l >= d && r.push(new nl(this, e.range, [{
        value: m("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
      }], a++));
      for (const h of t) {
        const u = h.range.startLineNumber === n ? h.range.startColumn : 1, f = h.range.endLineNumber === n ? h.range.endColumn : o, g = h.options.hoverMessage;
        if (!g || If(g))
          continue;
        const _ = new D(e.range.startLineNumber, u, e.range.startLineNumber, f);
        r.push(new nl(this, _, jI(g), a++));
      }
      return r;
    }
    computeAsync(e, t, i) {
      if (!this._editor.hasModel() || e.type !== 1)
        return vi.EMPTY;
      const n = this._editor.getModel();
      if (!this._languageFeaturesService.hoverProvider.has(n))
        return vi.EMPTY;
      const o = new V(e.range.startLineNumber, e.range.startColumn);
      return NN(this._languageFeaturesService.hoverProvider, n, o, i).filter((r) => !If(r.hover.contents)).map((r) => {
        const a = r.hover.range ? D.lift(r.hover.range) : e.range;
        return new nl(this, a, r.hover.contents, r.ordinal);
      });
    }
    renderHoverParts(e, t) {
      return P7(e, t, this._editor, this._languageService, this._openerService);
    }
  };
  $1 = Oee([
    Cb(1, Jt),
    Cb(2, No),
    Cb(3, At),
    Cb(4, me)
  ], $1);
  function P7(s, e, t, i, n) {
    e.sort((r, a) => r.ordinal - a.ordinal);
    const o = new te();
    for (const r of e)
      for (const a of r.contents) {
        if (If(a))
          continue;
        const l = kA("div.hover-row.markdown-hover"), c = q(l, kA("div.hover-contents")), d = o.add(new bl({ editor: t }, i, n));
        o.add(d.onDidRenderAsync(() => {
          c.className = "hover-contents code-hover-contents", s.onContentsChanged();
        }));
        const h = o.add(d.render(a));
        c.appendChild(h.element), s.fragment.appendChild(l);
      }
    return o;
  }
  var F7 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, j1 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class DA {
    constructor(e, t, i) {
      this.marker = e, this.index = t, this.total = i;
    }
  }
  let Ik = class {
    constructor(e, t, i) {
      this._markerService = t, this._configService = i, this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._dispoables = new te(), this._markers = [], this._nextIdx = -1, Ee.isUri(e) ? this._resourceFilter = (a) => a.toString() === e.toString() : e && (this._resourceFilter = e);
      const n = this._configService.getValue("problems.sortOrder"), o = (a, l) => {
        let c = zm(a.resource.toString(), l.resource.toString());
        return c === 0 && (n === "position" ? c = D.compareRangesUsingStarts(a, l) || Xt.compare(a.severity, l.severity) : c = Xt.compare(a.severity, l.severity) || D.compareRangesUsingStarts(a, l)), c;
      }, r = () => {
        this._markers = this._markerService.read({
          resource: Ee.isUri(e) ? e : void 0,
          severities: Xt.Error | Xt.Warning | Xt.Info
        }), typeof e == "function" && (this._markers = this._markers.filter((a) => this._resourceFilter(a.resource))), this._markers.sort(o);
      };
      r(), this._dispoables.add(t.onMarkerChanged((a) => {
        (!this._resourceFilter || a.some((l) => this._resourceFilter(l))) && (r(), this._nextIdx = -1, this._onDidChange.fire());
      }));
    }
    dispose() {
      this._dispoables.dispose(), this._onDidChange.dispose();
    }
    matches(e) {
      return !this._resourceFilter && !e ? !0 : !this._resourceFilter || !e ? !1 : this._resourceFilter(e);
    }
    get selected() {
      const e = this._markers[this._nextIdx];
      return e && new DA(e, this._nextIdx + 1, this._markers.length);
    }
    _initIdx(e, t, i) {
      let n = !1, o = this._markers.findIndex((r) => r.resource.toString() === e.uri.toString());
      o < 0 && (o = UI(this._markers, { resource: e.uri }, (r, a) => zm(r.resource.toString(), a.resource.toString())), o < 0 && (o = ~o));
      for (let r = o; r < this._markers.length; r++) {
        let a = D.lift(this._markers[r]);
        if (a.isEmpty()) {
          const l = e.getWordAtPosition(a.getStartPosition());
          l && (a = new D(a.startLineNumber, l.startColumn, a.startLineNumber, l.endColumn));
        }
        if (t && (a.containsPosition(t) || t.isBeforeOrEqual(a.getStartPosition()))) {
          this._nextIdx = r, n = !0;
          break;
        }
        if (this._markers[r].resource.toString() !== e.uri.toString())
          break;
      }
      n || (this._nextIdx = i ? 0 : this._markers.length - 1), this._nextIdx < 0 && (this._nextIdx = this._markers.length - 1);
    }
    resetIndex() {
      this._nextIdx = -1;
    }
    move(e, t, i) {
      if (this._markers.length === 0)
        return !1;
      let n = this._nextIdx;
      return this._nextIdx === -1 ? this._initIdx(t, i, e) : e ? this._nextIdx = (this._nextIdx + 1) % this._markers.length : e || (this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length), n !== this._nextIdx;
    }
    find(e, t) {
      let i = this._markers.findIndex((n) => n.resource.toString() === e.toString());
      if (!(i < 0)) {
        for (; i < this._markers.length; i++)
          if (D.containsPosition(this._markers[i], t))
            return new DA(this._markers[i], i + 1, this._markers.length);
      }
    }
  };
  Ik = F7([
    j1(1, wl),
    j1(2, At)
  ], Ik);
  const B7 = st("IMarkerNavigationService");
  let Ek = class {
    constructor(e, t) {
      this._markerService = e, this._configService = t, this._provider = new $s();
    }
    getMarkerList(e) {
      for (let t of this._provider) {
        const i = t.getMarkerList(e);
        if (i)
          return i;
      }
      return new Ik(e, this._markerService, this._configService);
    }
  };
  Ek = F7([
    j1(0, wl),
    j1(1, At)
  ], Ek);
  ht(B7, Ek, !0);
  var Nk;
  (function(s) {
    function e(t) {
      switch (t) {
        case Zt.Ignore:
          return "severity-ignore " + p.info.classNames;
        case Zt.Info:
          return p.info.classNames;
        case Zt.Warning:
          return p.warning.classNames;
        case Zt.Error:
          return p.error.classNames;
        default:
          return "";
      }
    }
    s.className = e;
  })(Nk || (Nk = {}));
  Vt((s, e) => {
    const t = s.getColor(OU);
    if (t) {
      const o = p.error.cssSelector;
      e.addRule(`
			.monaco-editor .zone-widget ${o},
			.markers-panel .marker-icon${o},
			.text-search-provider-messages .providerMessage ${o},
			.extensions-viewlet > .extensions ${o} {
				color: ${t};
			}
		`);
    }
    const i = s.getColor(PU);
    if (i) {
      const o = p.warning.cssSelector;
      e.addRule(`
			.monaco-editor .zone-widget ${o},
			.markers-panel .marker-icon${o},
			.extensions-viewlet > .extensions ${o},
			.extension-editor ${o},
			.text-search-provider-messages .providerMessage ${o},
			.preferences-editor ${o} {
				color: ${i};
			}
		`);
    }
    const n = s.getColor(FU);
    if (n) {
      const o = p.info.cssSelector;
      e.addRule(`
			.monaco-editor .zone-widget ${o},
			.markers-panel .marker-icon${o},
			.extensions-viewlet > .extensions ${o},
			.text-search-provider-messages .providerMessage ${o},
			.extension-editor ${o} {
				color: ${n};
			}
		`);
    }
  });
  var Pee = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, ou = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class Fee {
    constructor(e, t, i, n, o) {
      this._openerService = n, this._labelService = o, this._lines = 0, this._longestLineLength = 0, this._relatedDiagnostics = /* @__PURE__ */ new WeakMap(), this._disposables = new te(), this._editor = t;
      const r = document.createElement("div");
      r.className = "descriptioncontainer", this._messageBlock = document.createElement("div"), this._messageBlock.classList.add("message"), this._messageBlock.setAttribute("aria-live", "assertive"), this._messageBlock.setAttribute("role", "alert"), r.appendChild(this._messageBlock), this._relatedBlock = document.createElement("div"), r.appendChild(this._relatedBlock), this._disposables.add(on(this._relatedBlock, "click", (a) => {
        a.preventDefault();
        const l = this._relatedDiagnostics.get(a.target);
        l && i(l);
      })), this._scrollable = new X5(r, {
        horizontal: 1,
        vertical: 1,
        useShadows: !1,
        horizontalScrollbarSize: 6,
        verticalScrollbarSize: 6
      }), e.appendChild(this._scrollable.getDomNode()), this._disposables.add(this._scrollable.onScroll((a) => {
        r.style.left = `-${a.scrollLeft}px`, r.style.top = `-${a.scrollTop}px`;
      })), this._disposables.add(this._scrollable);
    }
    dispose() {
      at(this._disposables);
    }
    update(e) {
      const { source: t, message: i, relatedInformation: n, code: o } = e;
      let r = (t?.length || 0) + 2;
      o && (typeof o == "string" ? r += o.length : r += o.value.length);
      const a = da(i);
      this._lines = a.length, this._longestLineLength = 0;
      for (const u of a)
        this._longestLineLength = Math.max(u.length + r, this._longestLineLength);
      Bi(this._messageBlock), this._messageBlock.setAttribute("aria-label", this.getAriaLabel(e)), this._editor.applyFontInfo(this._messageBlock);
      let l = this._messageBlock;
      for (const u of a)
        l = document.createElement("div"), l.innerText = u, u === "" && (l.style.height = this._messageBlock.style.lineHeight), this._messageBlock.appendChild(l);
      if (t || o) {
        const u = document.createElement("span");
        if (u.classList.add("details"), l.appendChild(u), t) {
          const f = document.createElement("span");
          f.innerText = t, f.classList.add("source"), u.appendChild(f);
        }
        if (o)
          if (typeof o == "string") {
            const f = document.createElement("span");
            f.innerText = `(${o})`, f.classList.add("code"), u.appendChild(f);
          } else {
            this._codeLink = J("a.code-link"), this._codeLink.setAttribute("href", `${o.target.toString()}`), this._codeLink.onclick = (g) => {
              this._openerService.open(o.target, { allowCommands: !0 }), g.preventDefault(), g.stopPropagation();
            };
            const f = q(this._codeLink, J("span"));
            f.innerText = o.value, u.appendChild(this._codeLink);
          }
      }
      if (Bi(this._relatedBlock), this._editor.applyFontInfo(this._relatedBlock), Ds(n)) {
        const u = this._relatedBlock.appendChild(document.createElement("div"));
        u.style.paddingTop = `${Math.floor(this._editor.getOption(59) * 0.66)}px`, this._lines += 1;
        for (const f of n) {
          let g = document.createElement("div"), _ = document.createElement("a");
          _.classList.add("filename"), _.innerText = `${q3(f.resource)}(${f.startLineNumber}, ${f.startColumn}): `, _.title = this._labelService.getUriLabel(f.resource), this._relatedDiagnostics.set(_, f);
          let b = document.createElement("span");
          b.innerText = f.message, g.appendChild(_), g.appendChild(b), this._lines += 1, u.appendChild(g);
        }
      }
      const c = this._editor.getOption(44), d = Math.ceil(c.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75), h = c.lineHeight * this._lines;
      this._scrollable.setScrollDimensions({ scrollWidth: d, scrollHeight: h });
    }
    layout(e, t) {
      this._scrollable.getDomNode().style.height = `${e}px`, this._scrollable.getDomNode().style.width = `${t}px`, this._scrollable.setScrollDimensions({ width: t, height: e });
    }
    getHeightInLines() {
      return Math.min(17, this._lines);
    }
    getAriaLabel(e) {
      let t = "";
      switch (e.severity) {
        case Xt.Error:
          t = m("Error", "Error");
          break;
        case Xt.Warning:
          t = m("Warning", "Warning");
          break;
        case Xt.Info:
          t = m("Info", "Info");
          break;
        case Xt.Hint:
          t = m("Hint", "Hint");
          break;
      }
      let i = m("marker aria", "{0} at {1}. ", t, e.startLineNumber + ":" + e.startColumn);
      const n = this._editor.getModel();
      return n && e.startLineNumber <= n.getLineCount() && e.startLineNumber >= 1 && (i = `${n.getLineContent(e.startLineNumber)}, ${i}`), i;
    }
  }
  let Tf = class W7 extends M1 {
    constructor(e, t, i, n, o, r, a) {
      super(e, { showArrow: !0, showFrame: !0, isAccessible: !0, frameWidth: 1 }, o), this._themeService = t, this._openerService = i, this._menuService = n, this._contextKeyService = r, this._labelService = a, this._callOnDispose = new te(), this._onDidSelectRelatedInformation = new B(), this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event, this._severity = Xt.Warning, this._backgroundColor = H.white, this._applyTheme(t.getColorTheme()), this._callOnDispose.add(t.onDidColorThemeChange(this._applyTheme.bind(this))), this.create();
    }
    _applyTheme(e) {
      this._backgroundColor = e.getColor(Hee);
      let t = Tk, i = Bee;
      this._severity === Xt.Warning ? (t = Mk, i = Wee) : this._severity === Xt.Info && (t = Ak, i = Vee);
      const n = e.getColor(t), o = e.getColor(i);
      this.style({
        arrowColor: n,
        frameColor: n,
        headerBackgroundColor: o,
        primaryHeadingColor: e.getColor(L3),
        secondaryHeadingColor: e.getColor(k3)
      });
    }
    _applyStyles() {
      this._parentContainer && (this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : ""), super._applyStyles();
    }
    dispose() {
      this._callOnDispose.dispose(), super.dispose();
    }
    _fillHead(e) {
      super._fillHead(e), this._disposables.add(this._actionbarWidget.actionRunner.onBeforeRun((n) => this.editor.focus()));
      const t = [], i = this._menuService.createMenu(W7.TitleMenu, this._contextKeyService);
      FX(i, void 0, t), this._actionbarWidget.push(t, { label: !1, icon: !0, index: 0 }), i.dispose();
    }
    _fillTitleIcon(e) {
      this._icon = q(e, J(""));
    }
    _fillBody(e) {
      this._parentContainer = e, e.classList.add("marker-widget"), this._parentContainer.tabIndex = 0, this._parentContainer.setAttribute("role", "tooltip"), this._container = document.createElement("div"), e.appendChild(this._container), this._message = new Fee(this._container, this.editor, (t) => this._onDidSelectRelatedInformation.fire(t), this._openerService, this._labelService), this._disposables.add(this._message);
    }
    show() {
      throw new Error("call showAtMarker");
    }
    showAtMarker(e, t, i) {
      this._container.classList.remove("stale"), this._message.update(e), this._severity = e.severity, this._applyTheme(this._themeService.getColorTheme());
      let n = D.lift(e);
      const o = this.editor.getPosition();
      let r = o && n.containsPosition(o) ? o : n.getStartPosition();
      super.show(r, this.computeRequiredHeight());
      const a = this.editor.getModel();
      if (a) {
        const l = i > 1 ? m("problems", "{0} of {1} problems", t, i) : m("change", "{0} of {1} problem", t, i);
        this.setTitle(ko(a.uri), l);
      }
      this._icon.className = `codicon ${Nk.className(Xt.toSeverity(this._severity))}`, this.editor.revealPositionNearTop(r, 0), this.editor.focus();
    }
    updateMarker(e) {
      this._container.classList.remove("stale"), this._message.update(e);
    }
    showStale() {
      this._container.classList.add("stale"), this._relayout();
    }
    _doLayoutBody(e, t) {
      super._doLayoutBody(e, t), this._heightInPixel = e, this._message.layout(e, t), this._container.style.height = `${e}px`;
    }
    _onWidth(e) {
      this._message.layout(this._heightInPixel, e);
    }
    _relayout() {
      super._relayout(this.computeRequiredHeight());
    }
    computeRequiredHeight() {
      return 3 + this._message.getHeightInLines();
    }
  };
  Tf.TitleMenu = new A("gotoErrorTitleMenu");
  Tf = Pee([
    ou(1, jt),
    ou(2, No),
    ou(3, Eh),
    ou(4, et),
    ou(5, Fe),
    ou(6, w_)
  ], Tf);
  let xA = qm(ic, L5), IA = qm(Ko, Jv), EA = qm(Zs, JI);
  const Tk = M("editorMarkerNavigationError.background", { dark: xA, light: xA, hc: qt }, m("editorMarkerNavigationError", "Editor marker navigation widget error color.")), Bee = M("editorMarkerNavigationError.headerBackground", { dark: Re(Tk, 0.1), light: Re(Tk, 0.1), hc: null }, m("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background.")), Mk = M("editorMarkerNavigationWarning.background", { dark: IA, light: IA, hc: qt }, m("editorMarkerNavigationWarning", "Editor marker navigation widget warning color.")), Wee = M("editorMarkerNavigationWarning.headerBackground", { dark: Re(Mk, 0.1), light: Re(Mk, 0.1), hc: "#0C141F" }, m("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background.")), Ak = M("editorMarkerNavigationInfo.background", { dark: EA, light: EA, hc: qt }, m("editorMarkerNavigationInfo", "Editor marker navigation widget info color.")), Vee = M("editorMarkerNavigationInfo.headerBackground", { dark: Re(Ak, 0.1), light: Re(Ak, 0.1), hc: null }, m("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background.")), Hee = M("editorMarkerNavigation.background", { dark: cs, light: cs, hc: cs }, m("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
  var zee = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, wb = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, V7 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Tc = class w0 {
    constructor(e, t, i, n, o) {
      this._markerNavigationService = t, this._contextKeyService = i, this._editorService = n, this._instantiationService = o, this._sessionDispoables = new te(), this._editor = e, this._widgetVisible = H7.bindTo(this._contextKeyService);
    }
    static get(e) {
      return e.getContribution(w0.ID);
    }
    dispose() {
      this._cleanUp(), this._sessionDispoables.dispose();
    }
    _cleanUp() {
      this._widgetVisible.reset(), this._sessionDispoables.clear(), this._widget = void 0, this._model = void 0;
    }
    _getOrCreateModel(e) {
      if (this._model && this._model.matches(e))
        return this._model;
      let t = !1;
      return this._model && (t = !0, this._cleanUp()), this._model = this._markerNavigationService.getMarkerList(e), t && this._model.move(!0, this._editor.getModel(), this._editor.getPosition()), this._widget = this._instantiationService.createInstance(Tf, this._editor), this._widget.onDidClose(() => this.close(), this, this._sessionDispoables), this._widgetVisible.set(!0), this._sessionDispoables.add(this._model), this._sessionDispoables.add(this._widget), this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((i) => {
        var n, o, r;
        (!(!((n = this._model) === null || n === void 0) && n.selected) || !D.containsPosition((o = this._model) === null || o === void 0 ? void 0 : o.selected.marker, i.position)) && ((r = this._model) === null || r === void 0 || r.resetIndex());
      })), this._sessionDispoables.add(this._model.onDidChange(() => {
        if (!this._widget || !this._widget.position || !this._model)
          return;
        const i = this._model.find(this._editor.getModel().uri, this._widget.position);
        i ? this._widget.updateMarker(i.marker) : this._widget.showStale();
      })), this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((i) => {
        this._editorService.openCodeEditor({
          resource: i.resource,
          options: { pinned: !0, revealIfOpened: !0, selection: D.lift(i).collapseToStart() }
        }, this._editor), this.close(!1);
      })), this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp())), this._model;
    }
    close(e = !0) {
      this._cleanUp(), e && this._editor.focus();
    }
    showAtMarker(e) {
      if (this._editor.hasModel()) {
        const t = this._getOrCreateModel(this._editor.getModel().uri);
        t.resetIndex(), t.move(!0, this._editor.getModel(), new V(e.startLineNumber, e.startColumn)), t.selected && this._widget.showAtMarker(t.selected.marker, t.selected.index, t.selected.total);
      }
    }
    nagivate(e, t) {
      var i, n;
      return V7(this, void 0, void 0, function* () {
        if (this._editor.hasModel()) {
          const o = this._getOrCreateModel(t ? void 0 : this._editor.getModel().uri);
          if (o.move(e, this._editor.getModel(), this._editor.getPosition()), !o.selected)
            return;
          if (o.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
            this._cleanUp();
            const r = yield this._editorService.openCodeEditor({
              resource: o.selected.marker.resource,
              options: { pinned: !1, revealIfOpened: !0, selectionRevealType: 2, selection: o.selected.marker }
            }, this._editor);
            r && ((i = w0.get(r)) === null || i === void 0 || i.close(), (n = w0.get(r)) === null || n === void 0 || n.nagivate(e, t));
          } else
            this._widget.showAtMarker(o.selected.marker, o.selected.index, o.selected.total);
        }
      });
    }
  };
  Tc.ID = "editor.contrib.markerController";
  Tc = zee([
    wb(1, B7),
    wb(2, Fe),
    wb(3, St),
    wb(4, et)
  ], Tc);
  class HC extends ge {
    constructor(e, t, i) {
      super(i), this._next = e, this._multiFile = t;
    }
    run(e, t) {
      var i;
      return V7(this, void 0, void 0, function* () {
        t.hasModel() && ((i = Tc.get(t)) === null || i === void 0 || i.nagivate(this._next, this._multiFile));
      });
    }
  }
  class cc extends HC {
    constructor() {
      super(!0, !1, {
        id: cc.ID,
        label: cc.LABEL,
        alias: "Go to Next Problem (Error, Warning, Info)",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 578,
          weight: 100
        },
        menuOpts: {
          menuId: Tf.TitleMenu,
          title: cc.LABEL,
          icon: Vi("marker-navigation-next", p.arrowDown, m("nextMarkerIcon", "Icon for goto next marker.")),
          group: "navigation",
          order: 1
        }
      });
    }
  }
  cc.ID = "editor.action.marker.next";
  cc.LABEL = m("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
  class Bd extends HC {
    constructor() {
      super(!1, !1, {
        id: Bd.ID,
        label: Bd.LABEL,
        alias: "Go to Previous Problem (Error, Warning, Info)",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 1602,
          weight: 100
        },
        menuOpts: {
          menuId: Tf.TitleMenu,
          title: Bd.LABEL,
          icon: Vi("marker-navigation-previous", p.arrowUp, m("previousMarkerIcon", "Icon for goto previous marker.")),
          group: "navigation",
          order: 2
        }
      });
    }
  }
  Bd.ID = "editor.action.marker.prev";
  Bd.LABEL = m("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
  class Uee extends HC {
    constructor() {
      super(!0, !0, {
        id: "editor.action.marker.nextInFiles",
        label: m("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
        alias: "Go to Next Problem in Files (Error, Warning, Info)",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 66,
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarGoMenu,
          title: m({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
          group: "6_problem_nav",
          order: 1
        }
      });
    }
  }
  class $ee extends HC {
    constructor() {
      super(!1, !0, {
        id: "editor.action.marker.prevInFiles",
        label: m("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
        alias: "Go to Previous Problem in Files (Error, Warning, Info)",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 1090,
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarGoMenu,
          title: m({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
          group: "6_problem_nav",
          order: 2
        }
      });
    }
  }
  vt(Tc.ID, Tc);
  oe(cc);
  oe(Bd);
  oe(Uee);
  oe($ee);
  const H7 = new ue("markersNavigationVisible", !1), jee = wn.bindToContribution(Tc.get);
  se(new jee({
    id: "closeMarkersNavigation",
    precondition: H7,
    handler: (s) => s.close(),
    kbOpts: {
      weight: 100 + 50,
      kbExpr: T.focus,
      primary: 9,
      secondary: [1033]
    }
  }));
  var Kee = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, ty = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Po = J;
  class qee {
    constructor(e, t, i) {
      this.owner = e, this.range = t, this.marker = i;
    }
    isValidForHoverAnchor(e) {
      return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
    }
  }
  const NA = {
    type: 1,
    filter: { include: it.QuickFix }
  };
  let Rk = class {
    constructor(e, t, i, n) {
      this._editor = e, this._markerDecorationsService = t, this._openerService = i, this._languageFeaturesService = n, this.hoverOrdinal = 5, this.recentMarkerCodeActionsInfo = void 0;
    }
    computeSync(e, t) {
      if (!this._editor.hasModel() || e.type !== 1)
        return [];
      const i = this._editor.getModel(), n = e.range.startLineNumber, o = i.getLineMaxColumn(n), r = [];
      for (const a of t) {
        const l = a.range.startLineNumber === n ? a.range.startColumn : 1, c = a.range.endLineNumber === n ? a.range.endColumn : o, d = this._markerDecorationsService.getMarker(i.uri, a);
        if (!d)
          continue;
        const h = new D(e.range.startLineNumber, l, e.range.startLineNumber, c);
        r.push(new qee(this, h, d));
      }
      return r;
    }
    renderHoverParts(e, t) {
      if (!t.length)
        return z.None;
      const i = new te();
      t.forEach((o) => e.fragment.appendChild(this.renderMarkerHover(o, i)));
      const n = t.length === 1 ? t[0] : t.sort((o, r) => Xt.compare(o.marker.severity, r.marker.severity))[0];
      return this.renderMarkerStatusbar(e, n, i), i;
    }
    renderMarkerHover(e, t) {
      const i = Po("div.hover-row"), n = q(i, Po("div.marker.hover-contents")), { source: o, message: r, code: a, relatedInformation: l } = e.marker;
      this._editor.applyFontInfo(n);
      const c = q(n, Po("span"));
      if (c.style.whiteSpace = "pre-wrap", c.innerText = r, o || a)
        if (a && typeof a != "string") {
          const d = Po("span");
          if (o) {
            const g = q(d, Po("span"));
            g.innerText = o;
          }
          const h = q(d, Po("a.code-link"));
          h.setAttribute("href", a.target.toString()), t.add(ee(h, "click", (g) => {
            this._openerService.open(a.target, { allowCommands: !0 }), g.preventDefault(), g.stopPropagation();
          }));
          const u = q(h, Po("span"));
          u.innerText = a.value;
          const f = q(n, d);
          f.style.opacity = "0.6", f.style.paddingLeft = "6px";
        } else {
          const d = q(n, Po("span"));
          d.style.opacity = "0.6", d.style.paddingLeft = "6px", d.innerText = o && a ? `${o}(${a})` : o || `(${a})`;
        }
      if (Ds(l))
        for (const { message: d, resource: h, startLineNumber: u, startColumn: f } of l) {
          const g = q(n, Po("div"));
          g.style.marginTop = "8px";
          const _ = q(g, Po("a"));
          _.innerText = `${ko(h)}(${u}, ${f}): `, _.style.cursor = "pointer", t.add(ee(_, "click", (C) => {
            C.stopPropagation(), C.preventDefault(), this._openerService && this._openerService.open(h, {
              fromUserGesture: !0,
              editorOptions: { selection: { startLineNumber: u, startColumn: f } }
            }).catch(We);
          }));
          const b = q(g, Po("span"));
          b.innerText = d, this._editor.applyFontInfo(b);
        }
      return i;
    }
    renderMarkerStatusbar(e, t, i) {
      if ((t.marker.severity === Xt.Error || t.marker.severity === Xt.Warning || t.marker.severity === Xt.Info) && e.statusBar.addAction({
        label: m("view problem", "View Problem"),
        commandId: cc.ID,
        run: () => {
          var n;
          e.hide(), (n = Tc.get(this._editor)) === null || n === void 0 || n.showAtMarker(t.marker), this._editor.focus();
        }
      }), !this._editor.getOption(81)) {
        const n = e.statusBar.append(Po("div"));
        this.recentMarkerCodeActionsInfo && (E1.makeKey(this.recentMarkerCodeActionsInfo.marker) === E1.makeKey(t.marker) ? this.recentMarkerCodeActionsInfo.hasCodeActions || (n.textContent = m("noQuickFixes", "No quick fixes available")) : this.recentMarkerCodeActionsInfo = void 0);
        const o = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? z.None : i.add($d(() => n.textContent = m("checkingForQuickFixes", "Checking for quick fixes..."), 200));
        n.textContent || (n.textContent = String.fromCharCode(160));
        const r = this.getCodeActions(t.marker);
        i.add(qe(() => r.cancel())), r.then((a) => {
          if (o.dispose(), this.recentMarkerCodeActionsInfo = { marker: t.marker, hasCodeActions: a.validActions.length > 0 }, !this.recentMarkerCodeActionsInfo.hasCodeActions) {
            a.dispose(), n.textContent = m("noQuickFixes", "No quick fixes available");
            return;
          }
          n.style.display = "none";
          let l = !1;
          i.add(qe(() => {
            l || a.dispose();
          })), e.statusBar.addAction({
            label: m("quick fixes", "Quick Fix..."),
            commandId: lg.Id,
            run: (c) => {
              l = !0;
              const d = nh.get(this._editor), h = mn(c);
              e.hide(), d?.showCodeActions(NA, a, {
                x: h.left + 6,
                y: h.top + h.height + 6
              });
            }
          });
        }, We);
      }
    }
    getCodeActions(e) {
      return an((t) => JE(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new D(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), NA, Bh.None, t));
    }
  };
  Rk = Kee([
    ty(1, GI),
    ty(2, No),
    ty(3, me)
  ], Rk);
  Vt((s, e) => {
    const t = s.getColor(Xv);
    t && e.addRule(`.monaco-hover .hover-contents a.code-link span { color: ${t}; }`);
    const i = s.getColor(Qv);
    i && e.addRule(`.monaco-hover .hover-contents a.code-link span:hover { color: ${i}; }`);
  });
  var Gee = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Sb = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Mc = class z7 {
    constructor(e, t, i, n, o) {
      this._editor = e, this._instantiationService = t, this._openerService = i, this._languageService = n, this._toUnhook = new te(), this._isMouseDown = !1, this._hoverClicked = !1, this._contentWidget = null, this._glyphWidget = null, this._hookEvents(), this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((r) => {
        r.hasChanged(53) && (this._unhookEvents(), this._hookEvents());
      });
    }
    static get(e) {
      return e.getContribution(z7.ID);
    }
    _hookEvents() {
      const e = () => this._hideWidgets(), t = this._editor.getOption(53);
      this._isHoverEnabled = t.enabled, this._isHoverSticky = t.sticky, this._isHoverEnabled ? (this._toUnhook.add(this._editor.onMouseDown((i) => this._onEditorMouseDown(i))), this._toUnhook.add(this._editor.onMouseUp((i) => this._onEditorMouseUp(i))), this._toUnhook.add(this._editor.onMouseMove((i) => this._onEditorMouseMove(i))), this._toUnhook.add(this._editor.onKeyDown((i) => this._onKeyDown(i)))) : (this._toUnhook.add(this._editor.onMouseMove((i) => this._onEditorMouseMove(i))), this._toUnhook.add(this._editor.onKeyDown((i) => this._onKeyDown(i)))), this._toUnhook.add(this._editor.onMouseLeave(e)), this._toUnhook.add(this._editor.onDidChangeModel(e)), this._toUnhook.add(this._editor.onDidScrollChange((i) => this._onEditorScrollChanged(i)));
    }
    _unhookEvents() {
      this._toUnhook.clear();
    }
    _onEditorScrollChanged(e) {
      (e.scrollTopChanged || e.scrollLeftChanged) && this._hideWidgets();
    }
    _onEditorMouseDown(e) {
      this._isMouseDown = !0;
      const t = e.target;
      if (t.type === 9 && t.detail === Fd.ID) {
        this._hoverClicked = !0;
        return;
      }
      t.type === 12 && t.detail === sf.ID || (t.type !== 12 && (this._hoverClicked = !1), this._hideWidgets());
    }
    _onEditorMouseUp(e) {
      this._isMouseDown = !1;
    }
    _onEditorMouseMove(e) {
      var t, i, n, o, r;
      const a = e.target;
      if (this._isMouseDown && this._hoverClicked || this._isHoverSticky && a.type === 9 && a.detail === Fd.ID || this._isHoverSticky && !(!((i = (t = e.event.browserEvent.view) === null || t === void 0 ? void 0 : t.getSelection()) === null || i === void 0) && i.isCollapsed) || !this._isHoverSticky && a.type === 9 && a.detail === Fd.ID && ((n = this._contentWidget) === null || n === void 0 ? void 0 : n.isColorPickerVisible()) || this._isHoverSticky && a.type === 12 && a.detail === sf.ID)
        return;
      if (!this._isHoverEnabled) {
        this._hideWidgets();
        return;
      }
      if (this._getOrCreateContentWidget().maybeShowAt(e)) {
        (o = this._glyphWidget) === null || o === void 0 || o.hide();
        return;
      }
      if (a.type === 2 && a.position) {
        (r = this._contentWidget) === null || r === void 0 || r.hide(), this._glyphWidget || (this._glyphWidget = new sf(this._editor, this._languageService, this._openerService)), this._glyphWidget.startShowingAt(a.position.lineNumber);
        return;
      }
      this._hideWidgets();
    }
    _onKeyDown(e) {
      e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4 && this._hideWidgets();
    }
    _hideWidgets() {
      var e, t, i;
      this._isMouseDown && this._hoverClicked && ((e = this._contentWidget) === null || e === void 0 ? void 0 : e.isColorPickerVisible()) || (this._hoverClicked = !1, (t = this._glyphWidget) === null || t === void 0 || t.hide(), (i = this._contentWidget) === null || i === void 0 || i.hide());
    }
    _getOrCreateContentWidget() {
      return this._contentWidget || (this._contentWidget = this._instantiationService.createInstance(H1, this._editor)), this._contentWidget;
    }
    isColorPickerVisible() {
      var e;
      return ((e = this._contentWidget) === null || e === void 0 ? void 0 : e.isColorPickerVisible()) || !1;
    }
    showContentHover(e, t, i) {
      this._getOrCreateContentWidget().startShowingAtRange(e, t, i);
    }
    dispose() {
      var e, t;
      this._unhookEvents(), this._toUnhook.dispose(), this._didChangeConfigurationHandler.dispose(), (e = this._glyphWidget) === null || e === void 0 || e.dispose(), (t = this._contentWidget) === null || t === void 0 || t.dispose();
    }
  };
  Mc.ID = "editor.contrib.hover";
  Mc = Gee([
    Sb(1, et),
    Sb(2, No),
    Sb(3, Jt),
    Sb(4, Fe)
  ], Mc);
  class Zee extends ge {
    constructor() {
      super({
        id: "editor.action.showHover",
        label: m({
          key: "showHover",
          comment: [
            "Label for action that will trigger the showing of a hover in the editor.",
            "This allows for users to show the hover without using the mouse."
          ]
        }, "Show Hover"),
        alias: "Show Hover",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2087),
          weight: 100
        }
      });
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      let i = Mc.get(t);
      if (!i)
        return;
      const n = t.getPosition(), o = new D(n.lineNumber, n.column, n.lineNumber, n.column), r = t.getOption(2) === 2;
      i.showContentHover(o, 1, r);
    }
  }
  class Yee extends ge {
    constructor() {
      super({
        id: "editor.action.showDefinitionPreviewHover",
        label: m({
          key: "showDefinitionPreviewHover",
          comment: [
            "Label for action that will trigger the showing of definition preview hover in the editor.",
            "This allows for users to show the definition preview hover without using the mouse."
          ]
        }, "Show Definition Preview Hover"),
        alias: "Show Definition Preview Hover",
        precondition: void 0
      });
    }
    run(e, t) {
      const i = Mc.get(t);
      if (!i)
        return;
      const n = t.getPosition();
      if (!n)
        return;
      const o = new D(n.lineNumber, n.column, n.lineNumber, n.column), r = ch.get(t);
      if (!r)
        return;
      r.startFindDefinitionFromCursor(n).then(() => {
        i.showContentHover(o, 1, !0);
      });
    }
  }
  vt(Mc.ID, Mc);
  oe(Zee);
  oe(Yee);
  Kh.register($1);
  Kh.register(Rk);
  Vt((s, e) => {
    const t = s.getColor(Vz);
    t && e.addRule(`.monaco-editor .hoverHighlight { background-color: ${t}; }`);
    const i = s.getColor(Yd);
    i && e.addRule(`.monaco-editor .monaco-hover { background-color: ${i}; }`);
    const n = s.getColor(nE);
    n && (e.addRule(`.monaco-editor .monaco-hover { border: 1px solid ${n}; }`), e.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${n.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${n.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${n.transparent(0.5)}; }`));
    const o = s.getColor(Xv);
    o && e.addRule(`.monaco-editor .monaco-hover a { color: ${o}; }`);
    const r = s.getColor(Qv);
    r && e.addRule(`.monaco-editor .monaco-hover a:hover { color: ${r}; }`);
    const a = s.getColor(iE);
    a && e.addRule(`.monaco-editor .monaco-hover { color: ${a}; }`);
    const l = s.getColor(Hz);
    l && e.addRule(`.monaco-editor .monaco-hover .hover-row .actions { background-color: ${l}; }`);
    const c = s.getColor(g5);
    c && e.addRule(`.monaco-editor .monaco-hover code { background-color: ${c}; }`);
  });
  class Ok extends z {
    constructor(e) {
      super(), this._editor = e, this._register(e.onMouseDown((t) => this.onMouseDown(t)));
    }
    dispose() {
      super.dispose();
    }
    onMouseDown(e) {
      const t = e.target;
      if (t.type !== 6 || !t.detail.injectedText || t.detail.injectedText.options.attachedData !== m3 || !t.range)
        return;
      const i = this._editor.getContribution(Mc.ID);
      if (!!i && !i.isColorPickerVisible()) {
        const n = new D(t.range.startLineNumber, t.range.startColumn + 1, t.range.endLineNumber, t.range.endColumn + 1);
        i.showContentHover(n, 1, !1);
      }
    }
  }
  Ok.ID = "editor.contrib.colorContribution";
  vt(Ok.ID, Ok);
  Kh.register(ZL);
  class li {
    static insert(e, t) {
      return {
        range: new D(e.lineNumber, e.column, e.lineNumber, e.column),
        text: t,
        forceMoveMarkers: !0
      };
    }
    static delete(e) {
      return {
        range: e,
        text: null
      };
    }
    static replace(e, t) {
      return {
        range: e,
        text: t
      };
    }
    static replaceMove(e, t) {
      return {
        range: e,
        text: t,
        forceMoveMarkers: !0
      };
    }
  }
  class Zl {
    constructor(e, t, i) {
      this.languageConfigurationService = i, this._selection = e, this._insertSpace = t, this._usedEndToken = null;
    }
    static _haystackHasNeedleAtOffset(e, t, i) {
      if (i < 0)
        return !1;
      const n = t.length, o = e.length;
      if (i + n > o)
        return !1;
      for (let r = 0; r < n; r++) {
        const a = e.charCodeAt(i + r), l = t.charCodeAt(r);
        if (a !== l && !(a >= 65 && a <= 90 && a + 32 === l) && !(l >= 65 && l <= 90 && l + 32 === a))
          return !1;
      }
      return !0;
    }
    _createOperationsForBlockComment(e, t, i, n, o, r) {
      const a = e.startLineNumber, l = e.startColumn, c = e.endLineNumber, d = e.endColumn, h = o.getLineContent(a), u = o.getLineContent(c);
      let f = h.lastIndexOf(t, l - 1 + t.length), g = u.indexOf(i, d - 1 - i.length);
      if (f !== -1 && g !== -1)
        if (a === c)
          h.substring(f + t.length, g).indexOf(i) >= 0 && (f = -1, g = -1);
        else {
          const b = h.substring(f + t.length), C = u.substring(0, g);
          (b.indexOf(i) >= 0 || C.indexOf(i) >= 0) && (f = -1, g = -1);
        }
      let _;
      f !== -1 && g !== -1 ? (n && f + t.length < h.length && h.charCodeAt(f + t.length) === 32 && (t = t + " "), n && g > 0 && u.charCodeAt(g - 1) === 32 && (i = " " + i, g -= 1), _ = Zl._createRemoveBlockCommentOperations(new D(a, f + t.length + 1, c, g + 1), t, i)) : (_ = Zl._createAddBlockCommentOperations(e, t, i, this._insertSpace), this._usedEndToken = _.length === 1 ? i : null);
      for (const b of _)
        r.addTrackedEditOperation(b.range, b.text);
    }
    static _createRemoveBlockCommentOperations(e, t, i) {
      let n = [];
      return D.isEmpty(e) ? n.push(li.delete(new D(e.startLineNumber, e.startColumn - t.length, e.endLineNumber, e.endColumn + i.length))) : (n.push(li.delete(new D(e.startLineNumber, e.startColumn - t.length, e.startLineNumber, e.startColumn))), n.push(li.delete(new D(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn + i.length)))), n;
    }
    static _createAddBlockCommentOperations(e, t, i, n) {
      let o = [];
      return D.isEmpty(e) ? o.push(li.replace(new D(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), t + "  " + i)) : (o.push(li.insert(new V(e.startLineNumber, e.startColumn), t + (n ? " " : ""))), o.push(li.insert(new V(e.endLineNumber, e.endColumn), (n ? " " : "") + i))), o;
    }
    getEditOperations(e, t) {
      const i = this._selection.startLineNumber, n = this._selection.startColumn;
      e.tokenizeIfCheap(i);
      const o = e.getLanguageIdAtPosition(i, n), r = this.languageConfigurationService.getLanguageConfiguration(o).comments;
      !r || !r.blockCommentStartToken || !r.blockCommentEndToken || this._createOperationsForBlockComment(this._selection, r.blockCommentStartToken, r.blockCommentEndToken, this._insertSpace, e, t);
    }
    computeCursorState(e, t) {
      const i = t.getInverseEditOperations();
      if (i.length === 2) {
        const n = i[0], o = i[1];
        return new ae(n.range.endLineNumber, n.range.endColumn, o.range.startLineNumber, o.range.startColumn);
      } else {
        const n = i[0].range, o = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
        return new ae(n.endLineNumber, n.endColumn + o, n.endLineNumber, n.endColumn + o);
      }
    }
  }
  class $a {
    constructor(e, t, i, n, o, r, a) {
      this.languageConfigurationService = e, this._selection = t, this._tabSize = i, this._type = n, this._insertSpace = o, this._selectionId = null, this._deltaColumn = 0, this._moveEndPositionDown = !1, this._ignoreEmptyLines = r, this._ignoreFirstLine = a || !1;
    }
    static _gatherPreflightCommentStrings(e, t, i, n) {
      e.tokenizeIfCheap(t);
      const o = e.getLanguageIdAtPosition(t, 1), r = n.getLanguageConfiguration(o).comments, a = r ? r.lineCommentToken : null;
      if (!a)
        return null;
      let l = [];
      for (let c = 0, d = i - t + 1; c < d; c++)
        l[c] = {
          ignore: !1,
          commentStr: a,
          commentStrOffset: 0,
          commentStrLength: a.length
        };
      return l;
    }
    static _analyzeLines(e, t, i, n, o, r, a, l) {
      let c = !0, d;
      e === 0 ? d = !0 : e === 1 ? d = !1 : d = !0;
      for (let h = 0, u = n.length; h < u; h++) {
        const f = n[h], g = o + h;
        if (g === o && a) {
          f.ignore = !0;
          continue;
        }
        const _ = i.getLineContent(g), b = jn(_);
        if (b === -1) {
          f.ignore = r, f.commentStrOffset = _.length;
          continue;
        }
        if (c = !1, f.ignore = !1, f.commentStrOffset = b, d && !Zl._haystackHasNeedleAtOffset(_, f.commentStr, b) && (e === 0 ? d = !1 : e === 1 || (f.ignore = !0)), d && t) {
          const C = b + f.commentStrLength;
          C < _.length && _.charCodeAt(C) === 32 && (f.commentStrLength += 1);
        }
      }
      if (e === 0 && c) {
        d = !1;
        for (let h = 0, u = n.length; h < u; h++)
          n[h].ignore = !1;
      }
      return {
        supported: !0,
        shouldRemoveComments: d,
        lines: n
      };
    }
    static _gatherPreflightData(e, t, i, n, o, r, a, l) {
      const c = $a._gatherPreflightCommentStrings(i, n, o, l);
      return c === null ? {
        supported: !1
      } : $a._analyzeLines(e, t, i, c, n, r, a, l);
    }
    _executeLineComments(e, t, i, n) {
      let o;
      i.shouldRemoveComments ? o = $a._createRemoveLineCommentsOperations(i.lines, n.startLineNumber) : ($a._normalizeInsertionPoint(e, i.lines, n.startLineNumber, this._tabSize), o = this._createAddLineCommentsOperations(i.lines, n.startLineNumber));
      const r = new V(n.positionLineNumber, n.positionColumn);
      for (let a = 0, l = o.length; a < l; a++)
        t.addEditOperation(o[a].range, o[a].text), D.isEmpty(o[a].range) && D.getStartPosition(o[a].range).equals(r) && e.getLineContent(r.lineNumber).length + 1 === r.column && (this._deltaColumn = (o[a].text || "").length);
      this._selectionId = t.trackSelection(n);
    }
    _attemptRemoveBlockComment(e, t, i, n) {
      let o = t.startLineNumber, r = t.endLineNumber, a = n.length + Math.max(e.getLineFirstNonWhitespaceColumn(t.startLineNumber), t.startColumn), l = e.getLineContent(o).lastIndexOf(i, a - 1), c = e.getLineContent(r).indexOf(n, t.endColumn - 1 - i.length);
      return l !== -1 && c === -1 && (c = e.getLineContent(o).indexOf(n, l + i.length), r = o), l === -1 && c !== -1 && (l = e.getLineContent(r).lastIndexOf(i, c), o = r), t.isEmpty() && (l === -1 || c === -1) && (l = e.getLineContent(o).indexOf(i), l !== -1 && (c = e.getLineContent(o).indexOf(n, l + i.length))), l !== -1 && e.getLineContent(o).charCodeAt(l + i.length) === 32 && (i += " "), c !== -1 && e.getLineContent(r).charCodeAt(c - 1) === 32 && (n = " " + n, c -= 1), l !== -1 && c !== -1 ? Zl._createRemoveBlockCommentOperations(new D(o, l + i.length + 1, r, c + 1), i, n) : null;
    }
    _executeBlockComment(e, t, i) {
      e.tokenizeIfCheap(i.startLineNumber);
      let n = e.getLanguageIdAtPosition(i.startLineNumber, 1), o = Di.getComments(n);
      if (!o || !o.blockCommentStartToken || !o.blockCommentEndToken)
        return;
      const r = o.blockCommentStartToken, a = o.blockCommentEndToken;
      let l = this._attemptRemoveBlockComment(e, i, r, a);
      if (!l) {
        if (i.isEmpty()) {
          const c = e.getLineContent(i.startLineNumber);
          let d = jn(c);
          d === -1 && (d = c.length), l = Zl._createAddBlockCommentOperations(new D(i.startLineNumber, d + 1, i.startLineNumber, c.length + 1), r, a, this._insertSpace);
        } else
          l = Zl._createAddBlockCommentOperations(new D(i.startLineNumber, e.getLineFirstNonWhitespaceColumn(i.startLineNumber), i.endLineNumber, e.getLineMaxColumn(i.endLineNumber)), r, a, this._insertSpace);
        l.length === 1 && (this._deltaColumn = r.length + 1);
      }
      this._selectionId = t.trackSelection(i);
      for (const c of l)
        t.addEditOperation(c.range, c.text);
    }
    getEditOperations(e, t) {
      let i = this._selection;
      if (this._moveEndPositionDown = !1, i.startLineNumber === i.endLineNumber && this._ignoreFirstLine) {
        t.addEditOperation(new D(i.startLineNumber, e.getLineMaxColumn(i.startLineNumber), i.startLineNumber + 1, 1), i.startLineNumber === e.getLineCount() ? "" : `
`), this._selectionId = t.trackSelection(i);
        return;
      }
      i.startLineNumber < i.endLineNumber && i.endColumn === 1 && (this._moveEndPositionDown = !0, i = i.setEndPosition(i.endLineNumber - 1, e.getLineMaxColumn(i.endLineNumber - 1)));
      const n = $a._gatherPreflightData(this._type, this._insertSpace, e, i.startLineNumber, i.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
      return n.supported ? this._executeLineComments(e, t, n, i) : this._executeBlockComment(e, t, i);
    }
    computeCursorState(e, t) {
      let i = t.getTrackedSelection(this._selectionId);
      return this._moveEndPositionDown && (i = i.setEndPosition(i.endLineNumber + 1, 1)), new ae(i.selectionStartLineNumber, i.selectionStartColumn + this._deltaColumn, i.positionLineNumber, i.positionColumn + this._deltaColumn);
    }
    static _createRemoveLineCommentsOperations(e, t) {
      let i = [];
      for (let n = 0, o = e.length; n < o; n++) {
        const r = e[n];
        r.ignore || i.push(li.delete(new D(t + n, r.commentStrOffset + 1, t + n, r.commentStrOffset + r.commentStrLength + 1)));
      }
      return i;
    }
    _createAddLineCommentsOperations(e, t) {
      let i = [];
      const n = this._insertSpace ? " " : "";
      for (let o = 0, r = e.length; o < r; o++) {
        const a = e[o];
        a.ignore || i.push(li.insert(new V(t + o, a.commentStrOffset + 1), a.commentStr + n));
      }
      return i;
    }
    static nextVisibleColumn(e, t, i, n) {
      return i ? e + (t - e % t) : e + n;
    }
    static _normalizeInsertionPoint(e, t, i, n) {
      let o = 1073741824, r, a;
      for (let l = 0, c = t.length; l < c; l++) {
        if (t[l].ignore)
          continue;
        const d = e.getLineContent(i + l);
        let h = 0;
        for (let u = 0, f = t[l].commentStrOffset; h < o && u < f; u++)
          h = $a.nextVisibleColumn(h, n, d.charCodeAt(u) === 9, 1);
        h < o && (o = h);
      }
      o = Math.floor(o / n) * n;
      for (let l = 0, c = t.length; l < c; l++) {
        if (t[l].ignore)
          continue;
        const d = e.getLineContent(i + l);
        let h = 0;
        for (r = 0, a = t[l].commentStrOffset; h < o && r < a; r++)
          h = $a.nextVisibleColumn(h, n, d.charCodeAt(r) === 9, 1);
        h > o ? t[l].commentStrOffset = r - 1 : t[l].commentStrOffset = r;
      }
    }
  }
  class TN extends ge {
    constructor(e, t) {
      super(t), this._type = e;
    }
    run(e, t) {
      const i = e.get(Mn);
      if (!t.hasModel())
        return;
      const n = t.getModel(), o = [], r = n.getOptions(), a = t.getOption(19), l = t.getSelections().map((d, h) => ({ selection: d, index: h, ignoreFirstLine: !1 }));
      l.sort((d, h) => D.compareRangesUsingStarts(d.selection, h.selection));
      let c = l[0];
      for (let d = 1; d < l.length; d++) {
        const h = l[d];
        c.selection.endLineNumber === h.selection.startLineNumber && (c.index < h.index ? h.ignoreFirstLine = !0 : (c.ignoreFirstLine = !0, c = h));
      }
      for (const d of l)
        o.push(new $a(i, d.selection, r.tabSize, this._type, a.insertSpace, a.ignoreEmptyLines, d.ignoreFirstLine));
      t.pushUndoStop(), t.executeCommands(this.id, o), t.pushUndoStop();
    }
  }
  class Xee extends TN {
    constructor() {
      super(0, {
        id: "editor.action.commentLine",
        label: m("comment.line", "Toggle Line Comment"),
        alias: "Toggle Line Comment",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2133,
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarEditMenu,
          group: "5_insert",
          title: m({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
          order: 1
        }
      });
    }
  }
  class Qee extends TN {
    constructor() {
      super(1, {
        id: "editor.action.addCommentLine",
        label: m("comment.line.add", "Add Line Comment"),
        alias: "Add Line Comment",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2081),
          weight: 100
        }
      });
    }
  }
  class Jee extends TN {
    constructor() {
      super(2, {
        id: "editor.action.removeCommentLine",
        label: m("comment.line.remove", "Remove Line Comment"),
        alias: "Remove Line Comment",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2099),
          weight: 100
        }
      });
    }
  }
  class ete extends ge {
    constructor() {
      super({
        id: "editor.action.blockComment",
        label: m("comment.block", "Toggle Block Comment"),
        alias: "Toggle Block Comment",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1567,
          linux: { primary: 3103 },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarEditMenu,
          group: "5_insert",
          title: m({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
          order: 2
        }
      });
    }
    run(e, t) {
      const i = e.get(Mn);
      if (!t.hasModel())
        return;
      const n = t.getOption(19), o = [], r = t.getSelections();
      for (const a of r)
        o.push(new Zl(a, n.insertSpace, i));
      t.pushUndoStop(), t.executeCommands(this.id, o), t.pushUndoStop();
    }
  }
  oe(Xee);
  oe(Qee);
  oe(Jee);
  oe(ete);
  var tte = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Mg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Mf = class U7 {
    constructor(e, t, i, n, o, r) {
      this._contextMenuService = t, this._contextViewService = i, this._contextKeyService = n, this._keybindingService = o, this._menuService = r, this._toDispose = new te(), this._contextMenuIsBeingShownCount = 0, this._editor = e, this._toDispose.add(this._editor.onContextMenu((a) => this._onContextMenu(a))), this._toDispose.add(this._editor.onMouseWheel((a) => {
        if (this._contextMenuIsBeingShownCount > 0) {
          const l = this._contextViewService.getContextViewElement(), c = a.srcElement;
          c.shadowRoot && mc(l) === c.shadowRoot || this._contextViewService.hideContextView();
        }
      })), this._toDispose.add(this._editor.onKeyDown((a) => {
        a.keyCode === 58 && (a.preventDefault(), a.stopPropagation(), this.showContextMenu());
      }));
    }
    static get(e) {
      return e.getContribution(U7.ID);
    }
    _onContextMenu(e) {
      if (!this._editor.hasModel())
        return;
      if (!this._editor.getOption(20)) {
        this._editor.focus(), e.target.position && !this._editor.getSelection().containsPosition(e.target.position) && this._editor.setPosition(e.target.position);
        return;
      }
      if (e.target.type === 12 || e.target.type === 6 && e.target.detail.injectedText || (e.event.preventDefault(), e.event.stopPropagation(), e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1))
        return;
      if (this._editor.focus(), e.target.position) {
        let i = !1;
        for (const n of this._editor.getSelections())
          if (n.containsPosition(e.target.position)) {
            i = !0;
            break;
          }
        i || this._editor.setPosition(e.target.position);
      }
      let t = null;
      e.target.type !== 1 && (t = { x: e.event.posx - 1, width: 2, y: e.event.posy - 1, height: 2 }), this.showContextMenu(t);
    }
    showContextMenu(e) {
      if (!this._editor.getOption(20) || !this._editor.hasModel())
        return;
      if (!this._contextMenuService) {
        this._editor.focus();
        return;
      }
      const t = this._getMenuActions(this._editor.getModel(), this._editor.isSimpleWidget ? A.SimpleEditorContext : A.EditorContext);
      t.length > 0 && this._doShowContextMenu(t, e);
    }
    _getMenuActions(e, t) {
      const i = [], n = this._menuService.createMenu(t, this._contextKeyService), o = n.getActions({ arg: e.uri });
      n.dispose();
      for (let r of o) {
        const [, a] = r;
        let l = 0;
        for (const c of a)
          if (c instanceof VI) {
            const d = this._getMenuActions(e, c.item.submenu);
            d.length > 0 && (i.push(new Tv(c.id, c.label, d)), l++);
          } else
            i.push(c), l++;
        l && i.push(new mo());
      }
      return i.length && i.pop(), i;
    }
    _doShowContextMenu(e, t = null) {
      if (!this._editor.hasModel())
        return;
      const i = this._editor.getOption(53);
      if (this._editor.updateOptions({
        hover: {
          enabled: !1
        }
      }), !t) {
        this._editor.revealPosition(this._editor.getPosition(), 1), this._editor.render();
        const o = this._editor.getScrolledVisiblePosition(this._editor.getPosition()), r = mn(this._editor.getDomNode()), a = r.left + o.left, l = r.top + o.top + o.height;
        t = { x: a, y: l };
      }
      const n = this._editor.getOption(115) && !aa;
      this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu({
        domForShadowRoot: n ? this._editor.getDomNode() : void 0,
        getAnchor: () => t,
        getActions: () => e,
        getActionViewItem: (o) => {
          const r = this._keybindingFor(o);
          if (r)
            return new up(o, o, { label: !0, keybinding: r.getLabel(), isMenu: !0 });
          const a = o;
          return typeof a.getActionViewItem == "function" ? a.getActionViewItem() : new up(o, o, { icon: !0, label: !0, isMenu: !0 });
        },
        getKeyBinding: (o) => this._keybindingFor(o),
        onHide: (o) => {
          this._contextMenuIsBeingShownCount--, this._editor.focus(), this._editor.updateOptions({
            hover: i
          });
        }
      });
    }
    _keybindingFor(e) {
      return this._keybindingService.lookupKeybinding(e.id);
    }
    dispose() {
      this._contextMenuIsBeingShownCount > 0 && this._contextViewService.hideContextView(), this._toDispose.dispose();
    }
  };
  Mf.ID = "editor.contrib.contextmenu";
  Mf = tte([
    Mg(1, Fc),
    Mg(2, m_),
    Mg(3, Fe),
    Mg(4, ci),
    Mg(5, Eh)
  ], Mf);
  class ite extends ge {
    constructor() {
      super({
        id: "editor.action.showContextMenu",
        label: m("action.showContextMenu.label", "Show Editor Context Menu"),
        alias: "Show Editor Context Menu",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 1092,
          weight: 100
        }
      });
    }
    run(e, t) {
      var i;
      (i = Mf.get(t)) === null || i === void 0 || i.showContextMenu();
    }
  }
  vt(Mf.ID, Mf);
  oe(ite);
  class iy {
    constructor(e) {
      this.selections = e;
    }
    equals(e) {
      const t = this.selections.length, i = e.selections.length;
      if (t !== i)
        return !1;
      for (let n = 0; n < t; n++)
        if (!this.selections[n].equalsSelection(e.selections[n]))
          return !1;
      return !0;
    }
  }
  class ny {
    constructor(e, t, i) {
      this.cursorState = e, this.scrollTop = t, this.scrollLeft = i;
    }
  }
  class dh extends z {
    constructor(e) {
      super(), this._editor = e, this._isCursorUndoRedo = !1, this._undoStack = [], this._redoStack = [], this._register(e.onDidChangeModel((t) => {
        this._undoStack = [], this._redoStack = [];
      })), this._register(e.onDidChangeModelContent((t) => {
        this._undoStack = [], this._redoStack = [];
      })), this._register(e.onDidChangeCursorSelection((t) => {
        if (this._isCursorUndoRedo || !t.oldSelections || t.oldModelVersionId !== t.modelVersionId)
          return;
        const i = new iy(t.oldSelections);
        this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(i) || (this._undoStack.push(new ny(i, e.getScrollTop(), e.getScrollLeft())), this._redoStack = [], this._undoStack.length > 50 && this._undoStack.shift());
      }));
    }
    static get(e) {
      return e.getContribution(dh.ID);
    }
    cursorUndo() {
      !this._editor.hasModel() || this._undoStack.length === 0 || (this._redoStack.push(new ny(new iy(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft())), this._applyState(this._undoStack.pop()));
    }
    cursorRedo() {
      !this._editor.hasModel() || this._redoStack.length === 0 || (this._undoStack.push(new ny(new iy(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft())), this._applyState(this._redoStack.pop()));
    }
    _applyState(e) {
      this._isCursorUndoRedo = !0, this._editor.setSelections(e.cursorState.selections), this._editor.setScrollPosition({
        scrollTop: e.scrollTop,
        scrollLeft: e.scrollLeft
      }), this._isCursorUndoRedo = !1;
    }
  }
  dh.ID = "editor.contrib.cursorUndoRedoController";
  class nte extends ge {
    constructor() {
      super({
        id: "cursorUndo",
        label: m("cursor.undo", "Cursor Undo"),
        alias: "Cursor Undo",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 2099,
          weight: 100
        }
      });
    }
    run(e, t, i) {
      var n;
      (n = dh.get(t)) === null || n === void 0 || n.cursorUndo();
    }
  }
  class ste extends ge {
    constructor() {
      super({
        id: "cursorRedo",
        label: m("cursor.redo", "Cursor Redo"),
        alias: "Cursor Redo",
        precondition: void 0
      });
    }
    run(e, t, i) {
      var n;
      (n = dh.get(t)) === null || n === void 0 || n.cursorRedo();
    }
  }
  vt(dh.ID, dh);
  oe(nte);
  oe(ste);
  class ote {
    constructor(e, t, i) {
      this.selection = e, this.targetPosition = t, this.copy = i, this.targetSelection = null;
    }
    getEditOperations(e, t) {
      let i = e.getValueInRange(this.selection);
      if (this.copy || t.addEditOperation(this.selection, null), t.addEditOperation(new D(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), i), this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
        this.targetSelection = this.selection;
        return;
      }
      if (this.copy) {
        this.targetSelection = new ae(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
        return;
      }
      if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
        this.targetSelection = new ae(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
        return;
      }
      if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
        this.targetSelection = new ae(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
        return;
      }
      this.selection.endColumn <= this.targetPosition.column ? this.targetSelection = new ae(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn) : this.targetSelection = new ae(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
    }
    computeCursorState(e, t) {
      return this.targetSelection;
    }
  }
  function ru(s) {
    return Ye ? s.altKey : s.ctrlKey;
  }
  class hl extends z {
    constructor(e) {
      super(), this._editor = e, this._register(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._register(this._editor.onMouseUp((t) => this._onEditorMouseUp(t))), this._register(this._editor.onMouseDrag((t) => this._onEditorMouseDrag(t))), this._register(this._editor.onMouseDrop((t) => this._onEditorMouseDrop(t))), this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled())), this._register(this._editor.onKeyDown((t) => this.onEditorKeyDown(t))), this._register(this._editor.onKeyUp((t) => this.onEditorKeyUp(t))), this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur())), this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur())), this._dndDecorationIds = [], this._mouseDown = !1, this._modifierPressed = !1, this._dragSelection = null;
    }
    onEditorBlur() {
      this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1, this._modifierPressed = !1;
    }
    onEditorKeyDown(e) {
      !this._editor.getOption(31) || this._editor.getOption(18) || (ru(e) && (this._modifierPressed = !0), this._mouseDown && ru(e) && this._editor.updateOptions({
        mouseStyle: "copy"
      }));
    }
    onEditorKeyUp(e) {
      !this._editor.getOption(31) || this._editor.getOption(18) || (ru(e) && (this._modifierPressed = !1), this._mouseDown && e.keyCode === hl.TRIGGER_KEY_VALUE && this._editor.updateOptions({
        mouseStyle: "default"
      }));
    }
    _onEditorMouseDown(e) {
      this._mouseDown = !0;
    }
    _onEditorMouseUp(e) {
      this._mouseDown = !1, this._editor.updateOptions({
        mouseStyle: "text"
      });
    }
    _onEditorMouseDrag(e) {
      let t = e.target;
      if (this._dragSelection === null) {
        let n = (this._editor.getSelections() || []).filter((o) => t.position && o.containsPosition(t.position));
        if (n.length === 1)
          this._dragSelection = n[0];
        else
          return;
      }
      ru(e.event) ? this._editor.updateOptions({
        mouseStyle: "copy"
      }) : this._editor.updateOptions({
        mouseStyle: "default"
      }), t.position && (this._dragSelection.containsPosition(t.position) ? this._removeDecoration() : this.showAt(t.position));
    }
    _onEditorMouseDropCanceled() {
      this._editor.updateOptions({
        mouseStyle: "text"
      }), this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1;
    }
    _onEditorMouseDrop(e) {
      if (e.target && (this._hitContent(e.target) || this._hitMargin(e.target)) && e.target.position) {
        let t = new V(e.target.position.lineNumber, e.target.position.column);
        if (this._dragSelection === null) {
          let i = null;
          if (e.event.shiftKey) {
            let n = this._editor.getSelection();
            if (n) {
              const { selectionStartLineNumber: o, selectionStartColumn: r } = n;
              i = [new ae(o, r, t.lineNumber, t.column)];
            }
          } else
            i = (this._editor.getSelections() || []).map((n) => n.containsPosition(t) ? new ae(t.lineNumber, t.column, t.lineNumber, t.column) : n);
          this._editor.setSelections(i || [], "mouse", 3);
        } else
          (!this._dragSelection.containsPosition(t) || (ru(e.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(t) || this._dragSelection.getStartPosition().equals(t))) && (this._editor.pushUndoStop(), this._editor.executeCommand(hl.ID, new ote(this._dragSelection, t, ru(e.event) || this._modifierPressed)), this._editor.pushUndoStop());
      }
      this._editor.updateOptions({
        mouseStyle: "text"
      }), this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1;
    }
    showAt(e) {
      let t = [{
        range: new D(e.lineNumber, e.column, e.lineNumber, e.column),
        options: hl._DECORATION_OPTIONS
      }];
      this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, t), this._editor.revealPosition(e, 1);
    }
    _removeDecoration() {
      this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, []);
    }
    _hitContent(e) {
      return e.type === 6 || e.type === 7;
    }
    _hitMargin(e) {
      return e.type === 2 || e.type === 3 || e.type === 4;
    }
    dispose() {
      this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1, this._modifierPressed = !1, super.dispose();
    }
  }
  hl.ID = "editor.contrib.dragAndDrop";
  hl.TRIGGER_KEY_VALUE = Ye ? 6 : 5;
  hl._DECORATION_OPTIONS = $e.register({
    description: "dnd-target",
    className: "dnd-target"
  });
  vt(hl.ID, hl);
  class Rn {
    constructor(e) {
      this._editor = e, this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null, this._startPosition = this._editor.getPosition();
    }
    dispose() {
      this._editor.deltaDecorations(this._allDecorations(), []), this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
    }
    reset() {
      this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
    }
    getCount() {
      return this._decorations.length;
    }
    getFindScope() {
      return this._findScopeDecorationIds[0] ? this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]) : null;
    }
    getFindScopes() {
      if (this._findScopeDecorationIds.length) {
        const e = this._findScopeDecorationIds.map((t) => this._editor.getModel().getDecorationRange(t)).filter((t) => !!t);
        if (e.length)
          return e;
      }
      return null;
    }
    getStartPosition() {
      return this._startPosition;
    }
    setStartPosition(e) {
      this._startPosition = e, this.setCurrentFindMatch(null);
    }
    _getDecorationIndex(e) {
      const t = this._decorations.indexOf(e);
      return t >= 0 ? t + 1 : 1;
    }
    getCurrentMatchesPosition(e) {
      let t = this._editor.getModel().getDecorationsInRange(e);
      for (const i of t) {
        const n = i.options;
        if (n === Rn._FIND_MATCH_DECORATION || n === Rn._CURRENT_FIND_MATCH_DECORATION)
          return this._getDecorationIndex(i.id);
      }
      return 0;
    }
    setCurrentFindMatch(e) {
      let t = null, i = 0;
      if (e)
        for (let n = 0, o = this._decorations.length; n < o; n++) {
          let r = this._editor.getModel().getDecorationRange(this._decorations[n]);
          if (e.equalsRange(r)) {
            t = this._decorations[n], i = n + 1;
            break;
          }
        }
      return (this._highlightedDecorationId !== null || t !== null) && this._editor.changeDecorations((n) => {
        if (this._highlightedDecorationId !== null && (n.changeDecorationOptions(this._highlightedDecorationId, Rn._FIND_MATCH_DECORATION), this._highlightedDecorationId = null), t !== null && (this._highlightedDecorationId = t, n.changeDecorationOptions(this._highlightedDecorationId, Rn._CURRENT_FIND_MATCH_DECORATION)), this._rangeHighlightDecorationId !== null && (n.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), t !== null) {
          let o = this._editor.getModel().getDecorationRange(t);
          if (o.startLineNumber !== o.endLineNumber && o.endColumn === 1) {
            let r = o.endLineNumber - 1, a = this._editor.getModel().getLineMaxColumn(r);
            o = new D(o.startLineNumber, o.startColumn, r, a);
          }
          this._rangeHighlightDecorationId = n.addDecoration(o, Rn._RANGE_HIGHLIGHT_DECORATION);
        }
      }), i;
    }
    set(e, t) {
      this._editor.changeDecorations((i) => {
        let n = Rn._FIND_MATCH_DECORATION, o = [];
        if (e.length > 1e3) {
          n = Rn._FIND_MATCH_NO_OVERVIEW_DECORATION;
          const a = this._editor.getModel().getLineCount(), c = this._editor.getLayoutInfo().height / a, d = Math.max(2, Math.ceil(3 / c));
          let h = e[0].range.startLineNumber, u = e[0].range.endLineNumber;
          for (let f = 1, g = e.length; f < g; f++) {
            const _ = e[f].range;
            u + d >= _.startLineNumber ? _.endLineNumber > u && (u = _.endLineNumber) : (o.push({
              range: new D(h, 1, u, 1),
              options: Rn._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            }), h = _.startLineNumber, u = _.endLineNumber);
          }
          o.push({
            range: new D(h, 1, u, 1),
            options: Rn._FIND_MATCH_ONLY_OVERVIEW_DECORATION
          });
        }
        let r = new Array(e.length);
        for (let a = 0, l = e.length; a < l; a++)
          r[a] = {
            range: e[a].range,
            options: n
          };
        this._decorations = i.deltaDecorations(this._decorations, r), this._overviewRulerApproximateDecorations = i.deltaDecorations(this._overviewRulerApproximateDecorations, o), this._rangeHighlightDecorationId && (i.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), this._findScopeDecorationIds.length && (this._findScopeDecorationIds.forEach((a) => i.removeDecoration(a)), this._findScopeDecorationIds = []), t?.length && (this._findScopeDecorationIds = t.map((a) => i.addDecoration(a, Rn._FIND_SCOPE_DECORATION)));
      });
    }
    matchBeforePosition(e) {
      if (this._decorations.length === 0)
        return null;
      for (let t = this._decorations.length - 1; t >= 0; t--) {
        let i = this._decorations[t], n = this._editor.getModel().getDecorationRange(i);
        if (!(!n || n.endLineNumber > e.lineNumber)) {
          if (n.endLineNumber < e.lineNumber)
            return n;
          if (!(n.endColumn > e.column))
            return n;
        }
      }
      return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
    }
    matchAfterPosition(e) {
      if (this._decorations.length === 0)
        return null;
      for (let t = 0, i = this._decorations.length; t < i; t++) {
        let n = this._decorations[t], o = this._editor.getModel().getDecorationRange(n);
        if (!(!o || o.startLineNumber < e.lineNumber)) {
          if (o.startLineNumber > e.lineNumber)
            return o;
          if (!(o.startColumn < e.column))
            return o;
        }
      }
      return this._editor.getModel().getDecorationRange(this._decorations[0]);
    }
    _allDecorations() {
      let e = [];
      return e = e.concat(this._decorations), e = e.concat(this._overviewRulerApproximateDecorations), this._findScopeDecorationIds.length && e.push(...this._findScopeDecorationIds), this._rangeHighlightDecorationId && e.push(this._rangeHighlightDecorationId), e;
    }
  }
  Rn._CURRENT_FIND_MATCH_DECORATION = $e.register({
    description: "current-find-match",
    stickiness: 1,
    zIndex: 13,
    className: "currentFindMatch",
    showIfCollapsed: !0,
    overviewRuler: {
      color: ai(rE),
      position: Lo.Center
    },
    minimap: {
      color: ai(hm),
      position: _o.Inline
    }
  });
  Rn._FIND_MATCH_DECORATION = $e.register({
    description: "find-match",
    stickiness: 1,
    zIndex: 10,
    className: "findMatch",
    showIfCollapsed: !0,
    overviewRuler: {
      color: ai(rE),
      position: Lo.Center
    },
    minimap: {
      color: ai(hm),
      position: _o.Inline
    }
  });
  Rn._FIND_MATCH_NO_OVERVIEW_DECORATION = $e.register({
    description: "find-match-no-overview",
    stickiness: 1,
    className: "findMatch",
    showIfCollapsed: !0
  });
  Rn._FIND_MATCH_ONLY_OVERVIEW_DECORATION = $e.register({
    description: "find-match-only-overview",
    stickiness: 1,
    overviewRuler: {
      color: ai(rE),
      position: Lo.Center
    }
  });
  Rn._RANGE_HIGHLIGHT_DECORATION = $e.register({
    description: "find-range-highlight",
    stickiness: 1,
    className: "rangeHighlight",
    isWholeLine: !0
  });
  Rn._FIND_SCOPE_DECORATION = $e.register({
    description: "find-scope",
    className: "findScope",
    isWholeLine: !0
  });
  class rte {
    constructor(e, t, i) {
      this._editorSelection = e, this._ranges = t, this._replaceStrings = i, this._trackedEditorSelectionId = null;
    }
    getEditOperations(e, t) {
      if (this._ranges.length > 0) {
        let i = [];
        for (let r = 0; r < this._ranges.length; r++)
          i.push({
            range: this._ranges[r],
            text: this._replaceStrings[r]
          });
        i.sort((r, a) => D.compareRangesUsingStarts(r.range, a.range));
        let n = [], o = i[0];
        for (let r = 1; r < i.length; r++)
          o.range.endLineNumber === i[r].range.startLineNumber && o.range.endColumn === i[r].range.startColumn ? (o.range = o.range.plusRange(i[r].range), o.text = o.text + i[r].text) : (n.push(o), o = i[r]);
        n.push(o);
        for (const r of n)
          t.addEditOperation(r.range, r.text);
      }
      this._trackedEditorSelectionId = t.trackSelection(this._editorSelection);
    }
    computeCursorState(e, t) {
      return t.getTrackedSelection(this._trackedEditorSelectionId);
    }
  }
  function $7(s, e) {
    if (s && s[0] !== "") {
      const t = TA(s, e, "-"), i = TA(s, e, "_");
      return t && !i ? MA(s, e, "-") : !t && i ? MA(s, e, "_") : s[0].toUpperCase() === s[0] ? e.toUpperCase() : s[0].toLowerCase() === s[0] ? e.toLowerCase() : JW(s[0][0]) && e.length > 0 ? e[0].toUpperCase() + e.substr(1) : s[0][0].toUpperCase() !== s[0][0] && e.length > 0 ? e[0].toLowerCase() + e.substr(1) : e;
    } else
      return e;
  }
  function TA(s, e, t) {
    return s[0].indexOf(t) !== -1 && e.indexOf(t) !== -1 && s[0].split(t).length === e.split(t).length;
  }
  function MA(s, e, t) {
    const i = e.split(t), n = s[0].split(t);
    let o = "";
    return i.forEach((r, a) => {
      o += $7([n[a]], r) + t;
    }), o.slice(0, -1);
  }
  class AA {
    constructor(e) {
      this.staticValue = e, this.kind = 0;
    }
  }
  class ate {
    constructor(e) {
      this.pieces = e, this.kind = 1;
    }
  }
  class Af {
    constructor(e) {
      !e || e.length === 0 ? this._state = new AA("") : e.length === 1 && e[0].staticValue !== null ? this._state = new AA(e[0].staticValue) : this._state = new ate(e);
    }
    static fromStaticValue(e) {
      return new Af([Wd.staticValue(e)]);
    }
    get hasReplacementPatterns() {
      return this._state.kind === 1;
    }
    buildReplaceString(e, t) {
      if (this._state.kind === 0)
        return t ? $7(e, this._state.staticValue) : this._state.staticValue;
      let i = "";
      for (let n = 0, o = this._state.pieces.length; n < o; n++) {
        let r = this._state.pieces[n];
        if (r.staticValue !== null) {
          i += r.staticValue;
          continue;
        }
        let a = Af._substitute(r.matchIndex, e);
        if (r.caseOps !== null && r.caseOps.length > 0) {
          let l = [], c = r.caseOps.length, d = 0;
          for (let h = 0, u = a.length; h < u; h++) {
            if (d >= c) {
              l.push(a.slice(h));
              break;
            }
            switch (r.caseOps[d]) {
              case "U":
                l.push(a[h].toUpperCase());
                break;
              case "u":
                l.push(a[h].toUpperCase()), d++;
                break;
              case "L":
                l.push(a[h].toLowerCase());
                break;
              case "l":
                l.push(a[h].toLowerCase()), d++;
                break;
              default:
                l.push(a[h]);
            }
          }
          a = l.join("");
        }
        i += a;
      }
      return i;
    }
    static _substitute(e, t) {
      if (t === null)
        return "";
      if (e === 0)
        return t[0];
      let i = "";
      for (; e > 0; ) {
        if (e < t.length)
          return (t[e] || "") + i;
        i = String(e % 10) + i, e = Math.floor(e / 10);
      }
      return "$" + i;
    }
  }
  class Wd {
    constructor(e, t, i) {
      this.staticValue = e, this.matchIndex = t, !i || i.length === 0 ? this.caseOps = null : this.caseOps = i.slice(0);
    }
    static staticValue(e) {
      return new Wd(e, -1, null);
    }
    static caseOps(e, t) {
      return new Wd(null, e, t);
    }
  }
  class lte {
    constructor(e) {
      this._source = e, this._lastCharIndex = 0, this._result = [], this._resultLen = 0, this._currentStaticPiece = "";
    }
    emitUnchanged(e) {
      this._emitStatic(this._source.substring(this._lastCharIndex, e)), this._lastCharIndex = e;
    }
    emitStatic(e, t) {
      this._emitStatic(e), this._lastCharIndex = t;
    }
    _emitStatic(e) {
      e.length !== 0 && (this._currentStaticPiece += e);
    }
    emitMatchIndex(e, t, i) {
      this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = Wd.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), this._result[this._resultLen++] = Wd.caseOps(e, i), this._lastCharIndex = t;
    }
    finalize() {
      return this.emitUnchanged(this._source.length), this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = Wd.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), new Af(this._result);
    }
  }
  function cte(s) {
    if (!s || s.length === 0)
      return new Af(null);
    let e = [], t = new lte(s);
    for (let i = 0, n = s.length; i < n; i++) {
      let o = s.charCodeAt(i);
      if (o === 92) {
        if (i++, i >= n)
          break;
        let r = s.charCodeAt(i);
        switch (r) {
          case 92:
            t.emitUnchanged(i - 1), t.emitStatic("\\", i + 1);
            break;
          case 110:
            t.emitUnchanged(i - 1), t.emitStatic(`
`, i + 1);
            break;
          case 116:
            t.emitUnchanged(i - 1), t.emitStatic("	", i + 1);
            break;
          case 117:
          case 85:
          case 108:
          case 76:
            t.emitUnchanged(i - 1), t.emitStatic("", i + 1), e.push(String.fromCharCode(r));
            break;
        }
        continue;
      }
      if (o === 36) {
        if (i++, i >= n)
          break;
        let r = s.charCodeAt(i);
        if (r === 36) {
          t.emitUnchanged(i - 1), t.emitStatic("$", i + 1);
          continue;
        }
        if (r === 48 || r === 38) {
          t.emitUnchanged(i - 1), t.emitMatchIndex(0, i + 1, e), e.length = 0;
          continue;
        }
        if (49 <= r && r <= 57) {
          let a = r - 48;
          if (i + 1 < n) {
            let l = s.charCodeAt(i + 1);
            if (48 <= l && l <= 57) {
              i++, a = a * 10 + (l - 48), t.emitUnchanged(i - 2), t.emitMatchIndex(a, i + 1, e), e.length = 0;
              continue;
            }
          }
          t.emitUnchanged(i - 1), t.emitMatchIndex(a, i + 1, e), e.length = 0;
          continue;
        }
      }
    }
    return t.finalize();
  }
  const Vc = new ue("findWidgetVisible", !1);
  Vc.toNegated();
  const zC = new ue("findInputFocussed", !1), MN = new ue("replaceInputFocussed", !1), yb = {
    primary: 545,
    mac: { primary: 2593 }
  }, Lb = {
    primary: 565,
    mac: { primary: 2613 }
  }, kb = {
    primary: 560,
    mac: { primary: 2608 }
  }, Db = {
    primary: 554,
    mac: { primary: 2602 }
  }, xb = {
    primary: 558,
    mac: { primary: 2606 }
  }, Ft = {
    StartFindAction: "actions.find",
    StartFindWithSelection: "actions.findWithSelection",
    StartFindWithArgs: "editor.actions.findWithArgs",
    NextMatchFindAction: "editor.action.nextMatchFindAction",
    PreviousMatchFindAction: "editor.action.previousMatchFindAction",
    NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
    PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
    StartFindReplaceAction: "editor.action.startFindReplaceAction",
    CloseFindWidgetCommand: "closeFindWidget",
    ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
    ToggleWholeWordCommand: "toggleFindWholeWord",
    ToggleRegexCommand: "toggleFindRegex",
    ToggleSearchScopeCommand: "toggleFindInSelection",
    TogglePreserveCaseCommand: "togglePreserveCase",
    ReplaceOneAction: "editor.action.replaceOne",
    ReplaceAllAction: "editor.action.replaceAll",
    SelectAllMatchesAction: "editor.action.selectAllMatches"
  }, Yl = 19999, dte = 240;
  class Dm {
    constructor(e, t) {
      this._toDispose = new te(), this._editor = e, this._state = t, this._isDisposed = !1, this._startSearchingTimer = new Ns(), this._decorations = new Rn(e), this._toDispose.add(this._decorations), this._updateDecorationsScheduler = new It(() => this.research(!1), 100), this._toDispose.add(this._updateDecorationsScheduler), this._toDispose.add(this._editor.onDidChangeCursorPosition((i) => {
        (i.reason === 3 || i.reason === 5 || i.reason === 6) && this._decorations.setStartPosition(this._editor.getPosition());
      })), this._ignoreModelContentChanged = !1, this._toDispose.add(this._editor.onDidChangeModelContent((i) => {
        this._ignoreModelContentChanged || (i.isFlush && this._decorations.reset(), this._decorations.setStartPosition(this._editor.getPosition()), this._updateDecorationsScheduler.schedule());
      })), this._toDispose.add(this._state.onFindReplaceStateChange((i) => this._onStateChanged(i))), this.research(!1, this._state.searchScope);
    }
    dispose() {
      this._isDisposed = !0, at(this._startSearchingTimer), this._toDispose.dispose();
    }
    _onStateChanged(e) {
      this._isDisposed || !this._editor.hasModel() || (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) && (this._editor.getModel().isTooLargeForSyncing() ? (this._startSearchingTimer.cancel(), this._startSearchingTimer.setIfNotSet(() => {
        e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor);
      }, dte)) : e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor));
    }
    static _getSearchRange(e, t) {
      return t || e.getFullModelRange();
    }
    research(e, t) {
      let i = null;
      typeof t < "u" ? t !== null && (Array.isArray(t) ? i = t : i = [t]) : i = this._decorations.getFindScopes(), i !== null && (i = i.map((a) => {
        if (a.startLineNumber !== a.endLineNumber) {
          let l = a.endLineNumber;
          return a.endColumn === 1 && (l = l - 1), new D(a.startLineNumber, 1, l, this._editor.getModel().getLineMaxColumn(l));
        }
        return a;
      }));
      let n = this._findMatches(i, !1, Yl);
      this._decorations.set(n, i);
      const o = this._editor.getSelection();
      let r = this._decorations.getCurrentMatchesPosition(o);
      if (r === 0 && n.length > 0) {
        const a = jP(n.map((l) => l.range), (l) => D.compareRangesUsingStarts(l, o) >= 0);
        r = a > 0 ? a - 1 + 1 : r;
      }
      this._state.changeMatchInfo(r, this._decorations.getCount(), void 0), e && this._editor.getOption(35).cursorMoveOnType && this._moveToNextMatch(this._decorations.getStartPosition());
    }
    _hasMatches() {
      return this._state.matchesCount > 0;
    }
    _cannotFind() {
      if (!this._hasMatches()) {
        let e = this._decorations.getFindScope();
        return e && this._editor.revealRangeInCenterIfOutsideViewport(e, 0), !0;
      }
      return !1;
    }
    _setCurrentFindMatch(e) {
      let t = this._decorations.setCurrentFindMatch(e);
      this._state.changeMatchInfo(t, this._decorations.getCount(), e), this._editor.setSelection(e), this._editor.revealRangeInCenterIfOutsideViewport(e, 0);
    }
    _prevSearchPosition(e) {
      let t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0), { lineNumber: i, column: n } = e, o = this._editor.getModel();
      return t || n === 1 ? (i === 1 ? i = o.getLineCount() : i--, n = o.getLineMaxColumn(i)) : n--, new V(i, n);
    }
    _moveToPrevMatch(e, t = !1) {
      if (!this._state.canNavigateBack()) {
        const d = this._decorations.matchAfterPosition(e);
        d && this._setCurrentFindMatch(d);
        return;
      }
      if (this._decorations.getCount() < Yl) {
        let d = this._decorations.matchBeforePosition(e);
        d && d.isEmpty() && d.getStartPosition().equals(e) && (e = this._prevSearchPosition(e), d = this._decorations.matchBeforePosition(e)), d && this._setCurrentFindMatch(d);
        return;
      }
      if (this._cannotFind())
        return;
      let i = this._decorations.getFindScope(), n = Dm._getSearchRange(this._editor.getModel(), i);
      n.getEndPosition().isBefore(e) && (e = n.getEndPosition()), e.isBefore(n.getStartPosition()) && (e = n.getEndPosition());
      let { lineNumber: o, column: r } = e, a = this._editor.getModel(), l = new V(o, r), c = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117) : null, !1);
      if (c && c.range.isEmpty() && c.range.getStartPosition().equals(l) && (l = this._prevSearchPosition(l), c = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117) : null, !1)), !!c) {
        if (!t && !n.containsRange(c.range))
          return this._moveToPrevMatch(c.range.getStartPosition(), !0);
        this._setCurrentFindMatch(c.range);
      }
    }
    moveToPrevMatch() {
      this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
    }
    _nextSearchPosition(e) {
      let t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0), { lineNumber: i, column: n } = e, o = this._editor.getModel();
      return t || n === o.getLineMaxColumn(i) ? (i === o.getLineCount() ? i = 1 : i++, n = 1) : n++, new V(i, n);
    }
    _moveToNextMatch(e) {
      if (!this._state.canNavigateForward()) {
        const i = this._decorations.matchBeforePosition(e);
        i && this._setCurrentFindMatch(i);
        return;
      }
      if (this._decorations.getCount() < Yl) {
        let i = this._decorations.matchAfterPosition(e);
        i && i.isEmpty() && i.getStartPosition().equals(e) && (e = this._nextSearchPosition(e), i = this._decorations.matchAfterPosition(e)), i && this._setCurrentFindMatch(i);
        return;
      }
      let t = this._getNextMatch(e, !1, !0);
      t && this._setCurrentFindMatch(t.range);
    }
    _getNextMatch(e, t, i, n = !1) {
      if (this._cannotFind())
        return null;
      let o = this._decorations.getFindScope(), r = Dm._getSearchRange(this._editor.getModel(), o);
      r.getEndPosition().isBefore(e) && (e = r.getStartPosition()), e.isBefore(r.getStartPosition()) && (e = r.getStartPosition());
      let { lineNumber: a, column: l } = e, c = this._editor.getModel(), d = new V(a, l), h = c.findNextMatch(this._state.searchString, d, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117) : null, t);
      return i && h && h.range.isEmpty() && h.range.getStartPosition().equals(d) && (d = this._nextSearchPosition(d), h = c.findNextMatch(this._state.searchString, d, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117) : null, t)), h ? !n && !r.containsRange(h.range) ? this._getNextMatch(h.range.getEndPosition(), t, i, !0) : h : null;
    }
    moveToNextMatch() {
      this._moveToNextMatch(this._editor.getSelection().getEndPosition());
    }
    _getReplacePattern() {
      return this._state.isRegex ? cte(this._state.replaceString) : Af.fromStaticValue(this._state.replaceString);
    }
    replace() {
      if (!this._hasMatches())
        return;
      let e = this._getReplacePattern(), t = this._editor.getSelection(), i = this._getNextMatch(t.getStartPosition(), !0, !1);
      if (i)
        if (t.equalsRange(i.range)) {
          let n = e.buildReplaceString(i.matches, this._state.preserveCase), o = new fn(t, n);
          this._executeEditorCommand("replace", o), this._decorations.setStartPosition(new V(t.startLineNumber, t.startColumn + n.length)), this.research(!0);
        } else
          this._decorations.setStartPosition(this._editor.getPosition()), this._setCurrentFindMatch(i.range);
    }
    _findMatches(e, t, i) {
      const n = (e || [null]).map((o) => Dm._getSearchRange(this._editor.getModel(), o));
      return this._editor.getModel().findMatches(this._state.searchString, n, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117) : null, t, i);
    }
    replaceAll() {
      if (!this._hasMatches())
        return;
      const e = this._decorations.getFindScopes();
      e === null && this._state.matchesCount >= Yl ? this._largeReplaceAll() : this._regularReplaceAll(e), this.research(!1);
    }
    _largeReplaceAll() {
      const t = new td(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117) : null).parseSearchRequest();
      if (!t)
        return;
      let i = t.regex;
      if (!i.multiline) {
        let h = "mu";
        i.ignoreCase && (h += "i"), i.global && (h += "g"), i = new RegExp(i.source, h);
      }
      const n = this._editor.getModel(), o = n.getValue(1), r = n.getFullModelRange(), a = this._getReplacePattern();
      let l;
      const c = this._state.preserveCase;
      a.hasReplacementPatterns || c ? l = o.replace(i, function() {
        return a.buildReplaceString(arguments, c);
      }) : l = o.replace(i, a.buildReplaceString(null, c));
      let d = new HI(r, l, this._editor.getSelection());
      this._executeEditorCommand("replaceAll", d);
    }
    _regularReplaceAll(e) {
      const t = this._getReplacePattern();
      let i = this._findMatches(e, t.hasReplacementPatterns || this._state.preserveCase, 1073741824), n = [];
      for (let r = 0, a = i.length; r < a; r++)
        n[r] = t.buildReplaceString(i[r].matches, this._state.preserveCase);
      let o = new rte(this._editor.getSelection(), i.map((r) => r.range), n);
      this._executeEditorCommand("replaceAll", o);
    }
    selectAllMatches() {
      if (!this._hasMatches())
        return;
      let e = this._decorations.getFindScopes(), i = this._findMatches(e, !1, 1073741824).map((o) => new ae(o.range.startLineNumber, o.range.startColumn, o.range.endLineNumber, o.range.endColumn)), n = this._editor.getSelection();
      for (let o = 0, r = i.length; o < r; o++)
        if (i[o].equalsRange(n)) {
          i = [n].concat(i.slice(0, o)).concat(i.slice(o + 1));
          break;
        }
      this._editor.setSelections(i);
    }
    _executeEditorCommand(e, t) {
      try {
        this._ignoreModelContentChanged = !0, this._editor.pushUndoStop(), this._editor.executeCommand(e, t), this._editor.pushUndoStop();
      } finally {
        this._ignoreModelContentChanged = !1;
      }
    }
  }
  class UC extends Qo {
    constructor(e, t, i, n) {
      super(), this._hideSoon = this._register(new It(() => this._hide(), 2e3)), this._isVisible = !1, this._editor = e, this._state = t, this._keybindingService = i, this._domNode = document.createElement("div"), this._domNode.className = "findOptionsWidget", this._domNode.style.display = "none", this._domNode.style.top = "10px", this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
      const o = n.getColorTheme().getColor(uL), r = n.getColorTheme().getColor(gL), a = n.getColorTheme().getColor(fL);
      this.caseSensitive = this._register(new g7({
        appendTitle: this._keybindingLabelFor(Ft.ToggleCaseSensitiveCommand),
        isChecked: this._state.matchCase,
        inputActiveOptionBorder: o,
        inputActiveOptionForeground: r,
        inputActiveOptionBackground: a
      })), this._domNode.appendChild(this.caseSensitive.domNode), this._register(this.caseSensitive.onChange(() => {
        this._state.change({
          matchCase: this.caseSensitive.checked
        }, !1);
      })), this.wholeWords = this._register(new m7({
        appendTitle: this._keybindingLabelFor(Ft.ToggleWholeWordCommand),
        isChecked: this._state.wholeWord,
        inputActiveOptionBorder: o,
        inputActiveOptionForeground: r,
        inputActiveOptionBackground: a
      })), this._domNode.appendChild(this.wholeWords.domNode), this._register(this.wholeWords.onChange(() => {
        this._state.change({
          wholeWord: this.wholeWords.checked
        }, !1);
      })), this.regex = this._register(new p7({
        appendTitle: this._keybindingLabelFor(Ft.ToggleRegexCommand),
        isChecked: this._state.isRegex,
        inputActiveOptionBorder: o,
        inputActiveOptionForeground: r,
        inputActiveOptionBackground: a
      })), this._domNode.appendChild(this.regex.domNode), this._register(this.regex.onChange(() => {
        this._state.change({
          isRegex: this.regex.checked
        }, !1);
      })), this._editor.addOverlayWidget(this), this._register(this._state.onFindReplaceStateChange((l) => {
        let c = !1;
        l.isRegex && (this.regex.checked = this._state.isRegex, c = !0), l.wholeWord && (this.wholeWords.checked = this._state.wholeWord, c = !0), l.matchCase && (this.caseSensitive.checked = this._state.matchCase, c = !0), !this._state.isRevealed && c && this._revealTemporarily();
      })), this._register(kI(this._domNode, (l) => this._onMouseOut())), this._register(ee(this._domNode, "mouseover", (l) => this._onMouseOver())), this._applyTheme(n.getColorTheme()), this._register(n.onDidColorThemeChange(this._applyTheme.bind(this)));
    }
    _keybindingLabelFor(e) {
      let t = this._keybindingService.lookupKeybinding(e);
      return t ? ` (${t.getLabel()})` : "";
    }
    dispose() {
      this._editor.removeOverlayWidget(this), super.dispose();
    }
    getId() {
      return UC.ID;
    }
    getDomNode() {
      return this._domNode;
    }
    getPosition() {
      return {
        preference: 0
      };
    }
    highlightFindOptions() {
      this._revealTemporarily();
    }
    _revealTemporarily() {
      this._show(), this._hideSoon.schedule();
    }
    _onMouseOut() {
      this._hideSoon.schedule();
    }
    _onMouseOver() {
      this._hideSoon.cancel();
    }
    _show() {
      this._isVisible || (this._isVisible = !0, this._domNode.style.display = "block");
    }
    _hide() {
      !this._isVisible || (this._isVisible = !1, this._domNode.style.display = "none");
    }
    _applyTheme(e) {
      let t = {
        inputActiveOptionBorder: e.getColor(uL),
        inputActiveOptionForeground: e.getColor(gL),
        inputActiveOptionBackground: e.getColor(fL)
      };
      this.caseSensitive.style(t), this.wholeWords.style(t), this.regex.style(t);
    }
  }
  UC.ID = "editor.contrib.findOptionsWidget";
  Vt((s, e) => {
    const t = s.getColor(Kn);
    t && e.addRule(`.monaco-editor .findOptionsWidget { background-color: ${t}; }`);
    const i = s.getColor(ll);
    i && e.addRule(`.monaco-editor .findOptionsWidget { color: ${i}; }`);
    const n = s.getColor(wc);
    n && e.addRule(`.monaco-editor .findOptionsWidget { box-shadow: 0 0 8px 2px ${n}; }`);
    const o = s.getColor(qt);
    o && e.addRule(`.monaco-editor .findOptionsWidget { border: 2px solid ${o}; }`);
  });
  function Ib(s, e) {
    return s === 1 ? !0 : s === 2 ? !1 : e;
  }
  class hte extends z {
    constructor() {
      super(), this._onFindReplaceStateChange = this._register(new B()), this.onFindReplaceStateChange = this._onFindReplaceStateChange.event, this._searchString = "", this._replaceString = "", this._isRevealed = !1, this._isReplaceRevealed = !1, this._isRegex = !1, this._isRegexOverride = 0, this._wholeWord = !1, this._wholeWordOverride = 0, this._matchCase = !1, this._matchCaseOverride = 0, this._preserveCase = !1, this._preserveCaseOverride = 0, this._searchScope = null, this._matchesPosition = 0, this._matchesCount = 0, this._currentMatch = null, this._loop = !0, this._isSearching = !1, this._filters = null;
    }
    get searchString() {
      return this._searchString;
    }
    get replaceString() {
      return this._replaceString;
    }
    get isRevealed() {
      return this._isRevealed;
    }
    get isReplaceRevealed() {
      return this._isReplaceRevealed;
    }
    get isRegex() {
      return Ib(this._isRegexOverride, this._isRegex);
    }
    get wholeWord() {
      return Ib(this._wholeWordOverride, this._wholeWord);
    }
    get matchCase() {
      return Ib(this._matchCaseOverride, this._matchCase);
    }
    get preserveCase() {
      return Ib(this._preserveCaseOverride, this._preserveCase);
    }
    get actualIsRegex() {
      return this._isRegex;
    }
    get actualWholeWord() {
      return this._wholeWord;
    }
    get actualMatchCase() {
      return this._matchCase;
    }
    get actualPreserveCase() {
      return this._preserveCase;
    }
    get searchScope() {
      return this._searchScope;
    }
    get matchesPosition() {
      return this._matchesPosition;
    }
    get matchesCount() {
      return this._matchesCount;
    }
    get currentMatch() {
      return this._currentMatch;
    }
    changeMatchInfo(e, t, i) {
      let n = {
        moveCursor: !1,
        updateHistory: !1,
        searchString: !1,
        replaceString: !1,
        isRevealed: !1,
        isReplaceRevealed: !1,
        isRegex: !1,
        wholeWord: !1,
        matchCase: !1,
        preserveCase: !1,
        searchScope: !1,
        matchesPosition: !1,
        matchesCount: !1,
        currentMatch: !1,
        loop: !1,
        isSearching: !1,
        filters: !1
      }, o = !1;
      t === 0 && (e = 0), e > t && (e = t), this._matchesPosition !== e && (this._matchesPosition = e, n.matchesPosition = !0, o = !0), this._matchesCount !== t && (this._matchesCount = t, n.matchesCount = !0, o = !0), typeof i < "u" && (D.equalsRange(this._currentMatch, i) || (this._currentMatch = i, n.currentMatch = !0, o = !0)), o && this._onFindReplaceStateChange.fire(n);
    }
    change(e, t, i = !0) {
      var n;
      let o = {
        moveCursor: t,
        updateHistory: i,
        searchString: !1,
        replaceString: !1,
        isRevealed: !1,
        isReplaceRevealed: !1,
        isRegex: !1,
        wholeWord: !1,
        matchCase: !1,
        preserveCase: !1,
        searchScope: !1,
        matchesPosition: !1,
        matchesCount: !1,
        currentMatch: !1,
        loop: !1,
        isSearching: !1,
        filters: !1
      }, r = !1;
      const a = this.isRegex, l = this.wholeWord, c = this.matchCase, d = this.preserveCase;
      typeof e.searchString < "u" && this._searchString !== e.searchString && (this._searchString = e.searchString, o.searchString = !0, r = !0), typeof e.replaceString < "u" && this._replaceString !== e.replaceString && (this._replaceString = e.replaceString, o.replaceString = !0, r = !0), typeof e.isRevealed < "u" && this._isRevealed !== e.isRevealed && (this._isRevealed = e.isRevealed, o.isRevealed = !0, r = !0), typeof e.isReplaceRevealed < "u" && this._isReplaceRevealed !== e.isReplaceRevealed && (this._isReplaceRevealed = e.isReplaceRevealed, o.isReplaceRevealed = !0, r = !0), typeof e.isRegex < "u" && (this._isRegex = e.isRegex), typeof e.wholeWord < "u" && (this._wholeWord = e.wholeWord), typeof e.matchCase < "u" && (this._matchCase = e.matchCase), typeof e.preserveCase < "u" && (this._preserveCase = e.preserveCase), typeof e.searchScope < "u" && (!((n = e.searchScope) === null || n === void 0) && n.every((h) => {
        var u;
        return (u = this._searchScope) === null || u === void 0 ? void 0 : u.some((f) => !D.equalsRange(f, h));
      }) || (this._searchScope = e.searchScope, o.searchScope = !0, r = !0)), typeof e.loop < "u" && this._loop !== e.loop && (this._loop = e.loop, o.loop = !0, r = !0), typeof e.isSearching < "u" && this._isSearching !== e.isSearching && (this._isSearching = e.isSearching, o.isSearching = !0, r = !0), typeof e.filters < "u" && (this._filters ? this._filters.update(e.filters) : this._filters = e.filters, o.filters = !0, r = !0), this._isRegexOverride = typeof e.isRegexOverride < "u" ? e.isRegexOverride : 0, this._wholeWordOverride = typeof e.wholeWordOverride < "u" ? e.wholeWordOverride : 0, this._matchCaseOverride = typeof e.matchCaseOverride < "u" ? e.matchCaseOverride : 0, this._preserveCaseOverride = typeof e.preserveCaseOverride < "u" ? e.preserveCaseOverride : 0, a !== this.isRegex && (r = !0, o.isRegex = !0), l !== this.wholeWord && (r = !0, o.wholeWord = !0), c !== this.matchCase && (r = !0, o.matchCase = !0), d !== this.preserveCase && (r = !0, o.preserveCase = !0), r && this._onFindReplaceStateChange.fire(o);
    }
    canNavigateBack() {
      return this.canNavigateInLoop() || this.matchesPosition !== 1;
    }
    canNavigateForward() {
      return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
    }
    canNavigateInLoop() {
      return this._loop || this.matchesCount >= Yl;
    }
  }
  function RA(s) {
    var e, t;
    return ((e = s.lookupKeybinding("history.showPrevious")) === null || e === void 0 ? void 0 : e.getElectronAccelerator()) === "Up" && ((t = s.lookupKeybinding("history.showNext")) === null || t === void 0 ? void 0 : t.getElectronAccelerator()) === "Down";
  }
  var ute = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const fte = Vi("find-selection", p.selection, m("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget.")), OA = Vi("find-collapsed", p.chevronRight, m("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed.")), PA = Vi("find-expanded", p.chevronDown, m("findExpandedIcon", "Icon to indicate that the editor find widget is expanded.")), gte = Vi("find-replace", p.replace, m("findReplaceIcon", "Icon for 'Replace' in the editor find widget.")), mte = Vi("find-replace-all", p.replaceAll, m("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget.")), pte = Vi("find-previous-match", p.arrowUp, m("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget.")), _te = Vi("find-next-match", p.arrowDown, m("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget.")), bte = m("label.find", "Find"), vte = m("placeholder.find", "Find"), Cte = m("label.previousMatchButton", "Previous Match"), wte = m("label.nextMatchButton", "Next Match"), Ste = m("label.toggleSelectionFind", "Find in Selection"), yte = m("label.closeButton", "Close"), Lte = m("label.replace", "Replace"), kte = m("placeholder.replace", "Replace"), Dte = m("label.replaceButton", "Replace"), xte = m("label.replaceAllButton", "Replace All"), Ite = m("label.toggleReplaceButton", "Toggle Replace"), Ete = m("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", Yl), Nte = m("label.matchesLocation", "{0} of {1}"), FA = m("label.noResults", "No results"), Nr = 419, Tte = 275, Mte = Tte - 54;
  let Ag = 69;
  const Ate = 33, BA = "ctrlEnterReplaceAll.windows.donotask", WA = Ye ? 256 : 2048;
  class sy {
    constructor(e) {
      this.afterLineNumber = e, this.heightInPx = Ate, this.suppressMouseDown = !1, this.domNode = document.createElement("div"), this.domNode.className = "dock-find-viewzone";
    }
  }
  function VA(s, e, t) {
    const i = !!e.match(/\n/);
    if (t && i && t.selectionStart > 0) {
      s.stopPropagation();
      return;
    }
  }
  function HA(s, e, t) {
    const i = !!e.match(/\n/);
    if (t && i && t.selectionEnd < t.value.length) {
      s.stopPropagation();
      return;
    }
  }
  class $C extends Qo {
    constructor(e, t, i, n, o, r, a, l, c) {
      super(), this._cachedHeight = null, this._revealTimeouts = [], this._codeEditor = e, this._controller = t, this._state = i, this._contextViewProvider = n, this._keybindingService = o, this._contextKeyService = r, this._storageService = l, this._notificationService = c, this._ctrlEnterReplaceAllWarningPrompted = !!l.getBoolean(BA, 0), this._isVisible = !1, this._isReplaceVisible = !1, this._ignoreChangeEvent = !1, this._updateHistoryDelayer = new ca(500), this._register(qe(() => this._updateHistoryDelayer.cancel())), this._register(this._state.onFindReplaceStateChange((d) => this._onStateChanged(d))), this._buildDomNode(), this._updateButtons(), this._tryUpdateWidgetWidth(), this._findInput.inputBox.layout(), this._register(this._codeEditor.onDidChangeConfiguration((d) => {
        if (d.hasChanged(81) && (this._codeEditor.getOption(81) && this._state.change({ isReplaceRevealed: !1 }, !1), this._updateButtons()), d.hasChanged(131) && this._tryUpdateWidgetWidth(), d.hasChanged(2) && this.updateAccessibilitySupport(), d.hasChanged(35)) {
          const h = this._codeEditor.getOption(35).addExtraSpaceOnTop;
          h && !this._viewZone && (this._viewZone = new sy(0), this._showViewZone()), !h && this._viewZone && this._removeViewZone();
        }
      })), this.updateAccessibilitySupport(), this._register(this._codeEditor.onDidChangeCursorSelection(() => {
        this._isVisible && this._updateToggleSelectionFindButton();
      })), this._register(this._codeEditor.onDidFocusEditorWidget(() => ute(this, void 0, void 0, function* () {
        if (this._isVisible) {
          let d = yield this._controller.getGlobalBufferTerm();
          d && d !== this._state.searchString && (this._state.change({ searchString: d }, !1), this._findInput.select());
        }
      }))), this._findInputFocused = zC.bindTo(r), this._findFocusTracker = this._register(ff(this._findInput.inputBox.inputElement)), this._register(this._findFocusTracker.onDidFocus(() => {
        this._findInputFocused.set(!0), this._updateSearchScope();
      })), this._register(this._findFocusTracker.onDidBlur(() => {
        this._findInputFocused.set(!1);
      })), this._replaceInputFocused = MN.bindTo(r), this._replaceFocusTracker = this._register(ff(this._replaceInput.inputBox.inputElement)), this._register(this._replaceFocusTracker.onDidFocus(() => {
        this._replaceInputFocused.set(!0), this._updateSearchScope();
      })), this._register(this._replaceFocusTracker.onDidBlur(() => {
        this._replaceInputFocused.set(!1);
      })), this._codeEditor.addOverlayWidget(this), this._codeEditor.getOption(35).addExtraSpaceOnTop && (this._viewZone = new sy(0)), this._applyTheme(a.getColorTheme()), this._register(a.onDidColorThemeChange(this._applyTheme.bind(this))), this._register(this._codeEditor.onDidChangeModel(() => {
        !this._isVisible || (this._viewZoneId = void 0);
      })), this._register(this._codeEditor.onDidScrollChange((d) => {
        if (d.scrollTopChanged) {
          this._layoutViewZone();
          return;
        }
        setTimeout(() => {
          this._layoutViewZone();
        }, 0);
      }));
    }
    getId() {
      return $C.ID;
    }
    getDomNode() {
      return this._domNode;
    }
    getPosition() {
      return this._isVisible ? {
        preference: 0
      } : null;
    }
    _onStateChanged(e) {
      if (e.searchString) {
        try {
          this._ignoreChangeEvent = !0, this._findInput.setValue(this._state.searchString);
        } finally {
          this._ignoreChangeEvent = !1;
        }
        this._updateButtons();
      }
      if (e.replaceString && (this._replaceInput.inputBox.value = this._state.replaceString), e.isRevealed && (this._state.isRevealed ? this._reveal() : this._hide(!0)), e.isReplaceRevealed && (this._state.isReplaceRevealed ? !this._codeEditor.getOption(81) && !this._isReplaceVisible && (this._isReplaceVisible = !0, this._replaceInput.width = Bo(this._findInput.domNode), this._updateButtons(), this._replaceInput.inputBox.layout()) : this._isReplaceVisible && (this._isReplaceVisible = !1, this._updateButtons())), (e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed) && this._tryUpdateHeight() && this._showViewZone(), e.isRegex && this._findInput.setRegex(this._state.isRegex), e.wholeWord && this._findInput.setWholeWords(this._state.wholeWord), e.matchCase && this._findInput.setCaseSensitive(this._state.matchCase), e.preserveCase && this._replaceInput.setPreserveCase(this._state.preserveCase), e.searchScope && (this._state.searchScope ? this._toggleSelectionFind.checked = !0 : this._toggleSelectionFind.checked = !1, this._updateToggleSelectionFindButton()), e.searchString || e.matchesCount || e.matchesPosition) {
        let t = this._state.searchString.length > 0 && this._state.matchesCount === 0;
        this._domNode.classList.toggle("no-results", t), this._updateMatchesCount(), this._updateButtons();
      }
      (e.searchString || e.currentMatch) && this._layoutViewZone(), e.updateHistory && this._delayedUpdateHistory(), e.loop && this._updateButtons();
    }
    _delayedUpdateHistory() {
      this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, We);
    }
    _updateHistory() {
      this._state.searchString && this._findInput.inputBox.addToHistory(), this._state.replaceString && this._replaceInput.inputBox.addToHistory();
    }
    _updateMatchesCount() {
      this._matchesCount.style.minWidth = Ag + "px", this._state.matchesCount >= Yl ? this._matchesCount.title = Ete : this._matchesCount.title = "", this._matchesCount.firstChild && this._matchesCount.removeChild(this._matchesCount.firstChild);
      let e;
      if (this._state.matchesCount > 0) {
        let t = String(this._state.matchesCount);
        this._state.matchesCount >= Yl && (t += "+");
        let i = String(this._state.matchesPosition);
        i === "0" && (i = "?"), e = uo(Nte, i, t);
      } else
        e = FA;
      this._matchesCount.appendChild(document.createTextNode(e)), pn(this._getAriaLabel(e, this._state.currentMatch, this._state.searchString)), Ag = Math.max(Ag, this._matchesCount.clientWidth);
    }
    _getAriaLabel(e, t, i) {
      if (e === FA)
        return i === "" ? m("ariaSearchNoResultEmpty", "{0} found", e) : m("ariaSearchNoResult", "{0} found for '{1}'", e, i);
      if (t) {
        const n = m("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", e, i, t.startLineNumber + ":" + t.startColumn), o = this._codeEditor.getModel();
        return o && t.startLineNumber <= o.getLineCount() && t.startLineNumber >= 1 ? `${o.getLineContent(t.startLineNumber)}, ${n}` : n;
      }
      return m("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", e, i);
    }
    _updateToggleSelectionFindButton() {
      let e = this._codeEditor.getSelection(), t = e ? e.startLineNumber !== e.endLineNumber || e.startColumn !== e.endColumn : !1, i = this._toggleSelectionFind.checked;
      this._isVisible && (i || t) ? this._toggleSelectionFind.enable() : this._toggleSelectionFind.disable();
    }
    _updateButtons() {
      this._findInput.setEnabled(this._isVisible), this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible), this._updateToggleSelectionFindButton(), this._closeBtn.setEnabled(this._isVisible);
      let e = this._state.searchString.length > 0, t = !!this._state.matchesCount;
      this._prevBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateBack()), this._nextBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateForward()), this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
      let i = !this._codeEditor.getOption(81);
      this._toggleReplaceBtn.setEnabled(this._isVisible && i);
    }
    _reveal() {
      if (this._revealTimeouts.forEach((e) => {
        clearTimeout(e);
      }), this._revealTimeouts = [], !this._isVisible) {
        this._isVisible = !0;
        const e = this._codeEditor.getSelection();
        switch (this._codeEditor.getOption(35).autoFindInSelection) {
          case "always":
            this._toggleSelectionFind.checked = !0;
            break;
          case "never":
            this._toggleSelectionFind.checked = !1;
            break;
          case "multiline": {
            const i = !!e && e.startLineNumber !== e.endLineNumber;
            this._toggleSelectionFind.checked = i;
            break;
          }
        }
        this._tryUpdateWidgetWidth(), this._updateButtons(), this._revealTimeouts.push(setTimeout(() => {
          this._domNode.classList.add("visible"), this._domNode.setAttribute("aria-hidden", "false");
        }, 0)), this._revealTimeouts.push(setTimeout(() => {
          this._findInput.validate();
        }, 200)), this._codeEditor.layoutOverlayWidget(this);
        let t = !0;
        if (this._codeEditor.getOption(35).seedSearchStringFromSelection && e) {
          const i = this._codeEditor.getDomNode();
          if (i) {
            const n = mn(i), o = this._codeEditor.getScrolledVisiblePosition(e.getStartPosition()), r = n.left + (o ? o.left : 0), a = o ? o.top : 0;
            if (this._viewZone && a < this._viewZone.heightInPx) {
              e.endLineNumber > e.startLineNumber && (t = !1);
              const l = mP(this._domNode).left;
              r > l && (t = !1);
              const c = this._codeEditor.getScrolledVisiblePosition(e.getEndPosition());
              n.left + (c ? c.left : 0) > l && (t = !1);
            }
          }
        }
        this._showViewZone(t);
      }
    }
    _hide(e) {
      this._revealTimeouts.forEach((t) => {
        clearTimeout(t);
      }), this._revealTimeouts = [], this._isVisible && (this._isVisible = !1, this._updateButtons(), this._domNode.classList.remove("visible"), this._domNode.setAttribute("aria-hidden", "true"), this._findInput.clearMessage(), e && this._codeEditor.focus(), this._codeEditor.layoutOverlayWidget(this), this._removeViewZone());
    }
    _layoutViewZone(e) {
      if (!this._codeEditor.getOption(35).addExtraSpaceOnTop) {
        this._removeViewZone();
        return;
      }
      if (!this._isVisible)
        return;
      const i = this._viewZone;
      this._viewZoneId !== void 0 || !i || this._codeEditor.changeViewZones((n) => {
        i.heightInPx = this._getHeight(), this._viewZoneId = n.addZone(i), this._codeEditor.setScrollTop(e || this._codeEditor.getScrollTop() + i.heightInPx);
      });
    }
    _showViewZone(e = !0) {
      if (!this._isVisible || !this._codeEditor.getOption(35).addExtraSpaceOnTop)
        return;
      this._viewZone === void 0 && (this._viewZone = new sy(0));
      const i = this._viewZone;
      this._codeEditor.changeViewZones((n) => {
        if (this._viewZoneId !== void 0) {
          const o = this._getHeight();
          if (o === i.heightInPx)
            return;
          let r = o - i.heightInPx;
          i.heightInPx = o, n.layoutZone(this._viewZoneId), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + r);
          return;
        } else {
          let o = this._getHeight();
          if (o -= this._codeEditor.getOption(75).top, o <= 0)
            return;
          i.heightInPx = o, this._viewZoneId = n.addZone(i), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + o);
        }
      });
    }
    _removeViewZone() {
      this._codeEditor.changeViewZones((e) => {
        this._viewZoneId !== void 0 && (e.removeZone(this._viewZoneId), this._viewZoneId = void 0, this._viewZone && (this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx), this._viewZone = void 0));
      });
    }
    _applyTheme(e) {
      let t = {
        inputActiveOptionBorder: e.getColor(uL),
        inputActiveOptionBackground: e.getColor(fL),
        inputActiveOptionForeground: e.getColor(gL),
        inputBackground: e.getColor(YI),
        inputForeground: e.getColor(XI),
        inputBorder: e.getColor(QI),
        inputValidationInfoBackground: e.getColor(m5),
        inputValidationInfoForeground: e.getColor(p5),
        inputValidationInfoBorder: e.getColor(_5),
        inputValidationWarningBackground: e.getColor(b5),
        inputValidationWarningForeground: e.getColor(v5),
        inputValidationWarningBorder: e.getColor(C5),
        inputValidationErrorBackground: e.getColor(w5),
        inputValidationErrorForeground: e.getColor(S5),
        inputValidationErrorBorder: e.getColor(y5)
      };
      this._findInput.style(t), this._replaceInput.style(t), this._toggleSelectionFind.style(t);
    }
    _tryUpdateWidgetWidth() {
      if (!this._isVisible || !yI(this._domNode))
        return;
      const e = this._codeEditor.getLayoutInfo();
      if (e.contentWidth <= 0) {
        this._domNode.classList.add("hiddenEditor");
        return;
      } else
        this._domNode.classList.contains("hiddenEditor") && this._domNode.classList.remove("hiddenEditor");
      const i = e.width, n = e.minimap.minimapWidth;
      let o = !1, r = !1, a = !1;
      if (this._resized && Bo(this._domNode) > Nr) {
        this._domNode.style.maxWidth = `${i - 28 - n - 15}px`, this._replaceInput.width = Bo(this._findInput.domNode);
        return;
      }
      if (Nr + 28 + n >= i && (r = !0), Nr + 28 + n - Ag >= i && (a = !0), Nr + 28 + n - Ag >= i + 50 && (o = !0), this._domNode.classList.toggle("collapsed-find-widget", o), this._domNode.classList.toggle("narrow-find-widget", a), this._domNode.classList.toggle("reduced-find-widget", r), !a && !o && (this._domNode.style.maxWidth = `${i - 28 - n - 15}px`), this._resized) {
        this._findInput.inputBox.layout();
        let l = this._findInput.inputBox.element.clientWidth;
        l > 0 && (this._replaceInput.width = l);
      } else
        this._isReplaceVisible && (this._replaceInput.width = Bo(this._findInput.domNode));
    }
    _getHeight() {
      let e = 0;
      return e += 4, e += this._findInput.inputBox.height + 2, this._isReplaceVisible && (e += 4, e += this._replaceInput.inputBox.height + 2), e += 4, e;
    }
    _tryUpdateHeight() {
      const e = this._getHeight();
      return this._cachedHeight !== null && this._cachedHeight === e ? !1 : (this._cachedHeight = e, this._domNode.style.height = `${e}px`, !0);
    }
    focusFindInput() {
      this._findInput.select(), this._findInput.focus();
    }
    focusReplaceInput() {
      this._replaceInput.select(), this._replaceInput.focus();
    }
    highlightFindOptions() {
      this._findInput.highlightFindOptions();
    }
    _updateSearchScope() {
      if (!!this._codeEditor.hasModel() && this._toggleSelectionFind.checked) {
        let e = this._codeEditor.getSelections();
        e.map((t) => {
          t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(t.endLineNumber - 1)));
          const i = this._state.currentMatch;
          return t.startLineNumber !== t.endLineNumber && !D.equalsRange(t, i) ? t : null;
        }).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
      }
    }
    _onFindInputMouseDown(e) {
      e.middleButton && e.stopPropagation();
    }
    _onFindInputKeyDown(e) {
      if (e.equals(WA | 3))
        if (this._keybindingService.dispatchEvent(e, e.target)) {
          e.preventDefault();
          return;
        } else {
          this._findInput.inputBox.insertAtCursor(`
`), e.preventDefault();
          return;
        }
      if (e.equals(2)) {
        this._isReplaceVisible ? this._replaceInput.focus() : this._findInput.focusOnCaseSensitive(), e.preventDefault();
        return;
      }
      if (e.equals(2066)) {
        this._codeEditor.focus(), e.preventDefault();
        return;
      }
      if (e.equals(16))
        return VA(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
      if (e.equals(18))
        return HA(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
    _onReplaceInputKeyDown(e) {
      if (e.equals(WA | 3))
        if (this._keybindingService.dispatchEvent(e, e.target)) {
          e.preventDefault();
          return;
        } else {
          rn && gr && !this._ctrlEnterReplaceAllWarningPrompted && (this._notificationService.info(m("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.")), this._ctrlEnterReplaceAllWarningPrompted = !0, this._storageService.store(BA, !0, 0, 0)), this._replaceInput.inputBox.insertAtCursor(`
`), e.preventDefault();
          return;
        }
      if (e.equals(2)) {
        this._findInput.focusOnCaseSensitive(), e.preventDefault();
        return;
      }
      if (e.equals(1026)) {
        this._findInput.focus(), e.preventDefault();
        return;
      }
      if (e.equals(2066)) {
        this._codeEditor.focus(), e.preventDefault();
        return;
      }
      if (e.equals(16))
        return VA(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
      if (e.equals(18))
        return HA(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
    getVerticalSashLeft(e) {
      return 0;
    }
    _keybindingLabelFor(e) {
      let t = this._keybindingService.lookupKeybinding(e);
      return t ? ` (${t.getLabel()})` : "";
    }
    _buildDomNode() {
      this._findInput = this._register(new Sk(null, this._contextViewProvider, {
        width: Mte,
        label: bte,
        placeholder: vte,
        appendCaseSensitiveLabel: this._keybindingLabelFor(Ft.ToggleCaseSensitiveCommand),
        appendWholeWordsLabel: this._keybindingLabelFor(Ft.ToggleWholeWordCommand),
        appendRegexLabel: this._keybindingLabelFor(Ft.ToggleRegexCommand),
        validation: (l) => {
          if (l.length === 0 || !this._findInput.getRegex())
            return null;
          try {
            return new RegExp(l, "gu"), null;
          } catch (c) {
            return { content: c.message };
          }
        },
        flexibleHeight: !0,
        flexibleWidth: !0,
        flexibleMaxHeight: 118,
        showHistoryHint: () => RA(this._keybindingService)
      }, this._contextKeyService, !0)), this._findInput.setRegex(!!this._state.isRegex), this._findInput.setCaseSensitive(!!this._state.matchCase), this._findInput.setWholeWords(!!this._state.wholeWord), this._register(this._findInput.onKeyDown((l) => this._onFindInputKeyDown(l))), this._register(this._findInput.inputBox.onDidChange(() => {
        this._ignoreChangeEvent || this._state.change({ searchString: this._findInput.getValue() }, !0);
      })), this._register(this._findInput.onDidOptionChange(() => {
        this._state.change({
          isRegex: this._findInput.getRegex(),
          wholeWord: this._findInput.getWholeWords(),
          matchCase: this._findInput.getCaseSensitive()
        }, !0);
      })), this._register(this._findInput.onCaseSensitiveKeyDown((l) => {
        l.equals(1026) && this._isReplaceVisible && (this._replaceInput.focus(), l.preventDefault());
      })), this._register(this._findInput.onRegexKeyDown((l) => {
        l.equals(2) && this._isReplaceVisible && (this._replaceInput.focusOnPreserve(), l.preventDefault());
      })), this._register(this._findInput.inputBox.onDidHeightChange((l) => {
        this._tryUpdateHeight() && this._showViewZone();
      })), Nn && this._register(this._findInput.onMouseDown((l) => this._onFindInputMouseDown(l))), this._matchesCount = document.createElement("div"), this._matchesCount.className = "matchesCount", this._updateMatchesCount(), this._prevBtn = this._register(new au({
        label: Cte + this._keybindingLabelFor(Ft.PreviousMatchFindAction),
        icon: pte,
        onTrigger: () => {
          this._codeEditor.getAction(Ft.PreviousMatchFindAction).run().then(void 0, We);
        }
      })), this._nextBtn = this._register(new au({
        label: wte + this._keybindingLabelFor(Ft.NextMatchFindAction),
        icon: _te,
        onTrigger: () => {
          this._codeEditor.getAction(Ft.NextMatchFindAction).run().then(void 0, We);
        }
      }));
      let i = document.createElement("div");
      i.className = "find-part", i.appendChild(this._findInput.domNode);
      const n = document.createElement("div");
      n.className = "find-actions", i.appendChild(n), n.appendChild(this._matchesCount), n.appendChild(this._prevBtn.domNode), n.appendChild(this._nextBtn.domNode), this._toggleSelectionFind = this._register(new x_({
        icon: fte,
        title: Ste + this._keybindingLabelFor(Ft.ToggleSearchScopeCommand),
        isChecked: !1
      })), this._register(this._toggleSelectionFind.onChange(() => {
        if (this._toggleSelectionFind.checked) {
          if (this._codeEditor.hasModel()) {
            let l = this._codeEditor.getSelections();
            l.map((c) => (c.endColumn === 1 && c.endLineNumber > c.startLineNumber && (c = c.setEndPosition(c.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(c.endLineNumber - 1))), c.isEmpty() ? null : c)).filter((c) => !!c), l.length && this._state.change({ searchScope: l }, !0);
          }
        } else
          this._state.change({ searchScope: null }, !0);
      })), n.appendChild(this._toggleSelectionFind.domNode), this._closeBtn = this._register(new au({
        label: yte + this._keybindingLabelFor(Ft.CloseFindWidgetCommand),
        icon: RF,
        onTrigger: () => {
          this._state.change({ isRevealed: !1, searchScope: null }, !1);
        },
        onKeyDown: (l) => {
          l.equals(2) && this._isReplaceVisible && (this._replaceBtn.isEnabled() ? this._replaceBtn.focus() : this._codeEditor.focus(), l.preventDefault());
        }
      })), n.appendChild(this._closeBtn.domNode), this._replaceInput = this._register(new yk(null, void 0, {
        label: Lte,
        placeholder: kte,
        appendPreserveCaseLabel: this._keybindingLabelFor(Ft.TogglePreserveCaseCommand),
        history: [],
        flexibleHeight: !0,
        flexibleWidth: !0,
        flexibleMaxHeight: 118,
        showHistoryHint: () => RA(this._keybindingService)
      }, this._contextKeyService, !0)), this._replaceInput.setPreserveCase(!!this._state.preserveCase), this._register(this._replaceInput.onKeyDown((l) => this._onReplaceInputKeyDown(l))), this._register(this._replaceInput.inputBox.onDidChange(() => {
        this._state.change({ replaceString: this._replaceInput.inputBox.value }, !1);
      })), this._register(this._replaceInput.inputBox.onDidHeightChange((l) => {
        this._isReplaceVisible && this._tryUpdateHeight() && this._showViewZone();
      })), this._register(this._replaceInput.onDidOptionChange(() => {
        this._state.change({
          preserveCase: this._replaceInput.getPreserveCase()
        }, !0);
      })), this._register(this._replaceInput.onPreserveCaseKeyDown((l) => {
        l.equals(2) && (this._prevBtn.isEnabled() ? this._prevBtn.focus() : this._nextBtn.isEnabled() ? this._nextBtn.focus() : this._toggleSelectionFind.enabled ? this._toggleSelectionFind.focus() : this._closeBtn.isEnabled() && this._closeBtn.focus(), l.preventDefault());
      })), this._replaceBtn = this._register(new au({
        label: Dte + this._keybindingLabelFor(Ft.ReplaceOneAction),
        icon: gte,
        onTrigger: () => {
          this._controller.replace();
        },
        onKeyDown: (l) => {
          l.equals(1026) && (this._closeBtn.focus(), l.preventDefault());
        }
      })), this._replaceAllBtn = this._register(new au({
        label: xte + this._keybindingLabelFor(Ft.ReplaceAllAction),
        icon: mte,
        onTrigger: () => {
          this._controller.replaceAll();
        }
      }));
      let o = document.createElement("div");
      o.className = "replace-part", o.appendChild(this._replaceInput.domNode);
      const r = document.createElement("div");
      r.className = "replace-actions", o.appendChild(r), r.appendChild(this._replaceBtn.domNode), r.appendChild(this._replaceAllBtn.domNode), this._toggleReplaceBtn = this._register(new au({
        label: Ite,
        className: "codicon toggle left",
        onTrigger: () => {
          this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, !1), this._isReplaceVisible && (this._replaceInput.width = Bo(this._findInput.domNode), this._replaceInput.inputBox.layout()), this._showViewZone();
        }
      })), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible), this._domNode = document.createElement("div"), this._domNode.className = "editor-widget find-widget", this._domNode.setAttribute("aria-hidden", "true"), this._domNode.style.width = `${Nr}px`, this._domNode.appendChild(this._toggleReplaceBtn.domNode), this._domNode.appendChild(i), this._domNode.appendChild(o), this._resizeSash = new Dn(this._domNode, this, { orientation: 0, size: 2 }), this._resized = !1;
      let a = Nr;
      this._register(this._resizeSash.onDidStart(() => {
        a = Bo(this._domNode);
      })), this._register(this._resizeSash.onDidChange((l) => {
        this._resized = !0;
        let c = a + l.startX - l.currentX;
        if (c < Nr)
          return;
        const d = parseFloat(xI(this._domNode).maxWidth) || 0;
        c > d || (this._domNode.style.width = `${c}px`, this._isReplaceVisible && (this._replaceInput.width = Bo(this._findInput.domNode)), this._findInput.inputBox.layout(), this._tryUpdateHeight());
      })), this._register(this._resizeSash.onDidReset(() => {
        const l = Bo(this._domNode);
        if (l < Nr)
          return;
        let c = Nr;
        if (!this._resized || l === Nr) {
          const d = this._codeEditor.getLayoutInfo();
          c = d.width - 28 - d.minimap.minimapWidth - 15, this._resized = !0;
        }
        this._domNode.style.width = `${c}px`, this._isReplaceVisible && (this._replaceInput.width = Bo(this._findInput.domNode)), this._findInput.inputBox.layout();
      }));
    }
    updateAccessibilitySupport() {
      const e = this._codeEditor.getOption(2);
      this._findInput.setFocusInputOnOptionClick(e !== 2);
    }
  }
  $C.ID = "editor.contrib.findWidget";
  class au extends Qo {
    constructor(e) {
      super(), this._opts = e;
      let t = "button";
      this._opts.className && (t = t + " " + this._opts.className), this._opts.icon && (t = t + " " + Tt.asClassName(this._opts.icon)), this._domNode = document.createElement("div"), this._domNode.title = this._opts.label, this._domNode.tabIndex = 0, this._domNode.className = t, this._domNode.setAttribute("role", "button"), this._domNode.setAttribute("aria-label", this._opts.label), this.onclick(this._domNode, (i) => {
        this._opts.onTrigger(), i.preventDefault();
      }), this.onkeydown(this._domNode, (i) => {
        if (i.equals(10) || i.equals(3)) {
          this._opts.onTrigger(), i.preventDefault();
          return;
        }
        this._opts.onKeyDown && this._opts.onKeyDown(i);
      });
    }
    get domNode() {
      return this._domNode;
    }
    isEnabled() {
      return this._domNode.tabIndex >= 0;
    }
    focus() {
      this._domNode.focus();
    }
    setEnabled(e) {
      this._domNode.classList.toggle("disabled", !e), this._domNode.setAttribute("aria-disabled", String(!e)), this._domNode.tabIndex = e ? 0 : -1;
    }
    setExpanded(e) {
      this._domNode.setAttribute("aria-expanded", String(!!e)), e ? (this._domNode.classList.remove(...Tt.asClassNameArray(OA)), this._domNode.classList.add(...Tt.asClassNameArray(PA))) : (this._domNode.classList.remove(...Tt.asClassNameArray(PA)), this._domNode.classList.add(...Tt.asClassNameArray(OA)));
    }
  }
  Vt((s, e) => {
    const t = (g, _) => {
      _ && e.addRule(`.monaco-editor ${g} { background-color: ${_}; }`);
    };
    t(".findMatch", s.getColor(oc)), t(".currentFindMatch", s.getColor(Pz)), t(".findScope", s.getColor(Fz));
    const i = s.getColor(Kn);
    t(".find-widget", i);
    const n = s.getColor(wc);
    n && e.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${n}; }`);
    const o = s.getColor(Yu);
    o && e.addRule(`.monaco-editor .findMatch { border: 1px ${s.type === "hc" ? "dotted" : "solid"} ${o}; box-sizing: border-box; }`);
    const r = s.getColor(Bz);
    r && e.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${r}; padding: 1px; box-sizing: border-box; }`);
    const a = s.getColor(Wz);
    a && e.addRule(`.monaco-editor .findScope { border: 1px ${s.type === "hc" ? "dashed" : "solid"} ${a}; }`);
    const l = s.getColor(qt);
    l && e.addRule(`.monaco-editor .find-widget { border: 1px solid ${l}; }`);
    const c = s.getColor(ll);
    c && e.addRule(`.monaco-editor .find-widget { color: ${c}; }`);
    const d = s.getColor(pz);
    d && e.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${d}; }`);
    const h = s.getColor(kz);
    if (h)
      e.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${h}; }`);
    else {
      const g = s.getColor(Ed);
      g && e.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${g}; }`);
    }
    const u = s.getColor(bL);
    u && e.addRule(`
		.monaco-editor .find-widget .button:not(.disabled):hover,
		.monaco-editor .find-widget .codicon-find-selection:hover {
			background-color: ${u} !important;
		}
	`);
    const f = s.getColor(sa);
    f && e.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${f}; }`);
  });
  var j7 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Fr = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, hh = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const Rte = 524288;
  function Pk(s, e = "single", t = !1) {
    if (!s.hasModel())
      return null;
    const i = s.getSelection();
    if (e === "single" && i.startLineNumber === i.endLineNumber || e === "multiple") {
      if (i.isEmpty()) {
        const n = s.getConfiguredWordAtPosition(i.getStartPosition());
        if (n && t === !1)
          return n.word;
      } else if (s.getModel().getValueLengthInRange(i) < Rte)
        return s.getModel().getValueInRange(i);
    }
    return null;
  }
  let Es = class K7 extends z {
    constructor(e, t, i, n) {
      super(), this._editor = e, this._findWidgetVisible = Vc.bindTo(t), this._contextKeyService = t, this._storageService = i, this._clipboardService = n, this._updateHistoryDelayer = new ca(500), this._state = this._register(new hte()), this.loadQueryState(), this._register(this._state.onFindReplaceStateChange((o) => this._onStateChanged(o))), this._model = null, this._register(this._editor.onDidChangeModel(() => {
        let o = this._editor.getModel() && this._state.isRevealed;
        this.disposeModel(), this._state.change({
          searchScope: null,
          matchCase: this._storageService.getBoolean("editor.matchCase", 1, !1),
          wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, !1),
          isRegex: this._storageService.getBoolean("editor.isRegex", 1, !1),
          preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, !1)
        }, !1), o && this._start({
          forceRevealReplace: !1,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: !1,
          seedSearchStringFromGlobalClipboard: !1,
          shouldFocus: 0,
          shouldAnimate: !1,
          updateSearchScope: !1,
          loop: this._editor.getOption(35).loop
        });
      }));
    }
    get editor() {
      return this._editor;
    }
    static get(e) {
      return e.getContribution(K7.ID);
    }
    dispose() {
      this.disposeModel(), super.dispose();
    }
    disposeModel() {
      this._model && (this._model.dispose(), this._model = null);
    }
    _onStateChanged(e) {
      this.saveQueryState(e), e.isRevealed && (this._state.isRevealed ? this._findWidgetVisible.set(!0) : (this._findWidgetVisible.reset(), this.disposeModel())), e.searchString && this.setGlobalBufferTerm(this._state.searchString);
    }
    saveQueryState(e) {
      e.isRegex && this._storageService.store("editor.isRegex", this._state.actualIsRegex, 1, 0), e.wholeWord && this._storageService.store("editor.wholeWord", this._state.actualWholeWord, 1, 0), e.matchCase && this._storageService.store("editor.matchCase", this._state.actualMatchCase, 1, 0), e.preserveCase && this._storageService.store("editor.preserveCase", this._state.actualPreserveCase, 1, 0);
    }
    loadQueryState() {
      this._state.change({
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
      }, !1);
    }
    isFindInputFocused() {
      return !!zC.getValue(this._contextKeyService);
    }
    getState() {
      return this._state;
    }
    closeFindWidget() {
      this._state.change({
        isRevealed: !1,
        searchScope: null
      }, !1), this._editor.focus();
    }
    toggleCaseSensitive() {
      this._state.change({ matchCase: !this._state.matchCase }, !1), this._state.isRevealed || this.highlightFindOptions();
    }
    toggleWholeWords() {
      this._state.change({ wholeWord: !this._state.wholeWord }, !1), this._state.isRevealed || this.highlightFindOptions();
    }
    toggleRegex() {
      this._state.change({ isRegex: !this._state.isRegex }, !1), this._state.isRevealed || this.highlightFindOptions();
    }
    togglePreserveCase() {
      this._state.change({ preserveCase: !this._state.preserveCase }, !1), this._state.isRevealed || this.highlightFindOptions();
    }
    toggleSearchScope() {
      if (this._state.searchScope)
        this._state.change({ searchScope: null }, !0);
      else if (this._editor.hasModel()) {
        let e = this._editor.getSelections();
        e.map((t) => (t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(t.endLineNumber - 1))), t.isEmpty() ? null : t)).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
      }
    }
    setSearchString(e) {
      this._state.isRegex && (e = wo(e)), this._state.change({ searchString: e }, !1);
    }
    highlightFindOptions(e = !1) {
    }
    _start(e, t) {
      return hh(this, void 0, void 0, function* () {
        if (this.disposeModel(), !this._editor.hasModel())
          return;
        let i = Object.assign(Object.assign({}, t), { isRevealed: !0 });
        if (e.seedSearchStringFromSelection === "single") {
          let n = Pk(this._editor, e.seedSearchStringFromSelection, e.seedSearchStringFromNonEmptySelection);
          n && (this._state.isRegex ? i.searchString = wo(n) : i.searchString = n);
        } else if (e.seedSearchStringFromSelection === "multiple" && !e.updateSearchScope) {
          let n = Pk(this._editor, e.seedSearchStringFromSelection);
          n && (i.searchString = n);
        }
        if (!i.searchString && e.seedSearchStringFromGlobalClipboard) {
          let n = yield this.getGlobalBufferTerm();
          if (!this._editor.hasModel())
            return;
          n && (i.searchString = n);
        }
        if (e.forceRevealReplace || i.isReplaceRevealed ? i.isReplaceRevealed = !0 : this._findWidgetVisible.get() || (i.isReplaceRevealed = !1), e.updateSearchScope) {
          let n = this._editor.getSelections();
          n.some((o) => !o.isEmpty()) && (i.searchScope = n);
        }
        i.loop = e.loop, this._state.change(i, !1), this._model || (this._model = new Dm(this._editor, this._state));
      });
    }
    start(e, t) {
      return this._start(e, t);
    }
    moveToNextMatch() {
      return this._model ? (this._model.moveToNextMatch(), !0) : !1;
    }
    moveToPrevMatch() {
      return this._model ? (this._model.moveToPrevMatch(), !0) : !1;
    }
    replace() {
      return this._model ? (this._model.replace(), !0) : !1;
    }
    replaceAll() {
      return this._model ? (this._model.replaceAll(), !0) : !1;
    }
    selectAllMatches() {
      return this._model ? (this._model.selectAllMatches(), this._editor.focus(), !0) : !1;
    }
    getGlobalBufferTerm() {
      return hh(this, void 0, void 0, function* () {
        return this._editor.getOption(35).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() ? this._clipboardService.readFindText() : "";
      });
    }
    setGlobalBufferTerm(e) {
      this._editor.getOption(35).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() && this._clipboardService.writeFindText(e);
    }
  };
  Es.ID = "editor.contrib.findController";
  Es = j7([
    Fr(1, Fe),
    Fr(2, La),
    Fr(3, Fh)
  ], Es);
  let Fk = class extends Es {
    constructor(e, t, i, n, o, r, a, l) {
      super(e, i, a, l), this._contextViewService = t, this._keybindingService = n, this._themeService = o, this._notificationService = r, this._widget = null, this._findOptionsWidget = null;
    }
    _start(e, t) {
      const i = Object.create(null, {
        _start: { get: () => super._start }
      });
      return hh(this, void 0, void 0, function* () {
        this._widget || this._createFindWidget();
        const n = this._editor.getSelection();
        let o = !1;
        switch (this._editor.getOption(35).autoFindInSelection) {
          case "always":
            o = !0;
            break;
          case "never":
            o = !1;
            break;
          case "multiline": {
            o = !!n && n.startLineNumber !== n.endLineNumber;
            break;
          }
        }
        e.updateSearchScope = e.updateSearchScope || o, yield i._start.call(this, e, t), this._widget && (e.shouldFocus === 2 ? this._widget.focusReplaceInput() : e.shouldFocus === 1 && this._widget.focusFindInput());
      });
    }
    highlightFindOptions(e = !1) {
      this._widget || this._createFindWidget(), this._state.isRevealed && !e ? this._widget.highlightFindOptions() : this._findOptionsWidget.highlightFindOptions();
    }
    _createFindWidget() {
      this._widget = this._register(new $C(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService)), this._findOptionsWidget = this._register(new UC(this._editor, this._state, this._keybindingService, this._themeService));
    }
  };
  Fk = j7([
    Fr(1, m_),
    Fr(2, Fe),
    Fr(3, ci),
    Fr(4, jt),
    Fr(5, yi),
    Fr(6, La),
    Fr(7, Fh)
  ], Fk);
  const Ote = WP(new BP({
    id: Ft.StartFindAction,
    label: m("startFindAction", "Find"),
    alias: "Find",
    precondition: ce.or(T.focus, ce.has("editorIsOpen")),
    kbOpts: {
      kbExpr: null,
      primary: 2084,
      weight: 100
    },
    menuOpts: {
      menuId: A.MenubarEditMenu,
      group: "3_find",
      title: m({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
      order: 1
    }
  }));
  Ote.addImplementation(0, (s, e, t) => {
    const i = Es.get(e);
    return i ? i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: e.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
      seedSearchStringFromNonEmptySelection: e.getOption(35).seedSearchStringFromSelection === "selection",
      seedSearchStringFromGlobalClipboard: e.getOption(35).globalFindClipboard,
      shouldFocus: 1,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: e.getOption(35).loop
    }) : !1;
  });
  const Pte = {
    description: "Open a new In-Editor Find Widget.",
    args: [{
      name: "Open a new In-Editor Find Widget args",
      schema: {
        properties: {
          searchString: { type: "string" },
          replaceString: { type: "string" },
          regex: { type: "boolean" },
          regexOverride: {
            type: "number",
            description: m("actions.find.isRegexOverride", `Overrides "Use Regular Expression" flag.
The flag will not be saved for the future.
0: Do Nothing
1: True
2: False`)
          },
          wholeWord: { type: "boolean" },
          wholeWordOverride: {
            type: "number",
            description: m("actions.find.wholeWordOverride", `Overrides "Match Whole Word" flag.
The flag will not be saved for the future.
0: Do Nothing
1: True
2: False`)
          },
          matchCase: { type: "boolean" },
          matchCaseOverride: {
            type: "number",
            description: m("actions.find.matchCaseOverride", `Overrides "Math Case" flag.
The flag will not be saved for the future.
0: Do Nothing
1: True
2: False`)
          },
          preserveCase: { type: "boolean" },
          preserveCaseOverride: {
            type: "number",
            description: m("actions.find.preserveCaseOverride", `Overrides "Preserve Case" flag.
The flag will not be saved for the future.
0: Do Nothing
1: True
2: False`)
          },
          findInSelection: { type: "boolean" }
        }
      }
    }]
  };
  class Fte extends ge {
    constructor() {
      super({
        id: Ft.StartFindWithArgs,
        label: m("startFindWithArgsAction", "Find With Arguments"),
        alias: "Find With Arguments",
        precondition: void 0,
        kbOpts: {
          kbExpr: null,
          primary: 0,
          weight: 100
        },
        description: Pte
      });
    }
    run(e, t, i) {
      return hh(this, void 0, void 0, function* () {
        const n = Es.get(t);
        if (n) {
          const o = i ? {
            searchString: i.searchString,
            replaceString: i.replaceString,
            isReplaceRevealed: i.replaceString !== void 0,
            isRegex: i.isRegex,
            wholeWord: i.matchWholeWord,
            matchCase: i.isCaseSensitive,
            preserveCase: i.preserveCase
          } : {};
          yield n.start({
            forceRevealReplace: !1,
            seedSearchStringFromSelection: n.getState().searchString.length === 0 && t.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
            seedSearchStringFromNonEmptySelection: t.getOption(35).seedSearchStringFromSelection === "selection",
            seedSearchStringFromGlobalClipboard: !0,
            shouldFocus: 1,
            shouldAnimate: !0,
            updateSearchScope: i?.findInSelection || !1,
            loop: t.getOption(35).loop
          }, o), n.setGlobalBufferTerm(n.getState().searchString);
        }
      });
    }
  }
  class Bte extends ge {
    constructor() {
      super({
        id: Ft.StartFindWithSelection,
        label: m("startFindWithSelectionAction", "Find With Selection"),
        alias: "Find With Selection",
        precondition: void 0,
        kbOpts: {
          kbExpr: null,
          primary: 0,
          mac: {
            primary: 2083
          },
          weight: 100
        }
      });
    }
    run(e, t) {
      return hh(this, void 0, void 0, function* () {
        const i = Es.get(t);
        i && (yield i.start({
          forceRevealReplace: !1,
          seedSearchStringFromSelection: "multiple",
          seedSearchStringFromNonEmptySelection: !1,
          seedSearchStringFromGlobalClipboard: !1,
          shouldFocus: 0,
          shouldAnimate: !0,
          updateSearchScope: !1,
          loop: t.getOption(35).loop
        }), i.setGlobalBufferTerm(i.getState().searchString));
      });
    }
  }
  class q7 extends ge {
    run(e, t) {
      return hh(this, void 0, void 0, function* () {
        const i = Es.get(t);
        i && !this._run(i) && (yield i.start({
          forceRevealReplace: !1,
          seedSearchStringFromSelection: i.getState().searchString.length === 0 && t.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: t.getOption(35).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: !0,
          shouldFocus: 0,
          shouldAnimate: !0,
          updateSearchScope: !1,
          loop: t.getOption(35).loop
        }), this._run(i));
      });
    }
  }
  class Wte extends q7 {
    constructor() {
      super({
        id: Ft.NextMatchFindAction,
        label: m("findNextMatchAction", "Find Next"),
        alias: "Find Next",
        precondition: void 0,
        kbOpts: [{
          kbExpr: T.focus,
          primary: 61,
          mac: { primary: 2085, secondary: [61] },
          weight: 100
        }, {
          kbExpr: ce.and(T.focus, zC),
          primary: 3,
          weight: 100
        }]
      });
    }
    _run(e) {
      return e.moveToNextMatch() ? (e.editor.pushUndoStop(), !0) : !1;
    }
  }
  class Vte extends q7 {
    constructor() {
      super({
        id: Ft.PreviousMatchFindAction,
        label: m("findPreviousMatchAction", "Find Previous"),
        alias: "Find Previous",
        precondition: void 0,
        kbOpts: [
          {
            kbExpr: T.focus,
            primary: 1085,
            mac: { primary: 3109, secondary: [1085] },
            weight: 100
          },
          {
            kbExpr: ce.and(T.focus, zC),
            primary: 1027,
            weight: 100
          }
        ]
      });
    }
    _run(e) {
      return e.moveToPrevMatch();
    }
  }
  class G7 extends ge {
    run(e, t) {
      return hh(this, void 0, void 0, function* () {
        const i = Es.get(t);
        if (!i)
          return;
        const n = t.getOption(35).seedSearchStringFromSelection === "selection";
        let o = null;
        t.getOption(35).seedSearchStringFromSelection !== "never" && (o = Pk(t, "single", n)), o && i.setSearchString(o), this._run(i) || (yield i.start({
          forceRevealReplace: !1,
          seedSearchStringFromSelection: t.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: n,
          seedSearchStringFromGlobalClipboard: !1,
          shouldFocus: 0,
          shouldAnimate: !0,
          updateSearchScope: !1,
          loop: t.getOption(35).loop
        }), this._run(i));
      });
    }
  }
  class Hte extends G7 {
    constructor() {
      super({
        id: Ft.NextSelectionMatchFindAction,
        label: m("nextSelectionMatchFindAction", "Find Next Selection"),
        alias: "Find Next Selection",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 2109,
          weight: 100
        }
      });
    }
    _run(e) {
      return e.moveToNextMatch();
    }
  }
  class zte extends G7 {
    constructor() {
      super({
        id: Ft.PreviousSelectionMatchFindAction,
        label: m("previousSelectionMatchFindAction", "Find Previous Selection"),
        alias: "Find Previous Selection",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 3133,
          weight: 100
        }
      });
    }
    _run(e) {
      return e.moveToPrevMatch();
    }
  }
  const Ute = WP(new BP({
    id: Ft.StartFindReplaceAction,
    label: m("startReplace", "Replace"),
    alias: "Replace",
    precondition: ce.or(T.focus, ce.has("editorIsOpen")),
    kbOpts: {
      kbExpr: null,
      primary: 2086,
      mac: { primary: 2596 },
      weight: 100
    },
    menuOpts: {
      menuId: A.MenubarEditMenu,
      group: "3_find",
      title: m({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
      order: 2
    }
  }));
  Ute.addImplementation(0, (s, e, t) => {
    if (!e.hasModel() || e.getOption(81))
      return !1;
    const i = Es.get(e);
    if (!i)
      return !1;
    const n = e.getSelection(), o = i.isFindInputFocused(), r = !n.isEmpty() && n.startLineNumber === n.endLineNumber && e.getOption(35).seedSearchStringFromSelection !== "never" && !o, a = o || r ? 2 : 1;
    return i.start({
      forceRevealReplace: !0,
      seedSearchStringFromSelection: r ? "single" : "none",
      seedSearchStringFromNonEmptySelection: e.getOption(35).seedSearchStringFromSelection === "selection",
      seedSearchStringFromGlobalClipboard: e.getOption(35).seedSearchStringFromSelection !== "never",
      shouldFocus: a,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: e.getOption(35).loop
    });
  });
  vt(Es.ID, Fk);
  oe(Fte);
  oe(Bte);
  oe(Wte);
  oe(Vte);
  oe(Hte);
  oe(zte);
  const Dr = wn.bindToContribution(Es.get);
  se(new Dr({
    id: Ft.CloseFindWidgetCommand,
    precondition: Vc,
    handler: (s) => s.closeFindWidget(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: ce.and(T.focus, ce.not("isComposing")),
      primary: 9,
      secondary: [1033]
    }
  }));
  se(new Dr({
    id: Ft.ToggleCaseSensitiveCommand,
    precondition: void 0,
    handler: (s) => s.toggleCaseSensitive(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: yb.primary,
      mac: yb.mac,
      win: yb.win,
      linux: yb.linux
    }
  }));
  se(new Dr({
    id: Ft.ToggleWholeWordCommand,
    precondition: void 0,
    handler: (s) => s.toggleWholeWords(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: Lb.primary,
      mac: Lb.mac,
      win: Lb.win,
      linux: Lb.linux
    }
  }));
  se(new Dr({
    id: Ft.ToggleRegexCommand,
    precondition: void 0,
    handler: (s) => s.toggleRegex(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: kb.primary,
      mac: kb.mac,
      win: kb.win,
      linux: kb.linux
    }
  }));
  se(new Dr({
    id: Ft.ToggleSearchScopeCommand,
    precondition: void 0,
    handler: (s) => s.toggleSearchScope(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: Db.primary,
      mac: Db.mac,
      win: Db.win,
      linux: Db.linux
    }
  }));
  se(new Dr({
    id: Ft.TogglePreserveCaseCommand,
    precondition: void 0,
    handler: (s) => s.togglePreserveCase(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: xb.primary,
      mac: xb.mac,
      win: xb.win,
      linux: xb.linux
    }
  }));
  se(new Dr({
    id: Ft.ReplaceOneAction,
    precondition: Vc,
    handler: (s) => s.replace(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: 3094
    }
  }));
  se(new Dr({
    id: Ft.ReplaceOneAction,
    precondition: Vc,
    handler: (s) => s.replace(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: ce.and(T.focus, MN),
      primary: 3
    }
  }));
  se(new Dr({
    id: Ft.ReplaceAllAction,
    precondition: Vc,
    handler: (s) => s.replaceAll(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: 2563
    }
  }));
  se(new Dr({
    id: Ft.ReplaceAllAction,
    precondition: Vc,
    handler: (s) => s.replaceAll(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: ce.and(T.focus, MN),
      primary: void 0,
      mac: {
        primary: 2051
      }
    }
  }));
  se(new Dr({
    id: Ft.SelectAllMatchesAction,
    precondition: Vc,
    handler: (s) => s.selectAllMatches(),
    kbOpts: {
      weight: 100 + 5,
      kbExpr: T.focus,
      primary: 515
    }
  }));
  const zA = 65535, el = 16777215, UA = 4278190080;
  class Ep {
    constructor(e, t, i) {
      if (e.length !== t.length || e.length > zA)
        throw new Error("invalid startIndexes or endIndexes size");
      this._startIndexes = e, this._endIndexes = t, this._collapseStates = new Uint32Array(Math.ceil(e.length / 32)), this._types = i, this._parentsComputed = !1;
    }
    ensureParentIndices() {
      if (!this._parentsComputed) {
        this._parentsComputed = !0;
        let e = [], t = (i, n) => {
          let o = e[e.length - 1];
          return this.getStartLineNumber(o) <= i && this.getEndLineNumber(o) >= n;
        };
        for (let i = 0, n = this._startIndexes.length; i < n; i++) {
          let o = this._startIndexes[i], r = this._endIndexes[i];
          if (o > el || r > el)
            throw new Error("startLineNumber or endLineNumber must not exceed " + el);
          for (; e.length > 0 && !t(o, r); )
            e.pop();
          let a = e.length > 0 ? e[e.length - 1] : -1;
          e.push(i), this._startIndexes[i] = o + ((a & 255) << 24), this._endIndexes[i] = r + ((a & 65280) << 16);
        }
      }
    }
    get length() {
      return this._startIndexes.length;
    }
    getStartLineNumber(e) {
      return this._startIndexes[e] & el;
    }
    getEndLineNumber(e) {
      return this._endIndexes[e] & el;
    }
    getType(e) {
      return this._types ? this._types[e] : void 0;
    }
    hasTypes() {
      return !!this._types;
    }
    isCollapsed(e) {
      let t = e / 32 | 0, i = e % 32;
      return (this._collapseStates[t] & 1 << i) !== 0;
    }
    setCollapsed(e, t) {
      let i = e / 32 | 0, n = e % 32, o = this._collapseStates[i];
      t ? this._collapseStates[i] = o | 1 << n : this._collapseStates[i] = o & ~(1 << n);
    }
    setCollapsedAllOfType(e, t) {
      let i = !1;
      if (this._types)
        for (let n = 0; n < this._types.length; n++)
          this._types[n] === e && (this.setCollapsed(n, t), i = !0);
      return i;
    }
    toRegion(e) {
      return new $te(this, e);
    }
    getParentIndex(e) {
      this.ensureParentIndices();
      let t = ((this._startIndexes[e] & UA) >>> 24) + ((this._endIndexes[e] & UA) >>> 16);
      return t === zA ? -1 : t;
    }
    contains(e, t) {
      return this.getStartLineNumber(e) <= t && this.getEndLineNumber(e) >= t;
    }
    findIndex(e) {
      let t = 0, i = this._startIndexes.length;
      if (i === 0)
        return -1;
      for (; t < i; ) {
        let n = Math.floor((t + i) / 2);
        e < this.getStartLineNumber(n) ? i = n : t = n + 1;
      }
      return t - 1;
    }
    findRange(e) {
      let t = this.findIndex(e);
      if (t >= 0) {
        if (this.getEndLineNumber(t) >= e)
          return t;
        for (t = this.getParentIndex(t); t !== -1; ) {
          if (this.contains(t, e))
            return t;
          t = this.getParentIndex(t);
        }
      }
      return -1;
    }
    toString() {
      let e = [];
      for (let t = 0; t < this.length; t++)
        e[t] = `[${this.isCollapsed(t) ? "+" : "-"}] ${this.getStartLineNumber(t)}/${this.getEndLineNumber(t)}`;
      return e.join(", ");
    }
  }
  class $te {
    constructor(e, t) {
      this.ranges = e, this.index = t;
    }
    get startLineNumber() {
      return this.ranges.getStartLineNumber(this.index);
    }
    get endLineNumber() {
      return this.ranges.getEndLineNumber(this.index);
    }
    get regionIndex() {
      return this.index;
    }
    get parentIndex() {
      return this.ranges.getParentIndex(this.index);
    }
    get isCollapsed() {
      return this.ranges.isCollapsed(this.index);
    }
    containedBy(e) {
      return e.startLineNumber <= this.startLineNumber && e.endLineNumber >= this.endLineNumber;
    }
    containsLine(e) {
      return this.startLineNumber <= e && e <= this.endLineNumber;
    }
  }
  class jte {
    constructor(e, t) {
      this._updateEventEmitter = new B(), this.onDidChange = this._updateEventEmitter.event, this._textModel = e, this._decorationProvider = t, this._regions = new Ep(new Uint32Array(0), new Uint32Array(0)), this._editorDecorationIds = [], this._isInitialized = !1;
    }
    get regions() {
      return this._regions;
    }
    get textModel() {
      return this._textModel;
    }
    get isInitialized() {
      return this._isInitialized;
    }
    toggleCollapseState(e) {
      if (!e.length)
        return;
      e = e.sort((i, n) => i.regionIndex - n.regionIndex);
      const t = {};
      this._decorationProvider.changeDecorations((i) => {
        let n = 0, o = -1, r = -1;
        const a = (l) => {
          for (; n < l; ) {
            const c = this._regions.getEndLineNumber(n), d = this._regions.isCollapsed(n);
            c <= o && i.changeDecorationOptions(this._editorDecorationIds[n], this._decorationProvider.getDecorationOption(d, c <= r)), d && c > r && (r = c), n++;
          }
        };
        for (let l of e) {
          let c = l.regionIndex, d = this._editorDecorationIds[c];
          if (d && !t[d]) {
            t[d] = !0, a(c);
            let h = !this._regions.isCollapsed(c);
            this._regions.setCollapsed(c, h), o = Math.max(o, this._regions.getEndLineNumber(c));
          }
        }
        a(this._regions.length);
      }), this._updateEventEmitter.fire({ model: this, collapseStateChanged: e });
    }
    update(e, t = []) {
      let i = [], n = (h, u) => {
        for (let f of t)
          if (h < f && f <= u)
            return !0;
        return !1;
      }, o = -1, r = (h, u) => {
        const f = e.getStartLineNumber(h), g = e.getEndLineNumber(h);
        u || (u = e.isCollapsed(h)), u && n(f, g) && (u = !1), e.setCollapsed(h, u);
        const _ = this._textModel.getLineMaxColumn(f), b = {
          startLineNumber: f,
          startColumn: Math.max(_ - 1, 1),
          endLineNumber: f,
          endColumn: _
        };
        i.push({ range: b, options: this._decorationProvider.getDecorationOption(u, g <= o) }), u && g > o && (o = g);
      }, a = 0, l = () => {
        for (; a < this._regions.length; ) {
          let h = this._regions.isCollapsed(a);
          if (a++, h)
            return a - 1;
        }
        return -1;
      }, c = 0, d = l();
      for (; d !== -1 && c < e.length; ) {
        let h = this._textModel.getDecorationRange(this._editorDecorationIds[d]);
        if (h) {
          let u = h.startLineNumber;
          if (h.startColumn === Math.max(h.endColumn - 1, 1) && this._textModel.getLineMaxColumn(u) === h.endColumn)
            for (; c < e.length; ) {
              let f = e.getStartLineNumber(c);
              if (u >= f)
                r(c, u === f), c++;
              else
                break;
            }
        }
        d = l();
      }
      for (; c < e.length; )
        r(c, !1), c++;
      this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, i), this._regions = e, this._isInitialized = !0, this._updateEventEmitter.fire({ model: this });
    }
    getMemento() {
      let e = [];
      for (let t = 0; t < this._regions.length; t++)
        if (this._regions.isCollapsed(t)) {
          let i = this._textModel.getDecorationRange(this._editorDecorationIds[t]);
          if (i) {
            let n = i.startLineNumber, o = i.endLineNumber + this._regions.getEndLineNumber(t) - this._regions.getStartLineNumber(t);
            e.push({ startLineNumber: n, endLineNumber: o });
          }
        }
      if (e.length > 0)
        return e;
    }
    applyMemento(e) {
      if (!Array.isArray(e))
        return;
      let t = [];
      for (let i of e) {
        let n = this.getRegionAtLine(i.startLineNumber);
        n && !n.isCollapsed && t.push(n);
      }
      this.toggleCollapseState(t);
    }
    dispose() {
      this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);
    }
    getAllRegionsAtLine(e, t) {
      let i = [];
      if (this._regions) {
        let n = this._regions.findRange(e), o = 1;
        for (; n >= 0; ) {
          let r = this._regions.toRegion(n);
          (!t || t(r, o)) && i.push(r), o++, n = r.parentIndex;
        }
      }
      return i;
    }
    getRegionAtLine(e) {
      if (this._regions) {
        let t = this._regions.findRange(e);
        if (t >= 0)
          return this._regions.toRegion(t);
      }
      return null;
    }
    getRegionsInside(e, t) {
      let i = [], n = e ? e.regionIndex + 1 : 0, o = e ? e.endLineNumber : Number.MAX_VALUE;
      if (t && t.length === 2) {
        const r = [];
        for (let a = n, l = this._regions.length; a < l; a++) {
          let c = this._regions.toRegion(a);
          if (this._regions.getStartLineNumber(a) < o) {
            for (; r.length > 0 && !c.containedBy(r[r.length - 1]); )
              r.pop();
            r.push(c), t(c, r.length) && i.push(c);
          } else
            break;
        }
      } else
        for (let r = n, a = this._regions.length; r < a; r++) {
          let l = this._regions.toRegion(r);
          if (this._regions.getStartLineNumber(r) < o)
            (!t || t(l)) && i.push(l);
          else
            break;
        }
      return i;
    }
  }
  function Kte(s, e, t) {
    let i = [];
    for (let n of t) {
      let o = s.getRegionAtLine(n);
      if (o) {
        const r = !o.isCollapsed;
        if (i.push(o), e > 1) {
          let a = s.getRegionsInside(o, (l, c) => l.isCollapsed !== r && c < e);
          i.push(...a);
        }
      }
    }
    s.toggleCollapseState(i);
  }
  function dg(s, e, t = Number.MAX_VALUE, i) {
    let n = [];
    if (i && i.length > 0)
      for (let o of i) {
        let r = s.getRegionAtLine(o);
        if (r && (r.isCollapsed !== e && n.push(r), t > 1)) {
          let a = s.getRegionsInside(r, (l, c) => l.isCollapsed !== e && c < t);
          n.push(...a);
        }
      }
    else {
      let o = s.getRegionsInside(null, (r, a) => r.isCollapsed !== e && a < t);
      n.push(...o);
    }
    s.toggleCollapseState(n);
  }
  function Z7(s, e, t, i) {
    let n = [];
    for (let o of i) {
      let r = s.getAllRegionsAtLine(o, (a, l) => a.isCollapsed !== e && l <= t);
      n.push(...r);
    }
    s.toggleCollapseState(n);
  }
  function qte(s, e, t) {
    let i = [];
    for (let n of t) {
      let o = s.getAllRegionsAtLine(n, (r) => r.isCollapsed !== e);
      o.length > 0 && i.push(o[0]);
    }
    s.toggleCollapseState(i);
  }
  function Gte(s, e, t, i) {
    let n = (r, a) => a === e && r.isCollapsed !== t && !i.some((l) => r.containsLine(l)), o = s.getRegionsInside(null, n);
    s.toggleCollapseState(o);
  }
  function Y7(s, e, t) {
    let i = [];
    for (let r of t) {
      const a = s.getAllRegionsAtLine(r, void 0);
      a.length > 0 && i.push(a[0]);
    }
    let n = (r) => i.every((a) => !a.containedBy(r) && !r.containedBy(a)) && r.isCollapsed !== e, o = s.getRegionsInside(null, n);
    s.toggleCollapseState(o);
  }
  function AN(s, e, t) {
    let i = s.textModel, n = s.regions, o = [];
    for (let r = n.length - 1; r >= 0; r--)
      if (t !== n.isCollapsed(r)) {
        let a = n.getStartLineNumber(r);
        e.test(i.getLineContent(a)) && o.push(n.toRegion(r));
      }
    s.toggleCollapseState(o);
  }
  function RN(s, e, t) {
    let i = s.regions, n = [];
    for (let o = i.length - 1; o >= 0; o--)
      t !== i.isCollapsed(o) && e === i.getType(o) && n.push(i.toRegion(o));
    s.toggleCollapseState(n);
  }
  function Zte(s, e) {
    let t = null, i = e.getRegionAtLine(s);
    if (i !== null && (t = i.startLineNumber, s === t)) {
      let n = i.parentIndex;
      n !== -1 ? t = e.regions.getStartLineNumber(n) : t = null;
    }
    return t;
  }
  function Yte(s, e) {
    let t = e.getRegionAtLine(s);
    if (t !== null && t.startLineNumber === s) {
      if (s !== t.startLineNumber)
        return t.startLineNumber;
      {
        let i = t.parentIndex, n = 0;
        for (i !== -1 && (n = e.regions.getStartLineNumber(t.parentIndex)); t !== null; )
          if (t.regionIndex > 0) {
            if (t = e.regions.toRegion(t.regionIndex - 1), t.startLineNumber <= n)
              return null;
            if (t.parentIndex === i)
              return t.startLineNumber;
          } else
            return null;
      }
    } else if (e.regions.length > 0)
      for (t = e.regions.toRegion(e.regions.length - 1); t !== null; ) {
        if (t.startLineNumber < s)
          return t.startLineNumber;
        t.regionIndex > 0 ? t = e.regions.toRegion(t.regionIndex - 1) : t = null;
      }
    return null;
  }
  function Xte(s, e) {
    let t = e.getRegionAtLine(s);
    if (t !== null && t.startLineNumber === s) {
      let i = t.parentIndex, n = 0;
      if (i !== -1)
        n = e.regions.getEndLineNumber(t.parentIndex);
      else {
        if (e.regions.length === 0)
          return null;
        n = e.regions.getEndLineNumber(e.regions.length - 1);
      }
      for (; t !== null; )
        if (t.regionIndex < e.regions.length) {
          if (t = e.regions.toRegion(t.regionIndex + 1), t.startLineNumber >= n)
            return null;
          if (t.parentIndex === i)
            return t.startLineNumber;
        } else
          return null;
    } else if (e.regions.length > 0)
      for (t = e.regions.toRegion(0); t !== null; ) {
        if (t.startLineNumber > s)
          return t.startLineNumber;
        t.regionIndex < e.regions.length ? t = e.regions.toRegion(t.regionIndex + 1) : t = null;
      }
    return null;
  }
  class Qte {
    constructor(e) {
      this._updateEventEmitter = new B(), this._hasLineChanges = !1, this._foldingModel = e, this._foldingModelListener = e.onDidChange((t) => this.updateHiddenRanges()), this._hiddenRanges = [], e.regions.length && this.updateHiddenRanges();
    }
    get onDidChange() {
      return this._updateEventEmitter.event;
    }
    get hiddenRanges() {
      return this._hiddenRanges;
    }
    notifyChangeModelContent(e) {
      this._hiddenRanges.length && !this._hasLineChanges && (this._hasLineChanges = e.changes.some((t) => t.range.endLineNumber !== t.range.startLineNumber || eh(t.text)[0] !== 0));
    }
    updateHiddenRanges() {
      let e = !1, t = [], i = 0, n = 0, o = Number.MAX_VALUE, r = -1, a = this._foldingModel.regions;
      for (; i < a.length; i++) {
        if (!a.isCollapsed(i))
          continue;
        let l = a.getStartLineNumber(i) + 1, c = a.getEndLineNumber(i);
        o <= l && c <= r || (!e && n < this._hiddenRanges.length && this._hiddenRanges[n].startLineNumber === l && this._hiddenRanges[n].endLineNumber === c ? (t.push(this._hiddenRanges[n]), n++) : (e = !0, t.push(new D(l, 1, c, 1))), o = l, r = c);
      }
      (this._hasLineChanges || e || n < this._hiddenRanges.length) && this.applyHiddenRanges(t);
    }
    applyMemento(e) {
      if (!Array.isArray(e) || e.length === 0)
        return !1;
      let t = [];
      for (let i of e) {
        if (!i.startLineNumber || !i.endLineNumber)
          return !1;
        t.push(new D(i.startLineNumber + 1, 1, i.endLineNumber, 1));
      }
      return this.applyHiddenRanges(t), !0;
    }
    getMemento() {
      return this._hiddenRanges.map((e) => ({ startLineNumber: e.startLineNumber - 1, endLineNumber: e.endLineNumber }));
    }
    applyHiddenRanges(e) {
      this._hiddenRanges = e, this._hasLineChanges = !1, this._updateEventEmitter.fire(e);
    }
    hasRanges() {
      return this._hiddenRanges.length > 0;
    }
    isHidden(e) {
      return $A(this._hiddenRanges, e) !== null;
    }
    adjustSelections(e) {
      let t = !1, i = this._foldingModel.textModel, n = null, o = (r) => ((!n || !Jte(r, n)) && (n = $A(this._hiddenRanges, r)), n ? n.startLineNumber - 1 : null);
      for (let r = 0, a = e.length; r < a; r++) {
        let l = e[r], c = o(l.startLineNumber);
        c && (l = l.setStartPosition(c, i.getLineMaxColumn(c)), t = !0);
        let d = o(l.endLineNumber);
        d && (l = l.setEndPosition(d, i.getLineMaxColumn(d)), t = !0), e[r] = l;
      }
      return t;
    }
    dispose() {
      this.hiddenRanges.length > 0 && (this._hiddenRanges = [], this._updateEventEmitter.fire(this._hiddenRanges)), this._foldingModelListener && (this._foldingModelListener.dispose(), this._foldingModelListener = null);
    }
  }
  function Jte(s, e) {
    return s >= e.startLineNumber && s <= e.endLineNumber;
  }
  function $A(s, e) {
    let t = jP(s, (i) => e < i.startLineNumber) - 1;
    return t >= 0 && s[t].endLineNumber >= e ? s[t] : null;
  }
  const eie = 5e3, tie = "indent";
  class iie {
    constructor(e, t, i) {
      this.editorModel = e, this.languageConfigurationService = t, this.maxFoldingRegions = i, this.id = tie;
    }
    dispose() {
    }
    compute(e, t) {
      let i = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules, n = i && !!i.offSide, o = i && i.markers;
      return Promise.resolve(sie(this.editorModel, n, o, this.maxFoldingRegions, t));
    }
  }
  class nie {
    constructor(e, t) {
      this._notifyTooManyRegions = t, this._startIndexes = [], this._endIndexes = [], this._indentOccurrences = [], this._length = 0, this._foldingRangesLimit = e;
    }
    insertFirst(e, t, i) {
      if (e > el || t > el)
        return;
      let n = this._length;
      this._startIndexes[n] = e, this._endIndexes[n] = t, this._length++, i < 1e3 && (this._indentOccurrences[i] = (this._indentOccurrences[i] || 0) + 1);
    }
    toIndentRanges(e) {
      if (this._length <= this._foldingRangesLimit) {
        let t = new Uint32Array(this._length), i = new Uint32Array(this._length);
        for (let n = this._length - 1, o = 0; n >= 0; n--, o++)
          t[o] = this._startIndexes[n], i[o] = this._endIndexes[n];
        return new Ep(t, i);
      } else {
        this._notifyTooManyRegions && this._notifyTooManyRegions(this._foldingRangesLimit);
        let t = 0, i = this._indentOccurrences.length;
        for (let a = 0; a < this._indentOccurrences.length; a++) {
          let l = this._indentOccurrences[a];
          if (l) {
            if (l + t > this._foldingRangesLimit) {
              i = a;
              break;
            }
            t += l;
          }
        }
        const n = e.getOptions().tabSize;
        let o = new Uint32Array(this._foldingRangesLimit), r = new Uint32Array(this._foldingRangesLimit);
        for (let a = this._length - 1, l = 0; a >= 0; a--) {
          let c = this._startIndexes[a], d = e.getLineContent(c), h = cC(d, n);
          (h < i || h === i && t++ < this._foldingRangesLimit) && (o[l] = c, r[l] = this._endIndexes[a], l++);
        }
        return new Ep(o, r);
      }
    }
  }
  function sie(s, e, t, i, n) {
    const o = s.getOptions().tabSize;
    i = i ?? eie;
    let r = new nie(i, n), a;
    t && (a = new RegExp(`(${t.start.source})|(?:${t.end.source})`));
    let l = [], c = s.getLineCount() + 1;
    l.push({ indent: -1, endAbove: c, line: c });
    for (let d = s.getLineCount(); d > 0; d--) {
      let h = s.getLineContent(d), u = cC(h, o), f = l[l.length - 1];
      if (u === -1) {
        e && (f.endAbove = d);
        continue;
      }
      let g;
      if (a && (g = h.match(a)))
        if (g[1]) {
          let _ = l.length - 1;
          for (; _ > 0 && l[_].indent !== -2; )
            _--;
          if (_ > 0) {
            l.length = _ + 1, f = l[_], r.insertFirst(d, f.line, u), f.line = d, f.indent = u, f.endAbove = d;
            continue;
          }
        } else {
          l.push({ indent: -2, endAbove: d, line: d });
          continue;
        }
      if (f.indent > u) {
        do
          l.pop(), f = l[l.length - 1];
        while (f.indent > u);
        let _ = f.endAbove - 1;
        _ - d >= 1 && r.insertFirst(d, _, u);
      }
      f.indent === u ? f.endAbove = d : l.push({ indent: u, endAbove: d, line: d });
    }
    return r.toIndentRanges(s);
  }
  const oie = {}, X7 = "syntax";
  class rie {
    constructor(e, t, i, n) {
      this.editorModel = e, this.providers = t, this.limit = n, this.id = X7;
      for (const o of t)
        typeof o.onDidChange == "function" && (this.disposables || (this.disposables = new te()), this.disposables.add(o.onDidChange(i)));
    }
    compute(e, t) {
      return aie(this.providers, this.editorModel, e).then((i) => i ? Q7(i, this.limit, t) : null);
    }
    dispose() {
      var e;
      (e = this.disposables) === null || e === void 0 || e.dispose();
    }
  }
  function aie(s, e, t) {
    let i = null, n = s.map((o, r) => Promise.resolve(o.provideFoldingRanges(e, oie, t)).then((a) => {
      if (!t.isCancellationRequested && Array.isArray(a)) {
        Array.isArray(i) || (i = []);
        let l = e.getLineCount();
        for (let c of a)
          c.start > 0 && c.end > c.start && c.end <= l && i.push({ start: c.start, end: c.end, rank: r, kind: c.kind });
      }
    }, Xi));
    return Promise.all(n).then((o) => i);
  }
  class lie {
    constructor(e, t) {
      this._notifyTooManyRegions = t, this._startIndexes = [], this._endIndexes = [], this._nestingLevels = [], this._nestingLevelCounts = [], this._types = [], this._length = 0, this._foldingRangesLimit = e;
    }
    add(e, t, i, n) {
      if (e > el || t > el)
        return;
      let o = this._length;
      this._startIndexes[o] = e, this._endIndexes[o] = t, this._nestingLevels[o] = n, this._types[o] = i, this._length++, n < 30 && (this._nestingLevelCounts[n] = (this._nestingLevelCounts[n] || 0) + 1);
    }
    toIndentRanges() {
      if (this._length <= this._foldingRangesLimit) {
        let e = new Uint32Array(this._length), t = new Uint32Array(this._length);
        for (let i = 0; i < this._length; i++)
          e[i] = this._startIndexes[i], t[i] = this._endIndexes[i];
        return new Ep(e, t, this._types);
      } else {
        this._notifyTooManyRegions && this._notifyTooManyRegions(this._foldingRangesLimit);
        let e = 0, t = this._nestingLevelCounts.length;
        for (let r = 0; r < this._nestingLevelCounts.length; r++) {
          let a = this._nestingLevelCounts[r];
          if (a) {
            if (a + e > this._foldingRangesLimit) {
              t = r;
              break;
            }
            e += a;
          }
        }
        let i = new Uint32Array(this._foldingRangesLimit), n = new Uint32Array(this._foldingRangesLimit), o = [];
        for (let r = 0, a = 0; r < this._length; r++) {
          let l = this._nestingLevels[r];
          (l < t || l === t && e++ < this._foldingRangesLimit) && (i[a] = this._startIndexes[r], n[a] = this._endIndexes[r], o[a] = this._types[r], a++);
        }
        return new Ep(i, n, o);
      }
    }
  }
  function Q7(s, e, t) {
    let i = s.sort((a, l) => {
      let c = a.start - l.start;
      return c === 0 && (c = a.rank - l.rank), c;
    }), n = new lie(e, t), o, r = [];
    for (let a of i)
      if (!o)
        o = a, n.add(a.start, a.end, a.kind && a.kind.value, r.length);
      else if (a.start > o.start)
        if (a.end <= o.end)
          r.push(o), o = a, n.add(a.start, a.end, a.kind && a.kind.value, r.length);
        else {
          if (a.start > o.end) {
            do
              o = r.pop();
            while (o && a.start > o.end);
            o && r.push(o), o = a;
          }
          n.add(a.start, a.end, a.kind && a.kind.value, r.length);
        }
    return n.toIndentRanges();
  }
  const J7 = "init";
  class cie {
    constructor(e, t, i, n) {
      if (this.editorModel = e, this.id = J7, t.length) {
        let o = (r) => ({
          range: {
            startLineNumber: r.startLineNumber,
            startColumn: 0,
            endLineNumber: r.endLineNumber,
            endColumn: e.getLineLength(r.endLineNumber)
          },
          options: {
            description: "folding-initializing-range-provider",
            stickiness: 1
          }
        });
        this.decorationIds = e.deltaDecorations([], t.map(o)), this.timeout = setTimeout(i, n);
      }
    }
    dispose() {
      this.decorationIds && (this.editorModel.deltaDecorations(this.decorationIds, []), this.decorationIds = void 0), typeof this.timeout == "number" && (clearTimeout(this.timeout), this.timeout = void 0);
    }
    compute(e) {
      let t = [];
      if (this.decorationIds)
        for (let i of this.decorationIds) {
          let n = this.editorModel.getDecorationRange(i);
          n && t.push({ start: n.startLineNumber, end: n.endLineNumber, rank: 1 });
        }
      return Promise.resolve(Q7(t, Number.MAX_VALUE));
    }
  }
  const ON = Vi("folding-expanded", p.chevronDown, m("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin.")), PN = Vi("folding-collapsed", p.chevronRight, m("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin."));
  class zo {
    constructor(e) {
      this.editor = e, this.autoHideFoldingControls = !0, this.showFoldingHighlights = !0;
    }
    getDecorationOption(e, t) {
      return t ? zo.HIDDEN_RANGE_DECORATION : e ? this.showFoldingHighlights ? zo.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : zo.COLLAPSED_VISUAL_DECORATION : this.autoHideFoldingControls ? zo.EXPANDED_AUTO_HIDE_VISUAL_DECORATION : zo.EXPANDED_VISUAL_DECORATION;
    }
    deltaDecorations(e, t) {
      return this.editor.deltaDecorations(e, t);
    }
    changeDecorations(e) {
      return this.editor.changeDecorations(e);
    }
  }
  zo.COLLAPSED_VISUAL_DECORATION = $e.register({
    description: "folding-collapsed-visual-decoration",
    stickiness: 1,
    afterContentClassName: "inline-folded",
    isWholeLine: !0,
    firstLineDecorationClassName: Tt.asClassName(PN)
  });
  zo.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = $e.register({
    description: "folding-collapsed-highlighted-visual-decoration",
    stickiness: 1,
    afterContentClassName: "inline-folded",
    className: "folded-background",
    isWholeLine: !0,
    firstLineDecorationClassName: Tt.asClassName(PN)
  });
  zo.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = $e.register({
    description: "folding-expanded-auto-hide-visual-decoration",
    stickiness: 1,
    isWholeLine: !0,
    firstLineDecorationClassName: Tt.asClassName(ON)
  });
  zo.EXPANDED_VISUAL_DECORATION = $e.register({
    description: "folding-expanded-visual-decoration",
    stickiness: 1,
    isWholeLine: !0,
    firstLineDecorationClassName: "alwaysShowFoldIcons " + Tt.asClassName(ON)
  });
  zo.HIDDEN_RANGE_DECORATION = $e.register({
    description: "folding-hidden-range-decoration",
    stickiness: 1
  });
  var die = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Rg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Yn = new ue("foldingEnabled", !1);
  let Rf = class e9 extends z {
    constructor(e, t, i, n, o, r) {
      super(), this.contextKeyService = t, this.languageConfigurationService = i, this.languageFeaturesService = r, this._tooManyRegionsNotified = !1, this.localToDispose = this._register(new te()), this.editor = e;
      const a = this.editor.getOptions();
      this._isEnabled = a.get(37), this._useFoldingProviders = a.get(38) !== "indentation", this._unfoldOnClickAfterEndOfLine = a.get(42), this._restoringViewState = !1, this._currentModelHasFoldedImports = !1, this._foldingImportsByDefault = a.get(40), this._maxFoldingRegions = a.get(41), this.updateDebounceInfo = o.for(r.foldingRangeProvider, "Folding", { min: 200 }), this.foldingModel = null, this.hiddenRangeModel = null, this.rangeProvider = null, this.foldingRegionPromise = null, this.foldingStateMemento = null, this.foldingModelPromise = null, this.updateScheduler = null, this.cursorChangedScheduler = null, this.mouseDownInfo = null, this.foldingDecorationProvider = new zo(e), this.foldingDecorationProvider.autoHideFoldingControls = a.get(99) === "mouseover", this.foldingDecorationProvider.showFoldingHighlights = a.get(39), this.foldingEnabled = Yn.bindTo(this.contextKeyService), this.foldingEnabled.set(this._isEnabled), this._notifyTooManyRegions = (l) => {
        this._tooManyRegionsNotified || (n.notify({
          severity: Zt.Warning,
          sticky: !0,
          message: m("maximum fold ranges", `The number of foldable regions is limited to a maximum of {0}. Increase configuration option ['Folding Maximum Regions'](command:workbench.action.openSettings?["editor.foldingMaximumRegions"]) to enable more.`, l)
        }), this._tooManyRegionsNotified = !0);
      }, this._register(this.editor.onDidChangeModel(() => this.onModelChanged())), this._register(this.editor.onDidChangeConfiguration((l) => {
        if (l.hasChanged(37) && (this._isEnabled = this.editor.getOptions().get(37), this.foldingEnabled.set(this._isEnabled), this.onModelChanged()), l.hasChanged(41) && (this._maxFoldingRegions = this.editor.getOptions().get(41), this._tooManyRegionsNotified = !1, this.onModelChanged()), l.hasChanged(99) || l.hasChanged(39)) {
          const c = this.editor.getOptions();
          this.foldingDecorationProvider.autoHideFoldingControls = c.get(99) === "mouseover", this.foldingDecorationProvider.showFoldingHighlights = c.get(39), this.triggerFoldingModelChanged();
        }
        l.hasChanged(38) && (this._useFoldingProviders = this.editor.getOptions().get(38) !== "indentation", this.onFoldingStrategyChanged()), l.hasChanged(42) && (this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(42)), l.hasChanged(40) && (this._foldingImportsByDefault = this.editor.getOptions().get(40));
      })), this.onModelChanged();
    }
    static get(e) {
      return e.getContribution(e9.ID);
    }
    saveViewState() {
      let e = this.editor.getModel();
      if (!e || !this._isEnabled || e.isTooLargeForTokenization())
        return {};
      if (this.foldingModel) {
        let t = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento(), i = this.rangeProvider ? this.rangeProvider.id : void 0;
        return { collapsedRegions: t, lineCount: e.getLineCount(), provider: i, foldedImports: this._currentModelHasFoldedImports };
      }
    }
    restoreViewState(e) {
      let t = this.editor.getModel();
      if (!t || !this._isEnabled || t.isTooLargeForTokenization() || !this.hiddenRangeModel || !e || e.lineCount !== t.getLineCount() || (this._currentModelHasFoldedImports = !!e.foldedImports, !e.collapsedRegions))
        return;
      (e.provider === X7 || e.provider === J7) && (this.foldingStateMemento = e);
      const i = e.collapsedRegions;
      if (this.hiddenRangeModel.applyMemento(i)) {
        const n = this.getFoldingModel();
        n && n.then((o) => {
          if (o) {
            this._restoringViewState = !0;
            try {
              o.applyMemento(i);
            } finally {
              this._restoringViewState = !1;
            }
          }
        }).then(void 0, We);
      }
    }
    onModelChanged() {
      this.localToDispose.clear();
      let e = this.editor.getModel();
      !this._isEnabled || !e || e.isTooLargeForTokenization() || (this._currentModelHasFoldedImports = !1, this.foldingModel = new jte(e, this.foldingDecorationProvider), this.localToDispose.add(this.foldingModel), this.hiddenRangeModel = new Qte(this.foldingModel), this.localToDispose.add(this.hiddenRangeModel), this.localToDispose.add(this.hiddenRangeModel.onDidChange((t) => this.onHiddenRangesChanges(t))), this.updateScheduler = new ca(this.updateDebounceInfo.get(e)), this.cursorChangedScheduler = new It(() => this.revealCursor(), 200), this.localToDispose.add(this.cursorChangedScheduler), this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelContent((t) => this.onDidChangeModelContent(t))), this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged())), this.localToDispose.add(this.editor.onMouseDown((t) => this.onEditorMouseDown(t))), this.localToDispose.add(this.editor.onMouseUp((t) => this.onEditorMouseUp(t))), this.localToDispose.add({
        dispose: () => {
          this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), this.updateScheduler && this.updateScheduler.cancel(), this.updateScheduler = null, this.foldingModel = null, this.foldingModelPromise = null, this.hiddenRangeModel = null, this.cursorChangedScheduler = null, this.foldingStateMemento = null, this.rangeProvider && this.rangeProvider.dispose(), this.rangeProvider = null;
        }
      }), this.triggerFoldingModelChanged());
    }
    onFoldingStrategyChanged() {
      this.rangeProvider && this.rangeProvider.dispose(), this.rangeProvider = null, this.triggerFoldingModelChanged();
    }
    getRangeProvider(e) {
      if (this.rangeProvider)
        return this.rangeProvider;
      if (this.rangeProvider = new iie(e, this.languageConfigurationService, this._maxFoldingRegions), this._useFoldingProviders && this.foldingModel) {
        let t = this.languageFeaturesService.foldingRangeProvider.ordered(this.foldingModel.textModel);
        if (t.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions)
          return this.rangeProvider = new cie(e, this.foldingStateMemento.collapsedRegions, () => {
            this.foldingStateMemento = null, this.onFoldingStrategyChanged();
          }, 3e4);
        t.length > 0 && (this.rangeProvider = new rie(e, t, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions));
      }
      return this.foldingStateMemento = null, this.rangeProvider;
    }
    getFoldingModel() {
      return this.foldingModelPromise;
    }
    onDidChangeModelContent(e) {
      var t;
      (t = this.hiddenRangeModel) === null || t === void 0 || t.notifyChangeModelContent(e), this.triggerFoldingModelChanged();
    }
    triggerFoldingModelChanged() {
      this.updateScheduler && (this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), this.foldingModelPromise = this.updateScheduler.trigger(() => {
        const e = this.foldingModel;
        if (!e)
          return null;
        const t = new hs(!0), i = this.getRangeProvider(e.textModel);
        let n = this.foldingRegionPromise = an((o) => i.compute(o, this._notifyTooManyRegions));
        return n.then((o) => {
          if (o && n === this.foldingRegionPromise) {
            let r;
            if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
              const d = o.setCollapsedAllOfType(br.Imports.value, !0);
              d && (r = kc.capture(this.editor), this._currentModelHasFoldedImports = d);
            }
            let a = this.editor.getSelections(), l = a ? a.map((d) => d.startLineNumber) : [];
            e.update(o, l), r && r.restore(this.editor);
            const c = this.updateDebounceInfo.update(e.textModel, t.elapsed());
            this.updateScheduler && (this.updateScheduler.defaultDelay = c);
          }
          return e;
        });
      }).then(void 0, (e) => (We(e), null)));
    }
    onHiddenRangesChanges(e) {
      if (this.hiddenRangeModel && e.length && !this._restoringViewState) {
        let t = this.editor.getSelections();
        t && this.hiddenRangeModel.adjustSelections(t) && this.editor.setSelections(t);
      }
      this.editor.setHiddenAreas(e);
    }
    onCursorPositionChanged() {
      this.hiddenRangeModel && this.hiddenRangeModel.hasRanges() && this.cursorChangedScheduler.schedule();
    }
    revealCursor() {
      const e = this.getFoldingModel();
      !e || e.then((t) => {
        if (t) {
          let i = this.editor.getSelections();
          if (i && i.length > 0) {
            let n = [];
            for (let o of i) {
              let r = o.selectionStartLineNumber;
              this.hiddenRangeModel && this.hiddenRangeModel.isHidden(r) && n.push(...t.getAllRegionsAtLine(r, (a) => a.isCollapsed && r > a.startLineNumber));
            }
            n.length && (t.toggleCollapseState(n), this.reveal(i[0].getPosition()));
          }
        }
      }).then(void 0, We);
    }
    onEditorMouseDown(e) {
      if (this.mouseDownInfo = null, !this.hiddenRangeModel || !e.target || !e.target.range || !e.event.leftButton && !e.event.middleButton)
        return;
      const t = e.target.range;
      let i = !1;
      switch (e.target.type) {
        case 4: {
          const n = e.target.detail, o = e.target.element.offsetLeft;
          if (n.offsetX - o < 5)
            return;
          i = !0;
          break;
        }
        case 7: {
          if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges() && !e.target.detail.isAfterLines)
            break;
          return;
        }
        case 6: {
          if (this.hiddenRangeModel.hasRanges()) {
            let n = this.editor.getModel();
            if (n && t.startColumn === n.getLineMaxColumn(t.startLineNumber))
              break;
          }
          return;
        }
        default:
          return;
      }
      this.mouseDownInfo = { lineNumber: t.startLineNumber, iconClicked: i };
    }
    onEditorMouseUp(e) {
      const t = this.getFoldingModel();
      if (!t || !this.mouseDownInfo || !e.target)
        return;
      let i = this.mouseDownInfo.lineNumber, n = this.mouseDownInfo.iconClicked, o = e.target.range;
      if (!(!o || o.startLineNumber !== i)) {
        if (n) {
          if (e.target.type !== 4)
            return;
        } else {
          let r = this.editor.getModel();
          if (!r || o.startColumn !== r.getLineMaxColumn(i))
            return;
        }
        t.then((r) => {
          if (r) {
            let a = r.getRegionAtLine(i);
            if (a && a.startLineNumber === i) {
              let l = a.isCollapsed;
              if (n || l) {
                let c = e.event.altKey, d = [];
                if (c) {
                  let h = (f) => !f.containedBy(a) && !a.containedBy(f), u = r.getRegionsInside(null, h);
                  for (const f of u)
                    f.isCollapsed && d.push(f);
                  d.length === 0 && (d = u);
                } else {
                  let h = e.event.middleButton || e.event.shiftKey;
                  if (h)
                    for (const u of r.getRegionsInside(a))
                      u.isCollapsed === l && d.push(u);
                  (l || !h || d.length === 0) && d.push(a);
                }
                r.toggleCollapseState(d), this.reveal({ lineNumber: i, column: 1 });
              }
            }
          }
        }).then(void 0, We);
      }
    }
    reveal(e) {
      this.editor.revealPositionInCenterIfOutsideViewport(e, 0);
    }
  };
  Rf.ID = "editor.contrib.folding";
  Rf = die([
    Rg(1, Fe),
    Rg(2, Mn),
    Rg(3, yi),
    Rg(4, Io),
    Rg(5, me)
  ], Rf);
  class gs extends ge {
    runEditorCommand(e, t, i) {
      const n = e.get(Mn), o = Rf.get(t);
      if (!o)
        return;
      const r = o.getFoldingModel();
      if (r)
        return this.reportTelemetry(e, t), r.then((a) => {
          if (a) {
            this.invoke(o, a, t, i, n);
            const l = t.getSelection();
            l && o.reveal(l.getStartPosition());
          }
        });
    }
    getSelectedLines(e) {
      let t = e.getSelections();
      return t ? t.map((i) => i.startLineNumber) : [];
    }
    getLineNumbers(e, t) {
      return e && e.selectionLines ? e.selectionLines.map((i) => i + 1) : this.getSelectedLines(t);
    }
    run(e, t) {
    }
  }
  function t9(s) {
    if (!Ss(s)) {
      if (!ls(s))
        return !1;
      const e = s;
      if (!Ss(e.levels) && !zd(e.levels) || !Ss(e.direction) && !vo(e.direction) || !Ss(e.selectionLines) && (!X4(e.selectionLines) || !e.selectionLines.every(zd)))
        return !1;
    }
    return !0;
  }
  class hie extends gs {
    constructor() {
      super({
        id: "editor.unfold",
        label: m("unfoldAction.label", "Unfold"),
        alias: "Unfold",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3161,
          mac: {
            primary: 2649
          },
          weight: 100
        },
        description: {
          description: "Unfold the content in the editor",
          args: [
            {
              name: "Unfold editor argument",
              description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
              constraint: t9,
              schema: {
                type: "object",
                properties: {
                  levels: {
                    type: "number",
                    default: 1
                  },
                  direction: {
                    type: "string",
                    enum: ["up", "down"],
                    default: "down"
                  },
                  selectionLines: {
                    type: "array",
                    items: {
                      type: "number"
                    }
                  }
                }
              }
            }
          ]
        }
      });
    }
    invoke(e, t, i, n) {
      let o = n && n.levels || 1, r = this.getLineNumbers(n, i);
      n && n.direction === "up" ? Z7(t, !1, o, r) : dg(t, !1, o, r);
    }
  }
  class uie extends gs {
    constructor() {
      super({
        id: "editor.unfoldRecursively",
        label: m("unFoldRecursivelyAction.label", "Unfold Recursively"),
        alias: "Unfold Recursively",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2137),
          weight: 100
        }
      });
    }
    invoke(e, t, i, n) {
      dg(t, !1, Number.MAX_VALUE, this.getSelectedLines(i));
    }
  }
  class fie extends gs {
    constructor() {
      super({
        id: "editor.fold",
        label: m("foldAction.label", "Fold"),
        alias: "Fold",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3159,
          mac: {
            primary: 2647
          },
          weight: 100
        },
        description: {
          description: "Fold the content in the editor",
          args: [
            {
              name: "Fold editor argument",
              description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
              constraint: t9,
              schema: {
                type: "object",
                properties: {
                  levels: {
                    type: "number"
                  },
                  direction: {
                    type: "string",
                    enum: ["up", "down"]
                  },
                  selectionLines: {
                    type: "array",
                    items: {
                      type: "number"
                    }
                  }
                }
              }
            }
          ]
        }
      });
    }
    invoke(e, t, i, n) {
      let o = this.getLineNumbers(n, i);
      const r = n && n.levels, a = n && n.direction;
      typeof r != "number" && typeof a != "string" ? qte(t, !0, o) : a === "up" ? Z7(t, !0, r || 1, o) : dg(t, !0, r || 1, o);
    }
  }
  class gie extends gs {
    constructor() {
      super({
        id: "editor.toggleFold",
        label: m("toggleFoldAction.label", "Toggle Fold"),
        alias: "Toggle Fold",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2090),
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      let n = this.getSelectedLines(i);
      Kte(t, 1, n);
    }
  }
  class mie extends gs {
    constructor() {
      super({
        id: "editor.foldRecursively",
        label: m("foldRecursivelyAction.label", "Fold Recursively"),
        alias: "Fold Recursively",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2135),
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      let n = this.getSelectedLines(i);
      dg(t, !0, Number.MAX_VALUE, n);
    }
  }
  class pie extends gs {
    constructor() {
      super({
        id: "editor.foldAllBlockComments",
        label: m("foldAllBlockComments.label", "Fold All Block Comments"),
        alias: "Fold All Block Comments",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2133),
          weight: 100
        }
      });
    }
    invoke(e, t, i, n, o) {
      if (t.regions.hasTypes())
        RN(t, br.Comment.value, !0);
      else {
        const r = i.getModel();
        if (!r)
          return;
        const a = o.getLanguageConfiguration(r.getLanguageId()).comments;
        if (a && a.blockCommentStartToken) {
          let l = new RegExp("^\\s*" + wo(a.blockCommentStartToken));
          AN(t, l, !0);
        }
      }
    }
  }
  class _ie extends gs {
    constructor() {
      super({
        id: "editor.foldAllMarkerRegions",
        label: m("foldAllMarkerRegions.label", "Fold All Regions"),
        alias: "Fold All Regions",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2077),
          weight: 100
        }
      });
    }
    invoke(e, t, i, n, o) {
      if (t.regions.hasTypes())
        RN(t, br.Region.value, !0);
      else {
        const r = i.getModel();
        if (!r)
          return;
        const a = o.getLanguageConfiguration(r.getLanguageId()).foldingRules;
        if (a && a.markers && a.markers.start) {
          let l = new RegExp(a.markers.start);
          AN(t, l, !0);
        }
      }
    }
  }
  class bie extends gs {
    constructor() {
      super({
        id: "editor.unfoldAllMarkerRegions",
        label: m("unfoldAllMarkerRegions.label", "Unfold All Regions"),
        alias: "Unfold All Regions",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2078),
          weight: 100
        }
      });
    }
    invoke(e, t, i, n, o) {
      if (t.regions.hasTypes())
        RN(t, br.Region.value, !1);
      else {
        const r = i.getModel();
        if (!r)
          return;
        const a = o.getLanguageConfiguration(r.getLanguageId()).foldingRules;
        if (a && a.markers && a.markers.start) {
          let l = new RegExp(a.markers.start);
          AN(t, l, !1);
        }
      }
    }
  }
  class vie extends gs {
    constructor() {
      super({
        id: "editor.foldAllExcept",
        label: m("foldAllExcept.label", "Fold All Regions Except Selected"),
        alias: "Fold All Regions Except Selected",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2131),
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      let n = this.getSelectedLines(i);
      Y7(t, !0, n);
    }
  }
  class Cie extends gs {
    constructor() {
      super({
        id: "editor.unfoldAllExcept",
        label: m("unfoldAllExcept.label", "Unfold All Regions Except Selected"),
        alias: "Unfold All Regions Except Selected",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2129),
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      let n = this.getSelectedLines(i);
      Y7(t, !1, n);
    }
  }
  class wie extends gs {
    constructor() {
      super({
        id: "editor.foldAll",
        label: m("foldAllAction.label", "Fold All"),
        alias: "Fold All",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2069),
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      dg(t, !0);
    }
  }
  class Sie extends gs {
    constructor() {
      super({
        id: "editor.unfoldAll",
        label: m("unfoldAllAction.label", "Unfold All"),
        alias: "Unfold All",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2088),
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      dg(t, !1);
    }
  }
  class uh extends gs {
    getFoldingLevel() {
      return parseInt(this.id.substr(uh.ID_PREFIX.length));
    }
    invoke(e, t, i) {
      Gte(t, this.getFoldingLevel(), !0, this.getSelectedLines(i));
    }
  }
  uh.ID_PREFIX = "editor.foldLevel";
  uh.ID = (s) => uh.ID_PREFIX + s;
  class yie extends gs {
    constructor() {
      super({
        id: "editor.gotoParentFold",
        label: m("gotoParentFold.label", "Go to Parent Fold"),
        alias: "Go to Parent Fold",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      let n = this.getSelectedLines(i);
      if (n.length > 0) {
        let o = Zte(n[0], t);
        o !== null && i.setSelection({
          startLineNumber: o,
          startColumn: 1,
          endLineNumber: o,
          endColumn: 1
        });
      }
    }
  }
  class Lie extends gs {
    constructor() {
      super({
        id: "editor.gotoPreviousFold",
        label: m("gotoPreviousFold.label", "Go to Previous Folding Range"),
        alias: "Go to Previous Folding Range",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      let n = this.getSelectedLines(i);
      if (n.length > 0) {
        let o = Yte(n[0], t);
        o !== null && i.setSelection({
          startLineNumber: o,
          startColumn: 1,
          endLineNumber: o,
          endColumn: 1
        });
      }
    }
  }
  class kie extends gs {
    constructor() {
      super({
        id: "editor.gotoNextFold",
        label: m("gotoNextFold.label", "Go to Next Folding Range"),
        alias: "Go to Next Folding Range",
        precondition: Yn,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          weight: 100
        }
      });
    }
    invoke(e, t, i) {
      let n = this.getSelectedLines(i);
      if (n.length > 0) {
        let o = Xte(n[0], t);
        o !== null && i.setSelection({
          startLineNumber: o,
          startColumn: 1,
          endLineNumber: o,
          endColumn: 1
        });
      }
    }
  }
  vt(Rf.ID, Rf);
  oe(hie);
  oe(uie);
  oe(fie);
  oe(mie);
  oe(wie);
  oe(Sie);
  oe(pie);
  oe(_ie);
  oe(bie);
  oe(vie);
  oe(Cie);
  oe(gie);
  oe(yie);
  oe(Lie);
  oe(kie);
  for (let s = 1; s <= 7; s++)
    VP(new uh({
      id: uh.ID(s),
      label: m("foldLevelAction.label", "Fold Level {0}", s),
      alias: `Fold Level ${s}`,
      precondition: Yn,
      kbOpts: {
        kbExpr: T.editorTextFocus,
        primary: Qi(2089, 2048 | 21 + s),
        weight: 100
      }
    }));
  const Die = M("editor.foldBackground", { light: Re(sc, 0.3), dark: Re(sc, 0.3), hc: null }, m("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), !0), xie = M("editorGutter.foldingControlForeground", { dark: Uw, light: Uw, hc: Uw }, m("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
  Vt((s, e) => {
    const t = s.getColor(Die);
    t && e.addRule(`.monaco-editor .folded-background { background-color: ${t}; }`);
    const i = s.getColor(xie);
    i && e.addRule(`
		.monaco-editor .cldr${Tt.asCSSSelector(ON)},
		.monaco-editor .cldr${Tt.asCSSSelector(PN)} {
			color: ${i} !important;
		}
		`);
  });
  class Iie extends ge {
    constructor() {
      super({
        id: "editor.action.fontZoomIn",
        label: m("EditorFontZoomIn.label", "Editor Font Zoom In"),
        alias: "Editor Font Zoom In",
        precondition: void 0
      });
    }
    run(e, t) {
      fl.setZoomLevel(fl.getZoomLevel() + 1);
    }
  }
  class Eie extends ge {
    constructor() {
      super({
        id: "editor.action.fontZoomOut",
        label: m("EditorFontZoomOut.label", "Editor Font Zoom Out"),
        alias: "Editor Font Zoom Out",
        precondition: void 0
      });
    }
    run(e, t) {
      fl.setZoomLevel(fl.getZoomLevel() - 1);
    }
  }
  class Nie extends ge {
    constructor() {
      super({
        id: "editor.action.fontZoomReset",
        label: m("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
        alias: "Editor Font Zoom Reset",
        precondition: void 0
      });
    }
    run(e, t) {
      fl.setZoomLevel(0);
    }
  }
  oe(Iie);
  oe(Eie);
  oe(Nie);
  class Of {
    static _handleEolEdits(e, t) {
      let i, n = [];
      for (let o of t)
        typeof o.eol == "number" && (i = o.eol), o.range && typeof o.text == "string" && n.push(o);
      return typeof i == "number" && e.hasModel() && e.getModel().pushEOL(i), n;
    }
    static _isFullModelReplaceEdit(e, t) {
      if (!e.hasModel())
        return !1;
      const i = e.getModel(), n = i.validateRange(t.range);
      return i.getFullModelRange().equalsRange(n);
    }
    static execute(e, t, i) {
      i && e.pushUndoStop();
      const n = Of._handleEolEdits(e, t);
      n.length === 1 && Of._isFullModelReplaceEdit(e, n[0]) ? e.executeEdits("formatEditsCommand", n.map((o) => li.replace(D.lift(o.range), o.text))) : e.executeEdits("formatEditsCommand", n.map((o) => li.replaceMove(D.lift(o.range), o.text))), i && e.pushUndoStop();
    }
  }
  class oy {
    constructor(e) {
      this.value = e, this._lower = e.toLowerCase();
    }
    static toKey(e) {
      return typeof e == "string" ? e.toLowerCase() : e._lower;
    }
  }
  var Sr = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function FN(s) {
    if (s = s.filter((n) => n.range), !s.length)
      return;
    let { range: e } = s[0];
    for (let n = 1; n < s.length; n++)
      e = D.plusRange(e, s[n].range);
    const { startLineNumber: t, endLineNumber: i } = e;
    t === i ? s.length === 1 ? pn(m("hint11", "Made 1 formatting edit on line {0}", t)) : pn(m("hintn1", "Made {0} formatting edits on line {1}", s.length, t)) : s.length === 1 ? pn(m("hint1n", "Made 1 formatting edit between lines {0} and {1}", t, i)) : pn(m("hintnn", "Made {0} formatting edits between lines {1} and {2}", s.length, t, i));
  }
  function i9(s, e, t) {
    const i = [], n = /* @__PURE__ */ new Set(), o = s.ordered(t);
    for (const a of o)
      i.push(a), a.extensionId && n.add(oy.toKey(a.extensionId));
    const r = e.ordered(t);
    for (const a of r) {
      if (a.extensionId) {
        if (n.has(oy.toKey(a.extensionId)))
          continue;
        n.add(oy.toKey(a.extensionId));
      }
      i.push({
        displayName: a.displayName,
        extensionId: a.extensionId,
        provideDocumentFormattingEdits(l, c, d) {
          return a.provideDocumentRangeFormattingEdits(l, l.getFullModelRange(), c, d);
        }
      });
    }
    return i;
  }
  class fh {
    static setFormatterSelector(e) {
      return { dispose: fh._selectors.unshift(e) };
    }
    static select(e, t, i) {
      return Sr(this, void 0, void 0, function* () {
        if (e.length === 0)
          return;
        const n = rt.first(fh._selectors);
        if (n)
          return yield n(e, t, i);
      });
    }
  }
  fh._selectors = new $s();
  function n9(s, e, t, i, n, o) {
    return Sr(this, void 0, void 0, function* () {
      const r = s.get(et), { documentRangeFormattingEditProvider: a } = s.get(me), l = pl(e) ? e.getModel() : e, c = a.ordered(l), d = yield fh.select(c, l, i);
      d && (n.report(d), yield r.invokeFunction(Tie, d, e, t, o));
    });
  }
  function Tie(s, e, t, i, n) {
    return Sr(this, void 0, void 0, function* () {
      const o = s.get(xo);
      let r, a;
      pl(t) ? (r = t.getModel(), a = new mp(t, 5, void 0, n)) : (r = t, a = new GE(t, n));
      let l = [], c = 0;
      for (let g of jI(i).sort(D.compareRangesUsingStarts))
        c > 0 && D.areIntersectingOrTouching(l[c - 1], g) ? l[c - 1] = D.fromPositions(l[c - 1].getStartPosition(), g.getEndPosition()) : c = l.push(g);
      const d = (g) => Sr(this, void 0, void 0, function* () {
        return (yield e.provideDocumentRangeFormattingEdits(r, g, r.getFormattingOptions(), a.token)) || [];
      }), h = (g, _) => {
        if (!g.length || !_.length)
          return !1;
        const b = g.reduce((C, v) => D.plusRange(C, v.range), g[0].range);
        if (!_.some((C) => D.intersectRanges(b, C.range)))
          return !1;
        for (let C of g)
          for (let v of _)
            if (D.intersectRanges(C.range, v.range))
              return !0;
        return !1;
      }, u = [], f = [];
      try {
        for (let g of l) {
          if (a.token.isCancellationRequested)
            return !0;
          f.push(yield d(g));
        }
        for (let g = 0; g < l.length; ++g)
          for (let _ = g + 1; _ < l.length; ++_) {
            if (a.token.isCancellationRequested)
              return !0;
            if (h(f[g], f[_])) {
              const b = D.plusRange(l[g], l[_]), C = yield d(b);
              l.splice(_, 1), l.splice(g, 1), l.push(b), f.splice(_, 1), f.splice(g, 1), f.push(C), g = 0, _ = 0;
            }
          }
        for (let g of f) {
          if (a.token.isCancellationRequested)
            return !0;
          const _ = yield o.computeMoreMinimalEdits(r.uri, g);
          _ && u.push(..._);
        }
      } finally {
        a.dispose();
      }
      if (u.length === 0)
        return !1;
      if (pl(t))
        Of.execute(t, u, !0), FN(u), t.revealPositionInCenterIfOutsideViewport(t.getPosition(), 1);
      else {
        const [{ range: g }] = u, _ = new ae(g.startLineNumber, g.startColumn, g.endLineNumber, g.endColumn);
        r.pushEditOperations([_], u.map((b) => ({
          text: b.text,
          range: D.lift(b.range),
          forceMoveMarkers: !0
        })), (b) => {
          for (const { range: C } of b)
            if (D.areIntersectingOrTouching(C, _))
              return [new ae(C.startLineNumber, C.startColumn, C.endLineNumber, C.endColumn)];
          return null;
        });
      }
      return !0;
    });
  }
  function Mie(s, e, t, i, n) {
    return Sr(this, void 0, void 0, function* () {
      const o = s.get(et), r = s.get(me), a = pl(e) ? e.getModel() : e, l = i9(r.documentFormattingEditProvider, r.documentRangeFormattingEditProvider, a), c = yield fh.select(l, a, t);
      c && (i.report(c), yield o.invokeFunction(Aie, c, e, t, n));
    });
  }
  function Aie(s, e, t, i, n) {
    return Sr(this, void 0, void 0, function* () {
      const o = s.get(xo);
      let r, a;
      pl(t) ? (r = t.getModel(), a = new mp(t, 5, void 0, n)) : (r = t, a = new GE(t, n));
      let l;
      try {
        const c = yield e.provideDocumentFormattingEdits(r, r.getFormattingOptions(), a.token);
        if (l = yield o.computeMoreMinimalEdits(r.uri, c), a.token.isCancellationRequested)
          return !0;
      } finally {
        a.dispose();
      }
      if (!l || l.length === 0)
        return !1;
      if (pl(t))
        Of.execute(t, l, i !== 2), i !== 2 && (FN(l), t.revealPositionInCenterIfOutsideViewport(t.getPosition(), 1));
      else {
        const [{ range: c }] = l, d = new ae(c.startLineNumber, c.startColumn, c.endLineNumber, c.endColumn);
        r.pushEditOperations([d], l.map((h) => ({
          text: h.text,
          range: D.lift(h.range),
          forceMoveMarkers: !0
        })), (h) => {
          for (const { range: u } of h)
            if (D.areIntersectingOrTouching(u, d))
              return [new ae(u.startLineNumber, u.startColumn, u.endLineNumber, u.endColumn)];
          return null;
        });
      }
      return !0;
    });
  }
  function Rie(s, e, t, i, n, o) {
    return Sr(this, void 0, void 0, function* () {
      const r = e.documentRangeFormattingEditProvider.ordered(t);
      for (const a of r) {
        let l = yield Promise.resolve(a.provideDocumentRangeFormattingEdits(t, i, n, o)).catch(Xi);
        if (Ds(l))
          return yield s.computeMoreMinimalEdits(t.uri, l);
      }
    });
  }
  function Oie(s, e, t, i, n) {
    return Sr(this, void 0, void 0, function* () {
      const o = i9(e.documentFormattingEditProvider, e.documentRangeFormattingEditProvider, t);
      for (const r of o) {
        let a = yield Promise.resolve(r.provideDocumentFormattingEdits(t, i, n)).catch(Xi);
        if (Ds(a))
          return yield s.computeMoreMinimalEdits(t.uri, a);
      }
    });
  }
  function s9(s, e, t, i, n, o, r) {
    const a = e.onTypeFormattingEditProvider.ordered(t);
    return a.length === 0 || a[0].autoFormatTriggerCharacters.indexOf(n) < 0 ? Promise.resolve(void 0) : Promise.resolve(a[0].provideOnTypeFormattingEdits(t, i, n, o, r)).catch(Xi).then((l) => s.computeMoreMinimalEdits(t.uri, l));
  }
  lt.registerCommand("_executeFormatRangeProvider", function(s, ...e) {
    return Sr(this, void 0, void 0, function* () {
      const [t, i, n] = e;
      Nt(Ee.isUri(t)), Nt(D.isIRange(i));
      const o = s.get(fs), r = s.get(xo), a = s.get(me), l = yield o.createModelReference(t);
      try {
        return Rie(r, a, l.object.textEditorModel, D.lift(i), n, Je.None);
      } finally {
        l.dispose();
      }
    });
  });
  lt.registerCommand("_executeFormatDocumentProvider", function(s, ...e) {
    return Sr(this, void 0, void 0, function* () {
      const [t, i] = e;
      Nt(Ee.isUri(t));
      const n = s.get(fs), o = s.get(xo), r = s.get(me), a = yield n.createModelReference(t);
      try {
        return Oie(o, r, a.object.textEditorModel, i, Je.None);
      } finally {
        a.dispose();
      }
    });
  });
  lt.registerCommand("_executeFormatOnTypeProvider", function(s, ...e) {
    return Sr(this, void 0, void 0, function* () {
      const [t, i, n, o] = e;
      Nt(Ee.isUri(t)), Nt(V.isIPosition(i)), Nt(typeof n == "string");
      const r = s.get(fs), a = s.get(xo), l = s.get(me), c = yield r.createModelReference(t);
      try {
        return s9(a, l, c.object.textEditorModel, V.lift(i), n, o, Je.None);
      } finally {
        c.dispose();
      }
    });
  });
  var o9 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, K1 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, BN = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Np = class {
    constructor(e, t, i) {
      this._editor = e, this._languageFeaturesService = t, this._workerService = i, this._disposables = new te(), this._sessionDisposables = new te(), this._disposables.add(t.onTypeFormattingEditProvider.onDidChange(this._update, this)), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((n) => {
        n.hasChanged(49) && this._update();
      }));
    }
    dispose() {
      this._disposables.dispose(), this._sessionDisposables.dispose();
    }
    _update() {
      if (this._sessionDisposables.clear(), !this._editor.getOption(49) || !this._editor.hasModel())
        return;
      const e = this._editor.getModel(), [t] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(e);
      if (!t || !t.autoFormatTriggerCharacters)
        return;
      let i = new Lu();
      for (let n of t.autoFormatTriggerCharacters)
        i.add(n.charCodeAt(0));
      this._sessionDisposables.add(this._editor.onDidType((n) => {
        let o = n.charCodeAt(n.length - 1);
        i.has(o) && this._trigger(String.fromCharCode(o));
      }));
    }
    _trigger(e) {
      if (!this._editor.hasModel() || this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty())
        return;
      const t = this._editor.getModel(), i = this._editor.getPosition(), n = new bn(), o = this._editor.onDidChangeModelContent((r) => {
        if (r.isFlush) {
          n.cancel(), o.dispose();
          return;
        }
        for (let a = 0, l = r.changes.length; a < l; a++)
          if (r.changes[a].range.endLineNumber <= i.lineNumber) {
            n.cancel(), o.dispose();
            return;
          }
      });
      s9(this._workerService, this._languageFeaturesService, t, i, e, t.getFormattingOptions(), n.token).then((r) => {
        n.token.isCancellationRequested || Ds(r) && (Of.execute(this._editor, r, !0), FN(r));
      }).finally(() => {
        o.dispose();
      });
    }
  };
  Np.ID = "editor.contrib.autoFormat";
  Np = o9([
    K1(1, me),
    K1(2, xo)
  ], Np);
  let Tp = class {
    constructor(e, t, i) {
      this.editor = e, this._languageFeaturesService = t, this._instantiationService = i, this._callOnDispose = new te(), this._callOnModel = new te(), this._callOnDispose.add(e.onDidChangeConfiguration(() => this._update())), this._callOnDispose.add(e.onDidChangeModel(() => this._update())), this._callOnDispose.add(e.onDidChangeModelLanguage(() => this._update())), this._callOnDispose.add(t.documentRangeFormattingEditProvider.onDidChange(this._update, this));
    }
    dispose() {
      this._callOnDispose.dispose(), this._callOnModel.dispose();
    }
    _update() {
      this._callOnModel.clear(), this.editor.getOption(48) && (!this.editor.hasModel() || !this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel()) || this._callOnModel.add(this.editor.onDidPaste(({ range: e }) => this._trigger(e))));
    }
    _trigger(e) {
      !this.editor.hasModel() || this.editor.getSelections().length > 1 || this._instantiationService.invokeFunction(n9, this.editor, e, 2, Bh.None, Je.None).catch(We);
    }
  };
  Tp.ID = "editor.contrib.formatOnPaste";
  Tp = o9([
    K1(1, me),
    K1(2, et)
  ], Tp);
  class Pie extends ge {
    constructor() {
      super({
        id: "editor.action.formatDocument",
        label: m("formatDocument.label", "Format Document"),
        alias: "Format Document",
        precondition: ce.and(T.notInCompositeEditor, T.writable, T.hasDocumentFormattingProvider),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1572,
          linux: { primary: 3111 },
          weight: 100
        },
        contextMenuOpts: {
          group: "1_modification",
          order: 1.3
        }
      });
    }
    run(e, t) {
      return BN(this, void 0, void 0, function* () {
        if (t.hasModel()) {
          const i = e.get(et);
          yield e.get(Bc).showWhile(i.invokeFunction(Mie, t, 1, Bh.None, Je.None), 250);
        }
      });
    }
  }
  class Fie extends ge {
    constructor() {
      super({
        id: "editor.action.formatSelection",
        label: m("formatSelection.label", "Format Selection"),
        alias: "Format Selection",
        precondition: ce.and(T.writable, T.hasDocumentSelectionFormattingProvider),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2084),
          weight: 100
        },
        contextMenuOpts: {
          when: T.hasNonEmptySelection,
          group: "1_modification",
          order: 1.31
        }
      });
    }
    run(e, t) {
      return BN(this, void 0, void 0, function* () {
        if (!t.hasModel())
          return;
        const i = e.get(et), n = t.getModel(), o = t.getSelections().map((a) => a.isEmpty() ? new D(a.startLineNumber, 1, a.startLineNumber, n.getLineMaxColumn(a.startLineNumber)) : a);
        yield e.get(Bc).showWhile(i.invokeFunction(n9, t, o, 1, Bh.None, Je.None), 250);
      });
    }
  }
  vt(Np.ID, Np);
  vt(Tp.ID, Tp);
  oe(Pie);
  oe(Fie);
  lt.registerCommand("editor.action.format", (s) => BN(void 0, void 0, void 0, function* () {
    const e = s.get(St).getFocusedCodeEditor();
    if (!e || !e.hasModel())
      return;
    const t = s.get(wi);
    e.getSelection().isEmpty() ? yield t.executeCommand("editor.action.formatDocument") : yield t.executeCommand("editor.action.formatSelection");
  }));
  var Bie = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, ry = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Wie = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Ru {
    remove() {
      this.parent && this.parent.children.delete(this.id);
    }
    static findId(e, t) {
      let i;
      typeof e == "string" ? i = `${t.id}/${e}` : (i = `${t.id}/${e.name}`, t.children.get(i) !== void 0 && (i = `${t.id}/${e.name}_${e.range.startLineNumber}_${e.range.startColumn}`));
      let n = i;
      for (let o = 0; t.children.get(n) !== void 0; o++)
        n = `${i}_${o}`;
      return n;
    }
    static empty(e) {
      return e.children.size === 0;
    }
  }
  class jA extends Ru {
    constructor(e, t, i) {
      super(), this.id = e, this.parent = t, this.symbol = i, this.children = /* @__PURE__ */ new Map();
    }
  }
  class Vie extends Ru {
    constructor(e, t, i, n) {
      super(), this.id = e, this.parent = t, this.label = i, this.order = n, this.children = /* @__PURE__ */ new Map();
    }
  }
  class Bl extends Ru {
    constructor(e) {
      super(), this.uri = e, this.id = "root", this.parent = void 0, this._groups = /* @__PURE__ */ new Map(), this.children = /* @__PURE__ */ new Map(), this.id = "root", this.parent = void 0;
    }
    static create(e, t, i) {
      const n = new bn(i), o = new Bl(t.uri), r = e.ordered(t), a = r.map((c, d) => {
        var h;
        let u = Ru.findId(`provider_${d}`, o), f = new Vie(u, o, (h = c.displayName) !== null && h !== void 0 ? h : "Unknown Outline Provider", d);
        return Promise.resolve(c.provideDocumentSymbols(t, n.token)).then((g) => {
          for (const _ of g || [])
            Bl._makeOutlineElement(_, f);
          return f;
        }, (g) => (Xi(g), f)).then((g) => {
          Ru.empty(g) ? g.remove() : o._groups.set(u, g);
        });
      }), l = e.onDidChange(() => {
        const c = e.ordered(t);
        Gs(c, r) || n.cancel();
      });
      return Promise.all(a).then(() => n.token.isCancellationRequested && !i.isCancellationRequested ? Bl.create(e, t, i) : o._compact()).finally(() => {
        l.dispose();
      });
    }
    static _makeOutlineElement(e, t) {
      let i = Ru.findId(e, t), n = new jA(i, t, e);
      if (e.children)
        for (const o of e.children)
          Bl._makeOutlineElement(o, n);
      t.children.set(n.id, n);
    }
    _compact() {
      let e = 0;
      for (const [t, i] of this._groups)
        i.children.size === 0 ? this._groups.delete(t) : e += 1;
      if (e !== 1)
        this.children = this._groups;
      else {
        let t = rt.first(this._groups.values());
        for (let [, i] of t.children)
          i.parent = this, this.children.set(i.id, i);
      }
      return this;
    }
    getTopLevelSymbols() {
      const e = [];
      for (const t of this.children.values())
        t instanceof jA ? e.push(t.symbol) : e.push(...rt.map(t.children.values(), (i) => i.symbol));
      return e.sort((t, i) => D.compareRangesUsingStarts(t.range, i.range));
    }
    asListOfDocumentSymbols() {
      const e = this.getTopLevelSymbols(), t = [];
      return Bl._flattenDocumentSymbols(t, e, ""), t.sort((i, n) => V.compare(D.getStartPosition(i.range), D.getStartPosition(n.range)) || V.compare(D.getEndPosition(n.range), D.getEndPosition(i.range)));
    }
    static _flattenDocumentSymbols(e, t, i) {
      for (const n of t)
        e.push({
          kind: n.kind,
          tags: n.tags,
          name: n.name,
          detail: n.detail,
          containerName: n.containerName || i,
          range: n.range,
          selectionRange: n.selectionRange,
          children: void 0
        }), n.children && Bl._flattenDocumentSymbols(e, n.children, n.name);
    }
  }
  const jC = st("IOutlineModelService");
  let Bk = class {
    constructor(e, t, i) {
      this._languageFeaturesService = e, this._disposables = new te(), this._cache = new Wc(10, 0.7), this._debounceInformation = t.for(e.documentSymbolProvider, "DocumentSymbols", { min: 350 }), this._disposables.add(i.onModelRemoved((n) => {
        this._cache.delete(n.id);
      }));
    }
    dispose() {
      this._disposables.dispose();
    }
    getOrCreate(e, t) {
      return Wie(this, void 0, void 0, function* () {
        const i = this._languageFeaturesService.documentSymbolProvider, n = i.ordered(e);
        let o = this._cache.get(e.id);
        if (!o || o.versionId !== e.getVersionId() || !Gs(o.provider, n)) {
          let a = new bn();
          o = {
            versionId: e.getVersionId(),
            provider: n,
            promiseCnt: 0,
            source: a,
            promise: Bl.create(i, e, a.token),
            model: void 0
          }, this._cache.set(e.id, o);
          const l = Date.now();
          o.promise.then((c) => {
            o.model = c, this._debounceInformation.update(e, Date.now() - l);
          }).catch((c) => {
            this._cache.delete(e.id);
          });
        }
        if (o.model)
          return o.model;
        o.promiseCnt += 1;
        const r = t.onCancellationRequested(() => {
          --o.promiseCnt === 0 && (o.source.cancel(), this._cache.delete(e.id));
        });
        try {
          return yield o.promise;
        } finally {
          r.dispose();
        }
      });
    }
  };
  Bk = Bie([
    ry(0, me),
    ry(1, Io),
    ry(2, Qt)
  ], Bk);
  ht(jC, Bk, !0);
  var Hie = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  lt.registerCommand("_executeDocumentSymbolProvider", function(s, ...e) {
    return Hie(this, void 0, void 0, function* () {
      const [t] = e;
      Nt(Ee.isUri(t));
      const i = s.get(jC), o = yield s.get(fs).createModelReference(t);
      try {
        return (yield i.getOrCreate(o.object.textEditorModel, Je.None)).getTopLevelSymbols();
      } finally {
        o.dispose();
      }
    });
  });
  const r9 = "editor.action.inlineSuggest.commit";
  class a9 {
    constructor(e, t, i = 0) {
      this.lineNumber = e, this.parts = t, this.additionalReservedLineCount = i;
    }
    renderForScreenReader(e) {
      if (this.parts.length === 0)
        return "";
      const t = this.parts[this.parts.length - 1], i = e.substr(0, t.column - 1);
      return Uie(i, this.parts.map((o) => ({
        range: { startLineNumber: 1, endLineNumber: 1, startColumn: o.column, endColumn: o.column },
        text: o.lines.join(`
`)
      }))).substring(this.parts[0].column - 1);
    }
  }
  class zie {
    constructor(e) {
      this.lineStartOffsetByLineIdx = [], this.lineStartOffsetByLineIdx.push(0);
      for (let t = 0; t < e.length; t++)
        e.charAt(t) === `
` && this.lineStartOffsetByLineIdx.push(t + 1);
    }
    getOffset(e) {
      return this.lineStartOffsetByLineIdx[e.lineNumber - 1] + e.column - 1;
    }
  }
  function Uie(s, e) {
    const t = new zie(s), i = e.map((n) => {
      const o = D.lift(n.range);
      return {
        startOffset: t.getOffset(o.getStartPosition()),
        endOffset: t.getOffset(o.getEndPosition()),
        text: n.text
      };
    });
    i.sort((n, o) => o.startOffset - n.startOffset);
    for (const n of i)
      s = s.substring(0, n.startOffset) + n.text + s.substring(n.endOffset);
    return s;
  }
  class KA {
    constructor(e, t, i) {
      this.column = e, this.lines = t, this.preview = i;
    }
  }
  class l9 extends z {
    constructor(e) {
      super(), this.editor = e, this._expanded = void 0, this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this._register(e.onDidChangeConfiguration((t) => {
        t.hasChanged(106) && this._expanded === void 0 && this.onDidChangeEmitter.fire();
      }));
    }
    setExpanded(e) {
      this._expanded = !0, this.onDidChangeEmitter.fire();
    }
  }
  function $ie(s, e) {
    return s === e ? !0 : !s || !e ? !1 : s.range.equalsRange(e.range) && s.text === e.text && s.command === e.command;
  }
  function c9(s, e, t, i, n = 0) {
    if (s.range.startLineNumber !== s.range.endLineNumber)
      return;
    const o = e.getLineContent(s.range.startLineNumber), r = Dt(o).length;
    if (s.range.startColumn - 1 <= r) {
      const f = Dt(s.text).length, g = o.substring(s.range.startColumn - 1, r), _ = D.fromPositions(s.range.getStartPosition().delta(0, g.length), s.range.getEndPosition()), b = s.text.startsWith(g) ? s.text.substring(g.length) : s.text.substring(f);
      s = {
        range: _,
        text: b,
        command: s.command
      };
    }
    const l = e.getValueInRange(s.range), c = jie(l, s.text);
    if (!c)
      return;
    const d = s.range.startLineNumber, h = new Array();
    if (t === "prefix") {
      const f = c.filter((g) => g.originalLength === 0);
      if (f.length > 1 || f.length === 1 && f[0].originalStart !== l.length)
        return;
    }
    const u = s.text.length - n;
    for (const f of c) {
      const g = s.range.startColumn + f.originalStart + f.originalLength;
      if (t === "subwordSmart" && i && i.lineNumber === s.range.startLineNumber && g < i.column || f.originalLength > 0)
        return;
      if (f.modifiedLength === 0)
        continue;
      const _ = f.modifiedStart + f.modifiedLength, b = Math.max(f.modifiedStart, Math.min(_, u)), C = s.text.substring(f.modifiedStart, b), v = s.text.substring(b, Math.max(f.modifiedStart, _));
      if (C.length > 0) {
        const w = da(C);
        h.push(new KA(g, w, !1));
      }
      if (v.length > 0) {
        const w = da(v);
        h.push(new KA(g, w, !0));
      }
    }
    return new a9(d, h, 0);
  }
  let Tr;
  function jie(s, e) {
    if (Tr?.originalValue === s && Tr?.newValue === e)
      return Tr?.changes;
    {
      const t = Kie(s, e);
      return Tr = {
        originalValue: s,
        newValue: e,
        changes: t
      }, t;
    }
  }
  function Kie(s, e) {
    if (s.length > 5e3 || e.length > 5e3)
      return;
    function t(l) {
      let c = 0;
      for (let d = 0, h = l.length; d < h; d++) {
        const u = l.charCodeAt(d);
        u > c && (c = u);
      }
      return c;
    }
    const i = Math.max(t(s), t(e));
    function n(l) {
      if (l < 0)
        throw new Error("unexpected");
      return i + l + 1;
    }
    function o(l) {
      let c = 0, d = 0;
      const h = new Int32Array(l.length);
      for (let u = 0, f = l.length; u < f; u++) {
        const g = d * 100 + c;
        l[u] === "(" ? (h[u] = n(2 * g), c++) : l[u] === ")" ? (h[u] = n(2 * g + 1), c === 1 && d++, c = Math.max(c - 1, 0)) : h[u] = l.charCodeAt(u);
      }
      return h;
    }
    const r = o(s), a = o(e);
    return new Yr({ getElements: () => r }, { getElements: () => a }).ComputeDiff(!1).changes;
  }
  function qie(s, e) {
    const t = new cF(), i = new hF(t, (c) => e.getLanguageConfiguration(c)), n = new dF(new Gie([s]), i), o = NL(n, [], void 0, !0);
    let r = "";
    const a = s.getLineContent();
    function l(c, d) {
      if (c.kind === 2)
        l(c.openingBracket, d), d = Ii(d, c.openingBracket.length), c.child && (l(c.child, d), d = Ii(d, c.child.length)), c.closingBracket ? (l(c.closingBracket, d), d = Ii(d, c.closingBracket.length)) : r += i.getSingleLanguageBracketTokens(c.openingBracket.languageId).findClosingTokenText(c.openingBracket.bracketIds);
      else if (c.kind !== 3) {
        if (c.kind === 0 || c.kind === 1)
          r += a.substring(d, Ii(d, c.length));
        else if (c.kind === 4)
          for (const h of c.children)
            l(h, d), d = Ii(d, h.length);
      }
    }
    return l(o, ua), r;
  }
  class Gie {
    constructor(e) {
      this.lines = e;
    }
    getLineCount() {
      return this.lines.length;
    }
    getLineLength(e) {
      return this.lines[e - 1].getLineContent().length;
    }
    getLineTokens(e) {
      return this.lines[e - 1];
    }
  }
  var Zie = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Eb = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Za = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Wk = class extends z {
    constructor(e, t, i, n, o, r) {
      super(), this.editor = e, this.cache = t, this.commandService = i, this.languageConfigurationService = n, this.languageFeaturesService = o, this.debounceService = r, this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.completionSession = this._register(new Gn()), this.active = !1, this.disposed = !1, this.debounceValue = this.debounceService.for(this.languageFeaturesService.inlineCompletionsProvider, "InlineCompletionsDebounce", { min: 50, max: 200 }), this._register(i.onDidExecuteCommand((a) => {
        (/* @__PURE__ */ new Set([
          ju.Tab.id,
          ju.DeleteLeft.id,
          ju.DeleteRight.id,
          r9,
          "acceptSelectedSuggestion"
        ])).has(a.commandId) && e.hasTextFocus() && this.handleUserInput();
      })), this._register(this.editor.onDidType((a) => {
        this.handleUserInput();
      })), this._register(this.editor.onDidChangeCursorPosition((a) => {
        this.session && !this.session.isValid && this.hide();
      })), this._register(qe(() => {
        this.disposed = !0;
      })), this._register(this.editor.onDidBlurEditorWidget(() => {
        this.hide();
      }));
    }
    handleUserInput() {
      this.session && !this.session.isValid && this.hide(), setTimeout(() => {
        this.disposed || this.startSessionIfTriggered();
      }, 0);
    }
    get session() {
      return this.completionSession.value;
    }
    get ghostText() {
      var e;
      return (e = this.session) === null || e === void 0 ? void 0 : e.ghostText;
    }
    get minReservedLineCount() {
      return this.session ? this.session.minReservedLineCount : 0;
    }
    setExpanded(e) {
      var t;
      (t = this.session) === null || t === void 0 || t.setExpanded(e);
    }
    setActive(e) {
      var t;
      this.active = e, e && ((t = this.session) === null || t === void 0 || t.scheduleAutomaticUpdate());
    }
    startSessionIfTriggered() {
      !this.editor.getOption(55).enabled || this.session && this.session.isValid || this.trigger(ao.Automatic);
    }
    trigger(e) {
      if (this.completionSession.value) {
        e === ao.Explicit && this.completionSession.value.ensureUpdateWithExplicitContext();
        return;
      }
      this.completionSession.value = new Yie(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, e, this.languageConfigurationService, this.languageFeaturesService.inlineCompletionsProvider, this.debounceValue), this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {
        this.onDidChangeEmitter.fire();
      }));
    }
    hide() {
      this.completionSession.clear(), this.onDidChangeEmitter.fire();
    }
    commitCurrentSuggestion() {
      var e;
      (e = this.session) === null || e === void 0 || e.commitCurrentCompletion();
    }
    showNext() {
      var e;
      (e = this.session) === null || e === void 0 || e.showNextInlineCompletion();
    }
    showPrevious() {
      var e;
      (e = this.session) === null || e === void 0 || e.showPreviousInlineCompletion();
    }
    hasMultipleInlineCompletions() {
      var e;
      return Za(this, void 0, void 0, function* () {
        const t = yield (e = this.session) === null || e === void 0 ? void 0 : e.hasMultipleInlineCompletions();
        return t !== void 0 ? t : !1;
      });
    }
  };
  Wk = Zie([
    Eb(2, wi),
    Eb(3, Mn),
    Eb(4, me),
    Eb(5, Io)
  ], Wk);
  class Yie extends l9 {
    constructor(e, t, i, n, o, r, a, l, c) {
      super(e), this.triggerPosition = t, this.shouldUpdate = i, this.commandService = n, this.cache = o, this.initialTriggerKind = r, this.languageConfigurationService = a, this.registry = l, this.debounce = c, this.minReservedLineCount = 0, this.updateOperation = this._register(new Gn()), this.updateSoon = this._register(new It(() => {
        let h = this.initialTriggerKind;
        return this.initialTriggerKind = ao.Automatic, this.update(h);
      }, 50)), this.currentlySelectedCompletionId = void 0;
      let d;
      this._register(this.onDidChange(() => {
        const h = this.currentCompletion;
        if (h && h.sourceInlineCompletion !== d) {
          d = h.sourceInlineCompletion;
          const u = h.sourceProvider;
          u.handleItemDidShow && u.handleItemDidShow(h.sourceInlineCompletions, d);
        }
      })), this._register(qe(() => {
        this.cache.clear();
      })), this._register(this.editor.onDidChangeCursorPosition((h) => {
        this.cache.value && this.onDidChangeEmitter.fire();
      })), this._register(this.editor.onDidChangeModelContent((h) => {
        this.scheduleAutomaticUpdate();
      })), this._register(this.registry.onDidChange(() => {
        this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));
      })), this.scheduleAutomaticUpdate();
    }
    fixAndGetIndexOfCurrentSelection() {
      if (!this.currentlySelectedCompletionId || !this.cache.value || this.cache.value.completions.length === 0)
        return 0;
      const e = this.cache.value.completions.findIndex((t) => t.semanticId === this.currentlySelectedCompletionId);
      return e === -1 ? (this.currentlySelectedCompletionId = void 0, 0) : e;
    }
    get currentCachedCompletion() {
      if (!!this.cache.value)
        return this.cache.value.completions[this.fixAndGetIndexOfCurrentSelection()];
    }
    showNextInlineCompletion() {
      var e;
      return Za(this, void 0, void 0, function* () {
        yield this.ensureUpdateWithExplicitContext();
        const t = ((e = this.cache.value) === null || e === void 0 ? void 0 : e.completions) || [];
        if (t.length > 0) {
          const i = (this.fixAndGetIndexOfCurrentSelection() + 1) % t.length;
          this.currentlySelectedCompletionId = t[i].semanticId;
        } else
          this.currentlySelectedCompletionId = void 0;
        this.onDidChangeEmitter.fire();
      });
    }
    showPreviousInlineCompletion() {
      var e;
      return Za(this, void 0, void 0, function* () {
        yield this.ensureUpdateWithExplicitContext();
        const t = ((e = this.cache.value) === null || e === void 0 ? void 0 : e.completions) || [];
        if (t.length > 0) {
          const i = (this.fixAndGetIndexOfCurrentSelection() + t.length - 1) % t.length;
          this.currentlySelectedCompletionId = t[i].semanticId;
        } else
          this.currentlySelectedCompletionId = void 0;
        this.onDidChangeEmitter.fire();
      });
    }
    ensureUpdateWithExplicitContext() {
      var e;
      return Za(this, void 0, void 0, function* () {
        this.updateOperation.value ? this.updateOperation.value.triggerKind === ao.Explicit ? yield this.updateOperation.value.promise : yield this.update(ao.Explicit) : ((e = this.cache.value) === null || e === void 0 ? void 0 : e.triggerKind) !== ao.Explicit && (yield this.update(ao.Explicit));
      });
    }
    hasMultipleInlineCompletions() {
      var e;
      return Za(this, void 0, void 0, function* () {
        return yield this.ensureUpdateWithExplicitContext(), (((e = this.cache.value) === null || e === void 0 ? void 0 : e.completions.length) || 0) > 1;
      });
    }
    get ghostText() {
      const e = this.currentCompletion, t = this.editor.getOptions().get(55).mode;
      return e ? c9(e, this.editor.getModel(), t, this.editor.getPosition()) : void 0;
    }
    get currentCompletion() {
      const e = this.currentCachedCompletion;
      if (!!e)
        return e.toLiveInlineCompletion();
    }
    get isValid() {
      return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;
    }
    scheduleAutomaticUpdate() {
      this.updateOperation.clear(), this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));
    }
    update(e) {
      return Za(this, void 0, void 0, function* () {
        if (!this.shouldUpdate())
          return;
        const t = this.editor.getPosition(), i = new Date(), n = an((r) => Za(this, void 0, void 0, function* () {
          let a;
          try {
            a = yield h9(this.registry, t, this.editor.getModel(), { triggerKind: e, selectedSuggestionInfo: void 0 }, r, this.languageConfigurationService);
            const l = new Date();
            this.debounce.update(this.editor.getModel(), l.getTime() - i.getTime());
          } catch (l) {
            We(l);
            return;
          }
          r.isCancellationRequested || (this.cache.setValue(this.editor, a, e), this.onDidChangeEmitter.fire());
        })), o = new d9(n, e);
        this.updateOperation.value = o, yield n, this.updateOperation.value === o && this.updateOperation.clear();
      });
    }
    takeOwnership(e) {
      this._register(e);
    }
    commitCurrentCompletion() {
      if (!this.ghostText)
        return;
      const e = this.currentCompletion;
      e && this.commit(e);
    }
    commit(e) {
      const t = this.cache.clearAndLeak();
      this.editor.executeEdits("inlineSuggestion.accept", [
        li.replaceMove(e.range, e.text)
      ]), e.command ? this.commandService.executeCommand(e.command.id, ...e.command.arguments || []).finally(() => {
        t?.dispose();
      }).then(void 0, Xi) : t?.dispose(), this.onDidChangeEmitter.fire();
    }
  }
  class d9 {
    constructor(e, t) {
      this.promise = e, this.triggerKind = t;
    }
    dispose() {
      this.promise.cancel();
    }
  }
  class Xie extends z {
    constructor(e, t, i, n) {
      super(), this.triggerKind = n;
      const o = e.deltaDecorations([], t.items.map((r) => ({
        range: r.range,
        options: {
          description: "inline-completion-tracking-range"
        }
      })));
      this._register(qe(() => {
        e.deltaDecorations(o, []);
      })), this.completions = t.items.map((r, a) => new Qie(r, o[a])), this._register(e.onDidChangeModelContent(() => {
        let r = !1;
        const a = e.getModel();
        for (const l of this.completions) {
          const c = a.getDecorationRange(l.decorationId);
          if (!c) {
            We(new Error("Decoration has no range"));
            continue;
          }
          l.synchronizedRange.equalsRange(c) || (r = !0, l.synchronizedRange = c);
        }
        r && i();
      })), this._register(t);
    }
  }
  class Qie {
    constructor(e, t) {
      this.inlineCompletion = e, this.decorationId = t, this.semanticId = JSON.stringify({
        text: this.inlineCompletion.text,
        startLine: this.inlineCompletion.range.startLineNumber,
        startColumn: this.inlineCompletion.range.startColumn,
        command: this.inlineCompletion.command
      }), this.synchronizedRange = e.range;
    }
    toLiveInlineCompletion() {
      return {
        text: this.inlineCompletion.text,
        range: this.synchronizedRange,
        command: this.inlineCompletion.command,
        sourceProvider: this.inlineCompletion.sourceProvider,
        sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,
        sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion
      };
    }
  }
  function Jie(s, e) {
    const t = e.getWordAtPosition(s), i = e.getLineMaxColumn(s.lineNumber);
    return t ? new D(s.lineNumber, t.startColumn, s.lineNumber, i) : D.fromPositions(s, s.with(void 0, i));
  }
  function h9(s, e, t, i, n = Je.None, o) {
    return Za(this, void 0, void 0, function* () {
      const r = Jie(e, t), a = s.all(t), l = yield Promise.all(a.map((d) => Za(this, void 0, void 0, function* () {
        const h = yield Promise.resolve(d.provideInlineCompletions(t, e, i, n)).catch(Xi);
        return {
          completions: h,
          provider: d,
          dispose: () => {
            h && d.freeInlineCompletions(h);
          }
        };
      }))), c = /* @__PURE__ */ new Map();
      for (const d of l) {
        const h = d.completions;
        if (h)
          for (const u of h.items) {
            const f = u.range ? D.lift(u.range) : r;
            if (f.startLineNumber !== f.endLineNumber)
              continue;
            const g = o && u.completeBracketPairs ? ene(u.text, f.getStartPosition(), t, o) : u.text, _ = {
              text: g,
              range: f,
              command: u.command,
              sourceProvider: d.provider,
              sourceInlineCompletions: h,
              sourceInlineCompletion: u
            };
            c.set(JSON.stringify({ text: g, range: u.range }), _);
          }
      }
      return {
        items: [...c.values()],
        dispose: () => {
          for (const d of l)
            d.dispose();
        }
      };
    });
  }
  function ene(s, e, t, i) {
    const o = t.getLineContent(e.lineNumber).substring(0, e.column - 1) + s, r = t.tokenizeLineWithEdit(e, o.length - (e.column - 1), s), a = r?.sliceAndInflate(e.column - 1, o.length, 0);
    return a ? (console.log(a), qie(a, i)) : s;
  }
  function q1(s, e) {
    if (!e)
      return e;
    const t = s.getValueInRange(e.range), i = pf(t, e.text), n = s.getOffsetAt(e.range.getStartPosition()) + i, o = s.getPositionAt(n), r = t.substr(i), a = K0(r, e.text), l = s.getPositionAt(Math.max(n, s.getOffsetAt(e.range.getEndPosition()) - a));
    return {
      range: D.fromPositions(o, l),
      text: e.text.substr(i, e.text.length - i - a)
    };
  }
  const u9 = st("contextService");
  function qA(s) {
    const e = s;
    return typeof e?.id == "string" && Ee.isUri(e.uri);
  }
  function tne(s) {
    if (s.configuration)
      return {
        id: s.id,
        configPath: s.configuration
      };
    if (s.folders.length === 1)
      return {
        id: s.id,
        uri: s.folders[0].uri
      };
  }
  class ine {
    constructor(e, t) {
      this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
    }
    toJSON() {
      return { uri: this.uri, name: this.name, index: this.index };
    }
  }
  const Vk = "code-workspace";
  m("codeWorkspace", "Code Workspace");
  const en = new Uint8Array(16), Wn = [];
  for (let s = 0; s < 256; s++)
    Wn.push(s.toString(16).padStart(2, "0"));
  let Hk;
  typeof crypto == "object" && typeof crypto.getRandomValues == "function" ? Hk = crypto.getRandomValues.bind(crypto) : Hk = function(s) {
    for (let e = 0; e < s.length; e++)
      s[e] = Math.floor(Math.random() * 256);
    return s;
  };
  function nne() {
    Hk(en), en[6] = en[6] & 15 | 64, en[8] = en[8] & 63 | 128;
    let s = 0, e = "";
    return e += Wn[en[s++]], e += Wn[en[s++]], e += Wn[en[s++]], e += Wn[en[s++]], e += "-", e += Wn[en[s++]], e += Wn[en[s++]], e += "-", e += Wn[en[s++]], e += Wn[en[s++]], e += "-", e += Wn[en[s++]], e += Wn[en[s++]], e += "-", e += Wn[en[s++]], e += Wn[en[s++]], e += Wn[en[s++]], e += Wn[en[s++]], e += Wn[en[s++]], e += Wn[en[s++]], e;
  }
  Object.freeze({
    CURRENT_YEAR: !0,
    CURRENT_YEAR_SHORT: !0,
    CURRENT_MONTH: !0,
    CURRENT_DATE: !0,
    CURRENT_HOUR: !0,
    CURRENT_MINUTE: !0,
    CURRENT_SECOND: !0,
    CURRENT_DAY_NAME: !0,
    CURRENT_DAY_NAME_SHORT: !0,
    CURRENT_MONTH_NAME: !0,
    CURRENT_MONTH_NAME_SHORT: !0,
    CURRENT_SECONDS_UNIX: !0,
    SELECTION: !0,
    CLIPBOARD: !0,
    TM_SELECTED_TEXT: !0,
    TM_CURRENT_LINE: !0,
    TM_CURRENT_WORD: !0,
    TM_LINE_INDEX: !0,
    TM_LINE_NUMBER: !0,
    TM_FILENAME: !0,
    TM_FILENAME_BASE: !0,
    TM_DIRECTORY: !0,
    TM_FILEPATH: !0,
    RELATIVE_FILEPATH: !0,
    BLOCK_COMMENT_START: !0,
    BLOCK_COMMENT_END: !0,
    LINE_COMMENT: !0,
    WORKSPACE_NAME: !0,
    WORKSPACE_FOLDER: !0,
    RANDOM: !0,
    RANDOM_HEX: !0,
    UUID: !0
  });
  class sne {
    constructor(e) {
      this._delegates = e;
    }
    resolve(e) {
      for (const t of this._delegates) {
        let i = t.resolve(e);
        if (i !== void 0)
          return i;
      }
    }
  }
  class one {
    constructor(e, t, i, n) {
      this._model = e, this._selection = t, this._selectionIdx = i, this._overtypingCapturer = n;
    }
    resolve(e) {
      const { name: t } = e;
      if (t === "SELECTION" || t === "TM_SELECTED_TEXT") {
        let i = this._model.getValueInRange(this._selection) || void 0, n = this._selection.startLineNumber !== this._selection.endLineNumber;
        if (!i && this._overtypingCapturer) {
          const o = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
          o && (i = o.value, n = o.multiline);
        }
        if (i && n && e.snippet) {
          const o = this._model.getLineContent(this._selection.startLineNumber), r = Dt(o, 0, this._selection.startColumn - 1);
          let a = r;
          e.snippet.walk((c) => c === e ? !1 : (c instanceof ws && (a = Dt(da(c.value).pop())), !0));
          const l = pf(a, r);
          i = i.replace(/(\r\n|\r|\n)(.*)/g, (c, d, h) => `${d}${a.substr(l)}${h}`);
        }
        return i;
      } else {
        if (t === "TM_CURRENT_LINE")
          return this._model.getLineContent(this._selection.positionLineNumber);
        if (t === "TM_CURRENT_WORD") {
          const i = this._model.getWordAtPosition({
            lineNumber: this._selection.positionLineNumber,
            column: this._selection.positionColumn
          });
          return i && i.word || void 0;
        } else {
          if (t === "TM_LINE_INDEX")
            return String(this._selection.positionLineNumber - 1);
          if (t === "TM_LINE_NUMBER")
            return String(this._selection.positionLineNumber);
        }
      }
    }
  }
  class rne {
    constructor(e, t) {
      this._labelService = e, this._model = t;
    }
    resolve(e) {
      const { name: t } = e;
      if (t === "TM_FILENAME")
        return kd(this._model.uri.fsPath);
      if (t === "TM_FILENAME_BASE") {
        const i = kd(this._model.uri.fsPath), n = i.lastIndexOf(".");
        return n <= 0 ? i : i.slice(0, n);
      } else {
        if (t === "TM_DIRECTORY")
          return oP(this._model.uri.fsPath) === "." ? "" : this._labelService.getUriLabel(hC(this._model.uri));
        if (t === "TM_FILEPATH")
          return this._labelService.getUriLabel(this._model.uri);
        if (t === "RELATIVE_FILEPATH")
          return this._labelService.getUriLabel(this._model.uri, { relative: !0, noPrefix: !0 });
      }
    }
  }
  class ane {
    constructor(e, t, i, n) {
      this._readClipboardText = e, this._selectionIdx = t, this._selectionCount = i, this._spread = n;
    }
    resolve(e) {
      if (e.name !== "CLIPBOARD")
        return;
      const t = this._readClipboardText();
      if (!!t) {
        if (this._spread) {
          const i = t.split(/\r\n|\n|\r/).filter((n) => !yP(n));
          if (i.length === this._selectionCount)
            return i[this._selectionIdx];
        }
        return t;
      }
    }
  }
  class lne {
    constructor(e, t) {
      this._model = e, this._selection = t;
    }
    resolve(e) {
      const { name: t } = e, i = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn), n = Di.getComments(i);
      if (!!n) {
        if (t === "LINE_COMMENT")
          return n.lineCommentToken || void 0;
        if (t === "BLOCK_COMMENT_START")
          return n.blockCommentStartToken || void 0;
        if (t === "BLOCK_COMMENT_END")
          return n.blockCommentEndToken || void 0;
      }
    }
  }
  class ea {
    constructor() {
      this._date = new Date();
    }
    resolve(e) {
      const { name: t } = e;
      if (t === "CURRENT_YEAR")
        return String(this._date.getFullYear());
      if (t === "CURRENT_YEAR_SHORT")
        return String(this._date.getFullYear()).slice(-2);
      if (t === "CURRENT_MONTH")
        return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
      if (t === "CURRENT_DATE")
        return String(this._date.getDate().valueOf()).padStart(2, "0");
      if (t === "CURRENT_HOUR")
        return String(this._date.getHours().valueOf()).padStart(2, "0");
      if (t === "CURRENT_MINUTE")
        return String(this._date.getMinutes().valueOf()).padStart(2, "0");
      if (t === "CURRENT_SECOND")
        return String(this._date.getSeconds().valueOf()).padStart(2, "0");
      if (t === "CURRENT_DAY_NAME")
        return ea.dayNames[this._date.getDay()];
      if (t === "CURRENT_DAY_NAME_SHORT")
        return ea.dayNamesShort[this._date.getDay()];
      if (t === "CURRENT_MONTH_NAME")
        return ea.monthNames[this._date.getMonth()];
      if (t === "CURRENT_MONTH_NAME_SHORT")
        return ea.monthNamesShort[this._date.getMonth()];
      if (t === "CURRENT_SECONDS_UNIX")
        return String(Math.floor(this._date.getTime() / 1e3));
    }
  }
  ea.dayNames = [m("Sunday", "Sunday"), m("Monday", "Monday"), m("Tuesday", "Tuesday"), m("Wednesday", "Wednesday"), m("Thursday", "Thursday"), m("Friday", "Friday"), m("Saturday", "Saturday")];
  ea.dayNamesShort = [m("SundayShort", "Sun"), m("MondayShort", "Mon"), m("TuesdayShort", "Tue"), m("WednesdayShort", "Wed"), m("ThursdayShort", "Thu"), m("FridayShort", "Fri"), m("SaturdayShort", "Sat")];
  ea.monthNames = [m("January", "January"), m("February", "February"), m("March", "March"), m("April", "April"), m("May", "May"), m("June", "June"), m("July", "July"), m("August", "August"), m("September", "September"), m("October", "October"), m("November", "November"), m("December", "December")];
  ea.monthNamesShort = [m("JanuaryShort", "Jan"), m("FebruaryShort", "Feb"), m("MarchShort", "Mar"), m("AprilShort", "Apr"), m("MayShort", "May"), m("JuneShort", "Jun"), m("JulyShort", "Jul"), m("AugustShort", "Aug"), m("SeptemberShort", "Sep"), m("OctoberShort", "Oct"), m("NovemberShort", "Nov"), m("DecemberShort", "Dec")];
  class cne {
    constructor(e) {
      this._workspaceService = e;
    }
    resolve(e) {
      if (!this._workspaceService)
        return;
      const t = tne(this._workspaceService.getWorkspace());
      if (!!t) {
        if (e.name === "WORKSPACE_NAME")
          return this._resolveWorkspaceName(t);
        if (e.name === "WORKSPACE_FOLDER")
          return this._resoveWorkspacePath(t);
      }
    }
    _resolveWorkspaceName(e) {
      if (qA(e))
        return kd(e.uri.path);
      let t = kd(e.configPath.path);
      return t.endsWith(Vk) && (t = t.substr(0, t.length - Vk.length - 1)), t;
    }
    _resoveWorkspacePath(e) {
      if (qA(e))
        return dk(e.uri.fsPath);
      let t = kd(e.configPath.path), i = e.configPath.fsPath;
      return i.endsWith(t) && (i = i.substr(0, i.length - t.length - 1)), i ? dk(i) : "/";
    }
  }
  class dne {
    resolve(e) {
      const { name: t } = e;
      if (t === "RANDOM")
        return Math.random().toString().slice(-6);
      if (t === "RANDOM_HEX")
        return Math.random().toString(16).slice(-6);
      if (t === "UUID")
        return nne();
    }
  }
  class Vo {
    constructor(e, t, i, n) {
      this._editor = e, this._snippet = t, this._offset = i, this._snippetLineLeadingWhitespace = n, this._nestingLevel = 1, this._placeholderGroups = z2(t.placeholders, Ho.compareByIndex), this._placeholderGroupsIdx = -1;
    }
    dispose() {
      this._placeholderDecorations && this._editor.deltaDecorations([...this._placeholderDecorations.values()], []), this._placeholderGroups.length = 0;
    }
    _initDecorations() {
      if (this._placeholderDecorations)
        return;
      this._placeholderDecorations = /* @__PURE__ */ new Map();
      const e = this._editor.getModel();
      this._editor.changeDecorations((t) => {
        for (const i of this._snippet.placeholders) {
          const n = this._snippet.offset(i), o = this._snippet.fullLen(i), r = D.fromPositions(e.getPositionAt(this._offset + n), e.getPositionAt(this._offset + n + o)), a = i.isFinalTabstop ? Vo._decor.inactiveFinal : Vo._decor.inactive, l = t.addDecoration(r, a);
          this._placeholderDecorations.set(i, l);
        }
      });
    }
    move(e) {
      if (!this._editor.hasModel())
        return [];
      if (this._initDecorations(), this._placeholderGroupsIdx >= 0) {
        let n = [];
        for (const o of this._placeholderGroups[this._placeholderGroupsIdx])
          if (o.transform) {
            const r = this._placeholderDecorations.get(o), a = this._editor.getModel().getDecorationRange(r), l = this._editor.getModel().getValueInRange(a), c = o.transform.resolve(l).split(/\r\n|\r|\n/);
            for (let d = 1; d < c.length; d++)
              c[d] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + c[d]);
            n.push(li.replace(a, c.join(this._editor.getModel().getEOL())));
          }
        n.length > 0 && this._editor.executeEdits("snippet.placeholderTransform", n);
      }
      let t = !1;
      e === !0 && this._placeholderGroupsIdx < this._placeholderGroups.length - 1 ? (this._placeholderGroupsIdx += 1, t = !0) : e === !1 && this._placeholderGroupsIdx > 0 && (this._placeholderGroupsIdx -= 1, t = !0);
      const i = this._editor.getModel().changeDecorations((n) => {
        const o = /* @__PURE__ */ new Set(), r = [];
        for (const a of this._placeholderGroups[this._placeholderGroupsIdx]) {
          const l = this._placeholderDecorations.get(a), c = this._editor.getModel().getDecorationRange(l);
          r.push(new ae(c.startLineNumber, c.startColumn, c.endLineNumber, c.endColumn)), t = t && this._hasPlaceholderBeenCollapsed(a), n.changeDecorationOptions(l, a.isFinalTabstop ? Vo._decor.activeFinal : Vo._decor.active), o.add(a);
          for (const d of this._snippet.enclosingPlaceholders(a)) {
            const h = this._placeholderDecorations.get(d);
            n.changeDecorationOptions(h, d.isFinalTabstop ? Vo._decor.activeFinal : Vo._decor.active), o.add(d);
          }
        }
        for (const [a, l] of this._placeholderDecorations)
          o.has(a) || n.changeDecorationOptions(l, a.isFinalTabstop ? Vo._decor.inactiveFinal : Vo._decor.inactive);
        return r;
      });
      return t ? this.move(e) : i ?? [];
    }
    _hasPlaceholderBeenCollapsed(e) {
      let t = e;
      for (; t; ) {
        if (t instanceof Ho) {
          const i = this._placeholderDecorations.get(t);
          if (this._editor.getModel().getDecorationRange(i).isEmpty() && t.toString().length > 0)
            return !0;
        }
        t = t.parent;
      }
      return !1;
    }
    get isAtFirstPlaceholder() {
      return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
    }
    get isAtLastPlaceholder() {
      return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
    }
    get hasPlaceholder() {
      return this._snippet.placeholders.length > 0;
    }
    computePossibleSelections() {
      const e = /* @__PURE__ */ new Map();
      for (const t of this._placeholderGroups) {
        let i;
        for (const n of t) {
          if (n.isFinalTabstop)
            break;
          i || (i = [], e.set(n.index, i));
          const o = this._placeholderDecorations.get(n), r = this._editor.getModel().getDecorationRange(o);
          if (!r) {
            e.delete(n.index);
            break;
          }
          i.push(r);
        }
      }
      return e;
    }
    get choice() {
      return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;
    }
    merge(e) {
      const t = this._editor.getModel();
      this._nestingLevel *= 10, this._editor.changeDecorations((i) => {
        for (const n of this._placeholderGroups[this._placeholderGroupsIdx]) {
          const o = e.shift();
          console.assert(!o._placeholderDecorations);
          const r = o._snippet.placeholderInfo.last.index;
          for (const l of o._snippet.placeholderInfo.all)
            l.isFinalTabstop ? l.index = n.index + (r + 1) / this._nestingLevel : l.index = n.index + l.index / this._nestingLevel;
          this._snippet.replace(n, o._snippet.children);
          const a = this._placeholderDecorations.get(n);
          i.removeDecoration(a), this._placeholderDecorations.delete(n);
          for (const l of o._snippet.placeholders) {
            const c = o._snippet.offset(l), d = o._snippet.fullLen(l), h = D.fromPositions(t.getPositionAt(o._offset + c), t.getPositionAt(o._offset + c + d)), u = i.addDecoration(h, Vo._decor.inactive);
            this._placeholderDecorations.set(l, u);
          }
        }
        this._placeholderGroups = z2(this._snippet.placeholders, Ho.compareByIndex);
      });
    }
  }
  Vo._decor = {
    active: $e.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
    inactive: $e.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
    activeFinal: $e.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
    inactiveFinal: $e.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
  };
  const GA = {
    overwriteBefore: 0,
    overwriteAfter: 0,
    adjustWhitespace: !0,
    clipboardText: void 0,
    overtypingCapturer: void 0
  };
  class Br {
    constructor(e, t, i = GA) {
      this._templateMerges = [], this._snippets = [], this._editor = e, this._template = t, this._options = i;
    }
    static adjustWhitespace(e, t, i, n, o) {
      const r = e.getLineContent(t.lineNumber), a = Dt(r, 0, t.column - 1);
      let l;
      return i.walk((c) => {
        if (!(c instanceof ws) || c.parent instanceof D_)
          return !0;
        const d = c.value.split(/\r\n|\r|\n/);
        if (n) {
          const u = i.offset(c);
          if (u === 0)
            d[0] = e.normalizeIndentation(d[0]);
          else {
            l = l ?? i.toString();
            let f = l.charCodeAt(u - 1);
            (f === 10 || f === 13) && (d[0] = e.normalizeIndentation(a + d[0]));
          }
          for (let f = 1; f < d.length; f++)
            d[f] = e.normalizeIndentation(a + d[f]);
        }
        const h = d.join(e.getEOL());
        return h !== c.value && (c.parent.replace(c, [new ws(h)]), l = void 0), !0;
      }), a;
    }
    static adjustSelection(e, t, i, n) {
      if (i !== 0 || n !== 0) {
        const { positionLineNumber: o, positionColumn: r } = t, a = r - i, l = r + n, c = e.validateRange({
          startLineNumber: o,
          startColumn: a,
          endLineNumber: o,
          endColumn: l
        });
        t = ae.createWithDirection(c.startLineNumber, c.startColumn, c.endLineNumber, c.endColumn, t.getDirection());
      }
      return t;
    }
    static createEditsAndSnippets(e, t, i, n, o, r, a, l) {
      const c = [], d = [];
      if (!e.hasModel())
        return { edits: c, snippets: d };
      const h = e.getModel(), u = e.invokeWithinContext((S) => S.get(u9)), f = e.invokeWithinContext((S) => new rne(S.get(w_), h)), g = () => a;
      let _ = 0, b = h.getValueInRange(Br.adjustSelection(h, e.getSelection(), i, 0)), C = h.getValueInRange(Br.adjustSelection(h, e.getSelection(), 0, n)), v = h.getLineFirstNonWhitespaceColumn(e.getSelection().positionLineNumber);
      const w = e.getSelections().map((S, L) => ({ selection: S, idx: L })).sort((S, L) => D.compareRangesUsingStarts(S.selection, L.selection));
      for (const { selection: S, idx: L } of w) {
        let x = Br.adjustSelection(h, S, i, 0), y = Br.adjustSelection(h, S, 0, n);
        b !== h.getValueInRange(x) && (x = S), C !== h.getValueInRange(y) && (y = S);
        const k = S.setStartPosition(x.startLineNumber, x.startColumn).setEndPosition(y.endLineNumber, y.endColumn), I = new WC().parse(t, !0, o), F = k.getStartPosition(), R = Br.adjustWhitespace(h, F, I, r || L > 0 && v !== h.getLineFirstNonWhitespaceColumn(S.positionLineNumber), !0);
        I.resolveVariables(new sne([
          f,
          new ane(g, L, w.length, e.getOption(71) === "spread"),
          new one(h, S, L, l),
          new lne(h, S),
          new ea(),
          new cne(u),
          new dne()
        ]));
        const $ = h.getOffsetAt(F) + _;
        _ += I.toString().length - h.getValueLengthInRange(k), c[L] = li.replace(k, I.toString()), c[L].identifier = { major: L, minor: 0 }, d[L] = new Vo(e, I, $, R);
      }
      return { edits: c, snippets: d };
    }
    dispose() {
      at(this._snippets);
    }
    _logInfo() {
      return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
    }
    insert() {
      if (!this._editor.hasModel())
        return;
      const { edits: e, snippets: t } = Br.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, !1, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);
      this._snippets = t, this._editor.executeEdits("snippet", e, (i) => this._snippets[0].hasPlaceholder ? this._move(!0) : i.filter((n) => !!n.identifier).map((n) => ae.fromPositions(n.range.getEndPosition()))), this._editor.revealRange(this._editor.getSelections()[0]);
    }
    merge(e, t = GA) {
      if (!this._editor.hasModel())
        return;
      this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, e]);
      const { edits: i, snippets: n } = Br.createEditsAndSnippets(this._editor, e, t.overwriteBefore, t.overwriteAfter, !0, t.adjustWhitespace, t.clipboardText, t.overtypingCapturer);
      this._editor.executeEdits("snippet", i, (o) => {
        for (const r of this._snippets)
          r.merge(n);
        return console.assert(n.length === 0), this._snippets[0].hasPlaceholder ? this._move(void 0) : o.filter((r) => !!r.identifier).map((r) => ae.fromPositions(r.range.getEndPosition()));
      });
    }
    next() {
      const e = this._move(!0);
      this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
    }
    prev() {
      const e = this._move(!1);
      this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
    }
    _move(e) {
      const t = [];
      for (const i of this._snippets) {
        const n = i.move(e);
        t.push(...n);
      }
      return t;
    }
    get isAtFirstPlaceholder() {
      return this._snippets[0].isAtFirstPlaceholder;
    }
    get isAtLastPlaceholder() {
      return this._snippets[0].isAtLastPlaceholder;
    }
    get hasPlaceholder() {
      return this._snippets[0].hasPlaceholder;
    }
    get choice() {
      return this._snippets[0].choice;
    }
    isSelectionWithinPlaceholders() {
      if (!this.hasPlaceholder)
        return !1;
      const e = this._editor.getSelections();
      if (e.length < this._snippets.length)
        return !1;
      let t = /* @__PURE__ */ new Map();
      for (const i of this._snippets) {
        const n = i.computePossibleSelections();
        if (t.size === 0)
          for (const [o, r] of n) {
            r.sort(D.compareRangesUsingStarts);
            for (const a of e)
              if (r[0].containsRange(a)) {
                t.set(o, []);
                break;
              }
          }
        if (t.size === 0)
          return !1;
        t.forEach((o, r) => {
          o.push(...n.get(r));
        });
      }
      e.sort(D.compareRangesUsingStarts);
      for (let [i, n] of t) {
        if (n.length !== e.length) {
          t.delete(i);
          continue;
        }
        n.sort(D.compareRangesUsingStarts);
        for (let o = 0; o < n.length; o++)
          if (!n[o].containsRange(e[o])) {
            t.delete(i);
            continue;
          }
      }
      return t.size > 0;
    }
  }
  var hne = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, ay = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const ZA = {
    overwriteBefore: 0,
    overwriteAfter: 0,
    undoStopBefore: !0,
    undoStopAfter: !0,
    adjustWhitespace: !0,
    clipboardText: void 0,
    overtypingCapturer: void 0
  };
  let vn = class Jg {
    constructor(e, t, i, n) {
      this._editor = e, this._instantiationService = t, this._logService = i, this._snippetListener = new te(), this._modelVersionId = -1, this._inSnippet = Jg.InSnippetMode.bindTo(n), this._hasNextTabstop = Jg.HasNextTabstop.bindTo(n), this._hasPrevTabstop = Jg.HasPrevTabstop.bindTo(n);
    }
    static get(e) {
      return e.getContribution(Jg.ID);
    }
    dispose() {
      var e;
      this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), (e = this._session) === null || e === void 0 || e.dispose(), this._snippetListener.dispose();
    }
    insert(e, t) {
      try {
        this._doInsert(e, typeof t > "u" ? ZA : Object.assign(Object.assign({}, ZA), t));
      } catch (i) {
        this.cancel(), this._logService.error(i), this._logService.error("snippet_error"), this._logService.error("insert_template=", e), this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
      }
    }
    _doInsert(e, t) {
      !this._editor.hasModel() || (this._snippetListener.clear(), t.undoStopBefore && this._editor.getModel().pushStackElement(), this._session ? this._session.merge(e, t) : (this._modelVersionId = this._editor.getModel().getAlternativeVersionId(), this._session = new Br(this._editor, e, t), this._session.insert()), t.undoStopAfter && this._editor.getModel().pushStackElement(), this._updateState(), this._snippetListener.add(this._editor.onDidChangeModelContent((i) => i.isFlush && this.cancel())), this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel())), this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState())));
    }
    _updateState() {
      if (!(!this._session || !this._editor.hasModel())) {
        if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId())
          return this.cancel();
        if (!this._session.hasPlaceholder)
          return this.cancel();
        if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders())
          return this._editor.getModel().pushStackElement(), this.cancel();
        this._inSnippet.set(!0), this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder), this._hasNextTabstop.set(!this._session.isAtLastPlaceholder), this._handleChoice();
      }
    }
    _handleChoice() {
      if (!this._session || !this._editor.hasModel()) {
        this._currentChoice = void 0;
        return;
      }
      const { choice: e } = this._session;
      if (!e) {
        this._currentChoice = void 0;
        return;
      }
      if (this._currentChoice !== e) {
        this._currentChoice = e, this._editor.setSelections(this._editor.getSelections().map((i) => ae.fromPositions(i.getStartPosition())));
        const [t] = e.options;
        this._instantiationService.invokeFunction(QJ, this._editor, e.options.map((i, n) => ({
          kind: 13,
          label: i.value,
          insertText: i.value,
          sortText: "a".repeat(n + 1),
          range: D.fromPositions(this._editor.getPosition(), this._editor.getPosition().delta(0, t.value.length))
        })));
      }
    }
    finish() {
      for (; this._inSnippet.get(); )
        this.next();
    }
    cancel(e = !1) {
      var t;
      this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), this._snippetListener.clear(), (t = this._session) === null || t === void 0 || t.dispose(), this._session = void 0, this._modelVersionId = -1, e && this._editor.setSelections([this._editor.getSelection()]);
    }
    prev() {
      this._session && this._session.prev(), this._updateState();
    }
    next() {
      this._session && this._session.next(), this._updateState();
    }
    isInSnippet() {
      return Boolean(this._inSnippet.get());
    }
  };
  vn.ID = "snippetController2";
  vn.InSnippetMode = new ue("inSnippetMode", !1, m("inSnippetMode", "Whether the editor in current in snippet mode"));
  vn.HasNextTabstop = new ue("hasNextTabstop", !1, m("hasNextTabstop", "Whether there is a next tab stop when in snippet mode"));
  vn.HasPrevTabstop = new ue("hasPrevTabstop", !1, m("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode"));
  vn = hne([
    ay(1, et),
    ay(2, Xo),
    ay(3, Fe)
  ], vn);
  vt(vn.ID, vn);
  const KC = wn.bindToContribution(vn.get);
  se(new KC({
    id: "jumpToNextSnippetPlaceholder",
    precondition: ce.and(vn.InSnippetMode, vn.HasNextTabstop),
    handler: (s) => s.next(),
    kbOpts: {
      weight: 100 + 30,
      kbExpr: T.editorTextFocus,
      primary: 2
    }
  }));
  se(new KC({
    id: "jumpToPrevSnippetPlaceholder",
    precondition: ce.and(vn.InSnippetMode, vn.HasPrevTabstop),
    handler: (s) => s.prev(),
    kbOpts: {
      weight: 100 + 30,
      kbExpr: T.editorTextFocus,
      primary: 1026
    }
  }));
  se(new KC({
    id: "leaveSnippet",
    precondition: vn.InSnippetMode,
    handler: (s) => s.cancel(!0),
    kbOpts: {
      weight: 100 + 30,
      kbExpr: T.editorTextFocus,
      primary: 9,
      secondary: [1033]
    }
  }));
  se(new KC({
    id: "acceptSnippet",
    precondition: vn.InSnippetMode,
    handler: (s) => s.finish()
  }));
  var une = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, YA = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class WN {
    constructor(e) {
      this.name = e;
    }
    select(e, t, i) {
      if (i.length === 0)
        return 0;
      let n = i[0].score[0];
      for (let o = 0; o < i.length; o++) {
        const { score: r, completion: a } = i[o];
        if (r[0] !== n)
          break;
        if (a.preselect)
          return o;
      }
      return 0;
    }
  }
  class f9 extends WN {
    constructor() {
      super("first");
    }
    memorize(e, t, i) {
    }
    toJSON() {
    }
    fromJSON() {
    }
  }
  class fne extends WN {
    constructor() {
      super("recentlyUsed"), this._cache = new Wc(300, 0.66), this._seq = 0;
    }
    memorize(e, t, i) {
      const n = `${e.getLanguageId()}/${i.textLabel}`;
      this._cache.set(n, {
        touch: this._seq++,
        type: i.completion.kind,
        insertText: i.completion.insertText
      });
    }
    select(e, t, i) {
      if (i.length === 0)
        return 0;
      const n = e.getLineContent(t.lineNumber).substr(t.column - 10, t.column - 1);
      if (/\s$/.test(n))
        return super.select(e, t, i);
      let o = i[0].score[0], r = -1, a = -1, l = -1;
      for (let c = 0; c < i.length && i[c].score[0] === o; c++) {
        const d = `${e.getLanguageId()}/${i[c].textLabel}`, h = this._cache.peek(d);
        if (h && h.touch > l && h.type === i[c].completion.kind && h.insertText === i[c].completion.insertText && (l = h.touch, a = c), i[c].completion.preselect && r === -1)
          return r = c;
      }
      return a !== -1 ? a : r !== -1 ? r : 0;
    }
    toJSON() {
      return this._cache.toJSON();
    }
    fromJSON(e) {
      this._cache.clear();
      let t = 0;
      for (const [i, n] of e)
        n.touch = t, n.type = typeof n.type == "number" ? n.type : Ym.fromString(n.type), this._cache.set(i, n);
      this._seq = this._cache.size;
    }
  }
  class gne extends WN {
    constructor() {
      super("recentlyUsedByPrefix"), this._trie = nf.forStrings(), this._seq = 0;
    }
    memorize(e, t, i) {
      const { word: n } = e.getWordUntilPosition(t), o = `${e.getLanguageId()}/${n}`;
      this._trie.set(o, {
        type: i.completion.kind,
        insertText: i.completion.insertText,
        touch: this._seq++
      });
    }
    select(e, t, i) {
      let { word: n } = e.getWordUntilPosition(t);
      if (!n)
        return super.select(e, t, i);
      let o = `${e.getLanguageId()}/${n}`, r = this._trie.get(o);
      if (r || (r = this._trie.findSubstr(o)), r)
        for (let a = 0; a < i.length; a++) {
          let { kind: l, insertText: c } = i[a].completion;
          if (l === r.type && c === r.insertText)
            return a;
        }
      return super.select(e, t, i);
    }
    toJSON() {
      let e = [];
      return this._trie.forEach((t, i) => e.push([i, t])), e.sort((t, i) => -(t[1].touch - i[1].touch)).forEach((t, i) => t[1].touch = i), e.slice(0, 200);
    }
    fromJSON(e) {
      if (this._trie.clear(), e.length > 0) {
        this._seq = e[0][1].touch + 1;
        for (const [t, i] of e)
          i.type = typeof i.type == "number" ? i.type : Ym.fromString(i.type), this._trie.set(t, i);
      }
    }
  }
  let Mp = class S0 {
    constructor(e, t) {
      this._storageService = e, this._configService = t, this._disposables = new te(), this._persistSoon = new It(() => this._saveState(), 500), this._disposables.add(e.onWillSaveState((i) => {
        i.reason === N1.SHUTDOWN && this._saveState();
      }));
    }
    dispose() {
      this._disposables.dispose(), this._persistSoon.dispose();
    }
    memorize(e, t, i) {
      this._withStrategy(e, t).memorize(e, t, i), this._persistSoon.schedule();
    }
    select(e, t, i) {
      return this._withStrategy(e, t).select(e, t, i);
    }
    _withStrategy(e, t) {
      var i;
      const n = this._configService.getValue("editor.suggestSelection", {
        overrideIdentifier: e.getLanguageIdAtPosition(t.lineNumber, t.column),
        resource: e.uri
      });
      if (((i = this._strategy) === null || i === void 0 ? void 0 : i.name) !== n) {
        this._saveState();
        const o = S0._strategyCtors.get(n) || f9;
        this._strategy = new o();
        try {
          const a = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, l = this._storageService.get(`${S0._storagePrefix}/${n}`, a);
          l && this._strategy.fromJSON(JSON.parse(l));
        } catch {
        }
      }
      return this._strategy;
    }
    _saveState() {
      if (this._strategy) {
        const t = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, i = JSON.stringify(this._strategy);
        this._storageService.store(`${S0._storagePrefix}/${this._strategy.name}`, i, t, 1);
      }
    }
  };
  Mp._strategyCtors = /* @__PURE__ */ new Map([
    ["recentlyUsedByPrefix", gne],
    ["recentlyUsed", fne],
    ["first", f9]
  ]);
  Mp._storagePrefix = "suggest/memories";
  Mp = une([
    YA(0, La),
    YA(1, At)
  ], Mp);
  const g9 = st("ISuggestMemories");
  ht(g9, Mp, !0);
  var mne = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, pne = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Ap = class m9 {
    constructor(e, t) {
      this._editor = e, this._enabled = !1, this._ckAtEnd = m9.AtEnd.bindTo(t), this._configListener = this._editor.onDidChangeConfiguration((i) => i.hasChanged(111) && this._update()), this._update();
    }
    dispose() {
      var e;
      this._configListener.dispose(), (e = this._selectionListener) === null || e === void 0 || e.dispose(), this._ckAtEnd.reset();
    }
    _update() {
      const e = this._editor.getOption(111) === "on";
      if (this._enabled !== e)
        if (this._enabled = e, this._enabled) {
          const t = () => {
            if (!this._editor.hasModel()) {
              this._ckAtEnd.set(!1);
              return;
            }
            const i = this._editor.getModel(), n = this._editor.getSelection(), o = i.getWordAtPosition(n.getStartPosition());
            if (!o) {
              this._ckAtEnd.set(!1);
              return;
            }
            this._ckAtEnd.set(o.endColumn === n.getStartPosition().column);
          };
          this._selectionListener = this._editor.onDidChangeCursorSelection(t), t();
        } else
          this._selectionListener && (this._ckAtEnd.reset(), this._selectionListener.dispose(), this._selectionListener = void 0);
    }
  };
  Ap.AtEnd = new ue("atEndOfWord", !1);
  Ap = mne([
    pne(1, Fe)
  ], Ap);
  var _ne = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, bne = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let gh = class y0 {
    constructor(e, t) {
      this._editor = e, this._index = 0, this._ckOtherSuggestions = y0.OtherSuggestions.bindTo(t);
    }
    dispose() {
      this.reset();
    }
    reset() {
      var e;
      this._ckOtherSuggestions.reset(), (e = this._listener) === null || e === void 0 || e.dispose(), this._model = void 0, this._acceptNext = void 0, this._ignore = !1;
    }
    set({ model: e, index: t }, i) {
      if (e.items.length === 0) {
        this.reset();
        return;
      }
      if (y0._moveIndex(!0, e, t) === t) {
        this.reset();
        return;
      }
      this._acceptNext = i, this._model = e, this._index = t, this._listener = this._editor.onDidChangeCursorPosition(() => {
        this._ignore || this.reset();
      }), this._ckOtherSuggestions.set(!0);
    }
    static _moveIndex(e, t, i) {
      let n = i;
      for (; n = (n + t.items.length + (e ? 1 : -1)) % t.items.length, !(n === i || !t.items[n].completion.additionalTextEdits); )
        ;
      return n;
    }
    next() {
      this._move(!0);
    }
    prev() {
      this._move(!1);
    }
    _move(e) {
      if (!!this._model)
        try {
          this._ignore = !0, this._index = y0._moveIndex(e, this._model, this._index), this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
        } finally {
          this._ignore = !1;
        }
    }
  };
  gh.OtherSuggestions = new ue("hasOtherSuggestions", !1);
  gh = _ne([
    bne(1, Fe)
  ], gh);
  class vne {
    constructor(e, t, i) {
      this._disposables = new te(), this._disposables.add(t.onDidShow(() => this._onItem(t.getFocusedItem()))), this._disposables.add(t.onDidFocus(this._onItem, this)), this._disposables.add(t.onDidHide(this.reset, this)), this._disposables.add(e.onWillType((n) => {
        if (this._active && !t.isFrozen()) {
          const o = n.charCodeAt(n.length - 1);
          this._active.acceptCharacters.has(o) && e.getOption(0) && i(this._active.item);
        }
      }));
    }
    _onItem(e) {
      if (!e || !Ds(e.item.completion.commitCharacters)) {
        this.reset();
        return;
      }
      if (this._active && this._active.item.item === e.item)
        return;
      const t = new Lu();
      for (const i of e.item.completion.commitCharacters)
        i.length > 0 && t.add(i.charCodeAt(0));
      this._active = { acceptCharacters: t, item: e };
    }
    reset() {
      this._active = void 0;
    }
    dispose() {
      this._disposables.dispose();
    }
  }
  var Cne = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Bs {
    provideSelectionRanges(e, t) {
      return Cne(this, void 0, void 0, function* () {
        const i = [];
        for (const n of t) {
          const o = [];
          i.push(o);
          const r = /* @__PURE__ */ new Map();
          yield new Promise((a) => Bs._bracketsRightYield(a, 0, e, n, r)), yield new Promise((a) => Bs._bracketsLeftYield(a, 0, e, n, r, o));
        }
        return i;
      });
    }
    static _bracketsRightYield(e, t, i, n, o) {
      const r = /* @__PURE__ */ new Map(), a = Date.now();
      for (; ; ) {
        if (t >= Bs._maxRounds) {
          e();
          break;
        }
        if (!n) {
          e();
          break;
        }
        let l = i.bracketPairs.findNextBracket(n);
        if (!l) {
          e();
          break;
        }
        if (Date.now() - a > Bs._maxDuration) {
          setTimeout(() => Bs._bracketsRightYield(e, t + 1, i, n, o));
          break;
        }
        const d = l.close[0];
        if (l.isOpen) {
          let h = r.has(d) ? r.get(d) : 0;
          r.set(d, h + 1);
        } else {
          let h = r.has(d) ? r.get(d) : 0;
          if (h -= 1, r.set(d, Math.max(0, h)), h < 0) {
            let u = o.get(d);
            u || (u = new $s(), o.set(d, u)), u.push(l.range);
          }
        }
        n = l.range.getEndPosition();
      }
    }
    static _bracketsLeftYield(e, t, i, n, o, r) {
      const a = /* @__PURE__ */ new Map(), l = Date.now();
      for (; ; ) {
        if (t >= Bs._maxRounds && o.size === 0) {
          e();
          break;
        }
        if (!n) {
          e();
          break;
        }
        let c = i.bracketPairs.findPrevBracket(n);
        if (!c) {
          e();
          break;
        }
        if (Date.now() - l > Bs._maxDuration) {
          setTimeout(() => Bs._bracketsLeftYield(e, t + 1, i, n, o, r));
          break;
        }
        const h = c.close[0];
        if (c.isOpen) {
          let u = a.has(h) ? a.get(h) : 0;
          if (u -= 1, a.set(h, Math.max(0, u)), u < 0) {
            let f = o.get(h);
            if (f) {
              let g = f.shift();
              f.size === 0 && o.delete(h);
              const _ = D.fromPositions(c.range.getEndPosition(), g.getStartPosition()), b = D.fromPositions(c.range.getStartPosition(), g.getEndPosition());
              r.push({ range: _ }), r.push({ range: b }), Bs._addBracketLeading(i, b, r);
            }
          }
        } else {
          let u = a.has(h) ? a.get(h) : 0;
          a.set(h, u + 1);
        }
        n = c.range.getStartPosition();
      }
    }
    static _addBracketLeading(e, t, i) {
      if (t.startLineNumber === t.endLineNumber)
        return;
      const n = t.startLineNumber, o = e.getLineFirstNonWhitespaceColumn(n);
      o !== 0 && o !== t.startColumn && (i.push({ range: D.fromPositions(new V(n, o), t.getEndPosition()) }), i.push({ range: D.fromPositions(new V(n, 1), t.getEndPosition()) }));
      const r = n - 1;
      if (r > 0) {
        const a = e.getLineFirstNonWhitespaceColumn(r);
        a === t.startColumn && a !== e.getLineLastNonWhitespaceColumn(r) && (i.push({ range: D.fromPositions(new V(r, a), t.getEndPosition()) }), i.push({ range: D.fromPositions(new V(r, 1), t.getEndPosition()) }));
      }
    }
  }
  Bs._maxDuration = 30;
  Bs._maxRounds = 2;
  var wne = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class $r {
    static create(e, t) {
      return wne(this, void 0, void 0, function* () {
        if (!t.getOption(106).localityBonus || !t.hasModel())
          return $r.None;
        const i = t.getModel(), n = t.getPosition();
        if (!e.canComputeWordRanges(i.uri))
          return $r.None;
        const [o] = yield new Bs().provideSelectionRanges(i, [n]);
        if (o.length === 0)
          return $r.None;
        const r = yield e.computeWordRanges(i.uri, o[0].range);
        if (!r)
          return $r.None;
        const a = i.getWordUntilPosition(n);
        return delete r[a.word], new class extends $r {
          distance(l, c) {
            if (!n.equals(t.getPosition()))
              return 0;
            if (c.kind === 17)
              return 2 << 20;
            let d = typeof c.label == "string" ? c.label : c.label.label, h = r[d];
            if (KP(h))
              return 2 << 20;
            let u = UI(h, D.fromPositions(l), D.compareRangesUsingStarts), f = u >= 0 ? h[u] : h[Math.max(0, ~u - 1)], g = o.length;
            for (const _ of o) {
              if (!D.containsRange(_.range, f))
                break;
              g -= 1;
            }
            return g;
          }
        }();
      });
    }
  }
  $r.None = new class extends $r {
    distance() {
      return 0;
    }
  }();
  class ud {
    constructor(e, t, i, n, o, r, a) {
      this.clipboardText = a, this._snippetCompareFn = ud._compareCompletionItems, this._items = e, this._column = t, this._wordDistance = n, this._options = o, this._refilterKind = 1, this._lineContext = i, r === "top" ? this._snippetCompareFn = ud._compareCompletionItemsSnippetsUp : r === "bottom" && (this._snippetCompareFn = ud._compareCompletionItemsSnippetsDown);
    }
    get lineContext() {
      return this._lineContext;
    }
    set lineContext(e) {
      (this._lineContext.leadingLineContent !== e.leadingLineContent || this._lineContext.characterCountDelta !== e.characterCountDelta) && (this._refilterKind = this._lineContext.characterCountDelta < e.characterCountDelta && this._filteredItems ? 2 : 1, this._lineContext = e);
    }
    get items() {
      return this._ensureCachedState(), this._filteredItems;
    }
    get allProvider() {
      return this._ensureCachedState(), this._providerInfo.keys();
    }
    get incomplete() {
      this._ensureCachedState();
      const e = /* @__PURE__ */ new Set();
      for (let [t, i] of this._providerInfo)
        i && e.add(t);
      return e;
    }
    adopt(e) {
      let t = [];
      for (let i = 0; i < this._items.length; )
        e.has(this._items[i].provider) ? i++ : (t.push(this._items[i]), this._items[i] = this._items[this._items.length - 1], this._items.pop());
      return this._refilterKind = 1, t;
    }
    get stats() {
      return this._ensureCachedState(), this._stats;
    }
    _ensureCachedState() {
      this._refilterKind !== 0 && this._createCachedState();
    }
    _createCachedState() {
      this._providerInfo = /* @__PURE__ */ new Map();
      const e = [], { leadingLineContent: t, characterCountDelta: i } = this._lineContext;
      let n = "", o = "";
      const r = this._refilterKind === 1 ? this._items : this._filteredItems, a = [], l = !this._options.filterGraceful || r.length > 2e3 ? xf : WZ;
      for (let c = 0; c < r.length; c++) {
        const d = r[c];
        if (d.isInvalid)
          continue;
        this._providerInfo.set(d.provider, Boolean(d.container.incomplete));
        const h = d.position.column - d.editStart.column, u = h + i - (d.position.column - this._column);
        if (n.length !== u && (n = u === 0 ? "" : t.slice(-u), o = n.toLowerCase()), d.word = n, u === 0)
          d.score = mr.Default;
        else {
          let f = 0;
          for (; f < h; ) {
            const g = n.charCodeAt(f);
            if (g === 32 || g === 9)
              f += 1;
            else
              break;
          }
          if (f >= u)
            d.score = mr.Default;
          else if (typeof d.completion.filterText == "string") {
            let g = l(n, o, f, d.completion.filterText, d.filterTextLow, 0, !1);
            if (!g)
              continue;
            eL(d.completion.filterText, d.textLabel) === 0 ? d.score = g : (d.score = OZ(n, o, f, d.textLabel, d.labelLow, 0), d.score[0] = g[0]);
          } else {
            let g = l(n, o, f, d.textLabel, d.labelLow, 0, !1);
            if (!g)
              continue;
            d.score = g;
          }
        }
        d.idx = c, d.distance = this._wordDistance.distance(d.position, d.completion), a.push(d), e.push(d.textLabel.length);
      }
      this._filteredItems = a.sort(this._snippetCompareFn), this._refilterKind = 0, this._stats = {
        pLabelLen: e.length ? iL(e.length - 0.85, e, (c, d) => c - d) : 0
      };
    }
    static _compareCompletionItems(e, t) {
      return e.score[0] > t.score[0] ? -1 : e.score[0] < t.score[0] ? 1 : e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : e.idx < t.idx ? -1 : e.idx > t.idx ? 1 : 0;
    }
    static _compareCompletionItemsSnippetsDown(e, t) {
      if (e.completion.kind !== t.completion.kind) {
        if (e.completion.kind === 27)
          return 1;
        if (t.completion.kind === 27)
          return -1;
      }
      return ud._compareCompletionItems(e, t);
    }
    static _compareCompletionItemsSnippetsUp(e, t) {
      if (e.completion.kind !== t.completion.kind) {
        if (e.completion.kind === 27)
          return -1;
        if (t.completion.kind === 27)
          return 1;
      }
      return ud._compareCompletionItems(e, t);
    }
  }
  var Sne = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Qc = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, yne = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class lu {
    constructor(e, t, i, n) {
      this.leadingLineContent = e.getLineContent(t.lineNumber).substr(0, t.column - 1), this.leadingWord = e.getWordUntilPosition(t), this.lineNumber = t.lineNumber, this.column = t.column, this.auto = i, this.shy = n;
    }
    static shouldAutoTrigger(e) {
      if (!e.hasModel())
        return !1;
      const t = e.getModel(), i = e.getPosition();
      t.tokenizeIfCheap(i.lineNumber);
      const n = t.getWordAtPosition(i);
      return !(!n || n.endColumn !== i.column || !isNaN(Number(n.word)));
    }
  }
  function Lne(s, e, t) {
    if (!Boolean(e.getContextKeyValue("inlineSuggestionVisible")))
      return !0;
    const i = t.getValue("editor.inlineSuggest.allowQuickSuggestions");
    return i !== void 0 ? Boolean(i) : !1;
  }
  function kne(s, e, t) {
    if (!Boolean(e.getContextKeyValue("inlineSuggestionVisible")))
      return !0;
    const i = t.getValue("editor.inlineSuggest.allowSuggestOnTriggerCharacters");
    return i !== void 0 ? Boolean(i) : !1;
  }
  let zk = class p9 {
    constructor(e, t, i, n, o, r, a, l) {
      this._editor = e, this._editorWorkerService = t, this._clipboardService = i, this._telemetryService = n, this._logService = o, this._contextKeyService = r, this._configurationService = a, this._languageFeaturesService = l, this._toDispose = new te(), this._quickSuggestDelay = 10, this._triggerCharacterListener = new te(), this._triggerQuickSuggest = new Ns(), this._state = 0, this._completionDisposables = new te(), this._onDidCancel = new B(), this._onDidTrigger = new B(), this._onDidSuggest = new B(), this.onDidCancel = this._onDidCancel.event, this.onDidTrigger = this._onDidTrigger.event, this.onDidSuggest = this._onDidSuggest.event, this._telemetryGate = 0, this._currentSelection = this._editor.getSelection() || new ae(1, 1, 1, 1), this._toDispose.add(this._editor.onDidChangeModel(() => {
        this._updateTriggerCharacters(), this.cancel();
      })), this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
        this._updateTriggerCharacters(), this.cancel();
      })), this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
        this._updateTriggerCharacters(), this._updateQuickSuggest();
      })), this._toDispose.add(this._languageFeaturesService.completionProvider.onDidChange(() => {
        this._updateTriggerCharacters(), this._updateActiveSuggestSession();
      }));
      let c = !1;
      this._toDispose.add(this._editor.onDidCompositionStart(() => {
        c = !0;
      })), this._toDispose.add(this._editor.onDidCompositionEnd(() => {
        c = !1, this._onCompositionEnd();
      })), this._toDispose.add(this._editor.onDidChangeCursorSelection((d) => {
        c || this._onCursorChange(d);
      })), this._toDispose.add(this._editor.onDidChangeModelContent(() => {
        c || this._refilterCompletionItems();
      })), this._updateTriggerCharacters(), this._updateQuickSuggest();
    }
    dispose() {
      at(this._triggerCharacterListener), at([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]), this._toDispose.dispose(), this._completionDisposables.dispose(), this.cancel();
    }
    _updateQuickSuggest() {
      this._quickSuggestDelay = this._editor.getOption(80), (isNaN(this._quickSuggestDelay) || !this._quickSuggestDelay && this._quickSuggestDelay !== 0 || this._quickSuggestDelay < 0) && (this._quickSuggestDelay = 10);
    }
    _updateTriggerCharacters() {
      if (this._triggerCharacterListener.clear(), this._editor.getOption(81) || !this._editor.hasModel() || !this._editor.getOption(109))
        return;
      const e = /* @__PURE__ */ new Map();
      for (const i of this._languageFeaturesService.completionProvider.all(this._editor.getModel()))
        for (const n of i.triggerCharacters || []) {
          let o = e.get(n);
          o || (o = /* @__PURE__ */ new Set(), o.add(GJ()), e.set(n, o)), o.add(i);
        }
      const t = (i) => {
        if (!kne(this._editor, this._contextKeyService, this._configurationService) || lu.shouldAutoTrigger(this._editor))
          return;
        if (!i) {
          const r = this._editor.getPosition();
          i = this._editor.getModel().getLineContent(r.lineNumber).substr(0, r.column - 1);
        }
        let n = "";
        Kd(i.charCodeAt(i.length - 1)) ? Pi(i.charCodeAt(i.length - 2)) && (n = i.substr(i.length - 2)) : n = i.charAt(i.length - 1);
        const o = e.get(n);
        if (o) {
          const r = this._completionModel ? { items: this._completionModel.adopt(o), clipboardText: this._completionModel.clipboardText } : void 0;
          this.trigger({ auto: !0, shy: !1, triggerCharacter: n }, Boolean(this._completionModel), o, r);
        }
      };
      this._triggerCharacterListener.add(this._editor.onDidType(t)), this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(() => t()));
    }
    get state() {
      return this._state;
    }
    cancel(e = !1) {
      var t;
      this._state !== 0 && (this._triggerQuickSuggest.cancel(), (t = this._requestToken) === null || t === void 0 || t.cancel(), this._requestToken = void 0, this._state = 0, this._completionModel = void 0, this._context = void 0, this._onDidCancel.fire({ retrigger: e }));
    }
    clear() {
      this._completionDisposables.clear();
    }
    _updateActiveSuggestSession() {
      this._state !== 0 && (!this._editor.hasModel() || !this._languageFeaturesService.completionProvider.has(this._editor.getModel()) ? this.cancel() : this.trigger({ auto: this._state === 2, shy: !1 }, !0));
    }
    _onCursorChange(e) {
      if (!this._editor.hasModel())
        return;
      const t = this._currentSelection;
      if (this._currentSelection = this._editor.getSelection(), !e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
        this.cancel();
        return;
      }
      this._state === 0 && e.reason === 0 ? (t.containsRange(this._currentSelection) || t.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) && this._doTriggerQuickSuggest() : this._state !== 0 && e.reason === 3 && this._refilterCompletionItems();
    }
    _onCompositionEnd() {
      this._state === 0 ? this._doTriggerQuickSuggest() : this._refilterCompletionItems();
    }
    _doTriggerQuickSuggest() {
      var e;
      this._editor.getOption(79) !== !1 && (this._editor.getOption(106).snippetsPreventQuickSuggestions && ((e = vn.get(this._editor)) === null || e === void 0 ? void 0 : e.isInSnippet()) || (this.cancel(), this._triggerQuickSuggest.cancelAndSet(() => {
        if (this._state !== 0 || !lu.shouldAutoTrigger(this._editor) || !this._editor.hasModel())
          return;
        const t = this._editor.getModel(), i = this._editor.getPosition(), n = this._editor.getOption(79);
        if (n !== !1) {
          if (n !== !0) {
            t.tokenizeIfCheap(i.lineNumber);
            const o = t.getLineTokens(i.lineNumber), r = o.getStandardTokenType(o.findTokenIndexAtOffset(Math.max(i.column - 1 - 1, 0)));
            if (!(n.other && r === 0 || n.comments && r === 1 || n.strings && r === 2))
              return;
          }
          !Lne(this._editor, this._contextKeyService, this._configurationService) || !this._languageFeaturesService.completionProvider.has(t) || this.trigger({ auto: !0, shy: !1 });
        }
      }, this._quickSuggestDelay)));
    }
    _refilterCompletionItems() {
      Promise.resolve().then(() => {
        if (this._state === 0 || !this._editor.hasModel())
          return;
        const e = this._editor.getModel(), t = this._editor.getPosition(), i = new lu(e, t, this._state === 2, !1);
        this._onNewContext(i);
      });
    }
    trigger(e, t = !1, i, n) {
      var o;
      if (!this._editor.hasModel())
        return;
      const r = this._editor.getModel(), a = e.auto, l = new lu(r, this._editor.getPosition(), a, e.shy);
      this.cancel(t), this._state = a ? 2 : 1, this._onDidTrigger.fire({ auto: a, shy: e.shy, position: this._editor.getPosition() }), this._context = l;
      let c = { triggerKind: (o = e.triggerKind) !== null && o !== void 0 ? o : 0 };
      e.triggerCharacter && (c = {
        triggerKind: 1,
        triggerCharacter: e.triggerCharacter
      }), this._requestToken = new bn();
      const d = this._editor.getOption(101);
      let h = 1;
      switch (d) {
        case "top":
          h = 0;
          break;
        case "bottom":
          h = 2;
          break;
      }
      const { itemKind: u, showDeprecated: f } = p9._createSuggestFilter(this._editor), g = $r.create(this._editorWorkerService, this._editor), _ = x7(this._languageFeaturesService.completionProvider, r, this._editor.getPosition(), new W1(h, u, i, f), c, this._requestToken.token);
      Promise.all([_, g]).then(([b, C]) => yne(this, void 0, void 0, function* () {
        var v;
        if ((v = this._requestToken) === null || v === void 0 || v.dispose(), !this._editor.hasModel())
          return;
        let w = n?.clipboardText;
        if (!w && b.needsClipboard && (w = yield this._clipboardService.readText()), this._state === 0)
          return;
        const S = this._editor.getModel();
        let L = b.items;
        if (n) {
          const y = I7(h);
          L = L.concat(n.items).sort(y);
        }
        const x = new lu(S, this._editor.getPosition(), a, e.shy);
        this._completionModel = new ud(L, this._context.column, {
          leadingLineContent: x.leadingLineContent,
          characterCountDelta: x.column - this._context.column
        }, C, this._editor.getOption(106), this._editor.getOption(101), w), this._completionDisposables.add(b.disposable), this._onNewContext(x), this._reportDurationsTelemetry(b.durations);
      })).catch(We);
    }
    _reportDurationsTelemetry(e) {
      this._telemetryGate++ % 230 === 0 && setTimeout(() => {
        this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(e) }), this._logService.debug("suggest.durations.json", e);
      });
    }
    static _createSuggestFilter(e) {
      const t = /* @__PURE__ */ new Set();
      e.getOption(101) === "none" && t.add(27);
      const n = e.getOption(106);
      return n.showMethods || t.add(0), n.showFunctions || t.add(1), n.showConstructors || t.add(2), n.showFields || t.add(3), n.showVariables || t.add(4), n.showClasses || t.add(5), n.showStructs || t.add(6), n.showInterfaces || t.add(7), n.showModules || t.add(8), n.showProperties || t.add(9), n.showEvents || t.add(10), n.showOperators || t.add(11), n.showUnits || t.add(12), n.showValues || t.add(13), n.showConstants || t.add(14), n.showEnums || t.add(15), n.showEnumMembers || t.add(16), n.showKeywords || t.add(17), n.showWords || t.add(18), n.showColors || t.add(19), n.showFiles || t.add(20), n.showReferences || t.add(21), n.showColors || t.add(22), n.showFolders || t.add(23), n.showTypeParameters || t.add(24), n.showSnippets || t.add(27), n.showUsers || t.add(25), n.showIssues || t.add(26), { itemKind: t, showDeprecated: n.showDeprecated };
    }
    _onNewContext(e) {
      if (!!this._context) {
        if (e.lineNumber !== this._context.lineNumber) {
          this.cancel();
          return;
        }
        if (Dt(e.leadingLineContent) !== Dt(this._context.leadingLineContent)) {
          this.cancel();
          return;
        }
        if (e.column < this._context.column) {
          e.leadingWord.word ? this.trigger({ auto: this._context.auto, shy: !1 }, !0) : this.cancel();
          return;
        }
        if (!!this._completionModel) {
          if (e.leadingWord.word.length !== 0 && e.leadingWord.startColumn > this._context.leadingWord.startColumn) {
            const t = new Set(this._languageFeaturesService.completionProvider.all(this._editor.getModel()));
            for (let n of this._completionModel.allProvider)
              t.delete(n);
            const i = this._completionModel.adopt(/* @__PURE__ */ new Set());
            this.trigger({ auto: this._context.auto, shy: !1 }, !0, t, { items: i, clipboardText: this._completionModel.clipboardText });
            return;
          }
          if (e.column > this._context.column && this._completionModel.incomplete.size > 0 && e.leadingWord.word.length !== 0) {
            const { incomplete: t } = this._completionModel, i = this._completionModel.adopt(t);
            this.trigger({ auto: this._state === 2, shy: !1, triggerKind: 2 }, !0, t, { items: i, clipboardText: this._completionModel.clipboardText });
          } else {
            let t = this._completionModel.lineContext, i = !1;
            if (this._completionModel.lineContext = {
              leadingLineContent: e.leadingLineContent,
              characterCountDelta: e.column - this._context.column
            }, this._completionModel.items.length === 0) {
              if (lu.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < e.leadingWord.startColumn) {
                this.trigger({ auto: this._context.auto, shy: !1 }, !0);
                return;
              }
              if (this._context.auto) {
                this.cancel();
                return;
              } else if (this._completionModel.lineContext = t, i = this._completionModel.items.length > 0, i && e.leadingWord.word.length === 0) {
                this.cancel();
                return;
              }
            }
            this._onDidSuggest.fire({
              completionModel: this._completionModel,
              auto: this._context.auto,
              shy: this._context.shy,
              isFrozen: i
            });
          }
        }
      }
    }
  };
  zk = Sne([
    Qc(1, xo),
    Qc(2, Fh),
    Qc(3, Ca),
    Qc(4, Xo),
    Qc(5, Fe),
    Qc(6, At),
    Qc(7, me)
  ], zk);
  class qC {
    constructor(e, t) {
      this._disposables = new te(), this._lastOvertyped = [], this._empty = !0, this._disposables.add(e.onWillType(() => {
        if (!this._empty || !e.hasModel())
          return;
        const i = e.getSelections(), n = i.length;
        let o = !1;
        for (let a = 0; a < n; a++)
          if (!i[a].isEmpty()) {
            o = !0;
            break;
          }
        if (!o)
          return;
        this._lastOvertyped = [];
        const r = e.getModel();
        for (let a = 0; a < n; a++) {
          const l = i[a];
          if (r.getValueLengthInRange(l) > qC._maxSelectionLength)
            return;
          this._lastOvertyped[a] = { value: r.getValueInRange(l), multiline: l.startLineNumber !== l.endLineNumber };
        }
        this._empty = !1;
      })), this._disposables.add(t.onDidCancel((i) => {
        !this._empty && !i.retrigger && (this._empty = !0);
      }));
    }
    getLastOvertypedInfo(e) {
      if (!this._empty && e >= 0 && e < this._lastOvertyped.length)
        return this._lastOvertyped[e];
    }
    dispose() {
      this._disposables.dispose();
    }
  }
  qC._maxSelectionLength = 51200;
  function XA(s) {
    let e = s.definition;
    for (; e instanceof p; )
      e = e.definition;
    return `.codicon-${s.id}:before { content: '${e.fontCharacter}'; }`;
  }
  var Dne = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, ly = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class VN extends Nf {
    updateLabel() {
      const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
      if (!e)
        return super.updateLabel();
      this.label && (this.label.textContent = m("ddd", "{0} ({1})", this._action.label, VN.symbolPrintEnter(e)));
    }
    static symbolPrintEnter(e) {
      var t;
      return (t = e.getLabel()) === null || t === void 0 ? void 0 : t.replace(/\benter\b/gi, "\u23CE");
    }
  }
  let Uk = class {
    constructor(e, t, i, n) {
      this._menuService = i, this._contextKeyService = n, this._menuDisposables = new te(), this.element = q(e, J(".suggest-status-bar"));
      const o = (r) => r instanceof vc ? t.createInstance(VN, r, void 0) : void 0;
      this._leftActions = new ga(this.element, { actionViewItemProvider: o }), this._rightActions = new ga(this.element, { actionViewItemProvider: o }), this._leftActions.domNode.classList.add("left"), this._rightActions.domNode.classList.add("right");
    }
    dispose() {
      this._menuDisposables.dispose(), this.element.remove();
    }
    show() {
      const e = this._menuService.createMenu(Nc, this._contextKeyService), t = () => {
        const i = [], n = [];
        for (let [o, r] of e.getActions())
          o === "left" ? i.push(...r) : n.push(...r);
        this._leftActions.clear(), this._leftActions.push(i), this._rightActions.clear(), this._rightActions.push(n);
      };
      this._menuDisposables.add(e.onDidChange(() => t())), this._menuDisposables.add(e);
    }
    hide() {
      this._menuDisposables.clear();
    }
  };
  Uk = Dne([
    ly(1, et),
    ly(2, Eh),
    ly(3, Fe)
  ], Uk);
  const xne = M("symbolIcon.arrayForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Ine = M("symbolIcon.booleanForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Ene = M("symbolIcon.classForeground", {
    dark: "#EE9D28",
    light: "#D67E00",
    hc: "#EE9D28"
  }, m("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Nne = M("symbolIcon.colorForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Tne = M("symbolIcon.constantForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Mne = M("symbolIcon.constructorForeground", {
    dark: "#B180D7",
    light: "#652D90",
    hc: "#B180D7"
  }, m("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Ane = M("symbolIcon.enumeratorForeground", {
    dark: "#EE9D28",
    light: "#D67E00",
    hc: "#EE9D28"
  }, m("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Rne = M("symbolIcon.enumeratorMemberForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hc: "#75BEFF"
  }, m("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), One = M("symbolIcon.eventForeground", {
    dark: "#EE9D28",
    light: "#D67E00",
    hc: "#EE9D28"
  }, m("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Pne = M("symbolIcon.fieldForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hc: "#75BEFF"
  }, m("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Fne = M("symbolIcon.fileForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Bne = M("symbolIcon.folderForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Wne = M("symbolIcon.functionForeground", {
    dark: "#B180D7",
    light: "#652D90",
    hc: "#B180D7"
  }, m("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Vne = M("symbolIcon.interfaceForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hc: "#75BEFF"
  }, m("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Hne = M("symbolIcon.keyForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), zne = M("symbolIcon.keywordForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Une = M("symbolIcon.methodForeground", {
    dark: "#B180D7",
    light: "#652D90",
    hc: "#B180D7"
  }, m("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), $ne = M("symbolIcon.moduleForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), jne = M("symbolIcon.namespaceForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Kne = M("symbolIcon.nullForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), qne = M("symbolIcon.numberForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Gne = M("symbolIcon.objectForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Zne = M("symbolIcon.operatorForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Yne = M("symbolIcon.packageForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Xne = M("symbolIcon.propertyForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Qne = M("symbolIcon.referenceForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), Jne = M("symbolIcon.snippetForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), ese = M("symbolIcon.stringForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), tse = M("symbolIcon.structForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), ise = M("symbolIcon.textForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), nse = M("symbolIcon.typeParameterForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), sse = M("symbolIcon.unitForeground", {
    dark: fe,
    light: fe,
    hc: fe
  }, m("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget.")), ose = M("symbolIcon.variableForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hc: "#75BEFF"
  }, m("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
  Vt((s, e) => {
    const t = s.getColor(xne);
    t && e.addRule(`${p.symbolArray.cssSelector} { color: ${t}; }`);
    const i = s.getColor(Ine);
    i && e.addRule(`${p.symbolBoolean.cssSelector} { color: ${i}; }`);
    const n = s.getColor(Ene);
    n && e.addRule(`${p.symbolClass.cssSelector} { color: ${n}; }`);
    const o = s.getColor(Une);
    o && e.addRule(`${p.symbolMethod.cssSelector} { color: ${o}; }`);
    const r = s.getColor(Nne);
    r && e.addRule(`${p.symbolColor.cssSelector} { color: ${r}; }`);
    const a = s.getColor(Tne);
    a && e.addRule(`${p.symbolConstant.cssSelector} { color: ${a}; }`);
    const l = s.getColor(Mne);
    l && e.addRule(`${p.symbolConstructor.cssSelector} { color: ${l}; }`);
    const c = s.getColor(Ane);
    c && e.addRule(`
			${p.symbolValue.cssSelector},${p.symbolEnum.cssSelector} { color: ${c}; }`);
    const d = s.getColor(Rne);
    d && e.addRule(`${p.symbolEnumMember.cssSelector} { color: ${d}; }`);
    const h = s.getColor(One);
    h && e.addRule(`${p.symbolEvent.cssSelector} { color: ${h}; }`);
    const u = s.getColor(Pne);
    u && e.addRule(`${p.symbolField.cssSelector} { color: ${u}; }`);
    const f = s.getColor(Fne);
    f && e.addRule(`${p.symbolFile.cssSelector} { color: ${f}; }`);
    const g = s.getColor(Bne);
    g && e.addRule(`${p.symbolFolder.cssSelector} { color: ${g}; }`);
    const _ = s.getColor(Wne);
    _ && e.addRule(`${p.symbolFunction.cssSelector} { color: ${_}; }`);
    const b = s.getColor(Vne);
    b && e.addRule(`${p.symbolInterface.cssSelector} { color: ${b}; }`);
    const C = s.getColor(Hne);
    C && e.addRule(`${p.symbolKey.cssSelector} { color: ${C}; }`);
    const v = s.getColor(zne);
    v && e.addRule(`${p.symbolKeyword.cssSelector} { color: ${v}; }`);
    const w = s.getColor($ne);
    w && e.addRule(`${p.symbolModule.cssSelector} { color: ${w}; }`);
    const S = s.getColor(jne);
    S && e.addRule(`${p.symbolNamespace.cssSelector} { color: ${S}; }`);
    const L = s.getColor(Kne);
    L && e.addRule(`${p.symbolNull.cssSelector} { color: ${L}; }`);
    const x = s.getColor(qne);
    x && e.addRule(`${p.symbolNumber.cssSelector} { color: ${x}; }`);
    const y = s.getColor(Gne);
    y && e.addRule(`${p.symbolObject.cssSelector} { color: ${y}; }`);
    const k = s.getColor(Zne);
    k && e.addRule(`${p.symbolOperator.cssSelector} { color: ${k}; }`);
    const I = s.getColor(Yne);
    I && e.addRule(`${p.symbolPackage.cssSelector} { color: ${I}; }`);
    const F = s.getColor(Xne);
    F && e.addRule(`${p.symbolProperty.cssSelector} { color: ${F}; }`);
    const R = s.getColor(Qne);
    R && e.addRule(`${p.symbolReference.cssSelector} { color: ${R}; }`);
    const $ = s.getColor(Jne);
    $ && e.addRule(`${p.symbolSnippet.cssSelector} { color: ${$}; }`);
    const j = s.getColor(ese);
    j && e.addRule(`${p.symbolString.cssSelector} { color: ${j}; }`);
    const le = s.getColor(tse);
    le && e.addRule(`${p.symbolStruct.cssSelector} { color: ${le}; }`);
    const he = s.getColor(ise);
    he && e.addRule(`${p.symbolText.cssSelector} { color: ${he}; }`);
    const Ce = s.getColor(nse);
    Ce && e.addRule(`${p.symbolTypeParameter.cssSelector} { color: ${Ce}; }`);
    const Ne = s.getColor(sse);
    Ne && e.addRule(`${p.symbolUnit.cssSelector} { color: ${Ne}; }`);
    const xe = s.getColor(ose);
    xe && e.addRule(`${p.symbolVariable.cssSelector} { color: ${xe}; }`);
  });
  class _9 {
    constructor() {
      this._onDidWillResize = new B(), this.onDidWillResize = this._onDidWillResize.event, this._onDidResize = new B(), this.onDidResize = this._onDidResize.event, this._sashListener = new te(), this._size = new Et(0, 0), this._minSize = new Et(0, 0), this._maxSize = new Et(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER), this.domNode = document.createElement("div"), this._eastSash = new Dn(this.domNode, { getVerticalSashLeft: () => this._size.width }, { orientation: 0 }), this._westSash = new Dn(this.domNode, { getVerticalSashLeft: () => 0 }, { orientation: 0 }), this._northSash = new Dn(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: L1.North }), this._southSash = new Dn(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: L1.South }), this._northSash.orthogonalStartSash = this._westSash, this._northSash.orthogonalEndSash = this._eastSash, this._southSash.orthogonalStartSash = this._westSash, this._southSash.orthogonalEndSash = this._eastSash;
      let e, t = 0, i = 0;
      this._sashListener.add(be.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
        e === void 0 && (this._onDidWillResize.fire(), e = this._size, t = 0, i = 0);
      })), this._sashListener.add(be.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
        e !== void 0 && (e = void 0, t = 0, i = 0, this._onDidResize.fire({ dimension: this._size, done: !0 }));
      })), this._sashListener.add(this._eastSash.onDidChange((n) => {
        e && (i = n.currentX - n.startX, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, east: !0 }));
      })), this._sashListener.add(this._westSash.onDidChange((n) => {
        e && (i = -(n.currentX - n.startX), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, west: !0 }));
      })), this._sashListener.add(this._northSash.onDidChange((n) => {
        e && (t = -(n.currentY - n.startY), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, north: !0 }));
      })), this._sashListener.add(this._southSash.onDidChange((n) => {
        e && (t = n.currentY - n.startY, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, south: !0 }));
      })), this._sashListener.add(be.any(this._eastSash.onDidReset, this._westSash.onDidReset)((n) => {
        this._preferredSize && (this.layout(this._size.height, this._preferredSize.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
      })), this._sashListener.add(be.any(this._northSash.onDidReset, this._southSash.onDidReset)((n) => {
        this._preferredSize && (this.layout(this._preferredSize.height, this._size.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
      }));
    }
    dispose() {
      this._northSash.dispose(), this._southSash.dispose(), this._eastSash.dispose(), this._westSash.dispose(), this._sashListener.dispose(), this._onDidResize.dispose(), this._onDidWillResize.dispose(), this.domNode.remove();
    }
    enableSashes(e, t, i, n) {
      this._northSash.state = e ? 3 : 0, this._eastSash.state = t ? 3 : 0, this._southSash.state = i ? 3 : 0, this._westSash.state = n ? 3 : 0;
    }
    layout(e = this.size.height, t = this.size.width) {
      const { height: i, width: n } = this._minSize, { height: o, width: r } = this._maxSize;
      e = Math.max(i, Math.min(o, e)), t = Math.max(n, Math.min(r, t));
      const a = new Et(t, e);
      Et.equals(a, this._size) || (this.domNode.style.height = e + "px", this.domNode.style.width = t + "px", this._size = a, this._northSash.layout(), this._eastSash.layout(), this._southSash.layout(), this._westSash.layout());
    }
    clearSashHoverState() {
      this._eastSash.clearSashHoverState(), this._westSash.clearSashHoverState(), this._northSash.clearSashHoverState(), this._southSash.clearSashHoverState();
    }
    get size() {
      return this._size;
    }
    set maxSize(e) {
      this._maxSize = e;
    }
    get maxSize() {
      return this._maxSize;
    }
    set minSize(e) {
      this._minSize = e;
    }
    get minSize() {
      return this._minSize;
    }
    set preferredSize(e) {
      this._preferredSize = e;
    }
    get preferredSize() {
      return this._preferredSize;
    }
  }
  var rse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, ase = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  function HN(s) {
    return !!s && Boolean(s.completion.documentation || s.completion.detail && s.completion.detail !== s.completion.label);
  }
  let $k = class {
    constructor(e, t) {
      this._editor = e, this._onDidClose = new B(), this.onDidClose = this._onDidClose.event, this._onDidChangeContents = new B(), this.onDidChangeContents = this._onDidChangeContents.event, this._disposables = new te(), this._renderDisposeable = new te(), this._borderWidth = 1, this._size = new Et(330, 0), this.domNode = J(".suggest-details"), this.domNode.classList.add("no-docs"), this._markdownRenderer = t.createInstance(bl, { editor: e }), this._body = J(".body"), this._scrollbar = new u_(this._body, {}), q(this.domNode, this._scrollbar.getDomNode()), this._disposables.add(this._scrollbar), this._header = q(this._body, J(".header")), this._close = q(this._header, J("span" + p.close.cssSelector)), this._close.title = m("details.close", "Close"), this._type = q(this._header, J("p.type")), this._docs = q(this._body, J("p.docs")), this._configureFont(), this._disposables.add(this._editor.onDidChangeConfiguration((i) => {
        i.hasChanged(44) && this._configureFont();
      }));
    }
    dispose() {
      this._disposables.dispose(), this._renderDisposeable.dispose();
    }
    _configureFont() {
      const e = this._editor.getOptions(), t = e.get(44), i = t.getMassagedFontFamily(Zo ? Fn.fontFamily : null), n = e.get(107) || t.fontSize, o = e.get(108) || t.lineHeight, r = t.fontWeight, a = `${n}px`, l = `${o}px`;
      this.domNode.style.fontSize = a, this.domNode.style.lineHeight = `${o / n}`, this.domNode.style.fontWeight = r, this.domNode.style.fontFeatureSettings = t.fontFeatureSettings, this._type.style.fontFamily = i, this._close.style.height = l, this._close.style.width = l;
    }
    getLayoutInfo() {
      const e = this._editor.getOption(108) || this._editor.getOption(44).lineHeight, t = this._borderWidth, i = t * 2;
      return {
        lineHeight: e,
        borderWidth: t,
        borderHeight: i,
        verticalPadding: 22,
        horizontalPadding: 14
      };
    }
    renderLoading() {
      this._type.textContent = m("loading", "Loading..."), this._docs.textContent = "", this.domNode.classList.remove("no-docs", "no-type"), this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2), this._onDidChangeContents.fire(this);
    }
    renderItem(e, t) {
      var i, n;
      this._renderDisposeable.clear();
      let { detail: o, documentation: r } = e.completion;
      if (t) {
        let a = "";
        a += `score: ${e.score[0]}
`, a += `prefix: ${(i = e.word) !== null && i !== void 0 ? i : "(no prefix)"}
`, a += `word: ${e.completion.filterText ? e.completion.filterText + " (filterText)" : e.textLabel}
`, a += `distance: ${e.distance} (localityBonus-setting)
`, a += `index: ${e.idx}, based on ${e.completion.sortText && `sortText: "${e.completion.sortText}"` || "label"}
`, a += `commit_chars: ${(n = e.completion.commitCharacters) === null || n === void 0 ? void 0 : n.join("")}
`, r = new Us().appendCodeblock("empty", a), o = `Provider: ${e.provider._debugDisplayName}`;
      }
      if (!t && !HN(e)) {
        this.clearContents();
        return;
      }
      if (this.domNode.classList.remove("no-docs", "no-type"), o) {
        const a = o.length > 1e5 ? `${o.substr(0, 1e5)}\u2026` : o;
        this._type.textContent = a, this._type.title = a, Vs(this._type), this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(a));
      } else
        Bi(this._type), this._type.title = "", os(this._type), this.domNode.classList.add("no-type");
      if (Bi(this._docs), typeof r == "string")
        this._docs.classList.remove("markdown-docs"), this._docs.textContent = r;
      else if (r) {
        this._docs.classList.add("markdown-docs"), Bi(this._docs);
        const a = this._markdownRenderer.render(r);
        this._docs.appendChild(a.element), this._renderDisposeable.add(a), this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
          this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
        }));
      }
      this.domNode.style.userSelect = "text", this.domNode.tabIndex = -1, this._close.onmousedown = (a) => {
        a.preventDefault(), a.stopPropagation();
      }, this._close.onclick = (a) => {
        a.preventDefault(), a.stopPropagation(), this._onDidClose.fire();
      }, this._body.scrollTop = 0, this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
    }
    clearContents() {
      this.domNode.classList.add("no-docs"), this._type.textContent = "", this._docs.textContent = "";
    }
    get size() {
      return this._size;
    }
    layout(e, t) {
      const i = new Et(e, t);
      Et.equals(i, this._size) || (this._size = i, EW(this.domNode, e, t)), this._scrollbar.scanDomNode();
    }
    scrollDown(e = 8) {
      this._body.scrollTop += e;
    }
    scrollUp(e = 8) {
      this._body.scrollTop -= e;
    }
    scrollTop() {
      this._body.scrollTop = 0;
    }
    scrollBottom() {
      this._body.scrollTop = this._body.scrollHeight;
    }
    pageDown() {
      this.scrollDown(80);
    }
    pageUp() {
      this.scrollUp(80);
    }
    set borderWidth(e) {
      this._borderWidth = e;
    }
    get borderWidth() {
      return this._borderWidth;
    }
  };
  $k = rse([
    ase(1, et)
  ], $k);
  class lse {
    constructor(e, t) {
      this.widget = e, this._editor = t, this._disposables = new te(), this._added = !1, this._preferAlignAtTop = !0, this._resizable = new _9(), this._resizable.domNode.classList.add("suggest-details-container"), this._resizable.domNode.appendChild(e.domNode), this._resizable.enableSashes(!1, !0, !0, !1);
      let i, n, o = 0, r = 0;
      this._disposables.add(this._resizable.onDidWillResize(() => {
        i = this._topLeft, n = this._resizable.size;
      })), this._disposables.add(this._resizable.onDidResize((a) => {
        if (i && n) {
          this.widget.layout(a.dimension.width, a.dimension.height);
          let l = !1;
          a.west && (r = n.width - a.dimension.width, l = !0), a.north && (o = n.height - a.dimension.height, l = !0), l && this._applyTopLeft({
            top: i.top + o,
            left: i.left + r
          });
        }
        a.done && (i = void 0, n = void 0, o = 0, r = 0, this._userSize = a.dimension);
      })), this._disposables.add(this.widget.onDidChangeContents(() => {
        var a;
        this._anchorBox && this._placeAtAnchor(this._anchorBox, (a = this._userSize) !== null && a !== void 0 ? a : this.widget.size, this._preferAlignAtTop);
      }));
    }
    dispose() {
      this._resizable.dispose(), this._disposables.dispose(), this.hide();
    }
    getId() {
      return "suggest.details";
    }
    getDomNode() {
      return this._resizable.domNode;
    }
    getPosition() {
      return null;
    }
    show() {
      this._added || (this._editor.addOverlayWidget(this), this.getDomNode().style.position = "fixed", this._added = !0);
    }
    hide(e = !1) {
      this._resizable.clearSashHoverState(), this._added && (this._editor.removeOverlayWidget(this), this._added = !1, this._anchorBox = void 0, this._topLeft = void 0), e && (this._userSize = void 0, this.widget.clearContents());
    }
    placeAtAnchor(e, t) {
      var i;
      const n = e.getBoundingClientRect();
      this._anchorBox = n, this._preferAlignAtTop = t, this._placeAtAnchor(this._anchorBox, (i = this._userSize) !== null && i !== void 0 ? i : this.widget.size, t);
    }
    _placeAtAnchor(e, t, i) {
      var n;
      const o = Nv(document.body), r = this.widget.getLayoutInfo(), a = new Et(220, 2 * r.lineHeight), l = e.top, c = function() {
        const w = o.width - (e.left + e.width + r.borderWidth + r.horizontalPadding), S = -r.borderWidth + e.left + e.width, L = new Et(w, o.height - e.top - r.borderHeight - r.verticalPadding), x = L.with(void 0, e.top + e.height - r.borderHeight - r.verticalPadding);
        return { top: l, left: S, fit: w - t.width, maxSizeTop: L, maxSizeBottom: x, minSize: a.with(Math.min(w, a.width)) };
      }(), d = function() {
        const w = e.left - r.borderWidth - r.horizontalPadding, S = Math.max(r.horizontalPadding, e.left - t.width - r.borderWidth), L = new Et(w, o.height - e.top - r.borderHeight - r.verticalPadding), x = L.with(void 0, e.top + e.height - r.borderHeight - r.verticalPadding);
        return { top: l, left: S, fit: w - t.width, maxSizeTop: L, maxSizeBottom: x, minSize: a.with(Math.min(w, a.width)) };
      }(), h = function() {
        const w = e.left, S = -r.borderWidth + e.top + e.height, L = new Et(e.width - r.borderHeight, o.height - e.top - e.height - r.verticalPadding);
        return { top: S, left: w, fit: L.height - t.height, maxSizeBottom: L, maxSizeTop: L, minSize: a.with(L.width) };
      }(), u = [c, d, h], f = (n = u.find((w) => w.fit >= 0)) !== null && n !== void 0 ? n : u.sort((w, S) => S.fit - w.fit)[0], g = e.top + e.height - r.borderHeight;
      let _, b = t.height;
      const C = Math.max(f.maxSizeTop.height, f.maxSizeBottom.height);
      b > C && (b = C);
      let v;
      i ? b <= f.maxSizeTop.height ? (_ = !0, v = f.maxSizeTop) : (_ = !1, v = f.maxSizeBottom) : b <= f.maxSizeBottom.height ? (_ = !1, v = f.maxSizeBottom) : (_ = !0, v = f.maxSizeTop), this._applyTopLeft({ left: f.left, top: _ ? f.top : g - b }), this.getDomNode().style.position = "fixed", this._resizable.enableSashes(!_, f === c, _, f !== c), this._resizable.minSize = f.minSize, this._resizable.maxSize = v, this._resizable.layout(b, Math.min(v.width, t.width)), this.widget.layout(this._resizable.size.width, this._resizable.size.height);
    }
    _applyTopLeft(e) {
      this._topLeft = e, this.getDomNode().style.left = `${this._topLeft.left}px`, this.getDomNode().style.top = `${this._topLeft.top}px`;
    }
  }
  var sl;
  (function(s) {
    s[s.FILE = 0] = "FILE", s[s.FOLDER = 1] = "FOLDER", s[s.ROOT_FOLDER = 2] = "ROOT_FOLDER";
  })(sl || (sl = {}));
  const cse = /(?:\/|^)(?:([^\/]+)\/)?([^\/]+)$/;
  function Nb(s, e, t, i) {
    const n = i === sl.ROOT_FOLDER ? ["rootfolder-icon"] : i === sl.FOLDER ? ["folder-icon"] : ["file-icon"];
    if (t) {
      let o;
      if (t.scheme === ze.data)
        o = yc.parseMetaData(t).get(yc.META_DATA_LABEL);
      else {
        const r = t.path.match(cse);
        r ? (o = Tb(r[2].toLowerCase()), r[1] && n.push(`${Tb(r[1].toLowerCase())}-name-dir-icon`)) : o = Tb(t.authority.toLowerCase());
      }
      if (i === sl.FOLDER)
        n.push(`${o}-name-folder-icon`);
      else {
        if (o) {
          if (n.push(`${o}-name-file-icon`), n.push("name-file-icon"), o.length <= 255) {
            const a = o.split(".");
            for (let l = 1; l < a.length; l++)
              n.push(`${a.slice(l).join(".")}-ext-file-icon`);
          }
          n.push("ext-file-icon");
        }
        const r = dse(s, e, t);
        r && n.push(`${Tb(r)}-lang-file-icon`);
      }
    }
    return n;
  }
  function dse(s, e, t) {
    if (!t)
      return null;
    let i = null;
    if (t.scheme === ze.data) {
      const o = yc.parseMetaData(t).get(yc.META_DATA_MIME);
      o && (i = e.getLanguageIdByMimeType(o));
    } else {
      const n = s.getModel(t);
      n && (i = n.getLanguageId());
    }
    return i && i !== ya ? i : e.guessLanguageIdByFilepathOrFirstLine(t);
  }
  function Tb(s) {
    return s.replace(/[\11\12\14\15\40]/g, "/");
  }
  var hse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, cy = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Og;
  function b9(s) {
    return `suggest-aria-id:${s}`;
  }
  const use = Vi("suggest-more-info", p.chevronRight, m("suggestMoreInfoIcon", "Icon for more information in the suggest widget.")), fse = new (Og = class L0 {
    extract(e, t) {
      if (e.textLabel.match(L0._regexStrict))
        return t[0] = e.textLabel, !0;
      if (e.completion.detail && e.completion.detail.match(L0._regexStrict))
        return t[0] = e.completion.detail, !0;
      if (typeof e.completion.documentation == "string") {
        const i = L0._regexRelaxed.exec(e.completion.documentation);
        if (i && (i.index === 0 || i.index + i[0].length === e.completion.documentation.length))
          return t[0] = i[0], !0;
      }
      return !1;
    }
  }, Og._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, Og._regexStrict = new RegExp(`^${Og._regexRelaxed.source}$`, "i"), Og)();
  let jk = class {
    constructor(e, t, i, n) {
      this._editor = e, this._modelService = t, this._languageService = i, this._themeService = n, this._onDidToggleDetails = new B(), this.onDidToggleDetails = this._onDidToggleDetails.event, this.templateId = "suggestion";
    }
    dispose() {
      this._onDidToggleDetails.dispose();
    }
    renderTemplate(e) {
      const t = /* @__PURE__ */ Object.create(null);
      t.disposables = new te(), t.root = e, t.root.classList.add("show-file-icons"), t.icon = q(e, J(".icon")), t.colorspan = q(t.icon, J("span.colorspan"));
      const i = q(e, J(".contents")), n = q(i, J(".main"));
      t.iconContainer = q(n, J(".icon-label.codicon")), t.left = q(n, J("span.left")), t.right = q(n, J("span.right")), t.iconLabel = new B1(t.left, { supportHighlights: !0, supportIcons: !0 }), t.disposables.add(t.iconLabel), t.parametersLabel = q(t.left, J("span.signature-label")), t.qualifierLabel = q(t.left, J("span.qualifier-label")), t.detailsLabel = q(t.right, J("span.details-label")), t.readMore = q(t.right, J("span.readMore" + Tt.asCSSSelector(use))), t.readMore.title = m("readMore", "Read More");
      const o = () => {
        const r = this._editor.getOptions(), a = r.get(44), l = a.getMassagedFontFamily(Zo ? Fn.fontFamily : null), c = a.fontFeatureSettings, d = r.get(107) || a.fontSize, h = r.get(108) || a.lineHeight, u = a.fontWeight, f = `${d}px`, g = `${h}px`;
        t.root.style.fontSize = f, t.root.style.fontWeight = u, n.style.fontFamily = l, n.style.fontFeatureSettings = c, n.style.lineHeight = g, t.icon.style.height = g, t.icon.style.width = g, t.readMore.style.height = g, t.readMore.style.width = g;
      };
      return o(), t.disposables.add(this._editor.onDidChangeConfiguration((r) => {
        (r.hasChanged(44) || r.hasChanged(107) || r.hasChanged(108)) && o();
      })), t;
    }
    renderElement(e, t, i) {
      const { completion: n } = e;
      i.root.id = b9(t), i.colorspan.style.backgroundColor = "";
      const o = {
        labelEscapeNewLines: !0,
        matches: pC(e.score)
      };
      let r = [];
      if (n.kind === 19 && fse.extract(e, r))
        i.icon.className = "icon customcolor", i.iconContainer.className = "icon hide", i.colorspan.style.backgroundColor = r[0];
      else if (n.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
        i.icon.className = "icon hide", i.iconContainer.className = "icon hide";
        const a = Nb(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: e.textLabel }), sl.FILE), l = Nb(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: n.detail }), sl.FILE);
        o.extraClasses = a.length > l.length ? a : l;
      } else
        n.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons ? (i.icon.className = "icon hide", i.iconContainer.className = "icon hide", o.extraClasses = $I([
          Nb(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: e.textLabel }), sl.FOLDER),
          Nb(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: n.detail }), sl.FOLDER)
        ])) : (i.icon.className = "icon hide", i.iconContainer.className = "", i.iconContainer.classList.add("suggest-icon", ...Un.asClassNameArray(Ym.toIcon(n.kind))));
      n.tags && n.tags.indexOf(1) >= 0 && (o.extraClasses = (o.extraClasses || []).concat(["deprecated"]), o.matches = []), i.iconLabel.setLabel(e.textLabel, void 0, o), typeof n.label == "string" ? (i.parametersLabel.textContent = "", i.detailsLabel.textContent = dy(n.detail || ""), i.root.classList.add("string-label")) : (i.parametersLabel.textContent = dy(n.label.detail || ""), i.detailsLabel.textContent = dy(n.label.description || ""), i.root.classList.remove("string-label")), this._editor.getOption(106).showInlineDetails ? Vs(i.detailsLabel) : os(i.detailsLabel), HN(e) ? (i.right.classList.add("can-expand-details"), Vs(i.readMore), i.readMore.onmousedown = (a) => {
        a.stopPropagation(), a.preventDefault();
      }, i.readMore.onclick = (a) => {
        a.stopPropagation(), a.preventDefault(), this._onDidToggleDetails.fire();
      }) : (i.right.classList.remove("can-expand-details"), os(i.readMore), i.readMore.onmousedown = null, i.readMore.onclick = null);
    }
    disposeTemplate(e) {
      e.disposables.dispose();
    }
  };
  jk = hse([
    cy(1, Qt),
    cy(2, Jt),
    cy(3, jt)
  ], jk);
  function dy(s) {
    return s.replace(/\r\n|\r|\n/g, "");
  }
  var gse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Mb = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, mse = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  M("editorSuggestWidget.background", { dark: Kn, light: Kn, hc: Kn }, m("editorSuggestWidgetBackground", "Background color of the suggest widget."));
  M("editorSuggestWidget.border", { dark: Ed, light: Ed, hc: Ed }, m("editorSuggestWidgetBorder", "Border color of the suggest widget."));
  const hy = M("editorSuggestWidget.foreground", { dark: nc, light: nc, hc: nc }, m("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
  M("editorSuggestWidget.selectedForeground", { dark: a0, light: a0, hc: a0 }, m("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
  M("editorSuggestWidget.selectedIconForeground", { dark: l0, light: l0, hc: l0 }, m("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
  const pse = M("editorSuggestWidget.selectedBackground", { dark: c0, light: c0, hc: c0 }, m("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
  M("editorSuggestWidget.highlightForeground", { dark: cl, light: cl, hc: cl }, m("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
  M("editorSuggestWidget.focusHighlightForeground", { dark: jw, light: jw, hc: jw }, m("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
  M("editorSuggestWidgetStatus.foreground", { dark: Re(hy, 0.5), light: Re(hy, 0.5), hc: Re(hy, 0.5) }, m("editorSuggestWidgetStatusForeground", "Foreground color of the suggest widget status."));
  class _se {
    constructor(e, t) {
      this._service = e, this._key = `suggestWidget.size/${t.getEditorType()}/${t instanceof oh}`;
    }
    restore() {
      var e;
      const t = (e = this._service.get(this._key, 0)) !== null && e !== void 0 ? e : "";
      try {
        const i = JSON.parse(t);
        if (Et.is(i))
          return Et.lift(i);
      } catch {
      }
    }
    store(e) {
      this._service.store(this._key, JSON.stringify(e), 0, 1);
    }
    reset() {
      this._service.remove(this._key, 0);
    }
  }
  let Rp = class Kk {
    constructor(e, t, i, n, o) {
      this.editor = e, this._storageService = t, this._state = 0, this._isAuto = !1, this._ignoreFocusEvents = !1, this._forceRenderingAbove = !1, this._explainMode = !1, this._showTimeout = new Ns(), this._disposables = new te(), this._onDidSelect = new B(), this._onDidFocus = new B(), this._onDidHide = new B(), this._onDidShow = new B(), this.onDidSelect = this._onDidSelect.event, this.onDidFocus = this._onDidFocus.event, this.onDidHide = this._onDidHide.event, this.onDidShow = this._onDidShow.event, this._onDetailsKeydown = new B(), this.onDetailsKeyDown = this._onDetailsKeydown.event, this.element = new _9(), this.element.domNode.classList.add("editor-widget", "suggest-widget"), this._contentWidget = new bse(this, e), this._persistedSize = new _se(t, e);
      class r {
        constructor(f, g, _ = !1, b = !1) {
          this.persistedSize = f, this.currentSize = g, this.persistHeight = _, this.persistWidth = b;
        }
      }
      let a;
      this._disposables.add(this.element.onDidWillResize(() => {
        this._contentWidget.lockPreference(), a = new r(this._persistedSize.restore(), this.element.size);
      })), this._disposables.add(this.element.onDidResize((u) => {
        var f, g, _, b;
        if (this._resize(u.dimension.width, u.dimension.height), a && (a.persistHeight = a.persistHeight || !!u.north || !!u.south, a.persistWidth = a.persistWidth || !!u.east || !!u.west), !!u.done) {
          if (a) {
            const { itemHeight: C, defaultSize: v } = this.getLayoutInfo(), w = Math.round(C / 2);
            let { width: S, height: L } = this.element.size;
            (!a.persistHeight || Math.abs(a.currentSize.height - L) <= w) && (L = (g = (f = a.persistedSize) === null || f === void 0 ? void 0 : f.height) !== null && g !== void 0 ? g : v.height), (!a.persistWidth || Math.abs(a.currentSize.width - S) <= w) && (S = (b = (_ = a.persistedSize) === null || _ === void 0 ? void 0 : _.width) !== null && b !== void 0 ? b : v.width), this._persistedSize.store(new Et(S, L));
          }
          this._contentWidget.unlockPreference(), a = void 0;
        }
      })), this._messageElement = q(this.element.domNode, J(".message")), this._listElement = q(this.element.domNode, J(".tree"));
      const l = o.createInstance($k, this.editor);
      l.onDidClose(this.toggleDetails, this, this._disposables), this._details = new lse(l, this.editor);
      const c = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(106).showIcons);
      c();
      const d = o.createInstance(jk, this.editor);
      this._disposables.add(d), this._disposables.add(d.onDidToggleDetails(() => this.toggleDetails())), this._list = new ka("SuggestWidget", this._listElement, {
        getHeight: (u) => this.getLayoutInfo().itemHeight,
        getTemplateId: (u) => "suggestion"
      }, [d], {
        alwaysConsumeMouseWheel: !0,
        useShadows: !1,
        mouseSupport: !1,
        accessibilityProvider: {
          getRole: () => "option",
          getWidgetAriaLabel: () => m("suggest", "Suggest"),
          getWidgetRole: () => "listbox",
          getAriaLabel: (u) => {
            let f = u.textLabel;
            if (typeof u.completion.label != "string") {
              const { detail: C, description: v } = u.completion.label;
              C && v ? f = m("label.full", "{0}{1}, {2}", f, C, v) : C ? f = m("label.detail", "{0}{1}", f, C) : v && (f = m("label.desc", "{0}, {1}", f, v));
            }
            if (!u.isResolved || !this._isDetailsVisible())
              return f;
            const { documentation: g, detail: _ } = u.completion, b = uo("{0}{1}", _ || "", g ? typeof g == "string" ? g : g.value : "");
            return m("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", f, b);
          }
        }
      }), this._status = o.createInstance(Uk, this.element.domNode);
      const h = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(106).showStatusBar);
      h(), this._disposables.add(rh(this._list, n, {
        listInactiveFocusBackground: pse,
        listInactiveFocusOutline: Bn
      })), this._disposables.add(n.onDidColorThemeChange((u) => this._onThemeChange(u))), this._onThemeChange(n.getColorTheme()), this._disposables.add(this._list.onMouseDown((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onTap((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onDidChangeSelection((u) => this._onListSelection(u))), this._disposables.add(this._list.onDidChangeFocus((u) => this._onListFocus(u))), this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged())), this._disposables.add(this.editor.onDidChangeConfiguration((u) => {
        u.hasChanged(106) && (h(), c());
      })), this._ctxSuggestWidgetVisible = ot.Visible.bindTo(i), this._ctxSuggestWidgetDetailsVisible = ot.DetailsVisible.bindTo(i), this._ctxSuggestWidgetMultipleSuggestions = ot.MultipleSuggestions.bindTo(i), this._disposables.add(on(this._details.widget.domNode, "keydown", (u) => {
        this._onDetailsKeydown.fire(u);
      })), this._disposables.add(this.editor.onMouseDown((u) => this._onEditorMouseDown(u)));
    }
    dispose() {
      var e;
      this._details.widget.dispose(), this._details.dispose(), this._list.dispose(), this._status.dispose(), this._disposables.dispose(), (e = this._loadingTimeout) === null || e === void 0 || e.dispose(), this._showTimeout.dispose(), this._contentWidget.dispose(), this.element.dispose();
    }
    _onEditorMouseDown(e) {
      this._details.widget.domNode.contains(e.target.element) ? this._details.widget.domNode.focus() : this.element.domNode.contains(e.target.element) && this.editor.focus();
    }
    _onCursorSelectionChanged() {
      this._state !== 0 && this._contentWidget.layout();
    }
    _onListMouseDownOrTap(e) {
      typeof e.element > "u" || typeof e.index > "u" || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation(), this._select(e.element, e.index));
    }
    _onListSelection(e) {
      e.elements.length && this._select(e.elements[0], e.indexes[0]);
    }
    _select(e, t) {
      const i = this._completionModel;
      i && (this._onDidSelect.fire({ item: e, index: t, model: i }), this.editor.focus());
    }
    _onThemeChange(e) {
      this._details.widget.borderWidth = e.type === "hc" ? 2 : 1;
    }
    _onListFocus(e) {
      var t;
      if (this._ignoreFocusEvents)
        return;
      if (!e.elements.length) {
        this._currentSuggestionDetails && (this._currentSuggestionDetails.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = void 0), this.editor.setAriaOptions({ activeDescendant: void 0 });
        return;
      }
      if (!this._completionModel)
        return;
      const i = e.elements[0], n = e.indexes[0];
      i !== this._focusedItem && ((t = this._currentSuggestionDetails) === null || t === void 0 || t.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = i, this._list.reveal(n), this._currentSuggestionDetails = an((o) => mse(this, void 0, void 0, function* () {
        const r = $d(() => {
          this._isDetailsVisible() && this.showDetails(!0);
        }, 250), a = o.onCancellationRequested(() => r.dispose()), l = yield i.resolve(o);
        return r.dispose(), a.dispose(), l;
      })), this._currentSuggestionDetails.then(() => {
        n >= this._list.length || i !== this._list.element(n) || (this._ignoreFocusEvents = !0, this._list.splice(n, 1, [i]), this._list.setFocus([n]), this._ignoreFocusEvents = !1, this._isDetailsVisible() ? this.showDetails(!1) : this.element.domNode.classList.remove("docs-side"), this.editor.setAriaOptions({ activeDescendant: b9(n) }));
      }).catch(We)), this._onDidFocus.fire({ item: i, index: n, model: this._completionModel });
    }
    _setState(e) {
      if (this._state !== e)
        switch (this._state = e, this.element.domNode.classList.toggle("frozen", e === 4), this.element.domNode.classList.remove("message"), e) {
          case 0:
            os(this._messageElement, this._listElement, this._status.element), this._details.hide(!0), this._status.hide(), this._contentWidget.hide(), this._ctxSuggestWidgetVisible.reset(), this._ctxSuggestWidgetMultipleSuggestions.reset(), this._showTimeout.cancel(), this.element.domNode.classList.remove("visible"), this._list.splice(0, this._list.length), this._focusedItem = void 0, this._cappedHeight = void 0, this._explainMode = !1;
            break;
          case 1:
            this.element.domNode.classList.add("message"), this._messageElement.textContent = Kk.LOADING_MESSAGE, os(this._listElement, this._status.element), Vs(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0;
            break;
          case 2:
            this.element.domNode.classList.add("message"), this._messageElement.textContent = Kk.NO_SUGGESTIONS_MESSAGE, os(this._listElement, this._status.element), Vs(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0;
            break;
          case 3:
            os(this._messageElement), Vs(this._listElement, this._status.element), this._show();
            break;
          case 4:
            os(this._messageElement), Vs(this._listElement, this._status.element), this._show();
            break;
          case 5:
            os(this._messageElement), Vs(this._listElement, this._status.element), this._details.show(), this._show();
            break;
        }
    }
    _show() {
      this._status.show(), this._contentWidget.show(), this._layout(this._persistedSize.restore()), this._ctxSuggestWidgetVisible.set(!0), this._showTimeout.cancelAndSet(() => {
        this.element.domNode.classList.add("visible"), this._onDidShow.fire(this);
      }, 100);
    }
    showTriggered(e, t) {
      this._state === 0 && (this._contentWidget.setPosition(this.editor.getPosition()), this._isAuto = !!e, this._isAuto || (this._loadingTimeout = $d(() => this._setState(1), t)));
    }
    showSuggestions(e, t, i, n) {
      var o, r;
      if (this._contentWidget.setPosition(this.editor.getPosition()), (o = this._loadingTimeout) === null || o === void 0 || o.dispose(), (r = this._currentSuggestionDetails) === null || r === void 0 || r.cancel(), this._currentSuggestionDetails = void 0, this._completionModel !== e && (this._completionModel = e), i && this._state !== 2 && this._state !== 0) {
        this._setState(4);
        return;
      }
      const a = this._completionModel.items.length, l = a === 0;
      if (this._ctxSuggestWidgetMultipleSuggestions.set(a > 1), l) {
        this._setState(n ? 0 : 2), this._completionModel = void 0;
        return;
      }
      this._focusedItem = void 0, this._list.splice(0, this._list.length, this._completionModel.items), this._setState(i ? 4 : 3), this._list.reveal(t, 0), this._list.setFocus([t]), this._layout(this.element.size), this._details.widget.domNode.classList.remove("focused");
    }
    selectNextPage() {
      switch (this._state) {
        case 0:
          return !1;
        case 5:
          return this._details.widget.pageDown(), !0;
        case 1:
          return !this._isAuto;
        default:
          return this._list.focusNextPage(), !0;
      }
    }
    selectNext() {
      switch (this._state) {
        case 0:
          return !1;
        case 1:
          return !this._isAuto;
        default:
          return this._list.focusNext(1, !0), !0;
      }
    }
    selectLast() {
      switch (this._state) {
        case 0:
          return !1;
        case 5:
          return this._details.widget.scrollBottom(), !0;
        case 1:
          return !this._isAuto;
        default:
          return this._list.focusLast(), !0;
      }
    }
    selectPreviousPage() {
      switch (this._state) {
        case 0:
          return !1;
        case 5:
          return this._details.widget.pageUp(), !0;
        case 1:
          return !this._isAuto;
        default:
          return this._list.focusPreviousPage(), !0;
      }
    }
    selectPrevious() {
      switch (this._state) {
        case 0:
          return !1;
        case 1:
          return !this._isAuto;
        default:
          return this._list.focusPrevious(1, !0), !1;
      }
    }
    selectFirst() {
      switch (this._state) {
        case 0:
          return !1;
        case 5:
          return this._details.widget.scrollTop(), !0;
        case 1:
          return !this._isAuto;
        default:
          return this._list.focusFirst(), !0;
      }
    }
    getFocusedItem() {
      if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel)
        return {
          item: this._list.getFocusedElements()[0],
          index: this._list.getFocus()[0],
          model: this._completionModel
        };
    }
    toggleDetailsFocus() {
      this._state === 5 ? (this._setState(3), this._details.widget.domNode.classList.remove("focused")) : this._state === 3 && this._isDetailsVisible() && (this._setState(5), this._details.widget.domNode.classList.add("focused"));
    }
    toggleDetails() {
      this._isDetailsVisible() ? (this._ctxSuggestWidgetDetailsVisible.set(!1), this._setDetailsVisible(!1), this._details.hide(), this.element.domNode.classList.remove("shows-details")) : (HN(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4) && (this._ctxSuggestWidgetDetailsVisible.set(!0), this._setDetailsVisible(!0), this.showDetails(!1));
    }
    showDetails(e) {
      this._details.show(), e ? this._details.widget.renderLoading() : this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode), this._positionDetails(), this.editor.focus(), this.element.domNode.classList.add("shows-details");
    }
    toggleExplainMode() {
      this._list.getFocusedElements()[0] && (this._explainMode = !this._explainMode, this._isDetailsVisible() ? this.showDetails(!1) : this.toggleDetails());
    }
    resetPersistedSize() {
      this._persistedSize.reset();
    }
    hideWidget() {
      var e;
      (e = this._loadingTimeout) === null || e === void 0 || e.dispose(), this._setState(0), this._onDidHide.fire(this), this.element.clearSashHoverState();
      const t = this._persistedSize.restore(), i = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
      t && t.height < i && this._persistedSize.store(t.with(void 0, i));
    }
    isFrozen() {
      return this._state === 4;
    }
    _afterRender(e) {
      if (e === null) {
        this._isDetailsVisible() && this._details.hide();
        return;
      }
      this._state === 2 || this._state === 1 || (this._isDetailsVisible() && this._details.show(), this._positionDetails());
    }
    _layout(e) {
      var t, i, n;
      if (!this.editor.hasModel() || !this.editor.getDomNode())
        return;
      const o = Nv(document.body), r = this.getLayoutInfo();
      e || (e = r.defaultSize);
      let a = e.height, l = e.width;
      if (this._status.element.style.lineHeight = `${r.itemHeight}px`, this._state === 2 || this._state === 1)
        a = r.itemHeight + r.borderHeight, l = r.defaultSize.width / 2, this.element.enableSashes(!1, !1, !1, !1), this.element.minSize = this.element.maxSize = new Et(l, a), this._contentWidget.setPreference(2);
      else {
        const c = o.width - r.borderHeight - 2 * r.horizontalPadding;
        l > c && (l = c);
        const d = this._completionModel ? this._completionModel.stats.pLabelLen * r.typicalHalfwidthCharacterWidth : l, h = r.statusBarHeight + this._list.contentHeight + r.borderHeight, u = r.itemHeight + r.statusBarHeight, f = mn(this.editor.getDomNode()), g = this.editor.getScrolledVisiblePosition(this.editor.getPosition()), _ = f.top + g.top + g.height, b = Math.min(o.height - _ - r.verticalPadding, h), C = f.top + g.top - r.verticalPadding, v = Math.min(C, h);
        let w = Math.min(Math.max(v, b) + r.borderHeight, h);
        a === ((t = this._cappedHeight) === null || t === void 0 ? void 0 : t.capped) && (a = this._cappedHeight.wanted), a < u && (a = u), a > w && (a = w);
        const S = 150;
        a > b || this._forceRenderingAbove && C > S ? (this._contentWidget.setPreference(1), this.element.enableSashes(!0, !0, !1, !1), w = v) : (this._contentWidget.setPreference(2), this.element.enableSashes(!1, !0, !0, !1), w = b), this.element.preferredSize = new Et(d, r.defaultSize.height), this.element.maxSize = new Et(c, w), this.element.minSize = new Et(220, u), this._cappedHeight = a === h ? { wanted: (n = (i = this._cappedHeight) === null || i === void 0 ? void 0 : i.wanted) !== null && n !== void 0 ? n : e.height, capped: a } : void 0;
      }
      this._resize(l, a);
    }
    _resize(e, t) {
      const { width: i, height: n } = this.element.maxSize;
      e = Math.min(i, e), t = Math.min(n, t);
      const { statusBarHeight: o } = this.getLayoutInfo();
      this._list.layout(t - o, e), this._listElement.style.height = `${t - o}px`, this.element.layout(t, e), this._contentWidget.layout(), this._positionDetails();
    }
    _positionDetails() {
      var e;
      this._isDetailsVisible() && this._details.placeAtAnchor(this.element.domNode, ((e = this._contentWidget.getPosition()) === null || e === void 0 ? void 0 : e.preference[0]) === 2);
    }
    getLayoutInfo() {
      const e = this.editor.getOption(44), t = vs(this.editor.getOption(108) || e.lineHeight, 8, 1e3), i = !this.editor.getOption(106).showStatusBar || this._state === 2 || this._state === 1 ? 0 : t, n = this._details.widget.borderWidth, o = 2 * n;
      return {
        itemHeight: t,
        statusBarHeight: i,
        borderWidth: n,
        borderHeight: o,
        typicalHalfwidthCharacterWidth: e.typicalHalfwidthCharacterWidth,
        verticalPadding: 22,
        horizontalPadding: 14,
        defaultSize: new Et(430, i + 12 * t + o)
      };
    }
    _isDetailsVisible() {
      return this._storageService.getBoolean("expandSuggestionDocs", 0, !1);
    }
    _setDetailsVisible(e) {
      this._storageService.store("expandSuggestionDocs", e, 0, 0);
    }
    forceRenderingAbove() {
      this._forceRenderingAbove || (this._forceRenderingAbove = !0, this._layout(this._persistedSize.restore()));
    }
    stopForceRenderingAbove() {
      this._forceRenderingAbove = !1;
    }
  };
  Rp.LOADING_MESSAGE = m("suggestWidget.loading", "Loading...");
  Rp.NO_SUGGESTIONS_MESSAGE = m("suggestWidget.noSuggestions", "No suggestions.");
  Rp = gse([
    Mb(1, La),
    Mb(2, Fe),
    Mb(3, jt),
    Mb(4, et)
  ], Rp);
  class bse {
    constructor(e, t) {
      this._widget = e, this._editor = t, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._preferenceLocked = !1, this._added = !1, this._hidden = !1;
    }
    dispose() {
      this._added && (this._added = !1, this._editor.removeContentWidget(this));
    }
    getId() {
      return "editor.widget.suggestWidget";
    }
    getDomNode() {
      return this._widget.element.domNode;
    }
    show() {
      this._hidden = !1, this._added || (this._added = !0, this._editor.addContentWidget(this));
    }
    hide() {
      this._hidden || (this._hidden = !0, this.layout());
    }
    layout() {
      this._editor.layoutContentWidget(this);
    }
    getPosition() {
      return this._hidden || !this._position || !this._preference ? null : {
        position: this._position,
        preference: [this._preference]
      };
    }
    beforeRender() {
      const { height: e, width: t } = this._widget.element.size, { borderWidth: i, horizontalPadding: n } = this._widget.getLayoutInfo();
      return new Et(t + 2 * i + n, e + 2 * i);
    }
    afterRender(e) {
      this._widget._afterRender(e);
    }
    setPreference(e) {
      this._preferenceLocked || (this._preference = e);
    }
    lockPreference() {
      this._preferenceLocked = !0;
    }
    unlockPreference() {
      this._preferenceLocked = !1;
    }
    setPosition(e) {
      this._position = e;
    }
  }
  var vse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, cu = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class Cse {
    constructor(e, t) {
      if (this._model = e, this._position = t, e.getLineMaxColumn(t.lineNumber) !== t.column) {
        const n = e.getOffsetAt(t), o = e.getPositionAt(n + 1);
        this._marker = e.deltaDecorations([], [{
          range: D.fromPositions(t, o),
          options: { description: "suggest-line-suffix", stickiness: 1 }
        }]);
      }
    }
    dispose() {
      this._marker && !this._model.isDisposed() && this._model.deltaDecorations(this._marker, []);
    }
    delta(e) {
      if (this._model.isDisposed() || this._position.lineNumber !== e.lineNumber)
        return 0;
      if (this._marker) {
        const t = this._model.getDecorationRange(this._marker[0]);
        return this._model.getOffsetAt(t.getStartPosition()) - this._model.getOffsetAt(e);
      } else
        return this._model.getLineMaxColumn(e.lineNumber) - e.column;
    }
  }
  let $o = class v9 {
    constructor(e, t, i, n, o, r, a) {
      this._memoryService = t, this._commandService = i, this._contextKeyService = n, this._instantiationService = o, this._logService = r, this._telemetryService = a, this._lineSuffix = new Gn(), this._toDispose = new te(), this._selectors = new wse((h) => h.priority), this._telemetryGate = 0, this.editor = e, this.model = o.createInstance(zk, this.editor);
      const l = ot.InsertMode.bindTo(n);
      l.set(e.getOption(106).insertMode), this.model.onDidTrigger(() => l.set(e.getOption(106).insertMode)), this.widget = this._toDispose.add(new Jl(() => {
        const h = this._instantiationService.createInstance(Rp, this.editor);
        this._toDispose.add(h), this._toDispose.add(h.onDidSelect((b) => this._insertSuggestion(b, 0), this));
        const u = new vne(this.editor, h, (b) => this._insertSuggestion(b, 2));
        this._toDispose.add(u), this._toDispose.add(this.model.onDidSuggest((b) => {
          b.completionModel.items.length === 0 && u.reset();
        }));
        const f = ot.MakesTextEdit.bindTo(this._contextKeyService), g = ot.HasInsertAndReplaceRange.bindTo(this._contextKeyService), _ = ot.CanResolve.bindTo(this._contextKeyService);
        return this._toDispose.add(qe(() => {
          f.reset(), g.reset(), _.reset();
        })), this._toDispose.add(h.onDidFocus(({ item: b }) => {
          const C = this.editor.getPosition(), v = b.editStart.column, w = C.column;
          let S = !0;
          this.editor.getOption(1) === "smart" && this.model.state === 2 && !b.completion.additionalTextEdits && !(b.completion.insertTextRules & 4) && w - v === b.completion.insertText.length && (S = this.editor.getModel().getValueInRange({
            startLineNumber: C.lineNumber,
            startColumn: v,
            endLineNumber: C.lineNumber,
            endColumn: w
          }) !== b.completion.insertText), f.set(S), g.set(!V.equals(b.editInsertEnd, b.editReplaceEnd)), _.set(Boolean(b.provider.resolveCompletionItem) || Boolean(b.completion.documentation) || b.completion.detail !== b.completion.label);
        })), this._toDispose.add(h.onDetailsKeyDown((b) => {
          if (b.toKeybinding().equals(new Ud(!0, !1, !1, !1, 33)) || Ye && b.toKeybinding().equals(new Ud(!1, !1, !1, !0, 33))) {
            b.stopPropagation();
            return;
          }
          b.toKeybinding().isModifierKey() || this.editor.focus();
        })), h;
      })), this._overtypingCapturer = this._toDispose.add(new Jl(() => this._toDispose.add(new qC(this.editor, this.model)))), this._alternatives = this._toDispose.add(new Jl(() => this._toDispose.add(new gh(this.editor, this._contextKeyService)))), this._toDispose.add(o.createInstance(Ap, e)), this._toDispose.add(this.model.onDidTrigger((h) => {
        this.widget.value.showTriggered(h.auto, h.shy ? 250 : 50), this._lineSuffix.value = new Cse(this.editor.getModel(), h.position);
      })), this._toDispose.add(this.model.onDidSuggest((h) => {
        if (!h.shy) {
          let u = -1;
          for (const f of this._selectors.itemsOrderedByPriorityDesc)
            if (u = f.select(this.editor.getModel(), this.editor.getPosition(), h.completionModel.items), u !== -1)
              break;
          u === -1 && (u = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), h.completionModel.items)), this.widget.value.showSuggestions(h.completionModel, u, h.isFrozen, h.auto);
        }
      })), this._toDispose.add(this.model.onDidCancel((h) => {
        h.retrigger || this.widget.value.hideWidget();
      })), this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
        this.model.cancel(), this.model.clear();
      }));
      let c = ot.AcceptSuggestionsOnEnter.bindTo(n), d = () => {
        const h = this.editor.getOption(1);
        c.set(h === "on" || h === "smart");
      };
      this._toDispose.add(this.editor.onDidChangeConfiguration(() => d())), d();
    }
    static get(e) {
      return e.getContribution(v9.ID);
    }
    dispose() {
      this._alternatives.dispose(), this._toDispose.dispose(), this.widget.dispose(), this.model.dispose(), this._lineSuffix.dispose();
    }
    _insertSuggestion(e, t) {
      if (!e || !e.item) {
        this._alternatives.value.reset(), this.model.cancel(), this.model.clear();
        return;
      }
      if (!this.editor.hasModel())
        return;
      const i = vn.get(this.editor);
      if (!i)
        return;
      const n = this.editor.getModel(), o = n.getAlternativeVersionId(), { item: r } = e, a = [], l = new bn();
      t & 1 || this.editor.pushUndoStop();
      const c = this.getOverwriteInfo(r, Boolean(t & 8));
      if (this._memoryService.memorize(n, this.editor.getPosition(), r), Array.isArray(r.completion.additionalTextEdits)) {
        const h = kc.capture(this.editor);
        this.editor.executeEdits("suggestController.additionalTextEdits.sync", r.completion.additionalTextEdits.map((u) => li.replace(D.lift(u.range), u.text))), h.restoreRelativeVerticalPositionOfCursor(this.editor);
      } else if (!r.isResolved) {
        const h = new hs(!0);
        let u;
        const f = n.onDidChangeContent((C) => {
          if (C.isFlush) {
            l.cancel(), f.dispose();
            return;
          }
          for (let v of C.changes) {
            const w = D.getEndPosition(v.range);
            (!u || V.isBefore(w, u)) && (u = w);
          }
        });
        let g = t;
        t |= 2;
        let _ = !1, b = this.editor.onWillType(() => {
          b.dispose(), _ = !0, g & 2 || this.editor.pushUndoStop();
        });
        a.push(r.resolve(l.token).then(() => {
          if (!r.completion.additionalTextEdits || l.token.isCancellationRequested || u && r.completion.additionalTextEdits.some((v) => V.isBefore(u, D.getStartPosition(v.range))))
            return !1;
          _ && this.editor.pushUndoStop();
          const C = kc.capture(this.editor);
          return this.editor.executeEdits("suggestController.additionalTextEdits.async", r.completion.additionalTextEdits.map((v) => li.replace(D.lift(v.range), v.text))), C.restoreRelativeVerticalPositionOfCursor(this.editor), (_ || !(g & 2)) && this.editor.pushUndoStop(), !0;
        }).then((C) => {
          this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", h.elapsed(), C), f.dispose(), b.dispose();
        }));
      }
      let { insertText: d } = r.completion;
      r.completion.insertTextRules & 4 || (d = WC.escape(d)), i.insert(d, {
        overwriteBefore: c.overwriteBefore,
        overwriteAfter: c.overwriteAfter,
        undoStopBefore: !1,
        undoStopAfter: !1,
        adjustWhitespace: !(r.completion.insertTextRules & 1),
        clipboardText: e.model.clipboardText,
        overtypingCapturer: this._overtypingCapturer.value
      }), t & 2 || this.editor.pushUndoStop(), r.completion.command ? r.completion.command.id === I_.id ? this.model.trigger({ auto: !0, shy: !1 }, !0) : (a.push(this._commandService.executeCommand(r.completion.command.id, ...r.completion.command.arguments ? [...r.completion.command.arguments] : []).catch(We)), this.model.cancel()) : this.model.cancel(), t & 4 && this._alternatives.value.set(e, (h) => {
        for (l.cancel(); n.canUndo(); ) {
          o !== n.getAlternativeVersionId() && n.undo(), this._insertSuggestion(h, 3 | (t & 8 ? 8 : 0));
          break;
        }
      }), this._alertCompletionItem(r), Promise.all(a).finally(() => {
        this._reportSuggestionAcceptedTelemetry(n, e), this.model.clear(), l.dispose();
      });
    }
    _reportSuggestionAcceptedTelemetry(e, t) {
      var i;
      if (this._telemetryGate++ % 100 !== 0)
        return;
      const n = ((i = t.item.provider._debugDisplayName) !== null && i !== void 0 ? i : "unknown").split("(", 1)[0].toLowerCase();
      this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
        providerId: n,
        basenameHash: h3(ko(e.uri)).toString(16),
        languageId: e.getLanguageId(),
        fileExtension: kq(e.uri)
      });
    }
    getOverwriteInfo(e, t) {
      Nt(this.editor.hasModel());
      let i = this.editor.getOption(106).insertMode === "replace";
      t && (i = !i);
      const n = e.position.column - e.editStart.column, o = (i ? e.editReplaceEnd.column : e.editInsertEnd.column) - e.position.column, r = this.editor.getPosition().column - e.position.column, a = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
      return {
        overwriteBefore: n + r,
        overwriteAfter: o + a
      };
    }
    _alertCompletionItem(e) {
      if (Ds(e.completion.additionalTextEdits)) {
        let t = m("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", e.textLabel, e.completion.additionalTextEdits.length);
        pn(t);
      }
    }
    triggerSuggest(e, t) {
      this.editor.hasModel() && (this.model.trigger({ auto: t ?? !1, shy: !1 }, !1, e), this.editor.revealPosition(this.editor.getPosition(), 0), this.editor.focus());
    }
    triggerSuggestAndAcceptBest(e) {
      if (!this.editor.hasModel())
        return;
      const t = this.editor.getPosition(), i = () => {
        t.equals(this.editor.getPosition()) && this._commandService.executeCommand(e.fallback);
      }, n = (o) => {
        if (o.completion.insertTextRules & 4 || o.completion.additionalTextEdits)
          return !0;
        const r = this.editor.getPosition(), a = o.editStart.column, l = r.column;
        return l - a !== o.completion.insertText.length ? !0 : this.editor.getModel().getValueInRange({
          startLineNumber: r.lineNumber,
          startColumn: a,
          endLineNumber: r.lineNumber,
          endColumn: l
        }) !== o.completion.insertText;
      };
      be.once(this.model.onDidTrigger)((o) => {
        let r = [];
        be.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
          at(r), i();
        }, void 0, r), this.model.onDidSuggest(({ completionModel: a }) => {
          if (at(r), a.items.length === 0) {
            i();
            return;
          }
          const l = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), a.items), c = a.items[l];
          if (!n(c)) {
            i();
            return;
          }
          this.editor.pushUndoStop(), this._insertSuggestion({ index: l, item: c, model: a }, 7);
        }, void 0, r);
      }), this.model.trigger({ auto: !1, shy: !0 }), this.editor.revealPosition(t, 0), this.editor.focus();
    }
    acceptSelectedSuggestion(e, t) {
      const i = this.widget.value.getFocusedItem();
      let n = 0;
      e && (n |= 4), t && (n |= 8), this._insertSuggestion(i, n);
    }
    acceptNextSuggestion() {
      this._alternatives.value.next();
    }
    acceptPrevSuggestion() {
      this._alternatives.value.prev();
    }
    cancelSuggestWidget() {
      this.model.cancel(), this.model.clear(), this.widget.value.hideWidget();
    }
    selectNextSuggestion() {
      this.widget.value.selectNext();
    }
    selectNextPageSuggestion() {
      this.widget.value.selectNextPage();
    }
    selectLastSuggestion() {
      this.widget.value.selectLast();
    }
    selectPrevSuggestion() {
      this.widget.value.selectPrevious();
    }
    selectPrevPageSuggestion() {
      this.widget.value.selectPreviousPage();
    }
    selectFirstSuggestion() {
      this.widget.value.selectFirst();
    }
    toggleSuggestionDetails() {
      this.widget.value.toggleDetails();
    }
    toggleExplainMode() {
      this.widget.value.toggleExplainMode();
    }
    toggleSuggestionFocus() {
      this.widget.value.toggleDetailsFocus();
    }
    resetWidgetSize() {
      this.widget.value.resetPersistedSize();
    }
    forceRenderingAbove() {
      this.widget.value.forceRenderingAbove();
    }
    stopForceRenderingAbove() {
      !this.widget.isInitialized || this.widget.value.stopForceRenderingAbove();
    }
    registerSelector(e) {
      return this._selectors.register(e);
    }
  };
  $o.ID = "editor.contrib.suggestController";
  $o = vse([
    cu(1, g9),
    cu(2, wi),
    cu(3, Fe),
    cu(4, et),
    cu(5, Xo),
    cu(6, Ca)
  ], $o);
  class wse {
    constructor(e) {
      this.prioritySelector = e, this._items = new Array();
    }
    register(e) {
      if (this._items.indexOf(e) !== -1)
        throw new Error("Value is already registered");
      return this._items.push(e), this._items.sort((t, i) => this.prioritySelector(i) - this.prioritySelector(t)), {
        dispose: () => {
          const t = this._items.indexOf(e);
          t >= 0 && this._items.splice(t, 1);
        }
      };
    }
    get itemsOrderedByPriorityDesc() {
      return this._items;
    }
  }
  class I_ extends ge {
    constructor() {
      super({
        id: I_.id,
        label: m("suggest.trigger.label", "Trigger Suggest"),
        alias: "Trigger Suggest",
        precondition: ce.and(T.writable, T.hasCompletionItemProvider),
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 2058,
          secondary: [2087],
          mac: { primary: 266, secondary: [521, 2087] },
          weight: 100
        }
      });
    }
    run(e, t, i) {
      const n = $o.get(t);
      if (!n)
        return;
      let o;
      i && typeof i == "object" && i.auto === !0 && (o = !0), n.triggerSuggest(void 0, o);
    }
  }
  I_.id = "editor.action.triggerSuggest";
  vt($o.ID, $o);
  oe(I_);
  const To = 100 + 90, Ms = wn.bindToContribution($o.get);
  se(new Ms({
    id: "acceptSelectedSuggestion",
    precondition: ot.Visible,
    handler(s) {
      s.acceptSelectedSuggestion(!0, !1);
    }
  }));
  Zn.registerKeybindingRule({
    id: "acceptSelectedSuggestion",
    when: ce.and(ot.Visible, T.textInputFocus),
    primary: 2,
    weight: To
  });
  Zn.registerKeybindingRule({
    id: "acceptSelectedSuggestion",
    when: ce.and(ot.Visible, T.textInputFocus, ot.AcceptSuggestionsOnEnter, ot.MakesTextEdit),
    primary: 3,
    weight: To
  });
  qs.appendMenuItem(Nc, {
    command: { id: "acceptSelectedSuggestion", title: m("accept.insert", "Insert") },
    group: "left",
    order: 1,
    when: ot.HasInsertAndReplaceRange.toNegated()
  });
  qs.appendMenuItem(Nc, {
    command: { id: "acceptSelectedSuggestion", title: m("accept.insert", "Insert") },
    group: "left",
    order: 1,
    when: ce.and(ot.HasInsertAndReplaceRange, ot.InsertMode.isEqualTo("insert"))
  });
  qs.appendMenuItem(Nc, {
    command: { id: "acceptSelectedSuggestion", title: m("accept.replace", "Replace") },
    group: "left",
    order: 1,
    when: ce.and(ot.HasInsertAndReplaceRange, ot.InsertMode.isEqualTo("replace"))
  });
  se(new Ms({
    id: "acceptAlternativeSelectedSuggestion",
    precondition: ce.and(ot.Visible, T.textInputFocus),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 1027,
      secondary: [1026]
    },
    handler(s) {
      s.acceptSelectedSuggestion(!1, !0);
    },
    menuOpts: [{
      menuId: Nc,
      group: "left",
      order: 2,
      when: ce.and(ot.HasInsertAndReplaceRange, ot.InsertMode.isEqualTo("insert")),
      title: m("accept.replace", "Replace")
    }, {
      menuId: Nc,
      group: "left",
      order: 2,
      when: ce.and(ot.HasInsertAndReplaceRange, ot.InsertMode.isEqualTo("replace")),
      title: m("accept.insert", "Insert")
    }]
  }));
  lt.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
  se(new Ms({
    id: "hideSuggestWidget",
    precondition: ot.Visible,
    handler: (s) => s.cancelSuggestWidget(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 9,
      secondary: [1033]
    }
  }));
  se(new Ms({
    id: "selectNextSuggestion",
    precondition: ce.and(ot.Visible, ot.MultipleSuggestions),
    handler: (s) => s.selectNextSuggestion(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 18,
      secondary: [2066],
      mac: { primary: 18, secondary: [2066, 300] }
    }
  }));
  se(new Ms({
    id: "selectNextPageSuggestion",
    precondition: ce.and(ot.Visible, ot.MultipleSuggestions),
    handler: (s) => s.selectNextPageSuggestion(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 12,
      secondary: [2060]
    }
  }));
  se(new Ms({
    id: "selectLastSuggestion",
    precondition: ce.and(ot.Visible, ot.MultipleSuggestions),
    handler: (s) => s.selectLastSuggestion()
  }));
  se(new Ms({
    id: "selectPrevSuggestion",
    precondition: ce.and(ot.Visible, ot.MultipleSuggestions),
    handler: (s) => s.selectPrevSuggestion(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 16,
      secondary: [2064],
      mac: { primary: 16, secondary: [2064, 302] }
    }
  }));
  se(new Ms({
    id: "selectPrevPageSuggestion",
    precondition: ce.and(ot.Visible, ot.MultipleSuggestions),
    handler: (s) => s.selectPrevPageSuggestion(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 11,
      secondary: [2059]
    }
  }));
  se(new Ms({
    id: "selectFirstSuggestion",
    precondition: ce.and(ot.Visible, ot.MultipleSuggestions),
    handler: (s) => s.selectFirstSuggestion()
  }));
  se(new Ms({
    id: "toggleSuggestionDetails",
    precondition: ot.Visible,
    handler: (s) => s.toggleSuggestionDetails(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 2058,
      secondary: [2087],
      mac: { primary: 266, secondary: [2087] }
    },
    menuOpts: [{
      menuId: Nc,
      group: "right",
      order: 1,
      when: ce.and(ot.DetailsVisible, ot.CanResolve),
      title: m("detail.more", "show less")
    }, {
      menuId: Nc,
      group: "right",
      order: 1,
      when: ce.and(ot.DetailsVisible.toNegated(), ot.CanResolve),
      title: m("detail.less", "show more")
    }]
  }));
  se(new Ms({
    id: "toggleExplainMode",
    precondition: ot.Visible,
    handler: (s) => s.toggleExplainMode(),
    kbOpts: {
      weight: 100,
      primary: 2133
    }
  }));
  se(new Ms({
    id: "toggleSuggestionFocus",
    precondition: ot.Visible,
    handler: (s) => s.toggleSuggestionFocus(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 2570,
      mac: { primary: 778 }
    }
  }));
  se(new Ms({
    id: "insertBestCompletion",
    precondition: ce.and(T.textInputFocus, ce.equals("config.editor.tabCompletion", "on"), Ap.AtEnd, ot.Visible.toNegated(), gh.OtherSuggestions.toNegated(), vn.InSnippetMode.toNegated()),
    handler: (s, e) => {
      s.triggerSuggestAndAcceptBest(ls(e) ? Object.assign({ fallback: "tab" }, e) : { fallback: "tab" });
    },
    kbOpts: {
      weight: To,
      primary: 2
    }
  }));
  se(new Ms({
    id: "insertNextSuggestion",
    precondition: ce.and(T.textInputFocus, ce.equals("config.editor.tabCompletion", "on"), gh.OtherSuggestions, ot.Visible.toNegated(), vn.InSnippetMode.toNegated()),
    handler: (s) => s.acceptNextSuggestion(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 2
    }
  }));
  se(new Ms({
    id: "insertPrevSuggestion",
    precondition: ce.and(T.textInputFocus, ce.equals("config.editor.tabCompletion", "on"), gh.OtherSuggestions, ot.Visible.toNegated(), vn.InSnippetMode.toNegated()),
    handler: (s) => s.acceptPrevSuggestion(),
    kbOpts: {
      weight: To,
      kbExpr: T.textInputFocus,
      primary: 1026
    }
  }));
  oe(class extends ge {
    constructor() {
      super({
        id: "editor.action.resetSuggestSize",
        label: m("suggest.reset.label", "Reset Suggest Widget Size"),
        alias: "Reset Suggest Widget Size",
        precondition: void 0
      });
    }
    run(s, e) {
      var t;
      (t = $o.get(e)) === null || t === void 0 || t.resetWidgetSize();
    }
  });
  class Sse extends z {
    constructor(e, t) {
      super(), this.editor = e, this.suggestControllerPreselector = t, this.isSuggestWidgetVisible = !1, this.isShiftKeyPressed = !1, this._isActive = !1, this._currentSuggestItemInfo = void 0, this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.setInactiveDelayed = this._register(new It(() => {
        this.isSuggestWidgetVisible || this._isActive && (this._isActive = !1, this.onDidChangeEmitter.fire());
      }, 100)), this._register(e.onKeyDown((n) => {
        n.shiftKey && !this.isShiftKeyPressed && (this.isShiftKeyPressed = !0, this.update(this._isActive));
      })), this._register(e.onKeyUp((n) => {
        n.shiftKey && this.isShiftKeyPressed && (this.isShiftKeyPressed = !1, this.update(this._isActive));
      }));
      const i = $o.get(this.editor);
      if (i) {
        this._register(i.registerSelector({
          priority: 100,
          select: (r, a, l) => {
            const c = this.editor.getModel(), d = q1(c, this.suggestControllerPreselector());
            if (!d)
              return -1;
            const h = V.lift(a), u = l.map((g, _) => {
              const b = QA(i, h, g, this.isShiftKeyPressed), C = q1(c, b?.normalizedInlineCompletion);
              if (!C)
                return;
              const v = yse(d.range, C.range) && d.text.startsWith(C.text);
              return { index: _, valid: v, prefixLength: C.text.length, suggestItem: g };
            }).filter((g) => g && g.valid), f = ZP(u, o0((g) => g.prefixLength, FV));
            return f ? f.index : -1;
          }
        }));
        let n = !1;
        const o = () => {
          n || (n = !0, this._register(i.widget.value.onDidShow(() => {
            this.isSuggestWidgetVisible = !0, this.update(!0);
          })), this._register(i.widget.value.onDidHide(() => {
            this.isSuggestWidgetVisible = !1, this.setInactiveDelayed.schedule(), this.update(this._isActive);
          })), this._register(i.widget.value.onDidFocus(() => {
            this.isSuggestWidgetVisible = !0, this.update(!0);
          })));
        };
        this._register(be.once(i.model.onDidTrigger)((r) => {
          o();
        }));
      }
      this.update(this._isActive);
    }
    get state() {
      if (!!this._isActive)
        return { selectedItem: this._currentSuggestItemInfo };
    }
    update(e) {
      const t = this.getSuggestItemInfo();
      let i = !1;
      Lse(this._currentSuggestItemInfo, t) || (this._currentSuggestItemInfo = t, i = !0), this._isActive !== e && (this._isActive = e, i = !0), i && this.onDidChangeEmitter.fire();
    }
    getSuggestItemInfo() {
      const e = $o.get(this.editor);
      if (!e || !this.isSuggestWidgetVisible)
        return;
      const t = e.widget.value.getFocusedItem();
      if (!!t)
        return QA(e, this.editor.getPosition(), t.item, this.isShiftKeyPressed);
    }
    stopForceRenderingAbove() {
      const e = $o.get(this.editor);
      e && e.stopForceRenderingAbove();
    }
    forceRenderingAbove() {
      const e = $o.get(this.editor);
      e && e.forceRenderingAbove();
    }
  }
  function yse(s, e) {
    return e.startLineNumber === s.startLineNumber && e.startColumn === s.startColumn && (e.endLineNumber < s.endLineNumber || e.endLineNumber === s.endLineNumber && e.endColumn <= s.endColumn);
  }
  function Lse(s, e) {
    return s === e ? !0 : !s || !e ? !1 : s.completionItemKind === e.completionItemKind && s.isSnippetText === e.isSnippetText && $ie(s.normalizedInlineCompletion, e.normalizedInlineCompletion);
  }
  function QA(s, e, t, i) {
    if (Array.isArray(t.completion.additionalTextEdits) && t.completion.additionalTextEdits.length > 0)
      return {
        completionItemKind: t.completion.kind,
        isSnippetText: !1,
        normalizedInlineCompletion: {
          range: D.fromPositions(e, e),
          text: ""
        }
      };
    let { insertText: n } = t.completion, o = !1;
    if (t.completion.insertTextRules & 4) {
      const a = new WC().parse(n), l = s.editor.getModel();
      if (a.children.length > 100)
        return;
      Br.adjustWhitespace(l, e, a, !0, !0), n = a.toString(), o = !0;
    }
    const r = s.getOverwriteInfo(t, i);
    return {
      isSnippetText: o,
      completionItemKind: t.completion.kind,
      normalizedInlineCompletion: {
        text: n,
        range: D.fromPositions(e.delta(0, -r.overwriteBefore), e.delta(0, Math.max(r.overwriteAfter, 0)))
      }
    };
  }
  var kse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Dse = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, JA = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let qk = class extends l9 {
    constructor(e, t, i) {
      super(e), this.cache = t, this.languageFeaturesService = i, this.suggestionInlineCompletionSource = this._register(new Sse(this.editor, () => {
        var n, o;
        return (o = (n = this.cache.value) === null || n === void 0 ? void 0 : n.completions[0]) === null || o === void 0 ? void 0 : o.toLiveInlineCompletion();
      })), this.updateOperation = this._register(new Gn()), this.updateCacheSoon = this._register(new It(() => this.updateCache(), 50)), this.minReservedLineCount = 0, this._register(this.suggestionInlineCompletionSource.onDidChange(() => {
        this.updateCacheSoon.schedule(), this.suggestionInlineCompletionSource.state || (this.minReservedLineCount = 0);
        const o = this.ghostText;
        o && (this.minReservedLineCount = Math.max(this.minReservedLineCount, xse(o.parts.map((r) => r.lines.length - 1)))), this.minReservedLineCount >= 1 ? this.suggestionInlineCompletionSource.forceRenderingAbove() : this.suggestionInlineCompletionSource.stopForceRenderingAbove(), this.onDidChangeEmitter.fire();
      })), this._register(this.cache.onDidChange(() => {
        this.onDidChangeEmitter.fire();
      })), this._register(this.editor.onDidChangeCursorPosition((n) => {
        this.minReservedLineCount = 0, this.updateCacheSoon.schedule(), this.onDidChangeEmitter.fire();
      })), this._register(qe(() => this.suggestionInlineCompletionSource.stopForceRenderingAbove()));
    }
    get isActive() {
      return this.suggestionInlineCompletionSource.state !== void 0;
    }
    isSuggestionPreviewEnabled() {
      return this.editor.getOption(106).preview;
    }
    updateCache() {
      return JA(this, void 0, void 0, function* () {
        const e = this.suggestionInlineCompletionSource.state;
        if (!e || !e.selectedItem)
          return;
        const t = {
          text: e.selectedItem.normalizedInlineCompletion.text,
          range: e.selectedItem.normalizedInlineCompletion.range,
          isSnippetText: e.selectedItem.isSnippetText,
          completionKind: e.selectedItem.completionItemKind
        }, i = this.editor.getPosition(), n = an((r) => JA(this, void 0, void 0, function* () {
          let a;
          try {
            a = yield h9(this.languageFeaturesService.inlineCompletionsProvider, i, this.editor.getModel(), { triggerKind: ao.Automatic, selectedSuggestionInfo: t }, r);
          } catch (l) {
            We(l);
            return;
          }
          r.isCancellationRequested || (this.cache.setValue(this.editor, a, ao.Automatic), this.onDidChangeEmitter.fire());
        })), o = new d9(n, ao.Automatic);
        this.updateOperation.value = o, yield n, this.updateOperation.value === o && this.updateOperation.clear();
      });
    }
    get ghostText() {
      var e, t, i;
      const n = this.isSuggestionPreviewEnabled(), o = q1(this.editor.getModel(), (t = (e = this.cache.value) === null || e === void 0 ? void 0 : e.completions[0]) === null || t === void 0 ? void 0 : t.toLiveInlineCompletion()), r = this.suggestionInlineCompletionSource.state, a = q1(this.editor.getModel(), (i = r?.selectedItem) === null || i === void 0 ? void 0 : i.normalizedInlineCompletion), l = o && a && o.text.startsWith(a.text) && o.range.equalsRange(a.range);
      if (!n && !l)
        return;
      const c = l ? o : a || o, d = l ? c.text.length - a.text.length : 0;
      return this.toGhostText(c, d);
    }
    toGhostText(e, t) {
      const i = this.editor.getOptions().get(106).previewMode;
      return e ? c9(e, this.editor.getModel(), i, this.editor.getPosition(), t) || new a9(e.range.endLineNumber, [], this.minReservedLineCount) : void 0;
    }
  };
  qk = kse([
    Dse(2, me)
  ], qk);
  function xse(s) {
    return s.reduce((e, t) => e + t, 0);
  }
  function Ise(s, e) {
    return {
      object: s,
      dispose: () => e?.dispose()
    };
  }
  var Ese = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Nse = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Tse = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Mse extends z {
    constructor() {
      super(...arguments), this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.hasCachedGhostText = !1, this.currentModelRef = this._register(new Gn());
    }
    get targetModel() {
      var e;
      return (e = this.currentModelRef.value) === null || e === void 0 ? void 0 : e.object;
    }
    setTargetModel(e) {
      var t;
      ((t = this.currentModelRef.value) === null || t === void 0 ? void 0 : t.object) !== e && (this.currentModelRef.clear(), this.currentModelRef.value = e ? Ise(e, e.onDidChange(() => {
        this.hasCachedGhostText = !1, this.onDidChangeEmitter.fire();
      })) : void 0, this.hasCachedGhostText = !1, this.onDidChangeEmitter.fire());
    }
    get ghostText() {
      var e, t;
      return this.hasCachedGhostText || (this.cachedGhostText = (t = (e = this.currentModelRef.value) === null || e === void 0 ? void 0 : e.object) === null || t === void 0 ? void 0 : t.ghostText, this.hasCachedGhostText = !0), this.cachedGhostText;
    }
    setExpanded(e) {
      var t;
      (t = this.targetModel) === null || t === void 0 || t.setExpanded(e);
    }
    get minReservedLineCount() {
      return this.targetModel ? this.targetModel.minReservedLineCount : 0;
    }
  }
  let Gk = class extends Mse {
    constructor(e, t) {
      super(), this.editor = e, this.instantiationService = t, this.sharedCache = this._register(new Ase()), this.suggestWidgetAdapterModel = this._register(this.instantiationService.createInstance(qk, this.editor, this.sharedCache)), this.inlineCompletionsModel = this._register(this.instantiationService.createInstance(Wk, this.editor, this.sharedCache)), this._register(this.suggestWidgetAdapterModel.onDidChange(() => {
        this.updateModel();
      })), this.updateModel();
    }
    get activeInlineCompletionsModel() {
      if (this.targetModel === this.inlineCompletionsModel)
        return this.inlineCompletionsModel;
    }
    updateModel() {
      this.setTargetModel(this.suggestWidgetAdapterModel.isActive ? this.suggestWidgetAdapterModel : this.inlineCompletionsModel), this.inlineCompletionsModel.setActive(this.targetModel === this.inlineCompletionsModel);
    }
    shouldShowHoverAt(e) {
      var t;
      const i = (t = this.activeInlineCompletionsModel) === null || t === void 0 ? void 0 : t.ghostText;
      return i ? i.parts.some((n) => e.containsPosition(new V(i.lineNumber, n.column))) : !1;
    }
    triggerInlineCompletion() {
      var e;
      (e = this.activeInlineCompletionsModel) === null || e === void 0 || e.trigger(ao.Explicit);
    }
    commitInlineCompletion() {
      var e;
      (e = this.activeInlineCompletionsModel) === null || e === void 0 || e.commitCurrentSuggestion();
    }
    hideInlineCompletion() {
      var e;
      (e = this.activeInlineCompletionsModel) === null || e === void 0 || e.hide();
    }
    showNextInlineCompletion() {
      var e;
      (e = this.activeInlineCompletionsModel) === null || e === void 0 || e.showNext();
    }
    showPreviousInlineCompletion() {
      var e;
      (e = this.activeInlineCompletionsModel) === null || e === void 0 || e.showPrevious();
    }
    hasMultipleInlineCompletions() {
      var e;
      return Tse(this, void 0, void 0, function* () {
        const t = yield (e = this.activeInlineCompletionsModel) === null || e === void 0 ? void 0 : e.hasMultipleInlineCompletions();
        return t !== void 0 ? t : !1;
      });
    }
  };
  Gk = Ese([
    Nse(1, et)
  ], Gk);
  class Ase extends z {
    constructor() {
      super(...arguments), this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.cache = this._register(new Gn());
    }
    get value() {
      return this.cache.value;
    }
    setValue(e, t, i) {
      this.cache.value = new Xie(e, t, () => this.onDidChangeEmitter.fire(), i);
    }
    clearAndLeak() {
      return this.cache.clearAndLeak();
    }
    clear() {
      this.cache.clear();
    }
  }
  var Rse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, eR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, uy;
  const tR = (uy = window.trustedTypes) === null || uy === void 0 ? void 0 : uy.createPolicy("editorGhostText", { createHTML: (s) => s });
  let Zk = class extends z {
    constructor(e, t, i, n) {
      super(), this.editor = e, this.model = t, this.instantiationService = i, this.languageService = n, this.disposed = !1, this.partsWidget = this._register(this.instantiationService.createInstance(Ose, this.editor)), this.additionalLinesWidget = this._register(new Pse(this.editor, this.languageService.languageIdCodec)), this.viewMoreContentWidget = void 0, this._register(this.editor.onDidChangeConfiguration((o) => {
        (o.hasChanged(29) || o.hasChanged(105) || o.hasChanged(88) || o.hasChanged(83) || o.hasChanged(45) || o.hasChanged(44) || o.hasChanged(59)) && this.update();
      })), this._register(qe(() => {
        var o;
        this.disposed = !0, this.update(), (o = this.viewMoreContentWidget) === null || o === void 0 || o.dispose(), this.viewMoreContentWidget = void 0;
      })), this._register(t.onDidChange(() => {
        this.update();
      })), this.update();
    }
    shouldShowHoverAtViewZone(e) {
      return this.additionalLinesWidget.viewZoneId === e;
    }
    update() {
      var e;
      const t = this.model.ghostText;
      if (!this.editor.hasModel() || !t || this.disposed) {
        this.partsWidget.clear(), this.additionalLinesWidget.clear();
        return;
      }
      const i = new Array(), n = new Array();
      function o(c, d) {
        if (n.length > 0) {
          const h = n[n.length - 1];
          d && h.decorations.push(new js(h.content.length + 1, h.content.length + 1 + c[0].length, d, 0)), h.content += c[0], c = c.slice(1);
        }
        for (const h of c)
          n.push({
            content: h,
            decorations: d ? [new js(1, h.length + 1, d, 0)] : []
          });
      }
      const r = this.editor.getModel().getLineContent(t.lineNumber);
      this.editor.getModel().getLineTokens(t.lineNumber);
      let a, l = 0;
      for (const c of t.parts) {
        let d = c.lines;
        a === void 0 ? (i.push({
          column: c.column,
          text: d[0],
          preview: c.preview
        }), d = d.slice(1)) : o([r.substring(l, c.column - 1)], void 0), d.length > 0 && (o(d, "ghost-text"), a === void 0 && c.column <= r.length && (a = c.column)), l = c.column - 1;
      }
      a !== void 0 && o([r.substring(l)], void 0), this.partsWidget.setParts(t.lineNumber, i, a !== void 0 ? { column: a, length: r.length + 1 - a } : void 0), this.additionalLinesWidget.updateLines(t.lineNumber, n, t.additionalReservedLineCount), t.parts.some((c) => c.lines.length < 0) ? this.viewMoreContentWidget = this.renderViewMoreLines(new V(t.lineNumber, this.editor.getModel().getLineMaxColumn(t.lineNumber)), "", 0) : ((e = this.viewMoreContentWidget) === null || e === void 0 || e.dispose(), this.viewMoreContentWidget = void 0);
    }
    renderViewMoreLines(e, t, i) {
      const n = this.editor.getOption(44), o = document.createElement("div");
      o.className = "suggest-preview-additional-widget", En(o, n);
      const r = document.createElement("span");
      r.className = "content-spacer", r.append(t), o.append(r);
      const a = document.createElement("span");
      a.className = "content-newline suggest-preview-text", a.append("\u23CE  "), o.append(a);
      const l = new te(), c = document.createElement("div");
      return c.className = "button suggest-preview-text", c.append(`+${i} lines\u2026`), l.add(on(c, "mousedown", (d) => {
        var h;
        (h = this.model) === null || h === void 0 || h.setExpanded(!0), d.preventDefault(), this.editor.focus();
      })), o.append(c), new Bse(this.editor, e, o, l);
    }
  };
  Zk = Rse([
    eR(2, et),
    eR(3, Jt)
  ], Zk);
  class Ose {
    constructor(e) {
      this.editor = e, this.decorationIds = [], this.disposableStore = new te();
    }
    dispose() {
      this.clear(), this.disposableStore.dispose();
    }
    clear() {
      this.editor.deltaDecorations(this.decorationIds, []), this.disposableStore.clear();
    }
    setParts(e, t, i) {
      if (this.disposableStore.clear(), !this.editor.getModel())
        return;
      const o = new Array();
      i && o.push({
        range: D.fromPositions(new V(e, i.column), new V(e, i.column + i.length)),
        options: {
          inlineClassName: "ghost-text-hidden",
          description: "ghost-text-hidden"
        }
      }), this.decorationIds = this.editor.deltaDecorations(this.decorationIds, t.map((r) => ({
        range: D.fromPositions(new V(e, r.column)),
        options: {
          description: "ghost-text",
          after: { content: r.text, inlineClassName: r.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration" },
          showIfCollapsed: !0
        }
      })).concat(o));
    }
  }
  class Pse {
    constructor(e, t) {
      this.editor = e, this.languageIdCodec = t, this._viewZoneId = void 0;
    }
    get viewZoneId() {
      return this._viewZoneId;
    }
    dispose() {
      this.clear();
    }
    clear() {
      this.editor.changeViewZones((e) => {
        this._viewZoneId && (e.removeZone(this._viewZoneId), this._viewZoneId = void 0);
      });
    }
    updateLines(e, t, i) {
      const n = this.editor.getModel();
      if (!n)
        return;
      const { tabSize: o } = n.getOptions();
      this.editor.changeViewZones((r) => {
        this._viewZoneId && (r.removeZone(this._viewZoneId), this._viewZoneId = void 0);
        const a = Math.max(t.length, i);
        if (a > 0) {
          const l = document.createElement("div");
          Fse(l, o, t, this.editor.getOptions(), this.languageIdCodec), this._viewZoneId = r.addZone({
            afterLineNumber: e,
            heightInLines: a,
            domNode: l,
            afterColumnAffinity: 1
          });
        }
      });
    }
  }
  function Fse(s, e, t, i, n) {
    const o = i.get(29), r = i.get(105), a = "none", l = i.get(83), c = i.get(45), d = i.get(44), h = i.get(59), u = Zd(1e4);
    u.appendASCIIString('<div class="suggest-preview-text">');
    for (let _ = 0, b = t.length; _ < b; _++) {
      const C = t[_], v = C.content;
      u.appendASCIIString('<div class="view-line'), u.appendASCIIString('" style="top:'), u.appendASCIIString(String(_ * h)), u.appendASCIIString('px;width:1000000px;">');
      const w = Rv(v), S = Av(v), L = Fi.createEmpty(v, n);
      iC(new Rh(d.isMonospace && !o, d.canUseHalfwidthRightwardsArrow, v, !1, w, S, 0, L, C.decorations, e, 0, d.spaceWidth, d.middotWidth, d.wsmiddotWidth, r, a, l, c !== zs.OFF, null), u), u.appendASCIIString("</div>");
    }
    u.appendASCIIString("</div>"), En(s, d);
    const f = u.build(), g = tR ? tR.createHTML(f) : f;
    s.innerHTML = g;
  }
  class Bse extends z {
    constructor(e, t, i, n) {
      super(), this.editor = e, this.position = t, this.domNode = i, this.allowEditorOverflow = !1, this.suppressMouseDown = !1, this._register(n), this._register(qe(() => {
        this.editor.removeContentWidget(this);
      })), this.editor.addContentWidget(this);
    }
    getId() {
      return "editor.widget.viewMoreLinesWidget";
    }
    getDomNode() {
      return this.domNode;
    }
    getPosition() {
      return {
        position: this.position,
        preference: [0]
      };
    }
  }
  Vt((s, e) => {
    const t = s.getColor(W$);
    t && (e.addRule(`.monaco-editor .ghost-text-decoration { color: ${t.toString()} !important; }`), e.addRule(`.monaco-editor .ghost-text-decoration-preview { color: ${t.toString()} !important; }`), e.addRule(`.monaco-editor .suggest-preview-text .ghost-text { color: ${t.toString()} !important; }`));
    const i = s.getColor(V$);
    i && (e.addRule(`.monaco-editor .ghost-text-decoration { background-color: ${i.toString()}; }`), e.addRule(`.monaco-editor .ghost-text-decoration-preview { background-color: ${i.toString()}; }`), e.addRule(`.monaco-editor .suggest-preview-text .ghost-text { background-color: ${i.toString()}; }`));
    const n = s.getColor(B$);
    n && (e.addRule(`.monaco-editor .suggest-preview-text .ghost-text { border: 1px solid ${n}; }`), e.addRule(`.monaco-editor .ghost-text-decoration { border: 1px solid ${n}; }`), e.addRule(`.monaco-editor .ghost-text-decoration-preview { border: 1px solid ${n}; }`));
  });
  var C9 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Yk = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, GC = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Gi = class w9 extends z {
    constructor(e, t) {
      super(), this.editor = e, this.instantiationService = t, this.triggeredExplicitly = !1, this.activeController = this._register(new Gn()), this.activeModelDidChangeEmitter = this._register(new B()), this._register(this.editor.onDidChangeModel(() => {
        this.updateModelController();
      })), this._register(this.editor.onDidChangeConfiguration((i) => {
        i.hasChanged(106) && this.updateModelController(), i.hasChanged(55) && this.updateModelController();
      })), this.updateModelController();
    }
    static get(e) {
      return e.getContribution(w9.ID);
    }
    get activeModel() {
      var e;
      return (e = this.activeController.value) === null || e === void 0 ? void 0 : e.model;
    }
    updateModelController() {
      const e = this.editor.getOption(106), t = this.editor.getOption(55);
      this.activeController.value = void 0, this.activeController.value = this.editor.hasModel() && (e.preview || t.enabled || this.triggeredExplicitly) ? this.instantiationService.createInstance(Xk, this.editor) : void 0, this.activeModelDidChangeEmitter.fire();
    }
    shouldShowHoverAt(e) {
      var t;
      return ((t = this.activeModel) === null || t === void 0 ? void 0 : t.shouldShowHoverAt(e)) || !1;
    }
    shouldShowHoverAtViewZone(e) {
      var t, i;
      return ((i = (t = this.activeController.value) === null || t === void 0 ? void 0 : t.widget) === null || i === void 0 ? void 0 : i.shouldShowHoverAtViewZone(e)) || !1;
    }
    trigger() {
      var e;
      this.triggeredExplicitly = !0, this.activeController.value || this.updateModelController(), (e = this.activeModel) === null || e === void 0 || e.triggerInlineCompletion();
    }
    commit() {
      var e;
      (e = this.activeModel) === null || e === void 0 || e.commitInlineCompletion();
    }
    hide() {
      var e;
      (e = this.activeModel) === null || e === void 0 || e.hideInlineCompletion();
    }
    showNextInlineCompletion() {
      var e;
      (e = this.activeModel) === null || e === void 0 || e.showNextInlineCompletion();
    }
    showPreviousInlineCompletion() {
      var e;
      (e = this.activeModel) === null || e === void 0 || e.showPreviousInlineCompletion();
    }
    hasMultipleInlineCompletions() {
      var e;
      return GC(this, void 0, void 0, function* () {
        const t = yield (e = this.activeModel) === null || e === void 0 ? void 0 : e.hasMultipleInlineCompletions();
        return t !== void 0 ? t : !1;
      });
    }
  };
  Gi.inlineSuggestionVisible = new ue("inlineSuggestionVisible", !1, m("inlineSuggestionVisible", "Whether an inline suggestion is visible"));
  Gi.inlineSuggestionHasIndentation = new ue("inlineSuggestionHasIndentation", !1, m("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace"));
  Gi.inlineSuggestionHasIndentationLessThanTabSize = new ue("inlineSuggestionHasIndentationLessThanTabSize", !0, m("inlineSuggestionHasIndentationLessThanTabSize", "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
  Gi.ID = "editor.contrib.ghostTextController";
  Gi = C9([
    Yk(1, et)
  ], Gi);
  class Wse {
    constructor(e) {
      this.contextKeyService = e, this.inlineCompletionVisible = Gi.inlineSuggestionVisible.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentation = Gi.inlineSuggestionHasIndentation.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentationLessThanTabSize = Gi.inlineSuggestionHasIndentationLessThanTabSize.bindTo(this.contextKeyService);
    }
  }
  let Xk = class extends z {
    constructor(e, t, i) {
      super(), this.editor = e, this.instantiationService = t, this.contextKeyService = i, this.contextKeys = new Wse(this.contextKeyService), this.model = this._register(this.instantiationService.createInstance(Gk, this.editor)), this.widget = this._register(this.instantiationService.createInstance(Zk, this.editor, this.model)), this._register(qe(() => {
        this.contextKeys.inlineCompletionVisible.set(!1), this.contextKeys.inlineCompletionSuggestsIndentation.set(!1), this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(!0);
      })), this._register(this.model.onDidChange(() => {
        this.updateContextKeys();
      })), this.updateContextKeys();
    }
    updateContextKeys() {
      var e;
      this.contextKeys.inlineCompletionVisible.set(((e = this.model.activeInlineCompletionsModel) === null || e === void 0 ? void 0 : e.ghostText) !== void 0);
      let t = !1, i = !0;
      const n = this.model.inlineCompletionsModel.ghostText;
      if (!!this.model.activeInlineCompletionsModel && n && n.parts.length > 0) {
        const { column: o, lines: r } = n.parts[0], a = r[0], l = this.editor.getModel().getLineIndentColumn(n.lineNumber);
        if (o <= l) {
          let d = jn(a);
          d === -1 && (d = a.length - 1), t = d > 0;
          const h = this.editor.getModel().getOptions().tabSize;
          i = Oi.visibleColumnFromColumn(a, d + 1, h) < h;
        }
      }
      this.contextKeys.inlineCompletionSuggestsIndentation.set(t), this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(i);
    }
  };
  Xk = C9([
    Yk(1, et),
    Yk(2, Fe)
  ], Xk);
  const S9 = wn.bindToContribution(Gi.get), Op = new S9({
    id: r9,
    precondition: Gi.inlineSuggestionVisible,
    handler(s) {
      s.commit(), s.editor.focus();
    }
  });
  se(Op);
  Zn.registerKeybindingRule({
    primary: 2,
    weight: 200,
    id: Op.id,
    when: ce.and(Op.precondition, T.tabMovesFocus.toNegated(), Gi.inlineSuggestionHasIndentationLessThanTabSize)
  });
  se(new S9({
    id: "editor.action.inlineSuggest.hide",
    precondition: Gi.inlineSuggestionVisible,
    kbOpts: {
      weight: 100,
      primary: 9
    },
    handler(s) {
      s.hide();
    }
  }));
  class Pf extends ge {
    constructor() {
      super({
        id: Pf.ID,
        label: m("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
        alias: "Show Next Inline Suggestion",
        precondition: ce.and(T.writable, Gi.inlineSuggestionVisible),
        kbOpts: {
          weight: 100,
          primary: 601
        }
      });
    }
    run(e, t) {
      return GC(this, void 0, void 0, function* () {
        const i = Gi.get(t);
        i && (i.showNextInlineCompletion(), t.focus());
      });
    }
  }
  Pf.ID = "editor.action.inlineSuggest.showNext";
  class Ff extends ge {
    constructor() {
      super({
        id: Ff.ID,
        label: m("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
        alias: "Show Previous Inline Suggestion",
        precondition: ce.and(T.writable, Gi.inlineSuggestionVisible),
        kbOpts: {
          weight: 100,
          primary: 599
        }
      });
    }
    run(e, t) {
      return GC(this, void 0, void 0, function* () {
        const i = Gi.get(t);
        i && (i.showPreviousInlineCompletion(), t.focus());
      });
    }
  }
  Ff.ID = "editor.action.inlineSuggest.showPrevious";
  class Vse extends ge {
    constructor() {
      super({
        id: "editor.action.inlineSuggest.trigger",
        label: m("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
        alias: "Trigger Inline Suggestion",
        precondition: T.writable
      });
    }
    run(e, t) {
      return GC(this, void 0, void 0, function* () {
        const i = Gi.get(t);
        i && i.trigger();
      });
    }
  }
  var Hse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, du = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class zse {
    constructor(e, t, i) {
      this.owner = e, this.range = t, this.controller = i;
    }
    isValidForHoverAnchor(e) {
      return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
    }
    hasMultipleSuggestions() {
      return this.controller.hasMultipleInlineCompletions();
    }
  }
  let Qk = class {
    constructor(e, t, i, n, o, r, a) {
      this._editor = e, this._commandService = t, this._menuService = i, this._contextKeyService = n, this._languageService = o, this._openerService = r, this.accessibilityService = a, this.hoverOrdinal = 3;
    }
    suggestHoverAnchor(e) {
      const t = Gi.get(this._editor);
      if (!t)
        return null;
      const i = e.target;
      if (i.type === 8) {
        const n = i.detail;
        if (t.shouldShowHoverAtViewZone(n.viewZoneId))
          return new C0(1e3, this, D.fromPositions(n.positionBefore || n.position, n.positionBefore || n.position));
      }
      return i.type === 7 && t.shouldShowHoverAt(i.range) ? new C0(1e3, this, i.range) : i.type === 6 && i.detail.mightBeForeignElement && t.shouldShowHoverAt(i.range) ? new C0(1e3, this, i.range) : null;
    }
    computeSync(e, t) {
      const i = Gi.get(this._editor);
      return i && i.shouldShowHoverAt(e.range) ? [new zse(this, e.range, i)] : [];
    }
    renderHoverParts(e, t) {
      const i = new te(), n = t[0];
      this.accessibilityService.isScreenReaderOptimized() && this.renderScreenReaderText(e, n, i);
      const o = i.add(this._menuService.createMenu(A.InlineCompletionsActions, this._contextKeyService)), r = e.statusBar.addAction({
        label: m("showNextInlineSuggestion", "Next"),
        commandId: Pf.ID,
        run: () => this._commandService.executeCommand(Pf.ID)
      }), a = e.statusBar.addAction({
        label: m("showPreviousInlineSuggestion", "Previous"),
        commandId: Ff.ID,
        run: () => this._commandService.executeCommand(Ff.ID)
      });
      e.statusBar.addAction({
        label: m("acceptInlineSuggestion", "Accept"),
        commandId: Op.id,
        run: () => this._commandService.executeCommand(Op.id)
      });
      const l = [r, a];
      for (const c of l)
        c.setEnabled(!1);
      n.hasMultipleSuggestions().then((c) => {
        for (const d of l)
          d.setEnabled(c);
      });
      for (const [c, d] of o.getActions())
        for (const h of d)
          h instanceof vc && e.statusBar.addAction({
            label: h.label,
            commandId: h.item.id,
            run: () => this._commandService.executeCommand(h.item.id)
          });
      return i;
    }
    renderScreenReaderText(e, t, i) {
      var n, o;
      const r = J, a = r("div.hover-row.markdown-hover"), l = q(a, r("div.hover-contents")), c = i.add(new bl({ editor: this._editor }, this._languageService, this._openerService)), d = (u) => {
        i.add(c.onDidRenderAsync(() => {
          l.className = "hover-contents code-hover-contents", e.onContentsChanged();
        }));
        const f = m("inlineSuggestionFollows", "Suggestion:"), g = i.add(c.render(new Us().appendText(f).appendCodeblock("text", u)));
        l.replaceChildren(g.element);
      }, h = (o = (n = t.controller.activeModel) === null || n === void 0 ? void 0 : n.inlineCompletionsModel) === null || o === void 0 ? void 0 : o.ghostText;
      if (h) {
        const u = this._editor.getModel().getLineContent(h.lineNumber);
        d(h.renderForScreenReader(u));
      }
      e.fragment.appendChild(a);
    }
  };
  Qk = Hse([
    du(1, wi),
    du(2, Eh),
    du(3, Fe),
    du(4, Jt),
    du(5, No),
    du(6, Ts)
  ], Qk);
  vt(Gi.ID, Gi);
  oe(Vse);
  oe(Pf);
  oe(Ff);
  Kh.register(Qk);
  function bs(s, e) {
    let t = 0;
    for (let i = 0; i < s.length; i++)
      s.charAt(i) === "	" ? t += e : t++;
    return t;
  }
  function xm(s, e, t) {
    s = s < 0 ? 0 : s;
    let i = "";
    if (!t) {
      let n = Math.floor(s / e);
      s = s % e;
      for (let o = 0; o < n; o++)
        i += "	";
    }
    for (let n = 0; n < s; n++)
      i += " ";
    return i;
  }
  function y9(s, e, t, i, n) {
    if (s.getLineCount() === 1 && s.getLineMaxColumn(1) === 1)
      return [];
    const o = e.getLanguageConfiguration(s.getLanguageId()).indentationRules;
    if (!o)
      return [];
    for (i = Math.min(i, s.getLineCount()); t <= i && o.unIndentedLinePattern; ) {
      let b = s.getLineContent(t);
      if (!o.unIndentedLinePattern.test(b))
        break;
      t++;
    }
    if (t > i - 1)
      return [];
    const { tabSize: r, indentSize: a, insertSpaces: l } = s.getOptions(), c = (b, C) => (C = C || 1, Hs.shiftIndent(b, b.length + C, r, a, l)), d = (b, C) => (C = C || 1, Hs.unshiftIndent(b, b.length + C, r, a, l));
    let h = [], u, f = s.getLineContent(t), g = f;
    if (n != null) {
      u = n;
      let b = Dt(f);
      g = u + f.substring(b.length), o.decreaseIndentPattern && o.decreaseIndentPattern.test(g) && (u = d(u), g = u + f.substring(b.length)), f !== g && h.push(li.replaceMove(new ae(t, 1, t, b.length + 1), e1(u, a, l)));
    } else
      u = Dt(f);
    let _ = u;
    o.increaseIndentPattern && o.increaseIndentPattern.test(g) ? (_ = c(_), u = c(u)) : o.indentNextLinePattern && o.indentNextLinePattern.test(g) && (_ = c(_)), t++;
    for (let b = t; b <= i; b++) {
      let C = s.getLineContent(b), v = Dt(C), w = _ + C.substring(v.length);
      o.decreaseIndentPattern && o.decreaseIndentPattern.test(w) && (_ = d(_), u = d(u)), v !== _ && h.push(li.replaceMove(new ae(b, 1, b, v.length + 1), e1(_, a, l))), !(o.unIndentedLinePattern && o.unIndentedLinePattern.test(C)) && (o.increaseIndentPattern && o.increaseIndentPattern.test(w) ? (u = c(u), _ = u) : o.indentNextLinePattern && o.indentNextLinePattern.test(w) ? _ = c(_) : _ = u);
    }
    return h;
  }
  class ZC extends ge {
    constructor() {
      super({
        id: ZC.ID,
        label: m("indentationToSpaces", "Convert Indentation to Spaces"),
        alias: "Convert Indentation to Spaces",
        precondition: T.writable
      });
    }
    run(e, t) {
      let i = t.getModel();
      if (!i)
        return;
      let n = i.getOptions(), o = t.getSelection();
      if (!o)
        return;
      const r = new Kse(o, n.tabSize);
      t.pushUndoStop(), t.executeCommands(this.id, [r]), t.pushUndoStop(), i.updateOptions({
        insertSpaces: !0
      });
    }
  }
  ZC.ID = "editor.action.indentationToSpaces";
  class YC extends ge {
    constructor() {
      super({
        id: YC.ID,
        label: m("indentationToTabs", "Convert Indentation to Tabs"),
        alias: "Convert Indentation to Tabs",
        precondition: T.writable
      });
    }
    run(e, t) {
      let i = t.getModel();
      if (!i)
        return;
      let n = i.getOptions(), o = t.getSelection();
      if (!o)
        return;
      const r = new qse(o, n.tabSize);
      t.pushUndoStop(), t.executeCommands(this.id, [r]), t.pushUndoStop(), i.updateOptions({
        insertSpaces: !1
      });
    }
  }
  YC.ID = "editor.action.indentationToTabs";
  class L9 extends ge {
    constructor(e, t) {
      super(t), this.insertSpaces = e;
    }
    run(e, t) {
      const i = e.get(Sl), n = e.get(Qt);
      let o = t.getModel();
      if (!o)
        return;
      const r = n.getCreationOptions(o.getLanguageId(), o.uri, o.isForSimpleWidget), a = [1, 2, 3, 4, 5, 6, 7, 8].map((c) => ({
        id: c.toString(),
        label: c.toString(),
        description: c === r.tabSize ? m("configuredTabSize", "Configured Tab Size") : void 0
      })), l = Math.min(o.getOptions().tabSize - 1, 7);
      setTimeout(() => {
        i.pick(a, { placeHolder: m({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: a[l] }).then((c) => {
          c && o && !o.isDisposed() && o.updateOptions({
            tabSize: parseInt(c.label, 10),
            insertSpaces: this.insertSpaces
          });
        });
      }, 50);
    }
  }
  class XC extends L9 {
    constructor() {
      super(!1, {
        id: XC.ID,
        label: m("indentUsingTabs", "Indent Using Tabs"),
        alias: "Indent Using Tabs",
        precondition: void 0
      });
    }
  }
  XC.ID = "editor.action.indentUsingTabs";
  class QC extends L9 {
    constructor() {
      super(!0, {
        id: QC.ID,
        label: m("indentUsingSpaces", "Indent Using Spaces"),
        alias: "Indent Using Spaces",
        precondition: void 0
      });
    }
  }
  QC.ID = "editor.action.indentUsingSpaces";
  class JC extends ge {
    constructor() {
      super({
        id: JC.ID,
        label: m("detectIndentation", "Detect Indentation from Content"),
        alias: "Detect Indentation from Content",
        precondition: void 0
      });
    }
    run(e, t) {
      const i = e.get(Qt);
      let n = t.getModel();
      if (!n)
        return;
      const o = i.getCreationOptions(n.getLanguageId(), n.uri, n.isForSimpleWidget);
      n.detectIndentation(o.insertSpaces, o.tabSize);
    }
  }
  JC.ID = "editor.action.detectIndentation";
  class Use extends ge {
    constructor() {
      super({
        id: "editor.action.reindentlines",
        label: m("editor.reindentlines", "Reindent Lines"),
        alias: "Reindent Lines",
        precondition: T.writable
      });
    }
    run(e, t) {
      const i = e.get(Mn);
      let n = t.getModel();
      if (!n)
        return;
      let o = y9(n, i, 1, n.getLineCount());
      o.length > 0 && (t.pushUndoStop(), t.executeEdits(this.id, o), t.pushUndoStop());
    }
  }
  class $se extends ge {
    constructor() {
      super({
        id: "editor.action.reindentselectedlines",
        label: m("editor.reindentselectedlines", "Reindent Selected Lines"),
        alias: "Reindent Selected Lines",
        precondition: T.writable
      });
    }
    run(e, t) {
      const i = e.get(Mn);
      let n = t.getModel();
      if (!n)
        return;
      let o = t.getSelections();
      if (o === null)
        return;
      let r = [];
      for (let a of o) {
        let l = a.startLineNumber, c = a.endLineNumber;
        if (l !== c && a.endColumn === 1 && c--, l === 1) {
          if (l === c)
            continue;
        } else
          l--;
        let d = y9(n, i, l, c);
        r.push(...d);
      }
      r.length > 0 && (t.pushUndoStop(), t.executeEdits(this.id, r), t.pushUndoStop());
    }
  }
  class jse {
    constructor(e, t) {
      this._initialSelection = t, this._edits = [], this._selectionId = null;
      for (let i of e)
        i.range && typeof i.text == "string" && this._edits.push(i);
    }
    getEditOperations(e, t) {
      for (let n of this._edits)
        t.addEditOperation(D.lift(n.range), n.text);
      let i = !1;
      Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty() && (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber ? (i = !0, this._selectionId = t.trackSelection(this._initialSelection, !0)) : this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber && (i = !0, this._selectionId = t.trackSelection(this._initialSelection, !1))), i || (this._selectionId = t.trackSelection(this._initialSelection));
    }
    computeCursorState(e, t) {
      return t.getTrackedSelection(this._selectionId);
    }
  }
  class Jk {
    constructor(e) {
      this.callOnDispose = new te(), this.callOnModel = new te(), this.editor = e, this.callOnDispose.add(e.onDidChangeConfiguration(() => this.update())), this.callOnDispose.add(e.onDidChangeModel(() => this.update())), this.callOnDispose.add(e.onDidChangeModelLanguage(() => this.update()));
    }
    update() {
      this.callOnModel.clear(), !(this.editor.getOption(9) < 4 || this.editor.getOption(48)) && (!this.editor.hasModel() || this.callOnModel.add(this.editor.onDidPaste(({ range: e }) => {
        this.trigger(e);
      })));
    }
    trigger(e) {
      let t = this.editor.getSelections();
      if (t === null || t.length > 1)
        return;
      const i = this.editor.getModel();
      if (!i || !i.isCheapToTokenize(e.getStartPosition().lineNumber))
        return;
      const n = this.editor.getOption(9), { tabSize: o, indentSize: r, insertSpaces: a } = i.getOptions();
      let l = [], c = {
        shiftIndent: (f) => Hs.shiftIndent(f, f.length + 1, o, r, a),
        unshiftIndent: (f) => Hs.unshiftIndent(f, f.length + 1, o, r, a)
      }, d = e.startLineNumber;
      for (; d <= e.endLineNumber; ) {
        if (this.shouldIgnoreLine(i, d)) {
          d++;
          continue;
        }
        break;
      }
      if (d > e.endLineNumber)
        return;
      let h = i.getLineContent(d);
      if (!/\S/.test(h.substring(0, e.startColumn - 1))) {
        const f = Di.getGoodIndentForLine(n, i, i.getLanguageId(), d, c);
        if (f !== null) {
          let g = Dt(h), _ = bs(f, o), b = bs(g, o);
          if (_ !== b) {
            let C = xm(_, o, a);
            l.push({
              range: new D(d, 1, d, g.length + 1),
              text: C
            }), h = C + h.substr(g.length);
          } else {
            let C = Di.getIndentMetadata(i, d);
            if (C === 0 || C === 8)
              return;
          }
        }
      }
      const u = d;
      for (; d < e.endLineNumber; ) {
        if (!/\S/.test(i.getLineContent(d + 1))) {
          d++;
          continue;
        }
        break;
      }
      if (d !== e.endLineNumber) {
        let f = {
          getLineTokens: (_) => i.getLineTokens(_),
          getLanguageId: () => i.getLanguageId(),
          getLanguageIdAtPosition: (_, b) => i.getLanguageIdAtPosition(_, b),
          getLineContent: (_) => _ === u ? h : i.getLineContent(_)
        }, g = Di.getGoodIndentForLine(n, f, i.getLanguageId(), d + 1, c);
        if (g !== null) {
          let _ = bs(g, o), b = bs(Dt(i.getLineContent(d + 1)), o);
          if (_ !== b) {
            let C = _ - b;
            for (let v = d + 1; v <= e.endLineNumber; v++) {
              let w = i.getLineContent(v), S = Dt(w), x = bs(S, o) + C, y = xm(x, o, a);
              y !== S && l.push({
                range: new D(v, 1, v, S.length + 1),
                text: y
              });
            }
          }
        }
      }
      if (l.length > 0) {
        this.editor.pushUndoStop();
        let f = new jse(l, this.editor.getSelection());
        this.editor.executeCommand("autoIndentOnPaste", f), this.editor.pushUndoStop();
      }
    }
    shouldIgnoreLine(e, t) {
      e.forceTokenization(t);
      let i = e.getLineFirstNonWhitespaceColumn(t);
      if (i === 0)
        return !0;
      let n = e.getLineTokens(t);
      if (n.getCount() > 0) {
        let o = n.findTokenIndexAtOffset(i);
        if (o >= 0 && n.getStandardTokenType(o) === 1)
          return !0;
      }
      return !1;
    }
    dispose() {
      this.callOnDispose.dispose(), this.callOnModel.dispose();
    }
  }
  Jk.ID = "editor.contrib.autoIndentOnPaste";
  function k9(s, e, t, i) {
    if (s.getLineCount() === 1 && s.getLineMaxColumn(1) === 1)
      return;
    let n = "";
    for (let r = 0; r < t; r++)
      n += " ";
    let o = new RegExp(n, "gi");
    for (let r = 1, a = s.getLineCount(); r <= a; r++) {
      let l = s.getLineFirstNonWhitespaceColumn(r);
      if (l === 0 && (l = s.getLineMaxColumn(r)), l === 1)
        continue;
      const c = new D(r, 1, r, l), d = s.getValueInRange(c), h = i ? d.replace(/\t/ig, n) : d.replace(o, "	");
      e.addEditOperation(c, h);
    }
  }
  class Kse {
    constructor(e, t) {
      this.selection = e, this.tabSize = t, this.selectionId = null;
    }
    getEditOperations(e, t) {
      this.selectionId = t.trackSelection(this.selection), k9(e, t, this.tabSize, !0);
    }
    computeCursorState(e, t) {
      return t.getTrackedSelection(this.selectionId);
    }
  }
  class qse {
    constructor(e, t) {
      this.selection = e, this.tabSize = t, this.selectionId = null;
    }
    getEditOperations(e, t) {
      this.selectionId = t.trackSelection(this.selection), k9(e, t, this.tabSize, !1);
    }
    computeCursorState(e, t) {
      return t.getTrackedSelection(this.selectionId);
    }
  }
  vt(Jk.ID, Jk);
  oe(ZC);
  oe(YC);
  oe(XC);
  oe(QC);
  oe(JC);
  oe(Use);
  oe($se);
  var G1 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class D9 {
    constructor(e, t) {
      this.range = e, this.direction = t;
    }
  }
  class zN {
    constructor(e, t, i) {
      this.hint = e, this.anchor = t, this.provider = i, this._isResolved = !1;
    }
    with(e) {
      const t = new zN(this.hint, e.anchor, this.provider);
      return t._isResolved = this._isResolved, t._currentResolve = this._currentResolve, t;
    }
    resolve(e) {
      return G1(this, void 0, void 0, function* () {
        if (typeof this.provider.resolveInlayHint == "function") {
          if (this._currentResolve)
            return yield this._currentResolve, e.isCancellationRequested ? void 0 : this.resolve(e);
          this._isResolved || (this._currentResolve = this._doResolve(e).finally(() => this._currentResolve = void 0)), yield this._currentResolve;
        }
      });
    }
    _doResolve(e) {
      var t, i;
      return G1(this, void 0, void 0, function* () {
        try {
          const n = yield Promise.resolve(this.provider.resolveInlayHint(this.hint, e));
          this.hint.tooltip = (t = n?.tooltip) !== null && t !== void 0 ? t : this.hint.tooltip, this.hint.label = (i = n?.label) !== null && i !== void 0 ? i : this.hint.label, this._isResolved = !0;
        } catch (n) {
          Xi(n), this._isResolved = !1;
        }
      });
    }
  }
  class Pp {
    constructor(e, t, i) {
      this._disposables = new te(), this.ranges = e, this.provider = /* @__PURE__ */ new Set();
      const n = [];
      for (const [o, r] of t) {
        this._disposables.add(o), this.provider.add(r);
        for (const a of o.hints) {
          let l = i.validatePosition(a.position), c = "before";
          const d = Pp._getRangeAtPosition(i, l);
          let h;
          d.getStartPosition().isBefore(l) ? (h = D.fromPositions(d.getStartPosition(), l), c = "after") : (h = D.fromPositions(l, d.getEndPosition()), c = "before"), n.push(new zN(a, new D9(h, c), r));
        }
      }
      this.items = n.sort((o, r) => V.compare(o.hint.position, r.hint.position));
    }
    static create(e, t, i, n) {
      return G1(this, void 0, void 0, function* () {
        const o = [], r = e.ordered(t).reverse().map((a) => i.map((l) => G1(this, void 0, void 0, function* () {
          try {
            const c = yield a.provideInlayHints(t, l, n);
            c?.hints.length && o.push([c, a]);
          } catch (c) {
            Xi(c);
          }
        })));
        if (yield Promise.all(r.flat()), n.isCancellationRequested || t.isDisposed())
          throw new Dh();
        return new Pp(i, o, t);
      });
    }
    dispose() {
      this._disposables.dispose();
    }
    static _getRangeAtPosition(e, t) {
      const i = t.lineNumber, n = e.getWordAtPosition(t);
      if (n)
        return new D(i, n.startColumn, i, n.endColumn);
      e.tokenizeIfCheap(i);
      const o = e.getLineTokens(i), r = t.column - 1, a = o.findTokenIndexAtOffset(r);
      let l = o.getStartOffset(a), c = o.getEndOffset(a);
      return c - l === 1 && (l === r && a > 1 ? (l = o.getStartOffset(a - 1), c = o.getEndOffset(a - 1)) : c === r && a < o.getCount() - 1 && (l = o.getStartOffset(a + 1), c = o.getEndOffset(a + 1))), new D(i, l + 1, i, c + 1);
    }
  }
  function Gse(s) {
    return Ee.from({
      scheme: ze.command,
      path: s.id,
      query: s.arguments && encodeURIComponent(JSON.stringify(s.arguments))
    }).toString();
  }
  var Im = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function Zse(s, e, t, i) {
    var n;
    return Im(this, void 0, void 0, function* () {
      const o = s.get(fs), r = s.get(Fc), a = s.get(wi), l = s.get(et), c = s.get(yi);
      if (yield i.item.resolve(Je.None), !i.part.location)
        return;
      const d = i.part.location, h = [], u = new Set(qs.getMenuItems(A.EditorContext).map((g) => yu(g) ? g.command.id : ""));
      for (const g of Dd.getEditorActions())
        g instanceof jh && u.has(g.id) && h.push(new ks(g.id, g.label, void 0, !0, () => Im(this, void 0, void 0, function* () {
          const _ = yield o.createModelReference(d.uri);
          try {
            yield l.invokeFunction(g.run.bind(g), e, new Dp(_.object.textEditorModel, D.getStartPosition(d.range)));
          } finally {
            _.dispose();
          }
        })));
      if (i.part.command) {
        const { command: g } = i.part;
        h.push(new mo()), h.push(new ks(g.id, g.title, void 0, !0, () => Im(this, void 0, void 0, function* () {
          var _;
          try {
            yield a.executeCommand(g.id, ...(_ = g.arguments) !== null && _ !== void 0 ? _ : []);
          } catch (b) {
            c.notify({
              severity: IF.Error,
              source: i.item.provider.displayName,
              message: b
            });
          }
        })));
      }
      const f = e.getOption(115);
      r.showContextMenu({
        domForShadowRoot: f && (n = e.getDomNode()) !== null && n !== void 0 ? n : void 0,
        getAnchor: () => {
          const g = mn(t);
          return { x: g.left, y: g.top + g.height + 8 };
        },
        getActions: () => h,
        onHide: () => {
          e.focus();
        },
        autoSelectFirstItem: !0
      });
    });
  }
  function Yse(s, e, t, i) {
    return Im(this, void 0, void 0, function* () {
      const o = yield s.get(fs).createModelReference(i.uri);
      yield t.invokeWithinContext((r) => Im(this, void 0, void 0, function* () {
        const a = e.hasSideBySideModifier, l = r.get(Fe), c = us.inPeekEditor.getValue(l), d = !a && t.getOption(78) && !c;
        return new k_({ openToSide: a, openInPeek: d, muteMessage: !0 }, { alias: "", label: "", id: "", precondition: void 0 }).run(r, t, { model: o.object.textEditorModel, position: D.getStartPosition(i.range) });
      })), o.dispose();
    });
  }
  var Xse = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, hu = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, vu = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Z1 {
    constructor() {
      this._entries = new Wc(50);
    }
    get(e) {
      const t = Z1._key(e);
      return this._entries.get(t);
    }
    set(e, t) {
      const i = Z1._key(e);
      this._entries.set(i, t);
    }
    static _key(e) {
      return `${e.uri.toString()}/${e.getVersionId()}`;
    }
  }
  const x9 = st("IInlayHintsCache");
  ht(x9, Z1, !0);
  class eD {
    constructor(e, t) {
      this.item = e, this.index = t;
    }
    get part() {
      const e = this.item.hint.label;
      return typeof e == "string" ? { label: e } : e[this.index];
    }
  }
  class Qse {
    constructor(e, t) {
      this.part = e, this.hasTriggerModifier = t;
    }
  }
  let mh = class tD {
    constructor(e, t, i, n, o, r, a) {
      this._editor = e, this._languageFeaturesService = t, this._inlayHintsCache = n, this._commandService = o, this._notificationService = r, this._instaService = a, this._disposables = new te(), this._sessionDisposables = new te(), this._decorationsMetadata = /* @__PURE__ */ new Map(), this._ruleFactory = new c_(this._editor), this._debounceInfo = i.for(t.inlayHintsProvider, "InlayHint", { min: 25 }), this._disposables.add(t.inlayHintsProvider.onDidChange(() => this._update())), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((l) => {
        l.hasChanged(127) && this._update();
      })), this._update();
    }
    static get(e) {
      var t;
      return (t = e.getContribution(tD.ID)) !== null && t !== void 0 ? t : void 0;
    }
    dispose() {
      this._sessionDisposables.dispose(), this._removeAllDecorations(), this._disposables.dispose();
    }
    _update() {
      if (this._sessionDisposables.clear(), this._removeAllDecorations(), !this._editor.getOption(127).enabled)
        return;
      const e = this._editor.getModel();
      if (!e || !this._languageFeaturesService.inlayHintsProvider.has(e))
        return;
      const t = this._inlayHintsCache.get(e);
      t && this._updateHintsDecorators([e.getFullModelRange()], t), this._sessionDisposables.add(qe(() => {
        e.isDisposed() || this._cacheHintsForFastRestore(e);
      }));
      let i, n = /* @__PURE__ */ new Set();
      const o = new It(() => vu(this, void 0, void 0, function* () {
        const r = Date.now();
        i?.dispose(!0), i = new bn();
        const a = e.onWillDispose(() => i?.cancel());
        try {
          const l = i.token, c = yield Pp.create(this._languageFeaturesService.inlayHintsProvider, e, this._getHintsRanges(), l);
          if (o.delay = this._debounceInfo.update(e, Date.now() - r), l.isCancellationRequested) {
            c.dispose();
            return;
          }
          for (const d of c.provider)
            typeof d.onDidChangeInlayHints == "function" && !n.has(d) && (n.add(d), this._sessionDisposables.add(d.onDidChangeInlayHints(() => {
              o.isScheduled() || o.schedule();
            })));
          this._sessionDisposables.add(c), this._updateHintsDecorators(c.ranges, c.items), this._cacheHintsForFastRestore(e);
        } catch (l) {
          We(l);
        } finally {
          i.dispose(), a.dispose();
        }
      }), this._debounceInfo.get(e));
      this._sessionDisposables.add(o), this._sessionDisposables.add(qe(() => i?.dispose(!0))), o.schedule(0), this._sessionDisposables.add(this._editor.onDidScrollChange((r) => {
        (r.scrollTopChanged || !o.isScheduled()) && o.schedule();
      })), this._sessionDisposables.add(this._editor.onDidChangeModelContent((r) => {
        const a = Math.max(o.delay, 1250);
        o.schedule(a);
      })), this._sessionDisposables.add(this._installLinkGesture()), this._sessionDisposables.add(this._installDblClickGesture()), this._sessionDisposables.add(this._installContextMenu());
    }
    _installLinkGesture() {
      const e = new te(), t = e.add(new iN(this._editor)), i = new te();
      return e.add(i), e.add(t.onMouseMoveOrRelevantKeyDown((n) => {
        const [o] = n, r = this._getInlayHintLabelPart(o), a = this._editor.getModel();
        if (!r || !a) {
          i.clear();
          return;
        }
        const l = new bn();
        i.add(qe(() => l.dispose(!0))), r.item.resolve(l.token), this._activeInlayHintPart = r.part.command || r.part.location ? new Qse(r, o.hasTriggerModifier) : void 0;
        const c = r.item.hint.position.lineNumber, d = new D(c, 1, c, a.getLineMaxColumn(c)), h = /* @__PURE__ */ new Set();
        for (const u of this._decorationsMetadata.values())
          d.containsRange(u.item.anchor.range) && h.add(u.item);
        this._updateHintsDecorators([d], Array.from(h)), i.add(qe(() => {
          this._activeInlayHintPart = void 0, this._updateHintsDecorators([d], Array.from(h));
        }));
      })), e.add(t.onCancel(() => i.clear())), e.add(t.onExecute((n) => vu(this, void 0, void 0, function* () {
        const o = this._getInlayHintLabelPart(n);
        if (o) {
          const r = o.part;
          r.location ? this._instaService.invokeFunction(Yse, n, this._editor, r.location) : LL.is(r.command) && (yield this._invokeCommand(r.command, o.item));
        }
      }))), e;
    }
    _installDblClickGesture() {
      return this._editor.onMouseUp((e) => vu(this, void 0, void 0, function* () {
        if (e.event.detail !== 2)
          return;
        const t = this._getInlayHintLabelPart(e);
        !t || (e.event.preventDefault(), yield t.item.resolve(Je.None), t.item.hint.command && (yield this._invokeCommand(t.item.hint.command, t.item)));
      }));
    }
    _installContextMenu() {
      return this._editor.onContextMenu((e) => vu(this, void 0, void 0, function* () {
        if (!(e.event.target instanceof HTMLElement))
          return;
        const t = this._getInlayHintLabelPart(e);
        t && (yield this._instaService.invokeFunction(Zse, this._editor, e.event.target, t));
      }));
    }
    _getInlayHintLabelPart(e) {
      var t;
      if (e.target.type !== 6)
        return;
      const i = (t = e.target.detail.injectedText) === null || t === void 0 ? void 0 : t.options;
      if (i instanceof th && i?.attachedData instanceof eD)
        return i.attachedData;
    }
    _invokeCommand(e, t) {
      var i;
      return vu(this, void 0, void 0, function* () {
        try {
          yield this._commandService.executeCommand(e.id, ...(i = e.arguments) !== null && i !== void 0 ? i : []);
        } catch (n) {
          this._notificationService.notify({
            severity: IF.Error,
            source: t.provider.displayName,
            message: n
          });
        }
      });
    }
    _cacheHintsForFastRestore(e) {
      const t = /* @__PURE__ */ new Map();
      for (const [i, n] of this._decorationsMetadata) {
        if (t.has(n.item))
          continue;
        let o = n.item;
        const r = e.getDecorationRange(i);
        if (r) {
          const a = new D9(r, n.item.anchor.direction);
          o = n.item.with({ anchor: a });
        }
        t.set(n.item, o);
      }
      this._inlayHintsCache.set(e, Array.from(t.values()));
    }
    _getHintsRanges() {
      const t = this._editor.getModel(), i = this._editor.getVisibleRangesPlusViewportAboveBelow(), n = [];
      for (const o of i.sort(D.compareRangesUsingStarts)) {
        const r = t.validateRange(new D(o.startLineNumber - 30, o.startColumn, o.endLineNumber + 30, o.endColumn));
        n.length === 0 || !D.areIntersectingOrTouching(n[n.length - 1], r) ? n.push(r) : n[n.length - 1] = D.plusRange(n[n.length - 1], r);
      }
      return n;
    }
    _updateHintsDecorators(e, t) {
      var i, n;
      const o = [], r = (f, g, _, b, C) => {
        o.push({
          item: f,
          classNameRef: g,
          decoration: {
            range: f.anchor.range,
            options: {
              description: "InlayHint",
              showIfCollapsed: f.anchor.range.isEmpty(),
              collapseOnReplaceEdit: !f.anchor.range.isEmpty(),
              stickiness: 0,
              [f.anchor.direction]: {
                content: _,
                inlineClassNameAffectsLetterSpacing: !0,
                inlineClassName: g.className,
                cursorStops: b,
                attachedData: C
              }
            }
          }
        });
      }, a = (f, g) => {
        const _ = this._ruleFactory.createClassNameRef({
          width: `${l / 3 | 0}px`,
          display: "inline-block"
        });
        r(f, _, "\u200A", g ? Jr.Right : Jr.None);
      }, { fontSize: l, fontFamily: c } = this._getLayoutInfo(), d = "--code-editorInlayHintsFontFamily";
      this._editor.getContainerDomNode().style.setProperty(d, c);
      for (const f of t) {
        f.hint.paddingLeft && a(f, !1);
        const g = typeof f.hint.label == "string" ? [{ label: f.hint.label }] : f.hint.label;
        for (let _ = 0; _ < g.length; _++) {
          const b = g[_], C = _ === 0, v = _ === g.length - 1, w = {
            fontSize: `${l}px`,
            fontFamily: `var(${d}), ${Fn.fontFamily}`,
            verticalAlign: "middle"
          };
          f.hint.command && (w.cursor = "pointer"), this._fillInColors(w, f.hint), (b.command || b.location) && ((i = this._activeInlayHintPart) === null || i === void 0 ? void 0 : i.part.item) === f && this._activeInlayHintPart.part.index === _ && (w.textDecoration = "underline", this._activeInlayHintPart.hasTriggerModifier && (w.color = ai(sE), w.cursor = "pointer")), C && v ? (w.padding = `1px ${Math.max(1, l / 4) | 0}px`, w.borderRadius = `${l / 4 | 0}px`) : C ? (w.padding = `1px 0 1px ${Math.max(1, l / 4) | 0}px`, w.borderRadius = `${l / 4 | 0}px 0 0 ${l / 4 | 0}px`) : v ? (w.padding = `1px ${Math.max(1, l / 4) | 0}px 1px 0`, w.borderRadius = `0 ${l / 4 | 0}px ${l / 4 | 0}px 0`) : w.padding = "1px 0 1px 0", r(f, this._ruleFactory.createClassNameRef(w), Jse(b.label), v && !f.hint.paddingRight ? Jr.Right : Jr.None, new eD(f, _));
        }
        if (f.hint.paddingRight && a(f, !0), o.length > tD._MAX_DECORATORS)
          break;
      }
      const h = [];
      for (const f of e)
        for (const { id: g } of (n = this._editor.getDecorationsInRange(f)) !== null && n !== void 0 ? n : []) {
          const _ = this._decorationsMetadata.get(g);
          _ && (h.push(g), _.classNameRef.dispose(), this._decorationsMetadata.delete(g));
        }
      const u = this._editor.deltaDecorations(h, o.map((f) => f.decoration));
      for (let f = 0; f < u.length; f++) {
        const g = o[f];
        this._decorationsMetadata.set(u[f], { item: g.item, classNameRef: g.classNameRef });
      }
    }
    _fillInColors(e, t) {
      t.kind === d1.Parameter ? (e.backgroundColor = ai(jz), e.color = ai($z)) : t.kind === d1.Type ? (e.backgroundColor = ai(Uz), e.color = ai(zz)) : (e.backgroundColor = ai(Td), e.color = ai(Nd));
    }
    _getLayoutInfo() {
      const e = this._editor.getOption(127), t = this._editor.getOption(46);
      let i = e.fontSize;
      (!i || i < 5 || i > t) && (i = t * 0.9 | 0);
      const n = e.fontFamily || this._editor.getOption(43);
      return { fontSize: i, fontFamily: n };
    }
    _removeAllDecorations() {
      this._editor.deltaDecorations(Array.from(this._decorationsMetadata.keys()), []);
      for (let e of this._decorationsMetadata.values())
        e.classNameRef.dispose();
      this._decorationsMetadata.clear();
    }
  };
  mh.ID = "editor.contrib.InlayHints";
  mh._MAX_DECORATORS = 1500;
  mh = Xse([
    hu(1, me),
    hu(2, Io),
    hu(3, x9),
    hu(4, wi),
    hu(5, yi),
    hu(6, et)
  ], mh);
  function Jse(s) {
    const e = "\xA0";
    return s.replace(/[ \t]/g, e);
  }
  lt.registerCommand("_executeInlayHintProvider", (s, ...e) => vu(void 0, void 0, void 0, function* () {
    const [t, i] = e;
    Nt(Ee.isUri(t)), Nt(D.isIRange(i));
    const { inlayHintsProvider: n } = s.get(me), o = yield s.get(fs).createModelReference(t);
    try {
      const r = yield Pp.create(n, o.object.textEditorModel, [D.lift(i)], Je.None), a = r.items.map((l) => l.hint);
      return setTimeout(() => r.dispose(), 0), a;
    } finally {
      o.dispose();
    }
  }));
  var eoe = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Pg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, iR = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, toe = globalThis && globalThis.__asyncValues || function(s) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = s[Symbol.asyncIterator], t;
    return e ? e.call(s) : (s = typeof __values == "function" ? __values(s) : s[Symbol.iterator](), t = {}, i("next"), i("throw"), i("return"), t[Symbol.asyncIterator] = function() {
      return this;
    }, t);
    function i(o) {
      t[o] = s[o] && function(r) {
        return new Promise(function(a, l) {
          r = s[o](r), n(a, l, r.done, r.value);
        });
      };
    }
    function n(o, r, a, l) {
      Promise.resolve(l).then(function(c) {
        o({ value: c, done: a });
      }, r);
    }
  };
  class nR extends C0 {
    constructor(e, t) {
      super(10, t, e.item.anchor.range), this.part = e;
    }
  }
  let iD = class extends $1 {
    constructor(e, t, i, n, o, r) {
      super(e, t, i, n, r), this._resolverService = o, this.hoverOrdinal = 6;
    }
    suggestHoverAnchor(e) {
      var t;
      if (!mh.get(this._editor) || e.target.type !== 6)
        return null;
      const n = (t = e.target.detail.injectedText) === null || t === void 0 ? void 0 : t.options;
      return n instanceof th && n.attachedData instanceof eD ? new nR(n.attachedData, this) : null;
    }
    computeSync() {
      return [];
    }
    computeAsync(e, t, i) {
      return e instanceof nR ? new vi((n) => iR(this, void 0, void 0, function* () {
        var o, r;
        const { part: a } = e;
        if (yield a.item.resolve(i), i.isCancellationRequested)
          return;
        let l;
        typeof a.item.hint.tooltip == "string" ? l = new Us().appendText(a.item.hint.tooltip) : a.item.hint.tooltip && (l = a.item.hint.tooltip), l && n.emitOne(new nl(this, e.range, [l], 0));
        let c;
        if (typeof a.part.tooltip == "string" ? c = new Us().appendText(a.part.tooltip) : a.part.tooltip && (c = a.part.tooltip), c && n.emitOne(new nl(this, e.range, [c], 1)), a.part.location || a.part.command) {
          let f;
          const _ = this._editor.getOption(70) === "altKey" ? Ye ? m("links.navigate.kb.meta.mac", "cmd + click") : m("links.navigate.kb.meta", "ctrl + click") : Ye ? m("links.navigate.kb.alt.mac", "option + click") : m("links.navigate.kb.alt", "alt + click");
          a.part.location && a.part.command ? f = new Us().appendText(m("hint.defAndCommand", "Go to Definition ({0}), right click for more", _)) : a.part.location ? f = new Us().appendText(m("hint.def", "Go to Definition ({0})", _)) : a.part.command && (f = new Us(`[${m("hint.cmd", "Execute Command")}](${Gse(a.part.command)} "${a.part.command.title}") (${_})`, { isTrusted: !0 })), f && n.emitOne(new nl(this, e.range, [f], 1e4));
        }
        const d = yield this._resolveInlayHintLabelPartHover(a, i);
        try {
          for (var h = toe(d), u; u = yield h.next(), !u.done; ) {
            let f = u.value;
            n.emitOne(f);
          }
        } catch (f) {
          o = { error: f };
        } finally {
          try {
            u && !u.done && (r = h.return) && (yield r.call(h));
          } finally {
            if (o)
              throw o.error;
          }
        }
      })) : vi.EMPTY;
    }
    _resolveInlayHintLabelPartHover(e, t) {
      return iR(this, void 0, void 0, function* () {
        if (!e.part.location)
          return vi.EMPTY;
        const { uri: i, range: n } = e.part.location, o = yield this._resolverService.createModelReference(i);
        try {
          const r = o.object.textEditorModel;
          return this._languageFeaturesService.hoverProvider.has(r) ? NN(this._languageFeaturesService.hoverProvider, r, new V(n.startLineNumber, n.startColumn), t).filter((a) => !If(a.hover.contents)).map((a) => new nl(this, e.item.anchor.range, a.hover.contents, 2 + a.ordinal)) : vi.EMPTY;
        } finally {
          o.dispose();
        }
      });
    }
  };
  iD = eoe([
    Pg(1, Jt),
    Pg(2, No),
    Pg(3, At),
    Pg(4, fs),
    Pg(5, me)
  ], iD);
  vt(mh.ID, mh);
  Kh.register(iD);
  class ioe {
    constructor(e, t, i) {
      this._editRange = e, this._originalSelection = t, this._text = i;
    }
    getEditOperations(e, t) {
      t.addTrackedEditOperation(this._editRange, this._text);
    }
    computeCursorState(e, t) {
      const n = t.getInverseEditOperations()[0].range;
      return this._originalSelection.isEmpty() ? new ae(n.endLineNumber, Math.min(this._originalSelection.positionColumn, n.endColumn), n.endLineNumber, Math.min(this._originalSelection.positionColumn, n.endColumn)) : new ae(n.endLineNumber, n.endColumn - this._text.length, n.endLineNumber, n.endColumn);
    }
  }
  var noe = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, soe = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Ac = class nD {
    constructor(e, t) {
      this.decorationIds = [], this.editor = e, this.editorWorkerService = t;
    }
    static get(e) {
      return e.getContribution(nD.ID);
    }
    dispose() {
    }
    run(e, t) {
      this.currentRequest && this.currentRequest.cancel();
      const i = this.editor.getSelection(), n = this.editor.getModel();
      if (!n || !i)
        return;
      let o = i;
      if (o.startLineNumber !== o.endLineNumber)
        return;
      const r = new gp(this.editor, 5), a = n.uri;
      return this.editorWorkerService.canNavigateValueSet(a) ? (this.currentRequest = an((l) => this.editorWorkerService.navigateValueSet(a, o, t)), this.currentRequest.then((l) => {
        if (!l || !l.range || !l.value || !r.validate(this.editor))
          return;
        let c = D.lift(l.range), d = l.range, h = l.value.length - (o.endColumn - o.startColumn);
        d = {
          startLineNumber: d.startLineNumber,
          startColumn: d.startColumn,
          endLineNumber: d.endLineNumber,
          endColumn: d.startColumn + l.value.length
        }, h > 1 && (o = new ae(o.startLineNumber, o.startColumn, o.endLineNumber, o.endColumn + h - 1));
        const u = new ioe(c, o, l.value);
        this.editor.pushUndoStop(), this.editor.executeCommand(e, u), this.editor.pushUndoStop(), this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [{
          range: d,
          options: nD.DECORATION
        }]), this.decorationRemover && this.decorationRemover.cancel(), this.decorationRemover = gc(350), this.decorationRemover.then(() => this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [])).catch(We);
      }).catch(We)) : Promise.resolve(void 0);
    }
  };
  Ac.ID = "editor.contrib.inPlaceReplaceController";
  Ac.DECORATION = $e.register({
    description: "in-place-replace",
    className: "valueSetReplacement"
  });
  Ac = noe([
    soe(1, xo)
  ], Ac);
  class ooe extends ge {
    constructor() {
      super({
        id: "editor.action.inPlaceReplace.up",
        label: m("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
        alias: "Replace with Previous Value",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3154,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = Ac.get(t);
      return i ? i.run(this.id, !0) : Promise.resolve(void 0);
    }
  }
  class roe extends ge {
    constructor() {
      super({
        id: "editor.action.inPlaceReplace.down",
        label: m("InPlaceReplaceAction.next.label", "Replace with Next Value"),
        alias: "Replace with Next Value",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3156,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = Ac.get(t);
      return i ? i.run(this.id, !1) : Promise.resolve(void 0);
    }
  }
  vt(Ac.ID, Ac);
  oe(ooe);
  oe(roe);
  Vt((s, e) => {
    const t = s.getColor(W5);
    t && e.addRule(`.monaco-editor.vs .valueSetReplacement { outline: solid 2px ${t}; }`);
  });
  class aoe extends ge {
    constructor() {
      super({
        id: "expandLineSelection",
        label: m("expandLineSelection", "Expand Line Selection"),
        alias: "Expand Line Selection",
        precondition: void 0,
        kbOpts: {
          weight: 0,
          kbExpr: T.textInputFocus,
          primary: 2090
        }
      });
    }
    run(e, t, i) {
      if (i = i || {}, !t.hasModel())
        return;
      const n = t._getViewModel();
      n.model.pushStackElement(), n.setCursorStates(i.source, 3, tn.expandLineSelection(n, n.getCursorStates())), n.revealPrimaryCursor(i.source, !0);
    }
  }
  oe(aoe);
  class loe {
    constructor(e, t) {
      this._selection = e, this._cursors = t, this._selectionId = null;
    }
    getEditOperations(e, t) {
      const i = coe(e, this._cursors);
      for (let n = 0, o = i.length; n < o; n++) {
        const r = i[n];
        t.addEditOperation(r.range, r.text);
      }
      this._selectionId = t.trackSelection(this._selection);
    }
    computeCursorState(e, t) {
      return t.getTrackedSelection(this._selectionId);
    }
  }
  function coe(s, e) {
    e.sort((r, a) => r.lineNumber === a.lineNumber ? r.column - a.column : r.lineNumber - a.lineNumber);
    for (let r = e.length - 2; r >= 0; r--)
      e[r].lineNumber === e[r + 1].lineNumber && e.splice(r, 1);
    const t = [];
    let i = 0, n = 0;
    const o = e.length;
    for (let r = 1, a = s.getLineCount(); r <= a; r++) {
      const l = s.getLineContent(r), c = l.length + 1;
      let d = 0;
      if (n < o && e[n].lineNumber === r && (d = e[n].column, n++, d === c) || l.length === 0)
        continue;
      const h = ia(l);
      let u = 0;
      if (h === -1)
        u = 1;
      else if (h !== l.length - 1)
        u = h + 2;
      else
        continue;
      u = Math.max(d, u), t[i++] = li.delete(new D(r, u, r, c));
    }
    return t;
  }
  class I9 {
    constructor(e, t, i) {
      this._selection = e, this._isCopyingDown = t, this._noop = i || !1, this._selectionDirection = 0, this._selectionId = null, this._startLineNumberDelta = 0, this._endLineNumberDelta = 0;
    }
    getEditOperations(e, t) {
      let i = this._selection;
      this._startLineNumberDelta = 0, this._endLineNumberDelta = 0, i.startLineNumber < i.endLineNumber && i.endColumn === 1 && (this._endLineNumberDelta = 1, i = i.setEndPosition(i.endLineNumber - 1, e.getLineMaxColumn(i.endLineNumber - 1)));
      let n = [];
      for (let r = i.startLineNumber; r <= i.endLineNumber; r++)
        n.push(e.getLineContent(r));
      const o = n.join(`
`);
      o === "" && this._isCopyingDown && (this._startLineNumberDelta++, this._endLineNumberDelta++), this._noop ? t.addEditOperation(new D(i.endLineNumber, e.getLineMaxColumn(i.endLineNumber), i.endLineNumber + 1, 1), i.endLineNumber === e.getLineCount() ? "" : `
`) : this._isCopyingDown ? t.addEditOperation(new D(i.startLineNumber, 1, i.startLineNumber, 1), o + `
`) : t.addEditOperation(new D(i.endLineNumber, e.getLineMaxColumn(i.endLineNumber), i.endLineNumber, e.getLineMaxColumn(i.endLineNumber)), `
` + o), this._selectionId = t.trackSelection(i), this._selectionDirection = this._selection.getDirection();
    }
    computeCursorState(e, t) {
      let i = t.getTrackedSelection(this._selectionId);
      if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
        let n = i.startLineNumber, o = i.startColumn, r = i.endLineNumber, a = i.endColumn;
        this._startLineNumberDelta !== 0 && (n = n + this._startLineNumberDelta, o = 1), this._endLineNumberDelta !== 0 && (r = r + this._endLineNumberDelta, a = 1), i = ae.createWithDirection(n, o, r, a, this._selectionDirection);
      }
      return i;
    }
  }
  class doe {
    constructor(e, t, i) {
      this._selection = e, this._isMovingDown = t, this._autoIndent = i, this._selectionId = null, this._moveEndLineSelectionShrink = !1;
    }
    getEditOperations(e, t) {
      let i = e.getLineCount();
      if (this._isMovingDown && this._selection.endLineNumber === i) {
        this._selectionId = t.trackSelection(this._selection);
        return;
      }
      if (!this._isMovingDown && this._selection.startLineNumber === 1) {
        this._selectionId = t.trackSelection(this._selection);
        return;
      }
      this._moveEndPositionDown = !1;
      let n = this._selection;
      n.startLineNumber < n.endLineNumber && n.endColumn === 1 && (this._moveEndPositionDown = !0, n = n.setEndPosition(n.endLineNumber - 1, e.getLineMaxColumn(n.endLineNumber - 1)));
      const { tabSize: o, indentSize: r, insertSpaces: a } = e.getOptions();
      let l = this.buildIndentConverter(o, r, a), c = {
        getLineTokens: (d) => e.getLineTokens(d),
        getLanguageId: () => e.getLanguageId(),
        getLanguageIdAtPosition: (d, h) => e.getLanguageIdAtPosition(d, h),
        getLineContent: null
      };
      if (n.startLineNumber === n.endLineNumber && e.getLineMaxColumn(n.startLineNumber) === 1) {
        let d = n.startLineNumber, h = this._isMovingDown ? d + 1 : d - 1;
        e.getLineMaxColumn(h) === 1 ? t.addEditOperation(new D(1, 1, 1, 1), null) : (t.addEditOperation(new D(d, 1, d, 1), e.getLineContent(h)), t.addEditOperation(new D(h, 1, h, e.getLineMaxColumn(h)), null)), n = new ae(h, 1, h, 1);
      } else {
        let d, h;
        if (this._isMovingDown) {
          d = n.endLineNumber + 1, h = e.getLineContent(d), t.addEditOperation(new D(d - 1, e.getLineMaxColumn(d - 1), d, e.getLineMaxColumn(d)), null);
          let u = h;
          if (this.shouldAutoIndent(e, n)) {
            let f = this.matchEnterRule(e, l, o, d, n.startLineNumber - 1);
            if (f !== null) {
              let _ = Dt(e.getLineContent(d)), b = f + bs(_, o);
              u = xm(b, o, a) + this.trimLeft(h);
            } else {
              c.getLineContent = (b) => b === n.startLineNumber ? e.getLineContent(d) : e.getLineContent(b);
              let _ = Di.getGoodIndentForLine(this._autoIndent, c, e.getLanguageIdAtPosition(d, 1), n.startLineNumber, l);
              if (_ !== null) {
                let b = Dt(e.getLineContent(d)), C = bs(_, o), v = bs(b, o);
                C !== v && (u = xm(C, o, a) + this.trimLeft(h));
              }
            }
            t.addEditOperation(new D(n.startLineNumber, 1, n.startLineNumber, 1), u + `
`);
            let g = this.matchEnterRuleMovingDown(e, l, o, n.startLineNumber, d, u);
            if (g !== null)
              g !== 0 && this.getIndentEditsOfMovingBlock(e, t, n, o, a, g);
            else {
              c.getLineContent = (b) => b === n.startLineNumber ? u : b >= n.startLineNumber + 1 && b <= n.endLineNumber + 1 ? e.getLineContent(b - 1) : e.getLineContent(b);
              let _ = Di.getGoodIndentForLine(this._autoIndent, c, e.getLanguageIdAtPosition(d, 1), n.startLineNumber + 1, l);
              if (_ !== null) {
                const b = Dt(e.getLineContent(n.startLineNumber)), C = bs(_, o), v = bs(b, o);
                if (C !== v) {
                  const w = C - v;
                  this.getIndentEditsOfMovingBlock(e, t, n, o, a, w);
                }
              }
            }
          } else
            t.addEditOperation(new D(n.startLineNumber, 1, n.startLineNumber, 1), u + `
`);
        } else if (d = n.startLineNumber - 1, h = e.getLineContent(d), t.addEditOperation(new D(d, 1, d + 1, 1), null), t.addEditOperation(new D(n.endLineNumber, e.getLineMaxColumn(n.endLineNumber), n.endLineNumber, e.getLineMaxColumn(n.endLineNumber)), `
` + h), this.shouldAutoIndent(e, n)) {
          c.getLineContent = (f) => f === d ? e.getLineContent(n.startLineNumber) : e.getLineContent(f);
          let u = this.matchEnterRule(e, l, o, n.startLineNumber, n.startLineNumber - 2);
          if (u !== null)
            u !== 0 && this.getIndentEditsOfMovingBlock(e, t, n, o, a, u);
          else {
            let f = Di.getGoodIndentForLine(this._autoIndent, c, e.getLanguageIdAtPosition(n.startLineNumber, 1), d, l);
            if (f !== null) {
              let g = Dt(e.getLineContent(n.startLineNumber)), _ = bs(f, o), b = bs(g, o);
              if (_ !== b) {
                let C = _ - b;
                this.getIndentEditsOfMovingBlock(e, t, n, o, a, C);
              }
            }
          }
        }
      }
      this._selectionId = t.trackSelection(n);
    }
    buildIndentConverter(e, t, i) {
      return {
        shiftIndent: (n) => Hs.shiftIndent(n, n.length + 1, e, t, i),
        unshiftIndent: (n) => Hs.unshiftIndent(n, n.length + 1, e, t, i)
      };
    }
    parseEnterResult(e, t, i, n, o) {
      if (o) {
        let r = o.indentation;
        o.indentAction === _i.None || o.indentAction === _i.Indent ? r = o.indentation + o.appendText : o.indentAction === _i.IndentOutdent ? r = o.indentation : o.indentAction === _i.Outdent && (r = t.unshiftIndent(o.indentation) + o.appendText);
        let a = e.getLineContent(n);
        if (this.trimLeft(a).indexOf(this.trimLeft(r)) >= 0) {
          let l = Dt(e.getLineContent(n)), c = Dt(r), d = Di.getIndentMetadata(e, n);
          d !== null && d & 2 && (c = t.unshiftIndent(c));
          let h = bs(c, i), u = bs(l, i);
          return h - u;
        }
      }
      return null;
    }
    matchEnterRuleMovingDown(e, t, i, n, o, r) {
      if (ia(r) >= 0) {
        let a = e.getLineMaxColumn(o), l = Di.getEnterAction(this._autoIndent, e, new D(o, a, o, a));
        return this.parseEnterResult(e, t, i, n, l);
      } else {
        let a = n - 1;
        for (; a >= 1; ) {
          let d = e.getLineContent(a);
          if (ia(d) >= 0)
            break;
          a--;
        }
        if (a < 1 || n > e.getLineCount())
          return null;
        let l = e.getLineMaxColumn(a), c = Di.getEnterAction(this._autoIndent, e, new D(a, l, a, l));
        return this.parseEnterResult(e, t, i, n, c);
      }
    }
    matchEnterRule(e, t, i, n, o, r) {
      let a = o;
      for (; a >= 1; ) {
        let d;
        if (a === o && r !== void 0 ? d = r : d = e.getLineContent(a), ia(d) >= 0)
          break;
        a--;
      }
      if (a < 1 || n > e.getLineCount())
        return null;
      let l = e.getLineMaxColumn(a), c = Di.getEnterAction(this._autoIndent, e, new D(a, l, a, l));
      return this.parseEnterResult(e, t, i, n, c);
    }
    trimLeft(e) {
      return e.replace(/^\s+/, "");
    }
    shouldAutoIndent(e, t) {
      if (this._autoIndent < 4 || !e.isCheapToTokenize(t.startLineNumber))
        return !1;
      let i = e.getLanguageIdAtPosition(t.startLineNumber, 1), n = e.getLanguageIdAtPosition(t.endLineNumber, 1);
      return !(i !== n || Di.getIndentRulesSupport(i) === null);
    }
    getIndentEditsOfMovingBlock(e, t, i, n, o, r) {
      for (let a = i.startLineNumber; a <= i.endLineNumber; a++) {
        let l = e.getLineContent(a), c = Dt(l), h = bs(c, n) + r, u = xm(h, n, o);
        u !== c && (t.addEditOperation(new D(a, 1, a, c.length + 1), u), a === i.endLineNumber && i.endColumn <= c.length + 1 && u === "" && (this._moveEndLineSelectionShrink = !0));
      }
    }
    computeCursorState(e, t) {
      let i = t.getTrackedSelection(this._selectionId);
      return this._moveEndPositionDown && (i = i.setEndPosition(i.endLineNumber + 1, 1)), this._moveEndLineSelectionShrink && i.startLineNumber < i.endLineNumber && (i = i.setEndPosition(i.endLineNumber, 2)), i;
    }
  }
  class dc {
    constructor(e, t) {
      this.selection = e, this.descending = t, this.selectionId = null;
    }
    static getCollator() {
      return dc._COLLATOR || (dc._COLLATOR = new Intl.Collator()), dc._COLLATOR;
    }
    getEditOperations(e, t) {
      let i = hoe(e, this.selection, this.descending);
      i && t.addEditOperation(i.range, i.text), this.selectionId = t.trackSelection(this.selection);
    }
    computeCursorState(e, t) {
      return t.getTrackedSelection(this.selectionId);
    }
    static canRun(e, t, i) {
      if (e === null)
        return !1;
      let n = E9(e, t, i);
      if (!n)
        return !1;
      for (let o = 0, r = n.before.length; o < r; o++)
        if (n.before[o] !== n.after[o])
          return !0;
      return !1;
    }
  }
  dc._COLLATOR = null;
  function E9(s, e, t) {
    let i = e.startLineNumber, n = e.endLineNumber;
    if (e.endColumn === 1 && n--, i >= n)
      return null;
    let o = [];
    for (let a = i; a <= n; a++)
      o.push(s.getLineContent(a));
    let r = o.slice(0);
    return r.sort(dc.getCollator().compare), t === !0 && (r = r.reverse()), {
      startLineNumber: i,
      endLineNumber: n,
      before: o,
      after: r
    };
  }
  function hoe(s, e, t) {
    let i = E9(s, e, t);
    return i ? li.replace(new D(i.startLineNumber, 1, i.endLineNumber, s.getLineMaxColumn(i.endLineNumber)), i.after.join(`
`)) : null;
  }
  class N9 extends ge {
    constructor(e, t) {
      super(t), this.down = e;
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      const i = t.getSelections().map((r, a) => ({ selection: r, index: a, ignore: !1 }));
      i.sort((r, a) => D.compareRangesUsingStarts(r.selection, a.selection));
      let n = i[0];
      for (let r = 1; r < i.length; r++) {
        const a = i[r];
        n.selection.endLineNumber === a.selection.startLineNumber && (n.index < a.index ? a.ignore = !0 : (n.ignore = !0, n = a));
      }
      const o = [];
      for (const r of i)
        o.push(new I9(r.selection, this.down, r.ignore));
      t.pushUndoStop(), t.executeCommands(this.id, o), t.pushUndoStop();
    }
  }
  class uoe extends N9 {
    constructor() {
      super(!1, {
        id: "editor.action.copyLinesUpAction",
        label: m("lines.copyUp", "Copy Line Up"),
        alias: "Copy Line Up",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1552,
          linux: { primary: 3600 },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "2_line",
          title: m({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
          order: 1
        }
      });
    }
  }
  class foe extends N9 {
    constructor() {
      super(!0, {
        id: "editor.action.copyLinesDownAction",
        label: m("lines.copyDown", "Copy Line Down"),
        alias: "Copy Line Down",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1554,
          linux: { primary: 3602 },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "2_line",
          title: m({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
          order: 2
        }
      });
    }
  }
  class goe extends ge {
    constructor() {
      super({
        id: "editor.action.duplicateSelection",
        label: m("duplicateSelection", "Duplicate Selection"),
        alias: "Duplicate Selection",
        precondition: T.writable,
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "2_line",
          title: m({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
          order: 5
        }
      });
    }
    run(e, t, i) {
      if (!t.hasModel())
        return;
      const n = [], o = t.getSelections(), r = t.getModel();
      for (const a of o)
        if (a.isEmpty())
          n.push(new I9(a, !0));
        else {
          const l = new ae(a.endLineNumber, a.endColumn, a.endLineNumber, a.endColumn);
          n.push(new DV(l, r.getValueInRange(a)));
        }
      t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop();
    }
  }
  class T9 extends ge {
    constructor(e, t) {
      super(t), this.down = e;
    }
    run(e, t) {
      let i = [], n = t.getSelections() || [];
      const o = t.getOption(9);
      for (const r of n)
        i.push(new doe(r, this.down, o));
      t.pushUndoStop(), t.executeCommands(this.id, i), t.pushUndoStop();
    }
  }
  class moe extends T9 {
    constructor() {
      super(!1, {
        id: "editor.action.moveLinesUpAction",
        label: m("lines.moveUp", "Move Line Up"),
        alias: "Move Line Up",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 528,
          linux: { primary: 528 },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "2_line",
          title: m({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
          order: 3
        }
      });
    }
  }
  class poe extends T9 {
    constructor() {
      super(!0, {
        id: "editor.action.moveLinesDownAction",
        label: m("lines.moveDown", "Move Line Down"),
        alias: "Move Line Down",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 530,
          linux: { primary: 530 },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "2_line",
          title: m({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
          order: 4
        }
      });
    }
  }
  class M9 extends ge {
    constructor(e, t) {
      super(t), this.descending = e;
    }
    run(e, t) {
      const i = t.getSelections() || [];
      for (const o of i)
        if (!dc.canRun(t.getModel(), o, this.descending))
          return;
      let n = [];
      for (let o = 0, r = i.length; o < r; o++)
        n[o] = new dc(i[o], this.descending);
      t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop();
    }
  }
  class _oe extends M9 {
    constructor() {
      super(!1, {
        id: "editor.action.sortLinesAscending",
        label: m("lines.sortAscending", "Sort Lines Ascending"),
        alias: "Sort Lines Ascending",
        precondition: T.writable
      });
    }
  }
  class boe extends M9 {
    constructor() {
      super(!0, {
        id: "editor.action.sortLinesDescending",
        label: m("lines.sortDescending", "Sort Lines Descending"),
        alias: "Sort Lines Descending",
        precondition: T.writable
      });
    }
  }
  class voe extends ge {
    constructor() {
      super({
        id: "editor.action.removeDuplicateLines",
        label: m("lines.deleteDuplicates", "Delete Duplicate Lines"),
        alias: "Delete Duplicate Lines",
        precondition: T.writable
      });
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      let i = t.getModel();
      if (i.getLineCount() === 1 && i.getLineMaxColumn(1) === 1)
        return;
      let n = [], o = [], r = 0;
      for (let a of t.getSelections()) {
        let l = /* @__PURE__ */ new Set(), c = [];
        for (let f = a.startLineNumber; f <= a.endLineNumber; f++) {
          let g = i.getLineContent(f);
          l.has(g) || (c.push(g), l.add(g));
        }
        let d = new ae(a.startLineNumber, 1, a.endLineNumber, i.getLineMaxColumn(a.endLineNumber)), h = a.startLineNumber - r, u = new ae(h, 1, h + c.length - 1, c[c.length - 1].length);
        n.push(li.replace(d, c.join(`
`))), o.push(u), r += a.endLineNumber - a.startLineNumber + 1 - c.length;
      }
      t.pushUndoStop(), t.executeEdits(this.id, n, o), t.pushUndoStop();
    }
  }
  class ew extends ge {
    constructor() {
      super({
        id: ew.ID,
        label: m("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
        alias: "Trim Trailing Whitespace",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: Qi(2089, 2102),
          weight: 100
        }
      });
    }
    run(e, t, i) {
      let n = [];
      i.reason === "auto-save" && (n = (t.getSelections() || []).map((a) => new V(a.positionLineNumber, a.positionColumn)));
      let o = t.getSelection();
      if (o === null)
        return;
      let r = new loe(o, n);
      t.pushUndoStop(), t.executeCommands(this.id, [r]), t.pushUndoStop();
    }
  }
  ew.ID = "editor.action.trimTrailingWhitespace";
  class Coe extends ge {
    constructor() {
      super({
        id: "editor.action.deleteLines",
        label: m("lines.delete", "Delete Line"),
        alias: "Delete Line",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 3113,
          weight: 100
        }
      });
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      let i = this._getLinesToRemove(t), n = t.getModel();
      if (n.getLineCount() === 1 && n.getLineMaxColumn(1) === 1)
        return;
      let o = 0, r = [], a = [];
      for (let l = 0, c = i.length; l < c; l++) {
        const d = i[l];
        let h = d.startLineNumber, u = d.endLineNumber, f = 1, g = n.getLineMaxColumn(u);
        u < n.getLineCount() ? (u += 1, g = 1) : h > 1 && (h -= 1, f = n.getLineMaxColumn(h)), r.push(li.replace(new ae(h, f, u, g), "")), a.push(new ae(h - o, d.positionColumn, h - o, d.positionColumn)), o += d.endLineNumber - d.startLineNumber + 1;
      }
      t.pushUndoStop(), t.executeEdits(this.id, r, a), t.pushUndoStop();
    }
    _getLinesToRemove(e) {
      let t = e.getSelections().map((o) => {
        let r = o.endLineNumber;
        return o.startLineNumber < o.endLineNumber && o.endColumn === 1 && (r -= 1), {
          startLineNumber: o.startLineNumber,
          selectionStartColumn: o.selectionStartColumn,
          endLineNumber: r,
          positionColumn: o.positionColumn
        };
      });
      t.sort((o, r) => o.startLineNumber === r.startLineNumber ? o.endLineNumber - r.endLineNumber : o.startLineNumber - r.startLineNumber);
      let i = [], n = t[0];
      for (let o = 1; o < t.length; o++)
        n.endLineNumber + 1 >= t[o].startLineNumber ? n.endLineNumber = t[o].endLineNumber : (i.push(n), n = t[o]);
      return i.push(n), i;
    }
  }
  class woe extends ge {
    constructor() {
      super({
        id: "editor.action.indentLines",
        label: m("lines.indent", "Indent Line"),
        alias: "Indent Line",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2137,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = t._getViewModel();
      !i || (t.pushUndoStop(), t.executeCommands(this.id, Gt.indent(i.cursorConfig, t.getModel(), t.getSelections())), t.pushUndoStop());
    }
  }
  class Soe extends ge {
    constructor() {
      super({
        id: "editor.action.outdentLines",
        label: m("lines.outdent", "Outdent Line"),
        alias: "Outdent Line",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2135,
          weight: 100
        }
      });
    }
    run(e, t) {
      ju.Outdent.runEditorCommand(e, t, null);
    }
  }
  class yoe extends ge {
    constructor() {
      super({
        id: "editor.action.insertLineBefore",
        label: m("lines.insertBefore", "Insert Line Above"),
        alias: "Insert Line Above",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3075,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = t._getViewModel();
      !i || (t.pushUndoStop(), t.executeCommands(this.id, Gt.lineInsertBefore(i.cursorConfig, t.getModel(), t.getSelections())));
    }
  }
  class Loe extends ge {
    constructor() {
      super({
        id: "editor.action.insertLineAfter",
        label: m("lines.insertAfter", "Insert Line Below"),
        alias: "Insert Line Below",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2051,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = t._getViewModel();
      !i || (t.pushUndoStop(), t.executeCommands(this.id, Gt.lineInsertAfter(i.cursorConfig, t.getModel(), t.getSelections())));
    }
  }
  class A9 extends ge {
    run(e, t) {
      if (!t.hasModel())
        return;
      const i = t.getSelection();
      let n = this._getRangesToDelete(t), o = [];
      for (let l = 0, c = n.length - 1; l < c; l++) {
        let d = n[l], h = n[l + 1];
        D.intersectRanges(d, h) === null ? o.push(d) : n[l + 1] = D.plusRange(d, h);
      }
      o.push(n[n.length - 1]);
      let r = this._getEndCursorState(i, o), a = o.map((l) => li.replace(l, ""));
      t.pushUndoStop(), t.executeEdits(this.id, a, r), t.pushUndoStop();
    }
  }
  class koe extends A9 {
    constructor() {
      super({
        id: "deleteAllLeft",
        label: m("lines.deleteAllLeft", "Delete All Left"),
        alias: "Delete All Left",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 2049 },
          weight: 100
        }
      });
    }
    _getEndCursorState(e, t) {
      let i = null, n = [], o = 0;
      return t.forEach((r) => {
        let a;
        if (r.endColumn === 1 && o > 0) {
          let l = r.startLineNumber - o;
          a = new ae(l, r.startColumn, l, r.startColumn);
        } else
          a = new ae(r.startLineNumber, r.startColumn, r.startLineNumber, r.startColumn);
        o += r.endLineNumber - r.startLineNumber, r.intersectRanges(e) ? i = a : n.push(a);
      }), i && n.unshift(i), n;
    }
    _getRangesToDelete(e) {
      let t = e.getSelections();
      if (t === null)
        return [];
      let i = t, n = e.getModel();
      return n === null ? [] : (i.sort(D.compareRangesUsingStarts), i = i.map((o) => {
        if (o.isEmpty())
          if (o.startColumn === 1) {
            let r = Math.max(1, o.startLineNumber - 1), a = o.startLineNumber === 1 ? 1 : n.getLineContent(r).length + 1;
            return new D(r, a, o.startLineNumber, 1);
          } else
            return new D(o.startLineNumber, 1, o.startLineNumber, o.startColumn);
        else
          return new D(o.startLineNumber, 1, o.endLineNumber, o.endColumn);
      }), i);
    }
  }
  class Doe extends A9 {
    constructor() {
      super({
        id: "deleteAllRight",
        label: m("lines.deleteAllRight", "Delete All Right"),
        alias: "Delete All Right",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 297, secondary: [2068] },
          weight: 100
        }
      });
    }
    _getEndCursorState(e, t) {
      let i = null, n = [];
      for (let o = 0, r = t.length, a = 0; o < r; o++) {
        let l = t[o], c = new ae(l.startLineNumber - a, l.startColumn, l.startLineNumber - a, l.startColumn);
        l.intersectRanges(e) ? i = c : n.push(c);
      }
      return i && n.unshift(i), n;
    }
    _getRangesToDelete(e) {
      let t = e.getModel();
      if (t === null)
        return [];
      let i = e.getSelections();
      if (i === null)
        return [];
      let n = i.map((o) => {
        if (o.isEmpty()) {
          const r = t.getLineMaxColumn(o.startLineNumber);
          return o.startColumn === r ? new D(o.startLineNumber, o.startColumn, o.startLineNumber + 1, 1) : new D(o.startLineNumber, o.startColumn, o.startLineNumber, r);
        }
        return o;
      });
      return n.sort(D.compareRangesUsingStarts), n;
    }
  }
  class xoe extends ge {
    constructor() {
      super({
        id: "editor.action.joinLines",
        label: m("lines.joinLines", "Join Lines"),
        alias: "Join Lines",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 0,
          mac: { primary: 296 },
          weight: 100
        }
      });
    }
    run(e, t) {
      let i = t.getSelections();
      if (i === null)
        return;
      let n = t.getSelection();
      if (n === null)
        return;
      i.sort(D.compareRangesUsingStarts);
      let o = [], r = i.reduce((u, f) => u.isEmpty() ? u.endLineNumber === f.startLineNumber ? (n.equalsSelection(u) && (n = f), f) : f.startLineNumber > u.endLineNumber + 1 ? (o.push(u), f) : new ae(u.startLineNumber, u.startColumn, f.endLineNumber, f.endColumn) : f.startLineNumber > u.endLineNumber ? (o.push(u), f) : new ae(u.startLineNumber, u.startColumn, f.endLineNumber, f.endColumn));
      o.push(r);
      let a = t.getModel();
      if (a === null)
        return;
      let l = [], c = [], d = n, h = 0;
      for (let u = 0, f = o.length; u < f; u++) {
        let g = o[u], _ = g.startLineNumber, b = 1, C = 0, v, w, S = a.getLineContent(g.endLineNumber).length - g.endColumn;
        if (g.isEmpty() || g.startLineNumber === g.endLineNumber) {
          let y = g.getStartPosition();
          y.lineNumber < a.getLineCount() ? (v = _ + 1, w = a.getLineMaxColumn(v)) : (v = y.lineNumber, w = a.getLineMaxColumn(y.lineNumber));
        } else
          v = g.endLineNumber, w = a.getLineMaxColumn(v);
        let L = a.getLineContent(_);
        for (let y = _ + 1; y <= v; y++) {
          let k = a.getLineContent(y), I = a.getLineFirstNonWhitespaceColumn(y);
          if (I >= 1) {
            let F = !0;
            L === "" && (F = !1), F && (L.charAt(L.length - 1) === " " || L.charAt(L.length - 1) === "	") && (F = !1, L = L.replace(/[\s\uFEFF\xA0]+$/g, " "));
            let R = k.substr(I - 1);
            L += (F ? " " : "") + R, F ? C = R.length + 1 : C = R.length;
          } else
            C = 0;
        }
        let x = new D(_, b, v, w);
        if (!x.isEmpty()) {
          let y;
          g.isEmpty() ? (l.push(li.replace(x, L)), y = new ae(x.startLineNumber - h, L.length - C + 1, _ - h, L.length - C + 1)) : g.startLineNumber === g.endLineNumber ? (l.push(li.replace(x, L)), y = new ae(g.startLineNumber - h, g.startColumn, g.endLineNumber - h, g.endColumn)) : (l.push(li.replace(x, L)), y = new ae(g.startLineNumber - h, g.startColumn, g.startLineNumber - h, L.length - S)), D.intersectRanges(x, n) !== null ? d = y : c.push(y);
        }
        h += x.endLineNumber - x.startLineNumber;
      }
      c.unshift(d), t.pushUndoStop(), t.executeEdits(this.id, l, c), t.pushUndoStop();
    }
  }
  class Ioe extends ge {
    constructor() {
      super({
        id: "editor.action.transpose",
        label: m("editor.transpose", "Transpose characters around the cursor"),
        alias: "Transpose characters around the cursor",
        precondition: T.writable
      });
    }
    run(e, t) {
      let i = t.getSelections();
      if (i === null)
        return;
      let n = t.getModel();
      if (n === null)
        return;
      let o = [];
      for (let r = 0, a = i.length; r < a; r++) {
        let l = i[r];
        if (!l.isEmpty())
          continue;
        let c = l.getStartPosition(), d = n.getLineMaxColumn(c.lineNumber);
        if (c.column >= d) {
          if (c.lineNumber === n.getLineCount())
            continue;
          let h = new D(c.lineNumber, Math.max(1, c.column - 1), c.lineNumber + 1, 1), u = n.getValueInRange(h).split("").reverse().join("");
          o.push(new fn(new ae(c.lineNumber, Math.max(1, c.column - 1), c.lineNumber + 1, 1), u));
        } else {
          let h = new D(c.lineNumber, Math.max(1, c.column - 1), c.lineNumber, c.column + 1), u = n.getValueInRange(h).split("").reverse().join("");
          o.push(new HI(h, u, new ae(c.lineNumber, c.column + 1, c.lineNumber, c.column + 1)));
        }
      }
      t.pushUndoStop(), t.executeCommands(this.id, o), t.pushUndoStop();
    }
  }
  class tw extends ge {
    run(e, t) {
      const i = t.getSelections();
      if (i === null)
        return;
      const n = t.getModel();
      if (n === null)
        return;
      const o = t.getOption(117), r = [];
      for (const a of i)
        if (a.isEmpty()) {
          const l = a.getStartPosition(), c = t.getConfiguredWordAtPosition(l);
          if (!c)
            continue;
          const d = new D(l.lineNumber, c.startColumn, l.lineNumber, c.endColumn), h = n.getValueInRange(d);
          r.push(li.replace(d, this._modifyText(h, o)));
        } else {
          const l = n.getValueInRange(a);
          r.push(li.replace(a, this._modifyText(l, o)));
        }
      t.pushUndoStop(), t.executeEdits(this.id, r), t.pushUndoStop();
    }
  }
  class Eoe extends tw {
    constructor() {
      super({
        id: "editor.action.transformToUppercase",
        label: m("editor.transformToUppercase", "Transform to Uppercase"),
        alias: "Transform to Uppercase",
        precondition: T.writable
      });
    }
    _modifyText(e, t) {
      return e.toLocaleUpperCase();
    }
  }
  class Noe extends tw {
    constructor() {
      super({
        id: "editor.action.transformToLowercase",
        label: m("editor.transformToLowercase", "Transform to Lowercase"),
        alias: "Transform to Lowercase",
        precondition: T.writable
      });
    }
    _modifyText(e, t) {
      return e.toLocaleLowerCase();
    }
  }
  class UN {
    constructor(e, t) {
      this._pattern = e, this._flags = t, this._actual = null, this._evaluated = !1;
    }
    get() {
      if (!this._evaluated) {
        this._evaluated = !0;
        try {
          this._actual = new RegExp(this._pattern, this._flags);
        } catch {
        }
      }
      return this._actual;
    }
    isSupported() {
      return this.get() !== null;
    }
  }
  class Fp extends tw {
    constructor() {
      super({
        id: "editor.action.transformToTitlecase",
        label: m("editor.transformToTitlecase", "Transform to Title Case"),
        alias: "Transform to Title Case",
        precondition: T.writable
      });
    }
    _modifyText(e, t) {
      const i = Fp.titleBoundary.get();
      return i ? e.toLocaleLowerCase().replace(i, (n) => n.toLocaleUpperCase()) : e;
    }
  }
  Fp.titleBoundary = new UN("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
  class hc extends tw {
    constructor() {
      super({
        id: "editor.action.transformToSnakecase",
        label: m("editor.transformToSnakecase", "Transform to Snake Case"),
        alias: "Transform to Snake Case",
        precondition: T.writable
      });
    }
    _modifyText(e, t) {
      const i = hc.caseBoundary.get(), n = hc.singleLetters.get();
      return !i || !n ? e : e.replace(i, "$1_$2").replace(n, "$1_$2$3").toLocaleLowerCase();
    }
  }
  hc.caseBoundary = new UN("(\\p{Ll})(\\p{Lu})", "gmu");
  hc.singleLetters = new UN("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
  oe(uoe);
  oe(foe);
  oe(goe);
  oe(moe);
  oe(poe);
  oe(_oe);
  oe(boe);
  oe(voe);
  oe(ew);
  oe(Coe);
  oe(woe);
  oe(Soe);
  oe(yoe);
  oe(Loe);
  oe(koe);
  oe(Doe);
  oe(xoe);
  oe(Ioe);
  oe(Eoe);
  oe(Noe);
  hc.caseBoundary.isSupported() && hc.singleLetters.isSupported() && oe(hc);
  Fp.titleBoundary.isSupported() && oe(Fp);
  var Toe = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Ab = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, sD = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const R9 = new ue("LinkedEditingInputVisible", !1), O9 = "linked-editing-decoration";
  let Rc = class oD extends z {
    constructor(e, t, i, n, o) {
      super(), this.languageConfigurationService = n, this._localToDispose = this._register(new te()), this._editor = e, this._providers = i.linkedEditingRangeProvider, this._enabled = !1, this._visibleContextKey = R9.bindTo(t), this._debounceInformation = o.for(this._providers, "Linked Editing", { min: 200 }), this._currentDecorations = [], this._languageWordPattern = null, this._currentWordPattern = null, this._ignoreChangeEvent = !1, this._localToDispose = this._register(new te()), this._rangeUpdateTriggerPromise = null, this._rangeSyncTriggerPromise = null, this._currentRequest = null, this._currentRequestPosition = null, this._currentRequestModelVersion = null, this._register(this._editor.onDidChangeModel(() => this.reinitialize(!0))), this._register(this._editor.onDidChangeConfiguration((r) => {
        (r.hasChanged(62) || r.hasChanged(82)) && this.reinitialize(!1);
      })), this._register(this._providers.onDidChange(() => this.reinitialize(!1))), this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(!0))), this.reinitialize(!0);
    }
    static get(e) {
      return e.getContribution(oD.ID);
    }
    reinitialize(e) {
      const t = this._editor.getModel(), i = t !== null && (this._editor.getOption(62) || this._editor.getOption(82)) && this._providers.has(t);
      if (i === this._enabled && !e || (this._enabled = i, this.clearRanges(), this._localToDispose.clear(), !i || t === null))
        return;
      this._localToDispose.add(be.runAndSubscribe(t.onDidChangeLanguageConfiguration, () => {
        this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(t.getLanguageId()).getWordDefinition();
      }));
      const n = new ca(this._debounceInformation.get(t)), o = () => {
        var l;
        this._rangeUpdateTriggerPromise = n.trigger(() => this.updateRanges(), (l = this._debounceDuration) !== null && l !== void 0 ? l : this._debounceInformation.get(t));
      }, r = new ca(0), a = (l) => {
        this._rangeSyncTriggerPromise = r.trigger(() => this._syncRanges(l));
      };
      this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
        o();
      })), this._localToDispose.add(this._editor.onDidChangeModelContent((l) => {
        if (!this._ignoreChangeEvent && this._currentDecorations.length > 0) {
          const c = t.getDecorationRange(this._currentDecorations[0]);
          if (c && l.changes.every((d) => c.intersectRanges(d.range))) {
            a(this._currentDecorations);
            return;
          }
        }
        o();
      })), this._localToDispose.add({
        dispose: () => {
          n.dispose(), r.dispose();
        }
      }), this.updateRanges();
    }
    _syncRanges(e) {
      if (!this._editor.hasModel() || e !== this._currentDecorations || e.length === 0)
        return;
      const t = this._editor.getModel(), i = t.getDecorationRange(e[0]);
      if (!i || i.startLineNumber !== i.endLineNumber)
        return this.clearRanges();
      const n = t.getValueInRange(i);
      if (this._currentWordPattern) {
        const r = n.match(this._currentWordPattern);
        if ((r ? r[0].length : 0) !== n.length)
          return this.clearRanges();
      }
      let o = [];
      for (let r = 1, a = e.length; r < a; r++) {
        const l = t.getDecorationRange(e[r]);
        if (!!l)
          if (l.startLineNumber !== l.endLineNumber)
            o.push({
              range: l,
              text: n
            });
          else {
            let c = t.getValueInRange(l), d = n, h = l.startColumn, u = l.endColumn;
            const f = pf(c, d);
            h += f, c = c.substr(f), d = d.substr(f);
            const g = K0(c, d);
            u -= g, c = c.substr(0, c.length - g), d = d.substr(0, d.length - g), (h !== u || d.length !== 0) && o.push({
              range: new D(l.startLineNumber, h, l.endLineNumber, u),
              text: d
            });
          }
      }
      if (o.length !== 0)
        try {
          this._editor.popUndoStop(), this._ignoreChangeEvent = !0;
          const r = this._editor._getViewModel().getPrevEditOperationType();
          this._editor.executeEdits("linkedEditing", o), this._editor._getViewModel().setPrevEditOperationType(r);
        } finally {
          this._ignoreChangeEvent = !1;
        }
    }
    dispose() {
      this.clearRanges(), super.dispose();
    }
    clearRanges() {
      this._visibleContextKey.set(!1), this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, []), this._currentRequest && (this._currentRequest.cancel(), this._currentRequest = null, this._currentRequestPosition = null);
    }
    updateRanges(e = !1) {
      return sD(this, void 0, void 0, function* () {
        if (!this._editor.hasModel()) {
          this.clearRanges();
          return;
        }
        const t = this._editor.getPosition();
        if (!this._enabled && !e || this._editor.getSelections().length > 1) {
          this.clearRanges();
          return;
        }
        const i = this._editor.getModel(), n = i.getVersionId();
        if (this._currentRequestPosition && this._currentRequestModelVersion === n) {
          if (t.equals(this._currentRequestPosition))
            return;
          if (this._currentDecorations && this._currentDecorations.length > 0) {
            const r = i.getDecorationRange(this._currentDecorations[0]);
            if (r && r.containsPosition(t))
              return;
          }
        }
        this._currentRequestPosition = t, this._currentRequestModelVersion = n;
        const o = an((r) => sD(this, void 0, void 0, function* () {
          try {
            const a = new hs(!1), l = yield P9(this._providers, i, t, r);
            if (this._debounceInformation.update(i, a.elapsed()), o !== this._currentRequest || (this._currentRequest = null, n !== i.getVersionId()))
              return;
            let c = [];
            l?.ranges && (c = l.ranges), this._currentWordPattern = l?.wordPattern || this._languageWordPattern;
            let d = !1;
            for (let u = 0, f = c.length; u < f; u++)
              if (D.containsPosition(c[u], t)) {
                if (d = !0, u !== 0) {
                  const g = c[u];
                  c.splice(u, 1), c.unshift(g);
                }
                break;
              }
            if (!d) {
              this.clearRanges();
              return;
            }
            const h = c.map((u) => ({ range: u, options: oD.DECORATION }));
            this._visibleContextKey.set(!0), this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, h);
          } catch (a) {
            va(a) || We(a), (this._currentRequest === o || !this._currentRequest) && this.clearRanges();
          }
        }));
        return this._currentRequest = o, o;
      });
    }
  };
  Rc.ID = "editor.contrib.linkedEditing";
  Rc.DECORATION = $e.register({
    description: "linked-editing",
    stickiness: 0,
    className: O9
  });
  Rc = Toe([
    Ab(1, Fe),
    Ab(2, me),
    Ab(3, Mn),
    Ab(4, Io)
  ], Rc);
  class Moe extends ge {
    constructor() {
      super({
        id: "editor.action.linkedEditing",
        label: m("linkedEditing.label", "Start Linked Editing"),
        alias: "Start Linked Editing",
        precondition: ce.and(T.writable, T.hasRenameProvider),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3132,
          weight: 100
        }
      });
    }
    runCommand(e, t) {
      const i = e.get(St), [n, o] = Array.isArray(t) && t || [void 0, void 0];
      return Ee.isUri(n) && V.isIPosition(o) ? i.openCodeEditor({ resource: n }, i.getActiveCodeEditor()).then((r) => {
        !r || (r.setPosition(o), r.invokeWithinContext((a) => (this.reportTelemetry(a, r), this.run(a, r))));
      }, We) : super.runCommand(e, t);
    }
    run(e, t) {
      const i = Rc.get(t);
      return i ? Promise.resolve(i.updateRanges(!0)) : Promise.resolve();
    }
  }
  const Aoe = wn.bindToContribution(Rc.get);
  se(new Aoe({
    id: "cancelLinkedEditingInput",
    precondition: R9,
    handler: (s) => s.clearRanges(),
    kbOpts: {
      kbExpr: T.editorTextFocus,
      weight: 100 + 99,
      primary: 9,
      secondary: [1033]
    }
  }));
  function P9(s, e, t, i) {
    const n = s.ordered(e);
    return iP(n.map((o) => () => sD(this, void 0, void 0, function* () {
      try {
        return yield o.provideLinkedEditingRanges(e, t, i);
      } catch (r) {
        Xi(r);
        return;
      }
    })), (o) => !!o && Ds(o?.ranges));
  }
  const Roe = M("editor.linkedEditingBackground", { dark: H.fromHex("#f00").transparent(0.3), light: H.fromHex("#f00").transparent(0.3), hc: H.fromHex("#f00").transparent(0.3) }, m("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
  Vt((s, e) => {
    const t = s.getColor(Roe);
    t && e.addRule(`.monaco-editor .${O9} { background: ${t}; border-left-color: ${t}; }`);
  });
  wa("_executeLinkedEditingProvider", (s, e, t) => {
    const { linkedEditingRangeProvider: i } = s.get(me);
    return P9(i, e, t, Je.None);
  });
  vt(Rc.ID, Rc);
  oe(Moe);
  var F9 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Ooe {
    constructor(e, t) {
      this._link = e, this._provider = t;
    }
    toJSON() {
      return {
        range: this.range,
        url: this.url,
        tooltip: this.tooltip
      };
    }
    get range() {
      return this._link.range;
    }
    get url() {
      return this._link.url;
    }
    get tooltip() {
      return this._link.tooltip;
    }
    resolve(e) {
      return F9(this, void 0, void 0, function* () {
        return this._link.url ? this._link.url : typeof this._provider.resolveLink == "function" ? Promise.resolve(this._provider.resolveLink(this._link, e)).then((t) => (this._link = t || this._link, this._link.url ? this.resolve(e) : Promise.reject(new Error("missing")))) : Promise.reject(new Error("missing"));
      });
    }
  }
  class Y1 {
    constructor(e) {
      this._disposables = new te();
      let t = [];
      for (const [i, n] of e) {
        const o = i.links.map((r) => new Ooe(r, n));
        t = Y1._union(t, o), lI(i) && this._disposables.add(i);
      }
      this.links = t;
    }
    dispose() {
      this._disposables.dispose(), this.links.length = 0;
    }
    static _union(e, t) {
      let i = [], n, o, r, a;
      for (n = 0, r = 0, o = e.length, a = t.length; n < o && r < a; ) {
        const l = e[n], c = t[r];
        if (D.areIntersectingOrTouching(l.range, c.range)) {
          n++;
          continue;
        }
        D.compareRangesUsingStarts(l.range, c.range) < 0 ? (i.push(l), n++) : (i.push(c), r++);
      }
      for (; n < o; n++)
        i.push(e[n]);
      for (; r < a; r++)
        i.push(t[r]);
      return i;
    }
  }
  function B9(s, e, t) {
    const i = [], n = s.ordered(e).reverse().map((o, r) => Promise.resolve(o.provideLinks(e, t)).then((a) => {
      a && (i[r] = [a, o]);
    }, Xi));
    return Promise.all(n).then(() => {
      const o = new Y1(Nh(i));
      return t.isCancellationRequested ? (o.dispose(), new Y1([])) : o;
    });
  }
  lt.registerCommand("_executeLinkProvider", (s, ...e) => F9(void 0, void 0, void 0, function* () {
    let [t, i] = e;
    Nt(t instanceof Ee), typeof i != "number" && (i = 0);
    const { linkProvider: n } = s.get(me), o = s.get(Qt).getModel(t);
    if (!o)
      return [];
    const r = yield B9(n, o, Je.None);
    if (!r)
      return [];
    for (let l = 0; l < Math.min(i, r.links.length); l++)
      yield r.links[l].resolve(Je.None);
    const a = r.links.slice(0);
    return r.dispose(), a;
  }));
  var Poe = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Rb = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Foe = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Bf = class W9 extends z {
    constructor(e, t, i, n, o) {
      super(), this.editor = e, this.openerService = t, this.notificationService = i, this.languageFeaturesService = n, this.providers = this.languageFeaturesService.linkProvider, this.debounceInformation = o.for(this.providers, "Links", { min: 1e3, max: 4e3 }), this.computeLinks = this._register(new It(() => this.computeLinksNow(), 1e3)), this.computePromise = null, this.activeLinksList = null, this.currentOccurrences = {}, this.activeLinkDecorationId = null;
      const r = this._register(new iN(e));
      this._register(r.onMouseMoveOrRelevantKeyDown(([a, l]) => {
        this._onEditorMouseMove(a, l);
      })), this._register(r.onExecute((a) => {
        this.onEditorMouseUp(a);
      })), this._register(r.onCancel((a) => {
        this.cleanUpActiveLinkDecoration();
      })), this._register(e.onDidChangeConfiguration((a) => {
        !a.hasChanged(63) || (this.updateDecorations([]), this.stop(), this.computeLinks.schedule(0));
      })), this._register(e.onDidChangeModelContent((a) => {
        !this.editor.hasModel() || this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
      })), this._register(e.onDidChangeModel((a) => {
        this.currentOccurrences = {}, this.activeLinkDecorationId = null, this.stop(), this.computeLinks.schedule(0);
      })), this._register(e.onDidChangeModelLanguage((a) => {
        this.stop(), this.computeLinks.schedule(0);
      })), this._register(this.providers.onDidChange((a) => {
        this.stop(), this.computeLinks.schedule(0);
      })), this.computeLinks.schedule(0);
    }
    static get(e) {
      return e.getContribution(W9.ID);
    }
    computeLinksNow() {
      return Foe(this, void 0, void 0, function* () {
        if (!this.editor.hasModel() || !this.editor.getOption(63))
          return;
        const e = this.editor.getModel();
        if (!!this.providers.has(e)) {
          this.activeLinksList && (this.activeLinksList.dispose(), this.activeLinksList = null), this.computePromise = an((t) => B9(this.providers, e, t));
          try {
            const t = new hs(!1);
            if (this.activeLinksList = yield this.computePromise, this.debounceInformation.update(e, t.elapsed()), e.isDisposed())
              return;
            this.updateDecorations(this.activeLinksList.links);
          } catch (t) {
            We(t);
          } finally {
            this.computePromise = null;
          }
        }
      });
    }
    updateDecorations(e) {
      const t = this.editor.getOption(70) === "altKey", i = [], n = Object.keys(this.currentOccurrences);
      for (const a of n) {
        const l = this.currentOccurrences[a];
        i.push(l.decorationId);
      }
      const o = [];
      if (e)
        for (const a of e)
          o.push(of.decoration(a, t));
      const r = this.editor.deltaDecorations(i, o);
      this.currentOccurrences = {}, this.activeLinkDecorationId = null;
      for (let a = 0, l = r.length; a < l; a++) {
        const c = new of(e[a], r[a]);
        this.currentOccurrences[c.decorationId] = c;
      }
    }
    _onEditorMouseMove(e, t) {
      const i = this.editor.getOption(70) === "altKey";
      if (this.isEnabled(e, t)) {
        this.cleanUpActiveLinkDecoration();
        const n = this.getLinkOccurrence(e.target.position);
        n && this.editor.changeDecorations((o) => {
          n.activate(o, i), this.activeLinkDecorationId = n.decorationId;
        });
      } else
        this.cleanUpActiveLinkDecoration();
    }
    cleanUpActiveLinkDecoration() {
      const e = this.editor.getOption(70) === "altKey";
      if (this.activeLinkDecorationId) {
        const t = this.currentOccurrences[this.activeLinkDecorationId];
        t && this.editor.changeDecorations((i) => {
          t.deactivate(i, e);
        }), this.activeLinkDecorationId = null;
      }
    }
    onEditorMouseUp(e) {
      if (!this.isEnabled(e))
        return;
      const t = this.getLinkOccurrence(e.target.position);
      !t || this.openLinkOccurrence(t, e.hasSideBySideModifier, !0);
    }
    openLinkOccurrence(e, t, i = !1) {
      if (!this.openerService)
        return;
      const { link: n } = e;
      n.resolve(Je.None).then((o) => {
        if (typeof o == "string" && this.editor.hasModel()) {
          const r = this.editor.getModel().uri;
          if (r.scheme === ze.file && o.startsWith(`${ze.file}:`)) {
            const a = Ee.parse(o);
            if (a.scheme === ze.file) {
              const l = Ar(a);
              let c = null;
              l.startsWith("/./") ? c = `.${l.substr(1)}` : l.startsWith("//./") && (c = `.${l.substr(2)}`), c && (o = Dq(r, c));
            }
          }
        }
        return this.openerService.open(o, { openToSide: t, fromUserGesture: i, allowContributedOpeners: !0, allowCommands: !0 });
      }, (o) => {
        const r = o instanceof Error ? o.message : o;
        r === "invalid" ? this.notificationService.warn(m("invalid.url", "Failed to open this link because it is not well-formed: {0}", n.url.toString())) : r === "missing" ? this.notificationService.warn(m("missing.url", "Failed to open this link because its target is missing.")) : We(o);
      });
    }
    getLinkOccurrence(e) {
      if (!this.editor.hasModel() || !e)
        return null;
      const t = this.editor.getModel().getDecorationsInRange({
        startLineNumber: e.lineNumber,
        startColumn: e.column,
        endLineNumber: e.lineNumber,
        endColumn: e.column
      }, 0, !0);
      for (const i of t) {
        const n = this.currentOccurrences[i.id];
        if (n)
          return n;
      }
      return null;
    }
    isEnabled(e, t) {
      return Boolean(e.target.type === 6 && (e.hasTriggerModifier || t && t.keyCodeIsTriggerKey));
    }
    stop() {
      var e;
      this.computeLinks.cancel(), this.activeLinksList && ((e = this.activeLinksList) === null || e === void 0 || e.dispose(), this.activeLinksList = null), this.computePromise && (this.computePromise.cancel(), this.computePromise = null);
    }
    dispose() {
      super.dispose(), this.stop();
    }
  };
  Bf.ID = "editor.linkDetector";
  Bf = Poe([
    Rb(1, No),
    Rb(2, yi),
    Rb(3, me),
    Rb(4, Io)
  ], Bf);
  const sR = {
    general: $e.register({
      description: "detected-link",
      stickiness: 1,
      collapseOnReplaceEdit: !0,
      inlineClassName: "detected-link"
    }),
    active: $e.register({
      description: "detected-link-active",
      stickiness: 1,
      collapseOnReplaceEdit: !0,
      inlineClassName: "detected-link-active"
    })
  };
  class of {
    constructor(e, t) {
      this.link = e, this.decorationId = t;
    }
    static decoration(e, t) {
      return {
        range: e.range,
        options: of._getOptions(e, t, !1)
      };
    }
    static _getOptions(e, t, i) {
      const n = Object.assign({}, i ? sR.active : sR.general);
      return n.hoverMessage = Boe(e, t), n;
    }
    activate(e, t) {
      e.changeDecorationOptions(this.decorationId, of._getOptions(this.link, t, !0));
    }
    deactivate(e, t) {
      e.changeDecorationOptions(this.decorationId, of._getOptions(this.link, t, !1));
    }
  }
  function Boe(s, e) {
    const t = s.url && /^command:/i.test(s.url.toString()), i = s.tooltip ? s.tooltip : t ? m("links.navigate.executeCmd", "Execute command") : m("links.navigate.follow", "Follow link"), n = e ? Ye ? m("links.navigate.kb.meta.mac", "cmd + click") : m("links.navigate.kb.meta", "ctrl + click") : Ye ? m("links.navigate.kb.alt.mac", "option + click") : m("links.navigate.kb.alt", "alt + click");
    if (s.url) {
      let o = "";
      if (/^command:/i.test(s.url.toString())) {
        const a = s.url.toString().match(/^command:([^?#]+)/);
        if (a) {
          const l = a[1];
          o = ` "${m("tooltip.explanation", "Execute command {0}", l)}"`;
        }
      }
      return new Us("", !0).appendMarkdown(`[${i}](${s.url.toString(!0).replace(/ /g, "%20")}${o}) (${n})`);
    } else
      return new Us().appendText(`${i} (${n})`);
  }
  class Woe extends ge {
    constructor() {
      super({
        id: "editor.action.openLink",
        label: m("label", "Open Link"),
        alias: "Open Link",
        precondition: void 0
      });
    }
    run(e, t) {
      const i = Bf.get(t);
      if (!i || !t.hasModel())
        return;
      const n = t.getSelections();
      for (const o of n) {
        const r = i.getLinkOccurrence(o.getEndPosition());
        r && i.openLinkOccurrence(r, !1);
      }
    }
  }
  vt(Bf.ID, Bf);
  oe(Woe);
  Vt((s, e) => {
    const t = s.getColor(sE);
    t && e.addRule(`.monaco-editor .detected-link-active { color: ${t} !important; }`);
  });
  var Voe = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Hoe = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  function hg(s, e) {
    const t = e.filter((i) => !s.find((n) => n.equals(i)));
    if (t.length >= 1) {
      const i = t.map((o) => `line ${o.viewState.position.lineNumber} column ${o.viewState.position.column}`).join(", "), n = t.length === 1 ? m("cursorAdded", "Cursor added: {0}", i) : m("cursorsAdded", "Cursors added: {0}", i);
      U0(n);
    }
  }
  class zoe extends ge {
    constructor() {
      super({
        id: "editor.action.insertCursorAbove",
        label: m("mutlicursor.insertAbove", "Add Cursor Above"),
        alias: "Add Cursor Above",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2576,
          linux: {
            primary: 1552,
            secondary: [3088]
          },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "3_multi",
          title: m({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
          order: 2
        }
      });
    }
    run(e, t, i) {
      if (!t.hasModel())
        return;
      let n = !0;
      i && i.logicalLine === !1 && (n = !1);
      const o = t._getViewModel();
      if (o.cursorConfig.readOnly)
        return;
      o.model.pushStackElement();
      const r = o.getCursorStates();
      o.setCursorStates(i.source, 3, tn.addCursorUp(o, r, n)), o.revealTopMostCursor(i.source), hg(r, o.getCursorStates());
    }
  }
  class Uoe extends ge {
    constructor() {
      super({
        id: "editor.action.insertCursorBelow",
        label: m("mutlicursor.insertBelow", "Add Cursor Below"),
        alias: "Add Cursor Below",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2578,
          linux: {
            primary: 1554,
            secondary: [3090]
          },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "3_multi",
          title: m({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
          order: 3
        }
      });
    }
    run(e, t, i) {
      if (!t.hasModel())
        return;
      let n = !0;
      i && i.logicalLine === !1 && (n = !1);
      const o = t._getViewModel();
      if (o.cursorConfig.readOnly)
        return;
      o.model.pushStackElement();
      const r = o.getCursorStates();
      o.setCursorStates(i.source, 3, tn.addCursorDown(o, r, n)), o.revealBottomMostCursor(i.source), hg(r, o.getCursorStates());
    }
  }
  class $oe extends ge {
    constructor() {
      super({
        id: "editor.action.insertCursorAtEndOfEachLineSelected",
        label: m("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
        alias: "Add Cursors to Line Ends",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1575,
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "3_multi",
          title: m({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
          order: 4
        }
      });
    }
    getCursorsForSelection(e, t, i) {
      if (!e.isEmpty()) {
        for (let n = e.startLineNumber; n < e.endLineNumber; n++) {
          let o = t.getLineMaxColumn(n);
          i.push(new ae(n, o, n, o));
        }
        e.endColumn > 1 && i.push(new ae(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn));
      }
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      const i = t.getModel(), n = t.getSelections(), o = t._getViewModel(), r = o.getCursorStates();
      let a = [];
      n.forEach((l) => this.getCursorsForSelection(l, i, a)), a.length > 0 && t.setSelections(a), hg(r, o.getCursorStates());
    }
  }
  class joe extends ge {
    constructor() {
      super({
        id: "editor.action.addCursorsToBottom",
        label: m("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
        alias: "Add Cursors To Bottom",
        precondition: void 0
      });
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      const i = t.getSelections(), n = t.getModel().getLineCount();
      let o = [];
      for (let l = i[0].startLineNumber; l <= n; l++)
        o.push(new ae(l, i[0].startColumn, l, i[0].endColumn));
      const r = t._getViewModel(), a = r.getCursorStates();
      o.length > 0 && t.setSelections(o), hg(a, r.getCursorStates());
    }
  }
  class Koe extends ge {
    constructor() {
      super({
        id: "editor.action.addCursorsToTop",
        label: m("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
        alias: "Add Cursors To Top",
        precondition: void 0
      });
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      const i = t.getSelections();
      let n = [];
      for (let a = i[0].startLineNumber; a >= 1; a--)
        n.push(new ae(a, i[0].startColumn, a, i[0].endColumn));
      const o = t._getViewModel(), r = o.getCursorStates();
      n.length > 0 && t.setSelections(n), hg(r, o.getCursorStates());
    }
  }
  class Ob {
    constructor(e, t, i) {
      this.selections = e, this.revealRange = t, this.revealScrollType = i;
    }
  }
  class Bp {
    constructor(e, t, i, n, o, r, a) {
      this._editor = e, this.findController = t, this.isDisconnectedFromFindController = i, this.searchText = n, this.wholeWord = o, this.matchCase = r, this.currentMatch = a;
    }
    static create(e, t) {
      if (!e.hasModel())
        return null;
      const i = t.getState();
      if (!e.hasTextFocus() && i.isRevealed && i.searchString.length > 0)
        return new Bp(e, t, !1, i.searchString, i.wholeWord, i.matchCase, null);
      let n = !1, o, r;
      const a = e.getSelections();
      a.length === 1 && a[0].isEmpty() ? (n = !0, o = !0, r = !0) : (o = i.wholeWord, r = i.matchCase);
      const l = e.getSelection();
      let c, d = null;
      if (l.isEmpty()) {
        const h = e.getConfiguredWordAtPosition(l.getStartPosition());
        if (!h)
          return null;
        c = h.word, d = new ae(l.startLineNumber, h.startColumn, l.startLineNumber, h.endColumn);
      } else
        c = e.getModel().getValueInRange(l).replace(/\r\n/g, `
`);
      return new Bp(e, t, n, c, o, r, d);
    }
    addSelectionToNextFindMatch() {
      if (!this._editor.hasModel())
        return null;
      const e = this._getNextMatch();
      if (!e)
        return null;
      const t = this._editor.getSelections();
      return new Ob(t.concat(e), e, 0);
    }
    moveSelectionToNextFindMatch() {
      if (!this._editor.hasModel())
        return null;
      const e = this._getNextMatch();
      if (!e)
        return null;
      const t = this._editor.getSelections();
      return new Ob(t.slice(0, t.length - 1).concat(e), e, 0);
    }
    _getNextMatch() {
      if (!this._editor.hasModel())
        return null;
      if (this.currentMatch) {
        const n = this.currentMatch;
        return this.currentMatch = null, n;
      }
      this.findController.highlightFindOptions();
      const e = this._editor.getSelections(), t = e[e.length - 1], i = this._editor.getModel().findNextMatch(this.searchText, t.getEndPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getOption(117) : null, !1);
      return i ? new ae(i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn) : null;
    }
    addSelectionToPreviousFindMatch() {
      if (!this._editor.hasModel())
        return null;
      const e = this._getPreviousMatch();
      if (!e)
        return null;
      const t = this._editor.getSelections();
      return new Ob(t.concat(e), e, 0);
    }
    moveSelectionToPreviousFindMatch() {
      if (!this._editor.hasModel())
        return null;
      const e = this._getPreviousMatch();
      if (!e)
        return null;
      const t = this._editor.getSelections();
      return new Ob(t.slice(0, t.length - 1).concat(e), e, 0);
    }
    _getPreviousMatch() {
      if (!this._editor.hasModel())
        return null;
      if (this.currentMatch) {
        const n = this.currentMatch;
        return this.currentMatch = null, n;
      }
      this.findController.highlightFindOptions();
      const e = this._editor.getSelections(), t = e[e.length - 1], i = this._editor.getModel().findPreviousMatch(this.searchText, t.getStartPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getOption(117) : null, !1);
      return i ? new ae(i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn) : null;
    }
    selectAll() {
      return this._editor.hasModel() ? (this.findController.highlightFindOptions(), this._editor.getModel().findMatches(this.searchText, !0, !1, this.matchCase, this.wholeWord ? this._editor.getOption(117) : null, !1, 1073741824)) : [];
    }
  }
  class ph extends z {
    constructor(e) {
      super(), this._sessionDispose = this._register(new te()), this._editor = e, this._ignoreSelectionChange = !1, this._session = null;
    }
    static get(e) {
      return e.getContribution(ph.ID);
    }
    dispose() {
      this._endSession(), super.dispose();
    }
    _beginSessionIfNeeded(e) {
      if (!this._session) {
        const t = Bp.create(this._editor, e);
        if (!t)
          return;
        this._session = t;
        const i = { searchString: this._session.searchText };
        this._session.isDisconnectedFromFindController && (i.wholeWordOverride = 1, i.matchCaseOverride = 1, i.isRegexOverride = 2), e.getState().change(i, !1), this._sessionDispose.add(this._editor.onDidChangeCursorSelection((n) => {
          this._ignoreSelectionChange || this._endSession();
        })), this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
          this._endSession();
        })), this._sessionDispose.add(e.getState().onFindReplaceStateChange((n) => {
          (n.matchCase || n.wholeWord) && this._endSession();
        }));
      }
    }
    _endSession() {
      if (this._sessionDispose.clear(), this._session && this._session.isDisconnectedFromFindController) {
        const e = {
          wholeWordOverride: 0,
          matchCaseOverride: 0,
          isRegexOverride: 0
        };
        this._session.findController.getState().change(e, !1);
      }
      this._session = null;
    }
    _setSelections(e) {
      this._ignoreSelectionChange = !0, this._editor.setSelections(e), this._ignoreSelectionChange = !1;
    }
    _expandEmptyToWord(e, t) {
      if (!t.isEmpty())
        return t;
      const i = this._editor.getConfiguredWordAtPosition(t.getStartPosition());
      return i ? new ae(t.startLineNumber, i.startColumn, t.startLineNumber, i.endColumn) : t;
    }
    _applySessionResult(e) {
      !e || (this._setSelections(e.selections), e.revealRange && this._editor.revealRangeInCenterIfOutsideViewport(e.revealRange, e.revealScrollType));
    }
    getSession(e) {
      return this._session;
    }
    addSelectionToNextFindMatch(e) {
      if (!!this._editor.hasModel()) {
        if (!this._session) {
          const t = this._editor.getSelections();
          if (t.length > 1) {
            const n = e.getState().matchCase;
            if (!V9(this._editor.getModel(), t, n)) {
              const r = this._editor.getModel();
              let a = [];
              for (let l = 0, c = t.length; l < c; l++)
                a[l] = this._expandEmptyToWord(r, t[l]);
              this._editor.setSelections(a);
              return;
            }
          }
        }
        this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.addSelectionToNextFindMatch());
      }
    }
    addSelectionToPreviousFindMatch(e) {
      this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
    }
    moveSelectionToNextFindMatch(e) {
      this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.moveSelectionToNextFindMatch());
    }
    moveSelectionToPreviousFindMatch(e) {
      this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
    }
    selectAll(e) {
      if (!this._editor.hasModel())
        return;
      let t = null;
      const i = e.getState();
      if (i.isRevealed && i.searchString.length > 0 && i.isRegex)
        t = this._editor.getModel().findMatches(i.searchString, !0, i.isRegex, i.matchCase, i.wholeWord ? this._editor.getOption(117) : null, !1, 1073741824);
      else {
        if (this._beginSessionIfNeeded(e), !this._session)
          return;
        t = this._session.selectAll();
      }
      if (i.searchScope) {
        const n = i.searchScope;
        let o = [];
        t.forEach((r) => {
          n.forEach((a) => {
            r.range.endLineNumber <= a.endLineNumber && r.range.startLineNumber >= a.startLineNumber && o.push(r);
          });
        }), t = o;
      }
      if (t.length > 0) {
        const n = this._editor.getSelection();
        for (let o = 0, r = t.length; o < r; o++) {
          const a = t[o];
          if (a.range.intersectRanges(n)) {
            t[o] = t[0], t[0] = a;
            break;
          }
        }
        this._setSelections(t.map((o) => new ae(o.range.startLineNumber, o.range.startColumn, o.range.endLineNumber, o.range.endColumn)));
      }
    }
  }
  ph.ID = "editor.contrib.multiCursorController";
  class ug extends ge {
    run(e, t) {
      const i = ph.get(t);
      if (!i)
        return;
      const n = Es.get(t);
      if (!n)
        return;
      const o = t._getViewModel();
      if (o) {
        const r = o.getCursorStates();
        this._run(i, n), hg(r, o.getCursorStates());
      }
    }
  }
  class qoe extends ug {
    constructor() {
      super({
        id: "editor.action.addSelectionToNextFindMatch",
        label: m("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
        alias: "Add Selection To Next Find Match",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 2082,
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "3_multi",
          title: m({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
          order: 5
        }
      });
    }
    _run(e, t) {
      e.addSelectionToNextFindMatch(t);
    }
  }
  class Goe extends ug {
    constructor() {
      super({
        id: "editor.action.addSelectionToPreviousFindMatch",
        label: m("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
        alias: "Add Selection To Previous Find Match",
        precondition: void 0,
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "3_multi",
          title: m({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
          order: 6
        }
      });
    }
    _run(e, t) {
      e.addSelectionToPreviousFindMatch(t);
    }
  }
  class Zoe extends ug {
    constructor() {
      super({
        id: "editor.action.moveSelectionToNextFindMatch",
        label: m("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
        alias: "Move Last Selection To Next Find Match",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: Qi(2089, 2082),
          weight: 100
        }
      });
    }
    _run(e, t) {
      e.moveSelectionToNextFindMatch(t);
    }
  }
  class Yoe extends ug {
    constructor() {
      super({
        id: "editor.action.moveSelectionToPreviousFindMatch",
        label: m("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
        alias: "Move Last Selection To Previous Find Match",
        precondition: void 0
      });
    }
    _run(e, t) {
      e.moveSelectionToPreviousFindMatch(t);
    }
  }
  class Xoe extends ug {
    constructor() {
      super({
        id: "editor.action.selectHighlights",
        label: m("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
        alias: "Select All Occurrences of Find Match",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 3114,
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "3_multi",
          title: m({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
          order: 7
        }
      });
    }
    _run(e, t) {
      e.selectAll(t);
    }
  }
  class Qoe extends ug {
    constructor() {
      super({
        id: "editor.action.changeAll",
        label: m("changeAll.label", "Change All Occurrences"),
        alias: "Change All Occurrences",
        precondition: ce.and(T.writable, T.editorTextFocus),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 2108,
          weight: 100
        },
        contextMenuOpts: {
          group: "1_modification",
          order: 1.2
        }
      });
    }
    _run(e, t) {
      e.selectAll(t);
    }
  }
  class Joe {
    constructor(e, t, i, n, o) {
      this._model = e, this._searchText = t, this._matchCase = i, this._wordSeparators = n, this._modelVersionId = this._model.getVersionId(), this._cachedFindMatches = null, o && this._model === o._model && this._searchText === o._searchText && this._matchCase === o._matchCase && this._wordSeparators === o._wordSeparators && this._modelVersionId === o._modelVersionId && (this._cachedFindMatches = o._cachedFindMatches);
    }
    findMatches() {
      return this._cachedFindMatches === null && (this._cachedFindMatches = this._model.findMatches(this._searchText, !0, !1, this._matchCase, this._wordSeparators, !1).map((e) => e.range), this._cachedFindMatches.sort(D.compareRangesUsingStarts)), this._cachedFindMatches;
    }
  }
  let _h = class k0 extends z {
    constructor(e, t) {
      super(), this._languageFeaturesService = t, this.editor = e, this._isEnabled = e.getOption(97), this.decorations = [], this.updateSoon = this._register(new It(() => this._update(), 300)), this.state = null, this._register(e.onDidChangeConfiguration((n) => {
        this._isEnabled = e.getOption(97);
      })), this._register(e.onDidChangeCursorSelection((n) => {
        !this._isEnabled || (n.selection.isEmpty() ? n.reason === 3 ? (this.state && this._setState(null), this.updateSoon.schedule()) : this._setState(null) : this._update());
      })), this._register(e.onDidChangeModel((n) => {
        this._setState(null);
      })), this._register(e.onDidChangeModelContent((n) => {
        this._isEnabled && this.updateSoon.schedule();
      }));
      const i = Es.get(e);
      i && this._register(i.getState().onFindReplaceStateChange((n) => {
        this._update();
      }));
    }
    _update() {
      this._setState(k0._createState(this.state, this._isEnabled, this.editor));
    }
    static _createState(e, t, i) {
      if (!t || !i.hasModel())
        return null;
      const n = i.getSelection();
      if (n.startLineNumber !== n.endLineNumber)
        return null;
      const o = ph.get(i);
      if (!o)
        return null;
      const r = Es.get(i);
      if (!r)
        return null;
      let a = o.getSession(r);
      if (!a) {
        const d = i.getSelections();
        if (d.length > 1) {
          const u = r.getState().matchCase;
          if (!V9(i.getModel(), d, u))
            return null;
        }
        a = Bp.create(i, r);
      }
      if (!a || a.currentMatch || /^[ \t]+$/.test(a.searchText) || a.searchText.length > 200)
        return null;
      const l = r.getState(), c = l.matchCase;
      if (l.isRevealed) {
        let d = l.searchString;
        c || (d = d.toLowerCase());
        let h = a.searchText;
        if (c || (h = h.toLowerCase()), d === h && a.matchCase === l.matchCase && a.wholeWord === l.wholeWord && !l.isRegex)
          return null;
      }
      return new Joe(i.getModel(), a.searchText, a.matchCase, a.wholeWord ? i.getOption(117) : null, e);
    }
    _setState(e) {
      if (this.state = e, !this.state) {
        this.decorations = this.editor.deltaDecorations(this.decorations, []);
        return;
      }
      if (!this.editor.hasModel())
        return;
      const t = this.editor.getModel();
      if (t.isTooLargeForTokenization())
        return;
      const i = this.state.findMatches(), n = this.editor.getSelections();
      n.sort(D.compareRangesUsingStarts);
      const o = [];
      for (let l = 0, c = 0, d = i.length, h = n.length; l < d; ) {
        const u = i[l];
        if (c >= h)
          o.push(u), l++;
        else {
          const f = D.compareRangesUsingStarts(u, n[c]);
          f < 0 ? ((n[c].isEmpty() || !D.areIntersecting(u, n[c])) && o.push(u), l++) : (f > 0 || l++, c++);
        }
      }
      const r = this._languageFeaturesService.documentHighlightProvider.has(t) && this.editor.getOption(72), a = o.map((l) => ({
        range: l,
        options: r ? k0._SELECTION_HIGHLIGHT : k0._SELECTION_HIGHLIGHT_OVERVIEW
      }));
      this.decorations = this.editor.deltaDecorations(this.decorations, a);
    }
    dispose() {
      this._setState(null), super.dispose();
    }
  };
  _h.ID = "editor.contrib.selectionHighlighter";
  _h._SELECTION_HIGHLIGHT_OVERVIEW = $e.register({
    description: "selection-highlight-overview",
    stickiness: 1,
    className: "selectionHighlight",
    minimap: {
      color: ai(eC),
      position: _o.Inline
    },
    overviewRuler: {
      color: ai(I5),
      position: Lo.Center
    }
  });
  _h._SELECTION_HIGHLIGHT = $e.register({
    description: "selection-highlight",
    stickiness: 1,
    className: "selectionHighlight"
  });
  _h = Voe([
    Hoe(1, me)
  ], _h);
  function V9(s, e, t) {
    const i = oR(s, e[0], !t);
    for (let n = 1, o = e.length; n < o; n++) {
      const r = e[n];
      if (r.isEmpty())
        return !1;
      const a = oR(s, r, !t);
      if (i !== a)
        return !1;
    }
    return !0;
  }
  function oR(s, e, t) {
    const i = s.getValueInRange(e);
    return t ? i.toLowerCase() : i;
  }
  vt(ph.ID, ph);
  vt(_h.ID, _h);
  oe(zoe);
  oe(Uoe);
  oe($oe);
  oe(qoe);
  oe(Goe);
  oe(Zoe);
  oe(Yoe);
  oe(Xoe);
  oe(Qoe);
  oe(joe);
  oe(Koe);
  var H9 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const bh = {
    Visible: new ue("parameterHintsVisible", !1),
    MultipleSignatures: new ue("parameterHintsMultipleSignatures", !1)
  };
  function z9(s, e, t, i, n) {
    return H9(this, void 0, void 0, function* () {
      const o = s.ordered(e);
      for (const r of o)
        try {
          const a = yield r.provideSignatureHelp(e, t, n, i);
          if (a)
            return a;
        } catch (a) {
          Xi(a);
        }
    });
  }
  lt.registerCommand("_executeSignatureHelpProvider", (s, ...e) => H9(void 0, void 0, void 0, function* () {
    const [t, i, n] = e;
    Nt(Ee.isUri(t)), Nt(V.isIPosition(i)), Nt(typeof n == "string" || !n);
    const o = s.get(me), r = yield s.get(fs).createModelReference(t);
    try {
      const a = yield z9(o.signatureHelpProvider, r.object.textEditorModel, V.lift(i), {
        triggerKind: oa.Invoke,
        isRetrigger: !1,
        triggerCharacter: n
      }, Je.None);
      return a ? (setTimeout(() => a.dispose(), 0), a.value) : void 0;
    } finally {
      r.dispose();
    }
  }));
  var ere = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, Wl;
  (function(s) {
    s.Default = { type: 0 };
    class e {
      constructor(n, o) {
        this.request = n, this.previouslyActiveHints = o, this.type = 2;
      }
    }
    s.Pending = e;
    class t {
      constructor(n) {
        this.hints = n, this.type = 1;
      }
    }
    s.Active = t;
  })(Wl || (Wl = {}));
  class iw extends z {
    constructor(e, t, i = iw.DEFAULT_DELAY) {
      super(), this._onChangedHints = this._register(new B()), this.onChangedHints = this._onChangedHints.event, this.triggerOnType = !1, this._state = Wl.Default, this._pendingTriggers = [], this._lastSignatureHelpResult = this._register(new Gn()), this.triggerChars = new Lu(), this.retriggerChars = new Lu(), this.triggerId = 0, this.editor = e, this.providers = t, this.throttledDelayer = new ca(i), this._register(this.editor.onDidBlurEditorWidget(() => this.cancel())), this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange())), this._register(this.editor.onDidChangeModel((n) => this.onModelChanged())), this._register(this.editor.onDidChangeModelLanguage((n) => this.onModelChanged())), this._register(this.editor.onDidChangeCursorSelection((n) => this.onCursorChange(n))), this._register(this.editor.onDidChangeModelContent((n) => this.onModelContentChange())), this._register(this.providers.onDidChange(this.onModelChanged, this)), this._register(this.editor.onDidType((n) => this.onDidType(n))), this.onEditorConfigurationChange(), this.onModelChanged();
    }
    get state() {
      return this._state;
    }
    set state(e) {
      this._state.type === 2 && this._state.request.cancel(), this._state = e;
    }
    cancel(e = !1) {
      this.state = Wl.Default, this.throttledDelayer.cancel(), e || this._onChangedHints.fire(void 0);
    }
    trigger(e, t) {
      const i = this.editor.getModel();
      if (!i || !this.providers.has(i))
        return;
      const n = ++this.triggerId;
      this._pendingTriggers.push(e), this.throttledDelayer.trigger(() => this.doTrigger(n), t).catch(We);
    }
    next() {
      if (this.state.type !== 1)
        return;
      const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t % e === e - 1, n = this.editor.getOption(76).cycle;
      if ((e < 2 || i) && !n) {
        this.cancel();
        return;
      }
      this.updateActiveSignature(i && n ? 0 : t + 1);
    }
    previous() {
      if (this.state.type !== 1)
        return;
      const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t === 0, n = this.editor.getOption(76).cycle;
      if ((e < 2 || i) && !n) {
        this.cancel();
        return;
      }
      this.updateActiveSignature(i && n ? e - 1 : t - 1);
    }
    updateActiveSignature(e) {
      this.state.type === 1 && (this.state = new Wl.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature: e })), this._onChangedHints.fire(this.state.hints));
    }
    doTrigger(e) {
      return ere(this, void 0, void 0, function* () {
        const t = this.state.type === 1 || this.state.type === 2, i = this.getLastActiveHints();
        if (this.cancel(!0), this._pendingTriggers.length === 0)
          return !1;
        const n = this._pendingTriggers.reduce(tre);
        this._pendingTriggers = [];
        const o = {
          triggerKind: n.triggerKind,
          triggerCharacter: n.triggerCharacter,
          isRetrigger: t,
          activeSignatureHelp: i
        };
        if (!this.editor.hasModel())
          return !1;
        const r = this.editor.getModel(), a = this.editor.getPosition();
        this.state = new Wl.Pending(an((l) => z9(this.providers, r, a, o, l)), i);
        try {
          const l = yield this.state.request;
          return e !== this.triggerId ? (l?.dispose(), !1) : !l || !l.value.signatures || l.value.signatures.length === 0 ? (l?.dispose(), this._lastSignatureHelpResult.clear(), this.cancel(), !1) : (this.state = new Wl.Active(l.value), this._lastSignatureHelpResult.value = l, this._onChangedHints.fire(this.state.hints), !0);
        } catch (l) {
          return e === this.triggerId && (this.state = Wl.Default), We(l), !1;
        }
      });
    }
    getLastActiveHints() {
      switch (this.state.type) {
        case 1:
          return this.state.hints;
        case 2:
          return this.state.previouslyActiveHints;
        default:
          return;
      }
    }
    get isTriggered() {
      return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
    }
    onModelChanged() {
      this.cancel(), this.triggerChars = new Lu(), this.retriggerChars = new Lu();
      const e = this.editor.getModel();
      if (!!e)
        for (const t of this.providers.ordered(e)) {
          for (const i of t.signatureHelpTriggerCharacters || [])
            this.triggerChars.add(i.charCodeAt(0)), this.retriggerChars.add(i.charCodeAt(0));
          for (const i of t.signatureHelpRetriggerCharacters || [])
            this.retriggerChars.add(i.charCodeAt(0));
        }
    }
    onDidType(e) {
      if (!this.triggerOnType)
        return;
      const t = e.length - 1, i = e.charCodeAt(t);
      (this.triggerChars.has(i) || this.isTriggered && this.retriggerChars.has(i)) && this.trigger({
        triggerKind: oa.TriggerCharacter,
        triggerCharacter: e.charAt(t)
      });
    }
    onCursorChange(e) {
      e.source === "mouse" ? this.cancel() : this.isTriggered && this.trigger({ triggerKind: oa.ContentChange });
    }
    onModelContentChange() {
      this.isTriggered && this.trigger({ triggerKind: oa.ContentChange });
    }
    onEditorConfigurationChange() {
      this.triggerOnType = this.editor.getOption(76).enabled, this.triggerOnType || this.cancel();
    }
    dispose() {
      this.cancel(!0), super.dispose();
    }
  }
  iw.DEFAULT_DELAY = 120;
  function tre(s, e) {
    switch (e.triggerKind) {
      case oa.Invoke:
        return e;
      case oa.ContentChange:
        return s;
      case oa.TriggerCharacter:
      default:
        return e;
    }
  }
  var ire = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Pb = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Rs = J, nre = Vi("parameter-hints-next", p.chevronDown, m("parameterHintsNextIcon", "Icon for show next parameter hint.")), sre = Vi("parameter-hints-previous", p.chevronUp, m("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
  let X1 = class U9 extends z {
    constructor(e, t, i, n, o) {
      super(), this.editor = e, this.renderDisposeables = this._register(new te()), this.visible = !1, this.announcedLabel = null, this.allowEditorOverflow = !0, this.markdownRenderer = this._register(new bl({ editor: e }, n, i)), this.model = this._register(new iw(e, o.signatureHelpProvider)), this.keyVisible = bh.Visible.bindTo(t), this.keyMultipleSignatures = bh.MultipleSignatures.bindTo(t), this._register(this.model.onChangedHints((r) => {
        r ? (this.show(), this.render(r)) : this.hide();
      }));
    }
    createParameterHintDOMNodes() {
      const e = Rs(".editor-widget.parameter-hints-widget"), t = q(e, Rs(".phwrapper"));
      t.tabIndex = -1;
      const i = q(t, Rs(".controls")), n = q(i, Rs(".button" + Tt.asCSSSelector(sre))), o = q(i, Rs(".overloads")), r = q(i, Rs(".button" + Tt.asCSSSelector(nre)));
      this._register(ee(n, "click", (u) => {
        wt.stop(u), this.previous();
      })), this._register(ee(r, "click", (u) => {
        wt.stop(u), this.next();
      }));
      const a = Rs(".body"), l = new u_(a, {});
      this._register(l), t.appendChild(l.getDomNode());
      const c = q(a, Rs(".signature")), d = q(a, Rs(".docs"));
      e.style.userSelect = "text", this.domNodes = {
        element: e,
        signature: c,
        overloads: o,
        docs: d,
        scrollbar: l
      }, this.editor.addContentWidget(this), this.hide(), this._register(this.editor.onDidChangeCursorSelection((u) => {
        this.visible && this.editor.layoutContentWidget(this);
      }));
      const h = () => {
        if (!this.domNodes)
          return;
        const u = this.editor.getOption(44);
        this.domNodes.element.style.fontSize = `${u.fontSize}px`, this.domNodes.element.style.lineHeight = `${u.lineHeight / u.fontSize}`;
      };
      h(), this._register(be.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((u) => u.hasChanged(44)).on(h, null)), this._register(this.editor.onDidLayoutChange((u) => this.updateMaxHeight())), this.updateMaxHeight();
    }
    show() {
      this.visible || (this.domNodes || this.createParameterHintDOMNodes(), this.keyVisible.set(!0), this.visible = !0, setTimeout(() => {
        this.domNodes && this.domNodes.element.classList.add("visible");
      }, 100), this.editor.layoutContentWidget(this));
    }
    hide() {
      this.renderDisposeables.clear(), this.visible && (this.keyVisible.reset(), this.visible = !1, this.announcedLabel = null, this.domNodes && this.domNodes.element.classList.remove("visible"), this.editor.layoutContentWidget(this));
    }
    getPosition() {
      return this.visible ? {
        position: this.editor.getPosition(),
        preference: [1, 2]
      } : null;
    }
    render(e) {
      var t;
      if (this.renderDisposeables.clear(), !this.domNodes)
        return;
      const i = e.signatures.length > 1;
      this.domNodes.element.classList.toggle("multiple", i), this.keyMultipleSignatures.set(i), this.domNodes.signature.innerText = "", this.domNodes.docs.innerText = "";
      const n = e.signatures[e.activeSignature];
      if (!n)
        return;
      const o = q(this.domNodes.signature, Rs(".code")), r = this.editor.getOption(44);
      o.style.fontSize = `${r.fontSize}px`, o.style.fontFamily = r.fontFamily;
      const a = n.parameters.length > 0, l = (t = n.activeParameter) !== null && t !== void 0 ? t : e.activeParameter;
      if (a)
        this.renderParameters(o, n, l);
      else {
        const h = q(o, Rs("span"));
        h.textContent = n.label;
      }
      const c = n.parameters[l];
      if (c?.documentation) {
        const h = Rs("span.documentation");
        if (typeof c.documentation == "string")
          h.textContent = c.documentation;
        else {
          const u = this.renderMarkdownDocs(c.documentation);
          h.appendChild(u.element);
        }
        q(this.domNodes.docs, Rs("p", {}, h));
      }
      if (n.documentation !== void 0)
        if (typeof n.documentation == "string")
          q(this.domNodes.docs, Rs("p", {}, n.documentation));
        else {
          const h = this.renderMarkdownDocs(n.documentation);
          q(this.domNodes.docs, h.element);
        }
      const d = this.hasDocs(n, c);
      if (this.domNodes.signature.classList.toggle("has-docs", d), this.domNodes.docs.classList.toggle("empty", !d), this.domNodes.overloads.textContent = String(e.activeSignature + 1).padStart(e.signatures.length.toString().length, "0") + "/" + e.signatures.length, c) {
        let h = "";
        const u = n.parameters[l];
        Array.isArray(u.label) ? h = n.label.substring(u.label[0], u.label[1]) : h = u.label, u.documentation && (h += typeof u.documentation == "string" ? `, ${u.documentation}` : `, ${u.documentation.value}`), n.documentation && (h += typeof n.documentation == "string" ? `, ${n.documentation}` : `, ${n.documentation.value}`), this.announcedLabel !== h && (pn(m("hint", "{0}, hint", h)), this.announcedLabel = h);
      }
      this.editor.layoutContentWidget(this), this.domNodes.scrollbar.scanDomNode();
    }
    renderMarkdownDocs(e) {
      const t = this.renderDisposeables.add(this.markdownRenderer.render(e, {
        asyncRenderCallback: () => {
          var i;
          (i = this.domNodes) === null || i === void 0 || i.scrollbar.scanDomNode();
        }
      }));
      return t.element.classList.add("markdown-docs"), t;
    }
    hasDocs(e, t) {
      return !!(t && typeof t.documentation == "string" && H_(t.documentation).length > 0 || t && typeof t.documentation == "object" && H_(t.documentation).value.length > 0 || e.documentation && typeof e.documentation == "string" && H_(e.documentation).length > 0 || e.documentation && typeof e.documentation == "object" && H_(e.documentation.value).length > 0);
    }
    renderParameters(e, t, i) {
      const [n, o] = this.getParameterLabelOffsets(t, i), r = document.createElement("span");
      r.textContent = t.label.substring(0, n);
      const a = document.createElement("span");
      a.textContent = t.label.substring(n, o), a.className = "parameter active";
      const l = document.createElement("span");
      l.textContent = t.label.substring(o), q(e, r, a, l);
    }
    getParameterLabelOffsets(e, t) {
      const i = e.parameters[t];
      if (i) {
        if (Array.isArray(i.label))
          return i.label;
        if (i.label.length) {
          const n = new RegExp(`(\\W|^)${wo(i.label)}(?=\\W|$)`, "g");
          n.test(e.label);
          const o = n.lastIndex - i.label.length;
          return o >= 0 ? [o, n.lastIndex] : [0, 0];
        } else
          return [0, 0];
      } else
        return [0, 0];
    }
    next() {
      this.editor.focus(), this.model.next();
    }
    previous() {
      this.editor.focus(), this.model.previous();
    }
    cancel() {
      this.model.cancel();
    }
    getDomNode() {
      return this.domNodes || this.createParameterHintDOMNodes(), this.domNodes.element;
    }
    getId() {
      return U9.ID;
    }
    trigger(e) {
      this.model.trigger(e, 0);
    }
    updateMaxHeight() {
      if (!this.domNodes)
        return;
      const t = `${Math.max(this.editor.getLayoutInfo().height / 4, 250)}px`;
      this.domNodes.element.style.maxHeight = t;
      const i = this.domNodes.element.getElementsByClassName("phwrapper");
      i.length && (i[0].style.maxHeight = t);
    }
  };
  X1.ID = "editor.widget.parameterHintsWidget";
  X1 = ire([
    Pb(1, Fe),
    Pb(2, No),
    Pb(3, Jt),
    Pb(4, me)
  ], X1);
  const ore = M("editorHoverWidget.highlightForeground", { dark: cl, light: cl, hc: cl }, m("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));
  Vt((s, e) => {
    const t = s.getColor(nE);
    if (t) {
      const c = s.type === jo.HIGH_CONTRAST ? 2 : 1;
      e.addRule(`.monaco-editor .parameter-hints-widget { border: ${c}px solid ${t}; }`), e.addRule(`.monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid ${t.transparent(0.5)}; }`);
    }
    const i = s.getColor(Yd);
    i && e.addRule(`.monaco-editor .parameter-hints-widget { background-color: ${i}; }`);
    const n = s.getColor(Xv);
    n && e.addRule(`.monaco-editor .parameter-hints-widget a { color: ${n}; }`);
    const o = s.getColor(Qv);
    o && e.addRule(`.monaco-editor .parameter-hints-widget a:hover { color: ${o}; }`);
    const r = s.getColor(iE);
    r && e.addRule(`.monaco-editor .parameter-hints-widget { color: ${r}; }`);
    const a = s.getColor(g5);
    a && e.addRule(`.monaco-editor .parameter-hints-widget code { background-color: ${a}; }`);
    const l = s.getColor(ore);
    l && e.addRule(`.monaco-editor .parameter-hints-widget .parameter.active { color: ${l}}`);
  });
  var rre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, are = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let vh = class $9 extends z {
    constructor(e, t) {
      super(), this.editor = e, this.widget = this._register(t.createInstance(X1, this.editor));
    }
    static get(e) {
      return e.getContribution($9.ID);
    }
    cancel() {
      this.widget.cancel();
    }
    previous() {
      this.widget.previous();
    }
    next() {
      this.widget.next();
    }
    trigger(e) {
      this.widget.trigger(e);
    }
  };
  vh.ID = "editor.controller.parameterHints";
  vh = rre([
    are(1, et)
  ], vh);
  class lre extends ge {
    constructor() {
      super({
        id: "editor.action.triggerParameterHints",
        label: m("parameterHints.trigger.label", "Trigger Parameter Hints"),
        alias: "Trigger Parameter Hints",
        precondition: T.hasSignatureHelpProvider,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 3082,
          weight: 100
        }
      });
    }
    run(e, t) {
      const i = vh.get(t);
      i && i.trigger({
        triggerKind: oa.Invoke
      });
    }
  }
  vt(vh.ID, vh);
  oe(lre);
  const $N = 100 + 75, jN = wn.bindToContribution(vh.get);
  se(new jN({
    id: "closeParameterHints",
    precondition: bh.Visible,
    handler: (s) => s.cancel(),
    kbOpts: {
      weight: $N,
      kbExpr: T.focus,
      primary: 9,
      secondary: [1033]
    }
  }));
  se(new jN({
    id: "showPrevParameterHint",
    precondition: ce.and(bh.Visible, bh.MultipleSignatures),
    handler: (s) => s.previous(),
    kbOpts: {
      weight: $N,
      kbExpr: T.focus,
      primary: 16,
      secondary: [528],
      mac: { primary: 16, secondary: [528, 302] }
    }
  }));
  se(new jN({
    id: "showNextParameterHint",
    precondition: ce.and(bh.Visible, bh.MultipleSignatures),
    handler: (s) => s.next(),
    kbOpts: {
      weight: $N,
      kbExpr: T.focus,
      primary: 18,
      secondary: [530],
      mac: { primary: 18, secondary: [530, 300] }
    }
  }));
  const KN = st("textResourceConfigurationService"), j9 = st("textResourcePropertiesService");
  var cre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, fy = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const nw = new ue("renameInputVisible", !1, m("renameInputVisible", "Whether the rename input widget is visible"));
  let rD = class {
    constructor(e, t, i, n, o) {
      this._editor = e, this._acceptKeybindings = t, this._themeService = i, this._keybindingService = n, this._disposables = new te(), this.allowEditorOverflow = !0, this._visibleContextKey = nw.bindTo(o), this._editor.addContentWidget(this), this._disposables.add(this._editor.onDidChangeConfiguration((r) => {
        r.hasChanged(44) && this._updateFont();
      })), this._disposables.add(i.onDidColorThemeChange(this._updateStyles, this));
    }
    dispose() {
      this._disposables.dispose(), this._editor.removeContentWidget(this);
    }
    getId() {
      return "__renameInputWidget";
    }
    getDomNode() {
      if (!this._domNode) {
        this._domNode = document.createElement("div"), this._domNode.className = "monaco-editor rename-box", this._input = document.createElement("input"), this._input.className = "rename-input", this._input.type = "text", this._input.setAttribute("aria-label", m("renameAriaLabel", "Rename input. Type new name and press Enter to commit.")), this._domNode.appendChild(this._input), this._label = document.createElement("div"), this._label.className = "rename-label", this._domNode.appendChild(this._label);
        const e = () => {
          var t, i;
          const [n, o] = this._acceptKeybindings;
          this._keybindingService.lookupKeybinding(n), this._label.innerText = m({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (t = this._keybindingService.lookupKeybinding(n)) === null || t === void 0 ? void 0 : t.getLabel(), (i = this._keybindingService.lookupKeybinding(o)) === null || i === void 0 ? void 0 : i.getLabel());
        };
        e(), this._disposables.add(this._keybindingService.onDidUpdateKeybindings(e)), this._updateFont(), this._updateStyles(this._themeService.getColorTheme());
      }
      return this._domNode;
    }
    _updateStyles(e) {
      var t, i, n, o;
      if (!this._input || !this._domNode)
        return;
      const r = e.getColor(wc);
      this._domNode.style.backgroundColor = String((t = e.getColor(Kn)) !== null && t !== void 0 ? t : ""), this._domNode.style.boxShadow = r ? ` 0 0 8px 2px ${r}` : "", this._domNode.style.color = String((i = e.getColor(XI)) !== null && i !== void 0 ? i : ""), this._input.style.backgroundColor = String((n = e.getColor(YI)) !== null && n !== void 0 ? n : "");
      const a = e.getColor(QI);
      this._input.style.borderWidth = a ? "1px" : "0px", this._input.style.borderStyle = a ? "solid" : "none", this._input.style.borderColor = (o = a?.toString()) !== null && o !== void 0 ? o : "none";
    }
    _updateFont() {
      if (!this._input || !this._label)
        return;
      const e = this._editor.getOption(44);
      this._input.style.fontFamily = e.fontFamily, this._input.style.fontWeight = e.fontWeight, this._input.style.fontSize = `${e.fontSize}px`, this._label.style.fontSize = `${e.fontSize * 0.8}px`;
    }
    getPosition() {
      return this._visible ? {
        position: this._position,
        preference: [2, 1]
      } : null;
    }
    afterRender(e) {
      e || this.cancelInput(!0);
    }
    acceptInput(e) {
      this._currentAcceptInput && this._currentAcceptInput(e);
    }
    cancelInput(e) {
      this._currentCancelInput && this._currentCancelInput(e);
    }
    getInput(e, t, i, n, o, r) {
      this._domNode.classList.toggle("preview", o), this._position = new V(e.startLineNumber, e.startColumn), this._input.value = t, this._input.setAttribute("selectionStart", i.toString()), this._input.setAttribute("selectionEnd", n.toString()), this._input.size = Math.max((e.endColumn - e.startColumn) * 1.1, 20);
      const a = new te();
      return new Promise((l) => {
        this._currentCancelInput = (c) => (this._currentAcceptInput = void 0, this._currentCancelInput = void 0, l(c), !0), this._currentAcceptInput = (c) => {
          if (this._input.value.trim().length === 0 || this._input.value === t) {
            this.cancelInput(!0);
            return;
          }
          this._currentAcceptInput = void 0, this._currentCancelInput = void 0, l({
            newName: this._input.value,
            wantsPreview: o && c
          });
        }, a.add(r.onCancellationRequested(() => this.cancelInput(!0))), a.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(!1))), this._show();
      }).finally(() => {
        a.dispose(), this._hide();
      });
    }
    _show() {
      this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber, 0), this._visible = !0, this._visibleContextKey.set(!0), this._editor.layoutContentWidget(this), setTimeout(() => {
        this._input.focus(), this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
      }, 100);
    }
    _hide() {
      this._visible = !1, this._visibleContextKey.reset(), this._editor.layoutContentWidget(this);
    }
  };
  rD = cre([
    fy(2, jt),
    fy(3, ci),
    fy(4, Fe)
  ], rD);
  var dre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Jc = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Vd = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class qN {
    constructor(e, t, i) {
      this.model = e, this.position = t, this._providerRenameIdx = 0, this._providers = i.ordered(e);
    }
    hasProvider() {
      return this._providers.length > 0;
    }
    resolveRenameLocation(e) {
      return Vd(this, void 0, void 0, function* () {
        const t = [];
        for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
          const n = this._providers[this._providerRenameIdx];
          if (!n.resolveRenameLocation)
            break;
          let o = yield n.resolveRenameLocation(this.model, this.position, e);
          if (!!o) {
            if (o.rejectReason) {
              t.push(o.rejectReason);
              continue;
            }
            return o;
          }
        }
        const i = this.model.getWordAtPosition(this.position);
        return i ? {
          range: new D(this.position.lineNumber, i.startColumn, this.position.lineNumber, i.endColumn),
          text: i.word,
          rejectReason: t.length > 0 ? t.join(`
`) : void 0
        } : {
          range: D.fromPositions(this.position),
          text: "",
          rejectReason: t.length > 0 ? t.join(`
`) : void 0
        };
      });
    }
    provideRenameEdits(e, t) {
      return Vd(this, void 0, void 0, function* () {
        return this._provideRenameEdits(e, this._providerRenameIdx, [], t);
      });
    }
    _provideRenameEdits(e, t, i, n) {
      return Vd(this, void 0, void 0, function* () {
        const o = this._providers[t];
        if (!o)
          return {
            edits: [],
            rejectReason: i.join(`
`)
          };
        const r = yield o.provideRenameEdits(this.model, this.position, e, n);
        if (r) {
          if (r.rejectReason)
            return this._provideRenameEdits(e, t + 1, i.concat(r.rejectReason), n);
        } else
          return this._provideRenameEdits(e, t + 1, i.concat(m("no result", "No result.")), n);
        return r;
      });
    }
  }
  function hre(s, e, t, i) {
    return Vd(this, void 0, void 0, function* () {
      const n = new qN(e, t, s), o = yield n.resolveRenameLocation(Je.None);
      return o?.rejectReason ? { edits: [], rejectReason: o.rejectReason } : n.provideRenameEdits(i, Je.None);
    });
  }
  let Ch = class K9 {
    constructor(e, t, i, n, o, r, a, l) {
      this.editor = e, this._instaService = t, this._notificationService = i, this._bulkEditService = n, this._progressService = o, this._logService = r, this._configService = a, this._languageFeaturesService = l, this._dispoableStore = new te(), this._cts = new bn(), this._renameInputField = this._dispoableStore.add(new Jl(() => this._dispoableStore.add(this._instaService.createInstance(rD, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]))));
    }
    static get(e) {
      return e.getContribution(K9.ID);
    }
    dispose() {
      this._dispoableStore.dispose(), this._cts.dispose(!0);
    }
    run() {
      var e, t;
      return Vd(this, void 0, void 0, function* () {
        if (this._cts.dispose(!0), !this.editor.hasModel())
          return;
        const i = this.editor.getPosition(), n = new qN(this.editor.getModel(), i, this._languageFeaturesService.renameProvider);
        if (!n.hasProvider())
          return;
        this._cts = new mp(this.editor, 5);
        let o;
        try {
          const u = n.resolveRenameLocation(this._cts.token);
          this._progressService.showWhile(u, 250), o = yield u;
        } catch (u) {
          (e = eo.get(this.editor)) === null || e === void 0 || e.showMessage(u || m("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), i);
          return;
        }
        if (!o)
          return;
        if (o.rejectReason) {
          (t = eo.get(this.editor)) === null || t === void 0 || t.showMessage(o.rejectReason, i);
          return;
        }
        if (this._cts.token.isCancellationRequested)
          return;
        this._cts.dispose(), this._cts = new mp(this.editor, 5, o.range);
        let r = this.editor.getSelection(), a = 0, l = o.text.length;
        !D.isEmpty(r) && !D.spansMultipleLines(r) && D.containsRange(o.range, r) && (a = Math.max(0, r.startColumn - o.range.startColumn), l = Math.min(o.range.endColumn, r.endColumn) - o.range.startColumn);
        const c = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview"), d = yield this._renameInputField.value.getInput(o.range, o.text, a, l, c, this._cts.token);
        if (typeof d == "boolean") {
          d && this.editor.focus();
          return;
        }
        this.editor.focus();
        const h = CI(n.provideRenameEdits(d.newName, this._cts.token), this._cts.token).then((u) => Vd(this, void 0, void 0, function* () {
          if (!(!u || !this.editor.hasModel())) {
            if (u.rejectReason) {
              this._notificationService.info(u.rejectReason);
              return;
            }
            this.editor.setSelection(D.fromPositions(this.editor.getSelection().getPosition())), this._bulkEditService.apply(vC.convert(u), {
              editor: this.editor,
              showPreview: d.wantsPreview,
              label: m("label", "Renaming '{0}'", o?.text),
              quotableLabel: m("quotableLabel", "Renaming {0}", o?.text)
            }).then((f) => {
              f.ariaSummary && pn(m("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", o.text, d.newName, f.ariaSummary));
            }).catch((f) => {
              this._notificationService.error(m("rename.failedApply", "Rename failed to apply edits")), this._logService.error(f);
            });
          }
        }), (u) => {
          this._notificationService.error(m("rename.failed", "Rename failed to compute edits")), this._logService.error(u);
        });
        return this._progressService.showWhile(h, 250), h;
      });
    }
    acceptRenameInput(e) {
      this._renameInputField.value.acceptInput(e);
    }
    cancelRenameInput() {
      this._renameInputField.value.cancelInput(!0);
    }
  };
  Ch.ID = "editor.contrib.renameController";
  Ch = dre([
    Jc(1, et),
    Jc(2, yi),
    Jc(3, KE),
    Jc(4, Bc),
    Jc(5, Xo),
    Jc(6, KN),
    Jc(7, me)
  ], Ch);
  class ure extends ge {
    constructor() {
      super({
        id: "editor.action.rename",
        label: m("rename.label", "Rename Symbol"),
        alias: "Rename Symbol",
        precondition: ce.and(T.writable, T.hasRenameProvider),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 60,
          weight: 100
        },
        contextMenuOpts: {
          group: "1_modification",
          order: 1.1
        }
      });
    }
    runCommand(e, t) {
      const i = e.get(St), [n, o] = Array.isArray(t) && t || [void 0, void 0];
      return Ee.isUri(n) && V.isIPosition(o) ? i.openCodeEditor({ resource: n }, i.getActiveCodeEditor()).then((r) => {
        !r || (r.setPosition(o), r.invokeWithinContext((a) => (this.reportTelemetry(a, r), this.run(a, r))));
      }, We) : super.runCommand(e, t);
    }
    run(e, t) {
      const i = Ch.get(t);
      return i ? i.run() : Promise.resolve();
    }
  }
  vt(Ch.ID, Ch);
  oe(ure);
  const GN = wn.bindToContribution(Ch.get);
  se(new GN({
    id: "acceptRenameInput",
    precondition: nw,
    handler: (s) => s.acceptRenameInput(!1),
    kbOpts: {
      weight: 100 + 99,
      kbExpr: T.focus,
      primary: 3
    }
  }));
  se(new GN({
    id: "acceptRenameInputWithPreview",
    precondition: ce.and(nw, ce.has("config.editor.rename.enablePreview")),
    handler: (s) => s.acceptRenameInput(!0),
    kbOpts: {
      weight: 100 + 99,
      kbExpr: T.focus,
      primary: 1024 + 3
    }
  }));
  se(new GN({
    id: "cancelRenameInput",
    precondition: nw,
    handler: (s) => s.cancelRenameInput(),
    kbOpts: {
      weight: 100 + 99,
      kbExpr: T.focus,
      primary: 9,
      secondary: [1033]
    }
  }));
  wa("_executeDocumentRenameProvider", function(s, e, t, ...i) {
    const [n] = i;
    Nt(typeof n == "string");
    const { renameProvider: o } = s.get(me);
    return hre(o, e, t, n);
  });
  wa("_executePrepareRename", function(s, e, t) {
    return Vd(this, void 0, void 0, function* () {
      const { renameProvider: i } = s.get(me), o = yield new qN(e, t, i).resolveRenameLocation(Je.None);
      if (o?.rejectReason)
        throw new Error(o.rejectReason);
      return o;
    });
  });
  Si.as(Oh.Configuration).registerConfiguration({
    id: "editor",
    properties: {
      "editor.rename.enablePreview": {
        scope: 5,
        description: m("enablePreview", "Enable/disable the ability to preview changes before renaming"),
        default: !0,
        type: "boolean"
      }
    }
  });
  class fre {
    provideSelectionRanges(e, t) {
      const i = [];
      for (const n of t) {
        const o = [];
        i.push(o), this._addInWordRanges(o, e, n), this._addWordRanges(o, e, n), this._addWhitespaceLine(o, e, n), o.push({ range: e.getFullModelRange() });
      }
      return i;
    }
    _addInWordRanges(e, t, i) {
      const n = t.getWordAtPosition(i);
      if (!n)
        return;
      let { word: o, startColumn: r } = n, a = i.column - r, l = a, c = a, d = 0;
      for (; l >= 0; l--) {
        let h = o.charCodeAt(l);
        if (l !== a && (h === 95 || h === 45))
          break;
        if (jl(h) && Wr(d))
          break;
        d = h;
      }
      for (l += 1; c < o.length; c++) {
        let h = o.charCodeAt(c);
        if (Wr(h) && jl(d))
          break;
        if (h === 95 || h === 45)
          break;
        d = h;
      }
      l < c && e.push({ range: new D(i.lineNumber, r + l, i.lineNumber, r + c) });
    }
    _addWordRanges(e, t, i) {
      const n = t.getWordAtPosition(i);
      n && e.push({ range: new D(i.lineNumber, n.startColumn, i.lineNumber, n.endColumn) });
    }
    _addWhitespaceLine(e, t, i) {
      t.getLineLength(i.lineNumber) > 0 && t.getLineFirstNonWhitespaceColumn(i.lineNumber) === 0 && t.getLineLastNonWhitespaceColumn(i.lineNumber) === 0 && e.push({ range: new D(i.lineNumber, 1, i.lineNumber, t.getLineMaxColumn(i.lineNumber)) });
    }
  }
  var gre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, mre = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, sw = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class ZN {
    constructor(e, t) {
      this.index = e, this.ranges = t;
    }
    mov(e) {
      let t = this.index + (e ? 1 : -1);
      if (t < 0 || t >= this.ranges.length)
        return this;
      const i = new ZN(t, this.ranges);
      return i.ranges[t].equalsRange(this.ranges[this.index]) ? i.mov(e) : i;
    }
  }
  let Wf = class q9 {
    constructor(e, t) {
      this._editor = e, this._languageFeaturesService = t, this._ignoreSelection = !1;
    }
    static get(e) {
      return e.getContribution(q9.ID);
    }
    dispose() {
      var e;
      (e = this._selectionListener) === null || e === void 0 || e.dispose();
    }
    run(e) {
      return sw(this, void 0, void 0, function* () {
        if (!this._editor.hasModel())
          return;
        const t = this._editor.getSelections(), i = this._editor.getModel();
        if (this._state || (yield Z9(this._languageFeaturesService.selectionRangeProvider, i, t.map((o) => o.getPosition()), this._editor.getOption(102), Je.None).then((o) => {
          var r;
          if (!(!Ds(o) || o.length !== t.length) && !(!this._editor.hasModel() || !Gs(this._editor.getSelections(), t, (a, l) => a.equalsSelection(l)))) {
            for (let a = 0; a < o.length; a++)
              o[a] = o[a].filter((l) => l.containsPosition(t[a].getStartPosition()) && l.containsPosition(t[a].getEndPosition())), o[a].unshift(t[a]);
            this._state = o.map((a) => new ZN(0, a)), (r = this._selectionListener) === null || r === void 0 || r.dispose(), this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
              var a;
              this._ignoreSelection || ((a = this._selectionListener) === null || a === void 0 || a.dispose(), this._state = void 0);
            });
          }
        })), !this._state)
          return;
        this._state = this._state.map((o) => o.mov(e));
        const n = this._state.map((o) => ae.fromPositions(o.ranges[o.index].getStartPosition(), o.ranges[o.index].getEndPosition()));
        this._ignoreSelection = !0;
        try {
          this._editor.setSelections(n);
        } finally {
          this._ignoreSelection = !1;
        }
      });
    }
  };
  Wf.ID = "editor.contrib.smartSelectController";
  Wf = gre([
    mre(1, me)
  ], Wf);
  class G9 extends ge {
    constructor(e, t) {
      super(t), this._forward = e;
    }
    run(e, t) {
      return sw(this, void 0, void 0, function* () {
        let i = Wf.get(t);
        i && (yield i.run(this._forward));
      });
    }
  }
  class pre extends G9 {
    constructor() {
      super(!0, {
        id: "editor.action.smartSelect.expand",
        label: m("smartSelect.expand", "Expand Selection"),
        alias: "Expand Selection",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1553,
          mac: {
            primary: 3345,
            secondary: [1297]
          },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "1_basic",
          title: m({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
          order: 2
        }
      });
    }
  }
  lt.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
  class _re extends G9 {
    constructor() {
      super(!1, {
        id: "editor.action.smartSelect.shrink",
        label: m("smartSelect.shrink", "Shrink Selection"),
        alias: "Shrink Selection",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1551,
          mac: {
            primary: 3343,
            secondary: [1295]
          },
          weight: 100
        },
        menuOpts: {
          menuId: A.MenubarSelectionMenu,
          group: "1_basic",
          title: m({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
          order: 3
        }
      });
    }
  }
  vt(Wf.ID, Wf);
  oe(pre);
  oe(_re);
  function Z9(s, e, t, i, n) {
    return sw(this, void 0, void 0, function* () {
      const o = s.all(e).concat(new fre());
      o.length === 1 && o.unshift(new Bs());
      let r = [], a = [];
      for (const l of o)
        r.push(Promise.resolve(l.provideSelectionRanges(e, t, n)).then((c) => {
          if (Ds(c) && c.length === t.length)
            for (let d = 0; d < t.length; d++) {
              a[d] || (a[d] = []);
              for (const h of c[d])
                D.isIRange(h.range) && D.containsPosition(h.range, t[d]) && a[d].push(D.lift(h.range));
            }
        }, Xi));
      return yield Promise.all(r), a.map((l) => {
        if (l.length === 0)
          return [];
        l.sort((u, f) => V.isBefore(u.getStartPosition(), f.getStartPosition()) ? 1 : V.isBefore(f.getStartPosition(), u.getStartPosition()) || V.isBefore(u.getEndPosition(), f.getEndPosition()) ? -1 : V.isBefore(f.getEndPosition(), u.getEndPosition()) ? 1 : 0);
        let c = [], d;
        for (const u of l)
          (!d || D.containsRange(u, d) && !D.equalsRange(u, d)) && (c.push(u), d = u);
        if (!i.selectLeadingAndTrailingWhitespace)
          return c;
        let h = [c[0]];
        for (let u = 1; u < c.length; u++) {
          const f = c[u - 1], g = c[u];
          if (g.startLineNumber !== f.startLineNumber || g.endLineNumber !== f.endLineNumber) {
            const _ = new D(f.startLineNumber, e.getLineFirstNonWhitespaceColumn(f.startLineNumber), f.endLineNumber, e.getLineLastNonWhitespaceColumn(f.endLineNumber));
            _.containsRange(f) && !_.equalsRange(f) && g.containsRange(_) && !g.equalsRange(_) && h.push(_);
            const b = new D(f.startLineNumber, 1, f.endLineNumber, e.getLineMaxColumn(f.endLineNumber));
            b.containsRange(f) && !b.equalsRange(_) && g.containsRange(b) && !g.equalsRange(b) && h.push(b);
          }
          h.push(g);
        }
        return h;
      });
    });
  }
  lt.registerCommand("_executeSelectionRangeProvider", function(s, ...e) {
    return sw(this, void 0, void 0, function* () {
      const [t, i] = e;
      Nt(Ee.isUri(t));
      const n = s.get(me).selectionRangeProvider, o = yield s.get(fs).createModelReference(t);
      try {
        return Z9(n, o.object.textEditorModel, i, { selectLeadingAndTrailingWhitespace: !0 }, Je.None);
      } finally {
        o.dispose();
      }
    });
  });
  class bre extends ge {
    constructor() {
      super({
        id: "editor.action.forceRetokenize",
        label: m("forceRetokenize", "Developer: Force Retokenize"),
        alias: "Developer: Force Retokenize",
        precondition: void 0
      });
    }
    run(e, t) {
      if (!t.hasModel())
        return;
      const i = t.getModel();
      i.resetTokenization();
      const n = new hs(!0);
      i.forceTokenization(i.getLineCount()), n.stop(), console.log(`tokenization took ${n.elapsed()}`);
    }
  }
  oe(bre);
  class Vf extends ge {
    constructor() {
      super({
        id: Vf.ID,
        label: m({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"),
        alias: "Toggle Tab Key Moves Focus",
        precondition: void 0,
        kbOpts: {
          kbExpr: null,
          primary: 2091,
          mac: { primary: 1323 },
          weight: 100
        }
      });
    }
    run(e, t) {
      const n = !r1.getTabFocusMode();
      r1.setTabFocusMode(n), pn(n ? m("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element") : m("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
    }
  }
  Vf.ID = "editor.action.toggleTabFocusMode";
  oe(Vf);
  class YN {
    static computeUnicodeHighlights(e, t, i) {
      const n = i ? i.startLineNumber : 1, o = i ? i.endLineNumber : e.getLineCount(), r = new rR(t), a = r.getCandidateCodePoints();
      let l;
      a === "allNonBasicAscii" ? l = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : l = new RegExp(`${vre(Array.from(a))}`, "g");
      const c = new Nu(null, l), d = [];
      let h = !1, u, f = 0, g = 0, _ = 0;
      e:
        for (let b = n, C = o; b <= C; b++) {
          const v = e.getLineContent(b), w = v.length;
          c.reset(0);
          do
            if (u = c.next(v), u) {
              let S = u.index, L = u.index + u[0].length;
              if (S > 0) {
                const I = v.charCodeAt(S - 1);
                Pi(I) && S--;
              }
              if (L + 1 < w) {
                const I = v.charCodeAt(L - 1);
                Pi(I) && L++;
              }
              const x = v.substring(S, L), y = $m(S + 1, zI, v, 0), k = r.shouldHighlightNonBasicASCII(x, y ? y.word : null);
              if (k !== 0) {
                k === 3 ? f++ : k === 2 ? g++ : k === 1 ? _++ : _I();
                const I = 1e3;
                if (d.length >= I) {
                  h = !0;
                  break e;
                }
                d.push(new D(b, S + 1, b, L + 1));
              }
            }
          while (u);
        }
      return {
        ranges: d,
        hasMore: h,
        ambiguousCharacterCount: f,
        invisibleCharacterCount: g,
        nonBasicAsciiCharacterCount: _
      };
    }
    static computeUnicodeHighlightReason(e, t) {
      const i = new rR(t);
      switch (i.shouldHighlightNonBasicASCII(e, null)) {
        case 0:
          return null;
        case 2:
          return { kind: 1 };
        case 3: {
          const o = e.codePointAt(0), r = i.ambiguousCharacters.getPrimaryConfusable(o), a = Yo.getLocales().filter((l) => !Yo.getInstance(/* @__PURE__ */ new Set([...t.allowedLocales, l])).isAmbiguous(o));
          return { kind: 0, confusableWith: String.fromCodePoint(r), notAmbiguousInLocales: a };
        }
        case 1:
          return { kind: 2 };
      }
    }
  }
  function vre(s, e) {
    return `[${wo(s.map((i) => String.fromCodePoint(i)).join(""))}]`;
  }
  class rR {
    constructor(e) {
      this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = Yo.getInstance(new Set(e.allowedLocales));
    }
    getCandidateCodePoints() {
      if (this.options.nonBasicASCII)
        return "allNonBasicAscii";
      const e = /* @__PURE__ */ new Set();
      if (this.options.invisibleCharacters)
        for (const t of na.codePoints)
          aR(String.fromCodePoint(t)) || e.add(t);
      if (this.options.ambiguousCharacters)
        for (const t of this.ambiguousCharacters.getConfusableCodePoints())
          e.add(t);
      for (const t of this.allowedCodePoints)
        e.delete(t);
      return e;
    }
    shouldHighlightNonBasicASCII(e, t) {
      const i = e.codePointAt(0);
      if (this.allowedCodePoints.has(i))
        return 0;
      if (this.options.nonBasicASCII)
        return 1;
      let n = !1, o = !1;
      if (t)
        for (let r of t) {
          const a = r.codePointAt(0), l = Rv(r);
          n = n || l, !l && !this.ambiguousCharacters.isAmbiguous(a) && !na.isInvisibleCharacter(a) && (o = !0);
        }
      return !n && o ? 0 : this.options.invisibleCharacters && !aR(e) && na.isInvisibleCharacter(i) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(i) ? 3 : 0;
    }
  }
  function aR(s) {
    return s === " " || s === `
` || s === "	";
  }
  var Cre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, wre = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let aD = class extends z {
    constructor(e, t, i = {}, n) {
      var o;
      super(), this._link = t, this._enabled = !0, this.el = q(e, J("a.monaco-link", {
        tabIndex: (o = t.tabIndex) !== null && o !== void 0 ? o : 0,
        href: t.href,
        title: t.title
      }, t.label)), this.el.setAttribute("role", "button");
      const r = this._register(new xt(this.el, "click")), a = this._register(new xt(this.el, "keypress")), l = be.chain(a.event).map((h) => new $t(h)).filter((h) => h.keyCode === 3).event, c = this._register(new xt(this.el, Bt.Tap)).event;
      this._register(kt.addTarget(this.el));
      const d = be.any(r.event, l, c);
      this._register(d((h) => {
        !this.enabled || (wt.stop(h, !0), i?.opener ? i.opener(this._link.href) : n.open(this._link.href, { allowCommands: !0 }));
      })), this.enabled = !0;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e) {
      e ? (this.el.setAttribute("aria-disabled", "false"), this.el.tabIndex = 0, this.el.style.pointerEvents = "auto", this.el.style.opacity = "1", this.el.style.cursor = "pointer", this._enabled = !1) : (this.el.setAttribute("aria-disabled", "true"), this.el.tabIndex = -1, this.el.style.pointerEvents = "none", this.el.style.opacity = "0.4", this.el.style.cursor = "default", this._enabled = !0), this._enabled = e;
    }
  };
  aD = Cre([
    wre(3, No)
  ], aD);
  Vt((s, e) => {
    const t = s.getColor(Xv);
    t && e.addRule(`.monaco-link { color: ${t}; }`);
    const i = s.getColor(Qv);
    i && e.addRule(`.monaco-link:hover { color: ${i}; }`);
  });
  var Y9 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, X9 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Sre = 26;
  let lD = class extends z {
    constructor(e, t) {
      super(), this._editor = e, this.instantiationService = t, this.banner = this._register(this.instantiationService.createInstance(cD));
    }
    hide() {
      this._editor.setBanner(null, 0), this.banner.clear();
    }
    show(e) {
      this.banner.show(Object.assign(Object.assign({}, e), { onClose: () => {
        this.hide(), e.onClose && e.onClose();
      } })), this._editor.setBanner(this.banner.element, Sre);
    }
  };
  lD = Y9([
    X9(1, et)
  ], lD);
  let cD = class extends z {
    constructor(e) {
      super(), this.instantiationService = e, this.markdownRenderer = this.instantiationService.createInstance(bl, {}), this.element = J("div.editor-banner"), this.element.tabIndex = 0;
    }
    getAriaLabel(e) {
      if (e.ariaLabel)
        return e.ariaLabel;
      if (typeof e.message == "string")
        return e.message;
    }
    getBannerMessage(e) {
      if (typeof e == "string") {
        const t = J("span");
        return t.innerText = e, t;
      }
      return this.markdownRenderer.render(e).element;
    }
    clear() {
      Bi(this.element);
    }
    show(e) {
      Bi(this.element);
      const t = this.getAriaLabel(e);
      t && this.element.setAttribute("aria-label", t);
      const i = q(this.element, J("div.icon-container"));
      i.setAttribute("aria-hidden", "true"), e.icon && i.appendChild(J(`div${Tt.asCSSSelector(e.icon)}`));
      const n = q(this.element, J("div.message-container"));
      if (n.setAttribute("aria-hidden", "true"), n.appendChild(this.getBannerMessage(e.message)), this.messageActionsContainer = q(this.element, J("div.message-actions-container")), e.actions)
        for (const r of e.actions)
          this._register(this.instantiationService.createInstance(aD, this.messageActionsContainer, Object.assign(Object.assign({}, r), { tabIndex: -1 }), {}));
      const o = q(this.element, J("div.action-container"));
      this.actionBar = this._register(new ga(o)), this.actionBar.push(this._register(new ks("banner.close", "Close Banner", Tt.asClassName(RF), !0, () => {
        typeof e.onClose == "function" && e.onClose();
      })), { icon: !0, label: !1 }), this.actionBar.setFocusable(!1);
    }
  };
  cD = Y9([
    X9(0, et)
  ], cD);
  const Q9 = st("workspaceTrustManagementService");
  var XN = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, rf = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, xn = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const yre = Vi("extensions-warning-message", p.warning, m("warningIcon", "Icon shown with a warning message in the extensions editor."));
  let Hf = class extends z {
    constructor(e, t, i, n) {
      super(), this._editor = e, this._editorWorkerService = t, this._workspaceTrustService = i, this._highlighter = null, this._bannerClosed = !1, this._updateState = (o) => {
        if (o && o.hasMore) {
          if (this._bannerClosed)
            return;
          const r = Math.max(o.ambiguousCharacterCount, o.nonBasicAsciiCharacterCount, o.invisibleCharacterCount);
          let a;
          if (o.nonBasicAsciiCharacterCount >= r)
            a = {
              message: m("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
              command: new gg()
            };
          else if (o.ambiguousCharacterCount >= r)
            a = {
              message: m("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
              command: new Hc()
            };
          else if (o.invisibleCharacterCount >= r)
            a = {
              message: m("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
              command: new fg()
            };
          else
            throw new Error("Unreachable");
          this._bannerController.show({
            id: "unicodeHighlightBanner",
            message: a.message,
            icon: yre,
            actions: [
              {
                label: a.command.shortLabel,
                href: `command:${a.command.id}`
              }
            ],
            onClose: () => {
              this._bannerClosed = !0;
            }
          });
        } else
          this._bannerController.hide();
      }, this._bannerController = this._register(n.createInstance(lD, e)), this._register(this._editor.onDidChangeModel(() => {
        this._bannerClosed = !1, this._updateHighlighter();
      })), this._options = e.getOption(113), this._register(i.onDidChangeTrust((o) => {
        this._updateHighlighter();
      })), this._register(e.onDidChangeConfiguration((o) => {
        o.hasChanged(113) && (this._options = e.getOption(113), this._updateHighlighter());
      })), this._updateHighlighter();
    }
    dispose() {
      this._highlighter && (this._highlighter.dispose(), this._highlighter = null), super.dispose();
    }
    _updateHighlighter() {
      if (this._updateState(null), this._highlighter && (this._highlighter.dispose(), this._highlighter = null), !this._editor.hasModel())
        return;
      const e = Lre(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
      if ([
        e.nonBasicASCII,
        e.ambiguousCharacters,
        e.invisibleCharacters
      ].every((i) => i === !1))
        return;
      const t = {
        nonBasicASCII: e.nonBasicASCII,
        ambiguousCharacters: e.ambiguousCharacters,
        invisibleCharacters: e.invisibleCharacters,
        includeComments: e.includeComments,
        includeStrings: e.includeStrings,
        allowedCodePoints: Object.keys(e.allowedCharacters).map((i) => i.codePointAt(0)),
        allowedLocales: Object.keys(e.allowedLocales).map((i) => i === "_os" ? new Intl.NumberFormat().resolvedOptions().locale : i === "_vscode" ? LB : i)
      };
      this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri) ? this._highlighter = new dD(this._editor, t, this._updateState, this._editorWorkerService) : this._highlighter = new kre(this._editor, t, this._updateState);
    }
    getDecorationInfo(e) {
      return this._highlighter ? this._highlighter.getDecorationInfo(e) : null;
    }
  };
  Hf.ID = "editor.contrib.unicodeHighlighter";
  Hf = XN([
    rf(1, xo),
    rf(2, Q9),
    rf(3, et)
  ], Hf);
  function Lre(s, e) {
    return {
      nonBasicASCII: e.nonBasicASCII === Fs ? !s : e.nonBasicASCII,
      ambiguousCharacters: e.ambiguousCharacters,
      invisibleCharacters: e.invisibleCharacters,
      includeComments: e.includeComments === Fs ? !s : e.includeComments,
      includeStrings: e.includeStrings === Fs ? !s : e.includeStrings,
      allowedCharacters: e.allowedCharacters,
      allowedLocales: e.allowedLocales
    };
  }
  let dD = class extends z {
    constructor(e, t, i, n) {
      super(), this._editor = e, this._options = t, this._updateState = i, this._editorWorkerService = n, this._model = this._editor.getModel(), this._decorationIds = /* @__PURE__ */ new Set(), this._updateSoon = this._register(new It(() => this._update(), 250)), this._register(this._editor.onDidChangeModelContent(() => {
        this._updateSoon.schedule();
      })), this._updateSoon.schedule();
    }
    dispose() {
      this._decorationIds = new Set(this._model.deltaDecorations(Array.from(this._decorationIds), [])), super.dispose();
    }
    _update() {
      if (this._model.isDisposed())
        return;
      if (!this._model.mightContainNonBasicASCII()) {
        this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), []));
        return;
      }
      const e = this._model.getVersionId();
      this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((t) => {
        if (this._model.isDisposed() || this._model.getVersionId() !== e)
          return;
        this._updateState(t);
        const i = [];
        if (!t.hasMore)
          for (const n of t.ranges)
            i.push({
              range: n,
              options: zf.instance.getDecorationFromOptions(this._options)
            });
        this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), i));
      });
    }
    getDecorationInfo(e) {
      if (!this._decorationIds.has(e))
        return null;
      const t = this._editor.getModel(), i = t.getDecorationRange(e), n = {
        range: i,
        options: zf.instance.getDecorationFromOptions(this._options),
        id: e,
        ownerId: 0
      };
      if (!wE(t, n))
        return null;
      const o = t.getValueInRange(i);
      return {
        reason: J9(o, this._options),
        inComment: SE(t, n),
        inString: yE(t, n)
      };
    }
  };
  dD = XN([
    rf(3, xo)
  ], dD);
  class kre extends z {
    constructor(e, t, i) {
      super(), this._editor = e, this._options = t, this._updateState = i, this._model = this._editor.getModel(), this._decorationIds = /* @__PURE__ */ new Set(), this._updateSoon = this._register(new It(() => this._update(), 250)), this._register(this._editor.onDidLayoutChange(() => {
        this._updateSoon.schedule();
      })), this._register(this._editor.onDidScrollChange(() => {
        this._updateSoon.schedule();
      })), this._register(this._editor.onDidChangeHiddenAreas(() => {
        this._updateSoon.schedule();
      })), this._register(this._editor.onDidChangeModelContent(() => {
        this._updateSoon.schedule();
      })), this._updateSoon.schedule();
    }
    dispose() {
      this._decorationIds = new Set(this._model.deltaDecorations(Array.from(this._decorationIds), [])), super.dispose();
    }
    _update() {
      if (this._model.isDisposed())
        return;
      if (!this._model.mightContainNonBasicASCII()) {
        this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), []));
        return;
      }
      const e = this._editor.getVisibleRanges(), t = [], i = {
        ranges: [],
        ambiguousCharacterCount: 0,
        invisibleCharacterCount: 0,
        nonBasicAsciiCharacterCount: 0,
        hasMore: !1
      };
      for (const n of e) {
        const o = YN.computeUnicodeHighlights(this._model, this._options, n);
        for (const r of o.ranges)
          i.ranges.push(r);
        i.ambiguousCharacterCount += i.ambiguousCharacterCount, i.invisibleCharacterCount += i.invisibleCharacterCount, i.nonBasicAsciiCharacterCount += i.nonBasicAsciiCharacterCount, i.hasMore = i.hasMore || o.hasMore;
      }
      if (!i.hasMore)
        for (const n of i.ranges)
          t.push({ range: n, options: zf.instance.getDecorationFromOptions(this._options) });
      this._updateState(i), this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), t));
    }
    getDecorationInfo(e) {
      if (!this._decorationIds.has(e))
        return null;
      const t = this._editor.getModel(), i = t.getDecorationRange(e), n = t.getValueInRange(i), o = {
        range: i,
        options: zf.instance.getDecorationFromOptions(this._options),
        id: e,
        ownerId: 0
      };
      return wE(t, o) ? {
        reason: J9(n, this._options),
        inComment: SE(t, o),
        inString: yE(t, o)
      } : null;
    }
  }
  let hD = class {
    constructor(e, t, i) {
      this._editor = e, this._languageService = t, this._openerService = i, this.hoverOrdinal = 4;
    }
    computeSync(e, t) {
      if (!this._editor.hasModel() || e.type !== 1)
        return [];
      const i = this._editor.getModel(), n = this._editor.getContribution(Hf.ID);
      if (!n)
        return [];
      const o = [];
      let r = 300;
      for (const a of t) {
        const l = n.getDecorationInfo(a.id);
        if (!l)
          continue;
        const d = i.getValueInRange(a.range).codePointAt(0), h = lR(d);
        let u;
        switch (l.reason.kind) {
          case 0:
            u = m("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", h, lR(l.reason.confusableWith.codePointAt(0)));
            break;
          case 1:
            u = m("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", h);
            break;
          case 2:
            u = m("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", h);
            break;
        }
        const f = {
          codePoint: d,
          reason: l.reason,
          inComment: l.inComment,
          inString: l.inString
        }, g = m("unicodeHighlight.adjustSettings", "Adjust settings"), _ = [{
          value: `${u} [${g}](command:${E_.ID}?${encodeURIComponent(JSON.stringify(f))})`,
          isTrusted: !0
        }];
        o.push(new nl(this, a.range, _, r++));
      }
      return o;
    }
    renderHoverParts(e, t) {
      return P7(e, t, this._editor, this._languageService, this._openerService);
    }
  };
  hD = XN([
    rf(1, Jt),
    rf(2, No)
  ], hD);
  function uD(s) {
    return `U+${s.toString(16).padStart(4, "0")}`;
  }
  function lR(s) {
    let e = `\`${uD(s)}\``;
    return na.isInvisibleCharacter(s) || (e += ` "${`${Dre(s)}`}"`), e;
  }
  function Dre(s) {
    return s === 96 ? "`` ` ``" : "`" + String.fromCodePoint(s) + "`";
  }
  function J9(s, e) {
    return YN.computeUnicodeHighlightReason(s, e);
  }
  class zf {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    getDecorationFromOptions(e) {
      return this.getDecoration(!e.includeComments, !e.includeStrings);
    }
    getDecoration(e, t) {
      const i = `${e}${t}`;
      let n = this.map.get(i);
      return n || (n = $e.createDynamic({
        description: "unicode-highlight",
        stickiness: 1,
        className: "unicode-highlight",
        showIfCollapsed: !0,
        overviewRuler: null,
        minimap: null,
        hideInCommentTokens: e,
        hideInStringTokens: t
      }), this.map.set(i, n)), n;
    }
  }
  zf.instance = new zf();
  class xre extends ge {
    constructor() {
      super({
        id: Hc.ID,
        label: m("action.unicodeHighlight.disableHighlightingInComments", "Disable highlighting of characters in comments"),
        alias: "Disable highlighting of characters in comments",
        precondition: void 0
      }), this.shortLabel = m("unicodeHighlight.disableHighlightingInComments.shortLabel", "Disable Highlight In Comments");
    }
    run(e, t, i) {
      return xn(this, void 0, void 0, function* () {
        let n = e?.get(At);
        n && this.runAction(n);
      });
    }
    runAction(e) {
      return xn(this, void 0, void 0, function* () {
        yield e.updateValue(ss.includeComments, !1, 1);
      });
    }
  }
  class Ire extends ge {
    constructor() {
      super({
        id: Hc.ID,
        label: m("action.unicodeHighlight.disableHighlightingInStrings", "Disable highlighting of characters in strings"),
        alias: "Disable highlighting of characters in strings",
        precondition: void 0
      }), this.shortLabel = m("unicodeHighlight.disableHighlightingInStrings.shortLabel", "Disable Highlight In Strings");
    }
    run(e, t, i) {
      return xn(this, void 0, void 0, function* () {
        let n = e?.get(At);
        n && this.runAction(n);
      });
    }
    runAction(e) {
      return xn(this, void 0, void 0, function* () {
        yield e.updateValue(ss.includeStrings, !1, 1);
      });
    }
  }
  class Hc extends ge {
    constructor() {
      super({
        id: Hc.ID,
        label: m("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
        alias: "Disable highlighting of ambiguous characters",
        precondition: void 0
      }), this.shortLabel = m("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
    }
    run(e, t, i) {
      return xn(this, void 0, void 0, function* () {
        let n = e?.get(At);
        n && this.runAction(n);
      });
    }
    runAction(e) {
      return xn(this, void 0, void 0, function* () {
        yield e.updateValue(ss.ambiguousCharacters, !1, 1);
      });
    }
  }
  Hc.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
  class fg extends ge {
    constructor() {
      super({
        id: fg.ID,
        label: m("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
        alias: "Disable highlighting of invisible characters",
        precondition: void 0
      }), this.shortLabel = m("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
    }
    run(e, t, i) {
      return xn(this, void 0, void 0, function* () {
        let n = e?.get(At);
        n && this.runAction(n);
      });
    }
    runAction(e) {
      return xn(this, void 0, void 0, function* () {
        yield e.updateValue(ss.invisibleCharacters, !1, 1);
      });
    }
  }
  fg.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
  class gg extends ge {
    constructor() {
      super({
        id: gg.ID,
        label: m("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
        alias: "Disable highlighting of non basic ASCII characters",
        precondition: void 0
      }), this.shortLabel = m("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
    }
    run(e, t, i) {
      return xn(this, void 0, void 0, function* () {
        let n = e?.get(At);
        n && this.runAction(n);
      });
    }
    runAction(e) {
      return xn(this, void 0, void 0, function* () {
        yield e.updateValue(ss.nonBasicASCII, !1, 1);
      });
    }
  }
  gg.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
  class E_ extends ge {
    constructor() {
      super({
        id: E_.ID,
        label: m("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
        alias: "Show Exclude Options",
        precondition: void 0
      });
    }
    run(e, t, i) {
      return xn(this, void 0, void 0, function* () {
        const { codePoint: n, reason: o, inString: r, inComment: a } = i, l = String.fromCodePoint(n), c = e.get(Sl), d = e.get(At);
        function h(g) {
          return na.isInvisibleCharacter(g) ? m("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", uD(g)) : m("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `${uD(g)} "${l}"`);
        }
        const u = [];
        if (o.kind === 0)
          for (const g of o.notAmbiguousInLocales)
            u.push({
              label: m("unicodeHighlight.allowCommonCharactersInLanguage", 'Allow unicode characters that are more common in the language "{0}".', g),
              run: () => xn(this, void 0, void 0, function* () {
                Nre(d, [g]);
              })
            });
        if (u.push({
          label: h(n),
          run: () => Ere(d, [n])
        }), a) {
          const g = new xre();
          u.push({ label: g.label, run: () => xn(this, void 0, void 0, function* () {
            return g.runAction(d);
          }) });
        } else if (r) {
          const g = new Ire();
          u.push({ label: g.label, run: () => xn(this, void 0, void 0, function* () {
            return g.runAction(d);
          }) });
        }
        if (o.kind === 0) {
          const g = new Hc();
          u.push({ label: g.label, run: () => xn(this, void 0, void 0, function* () {
            return g.runAction(d);
          }) });
        } else if (o.kind === 1) {
          const g = new fg();
          u.push({ label: g.label, run: () => xn(this, void 0, void 0, function* () {
            return g.runAction(d);
          }) });
        } else if (o.kind === 2) {
          const g = new gg();
          u.push({ label: g.label, run: () => xn(this, void 0, void 0, function* () {
            return g.runAction(d);
          }) });
        } else
          Tre(o);
        const f = yield c.pick(u, { title: m("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options") });
        f && (yield f.run());
      });
    }
  }
  E_.ID = "editor.action.unicodeHighlight.showExcludeOptions";
  function Ere(s, e) {
    return xn(this, void 0, void 0, function* () {
      const t = s.getValue(ss.allowedCharacters);
      let i;
      typeof t == "object" && t ? i = t : i = {};
      for (const n of e)
        i[String.fromCodePoint(n)] = !0;
      yield s.updateValue(ss.allowedCharacters, i, 1);
    });
  }
  function Nre(s, e) {
    var t;
    return xn(this, void 0, void 0, function* () {
      const i = (t = s.inspect(ss.allowedLocales).user) === null || t === void 0 ? void 0 : t.value;
      let n;
      typeof i == "object" && i ? n = Object.assign({}, i) : n = {};
      for (const o of e)
        n[o] = !0;
      yield s.updateValue(ss.allowedLocales, n, 1);
    });
  }
  function Tre(s) {
    throw new Error(`Unexpected value: ${s}`);
  }
  oe(Hc);
  oe(fg);
  oe(gg);
  oe(E_);
  vt(Hf.ID, Hf);
  Kh.register(hD);
  const N_ = st("dialogService");
  var Mre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, cR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Are = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const e8 = "ignoreUnusualLineTerminators";
  function Rre(s, e, t) {
    s.setModelProperty(e.uri, e8, t);
  }
  function Ore(s, e) {
    return s.getModelProperty(e.uri, e8);
  }
  let Wp = class extends z {
    constructor(e, t, i) {
      super(), this._editor = e, this._dialogService = t, this._codeEditorService = i, this._config = this._editor.getOption(114), this._register(this._editor.onDidChangeConfiguration((n) => {
        n.hasChanged(114) && (this._config = this._editor.getOption(114), this._checkForUnusualLineTerminators());
      })), this._register(this._editor.onDidChangeModel(() => {
        this._checkForUnusualLineTerminators();
      })), this._register(this._editor.onDidChangeModelContent((n) => {
        n.isUndoing || this._checkForUnusualLineTerminators();
      }));
    }
    _checkForUnusualLineTerminators() {
      return Are(this, void 0, void 0, function* () {
        if (this._config === "off" || !this._editor.hasModel())
          return;
        const e = this._editor.getModel();
        if (!e.mightContainUnusualLineTerminators() || Ore(this._codeEditorService, e) === !0 || this._editor.getOption(81))
          return;
        if (this._config === "auto") {
          e.removeUnusualLineTerminators(this._editor.getSelections());
          return;
        }
        if (!(yield this._dialogService.confirm({
          title: m("unusualLineTerminators.title", "Unusual Line Terminators"),
          message: m("unusualLineTerminators.message", "Detected unusual line terminators"),
          detail: m("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", ko(e.uri)),
          primaryButton: m("unusualLineTerminators.fix", "Remove Unusual Line Terminators"),
          secondaryButton: m("unusualLineTerminators.ignore", "Ignore")
        })).confirmed) {
          Rre(this._codeEditorService, e, !0);
          return;
        }
        e.removeUnusualLineTerminators(this._editor.getSelections());
      });
    }
  };
  Wp.ID = "editor.contrib.unusualLineTerminatorsDetector";
  Wp = Mre([
    cR(1, N_),
    cR(2, St)
  ], Wp);
  vt(Wp.ID, Wp);
  function Pre(s) {
    for (let e = 0, t = s.length; e < t; e += 4) {
      const i = s[e + 0], n = s[e + 1], o = s[e + 2], r = s[e + 3];
      s[e + 0] = r, s[e + 1] = o, s[e + 2] = n, s[e + 3] = i;
    }
  }
  function Fre(s) {
    const e = new Uint8Array(s.buffer, s.byteOffset, s.length * 4);
    return q4() || Pre(e), jv.wrap(e);
  }
  function t8(s) {
    const e = new Uint32Array(Bre(s));
    let t = 0;
    if (e[t++] = s.id, s.type === "full")
      e[t++] = 1, e[t++] = s.data.length, e.set(s.data, t), t += s.data.length;
    else {
      e[t++] = 2, e[t++] = s.deltas.length;
      for (const i of s.deltas)
        e[t++] = i.start, e[t++] = i.deleteCount, i.data ? (e[t++] = i.data.length, e.set(i.data, t), t += i.data.length) : e[t++] = 0;
    }
    return Fre(e);
  }
  function Bre(s) {
    let e = 0;
    if (e += 1 + 1, s.type === "full")
      e += 1 + s.data.length;
    else {
      e += 1, e += (1 + 1 + 1) * s.deltas.length;
      for (const t of s.deltas)
        t.data && (e += t.data.length);
    }
    return e;
  }
  var Oc = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function ow(s) {
    return s && !!s.data;
  }
  function i8(s) {
    return s && Array.isArray(s.edits);
  }
  class Wre {
    constructor(e, t, i) {
      this.provider = e, this.tokens = t, this.error = i;
    }
  }
  function n8(s, e) {
    return s.has(e);
  }
  function Vre(s, e) {
    const t = s.orderedGroups(e);
    return t.length > 0 ? t[0] : [];
  }
  function s8(s, e, t, i, n) {
    return Oc(this, void 0, void 0, function* () {
      const o = Vre(s, e), r = yield Promise.all(o.map((a) => Oc(this, void 0, void 0, function* () {
        let l, c = null;
        try {
          l = yield a.provideDocumentSemanticTokens(e, a === t ? i : null, n);
        } catch (d) {
          c = d, l = null;
        }
        return (!l || !ow(l) && !i8(l)) && (l = null), new Wre(a, l, c);
      })));
      for (const a of r) {
        if (a.error)
          throw a.error;
        if (a.tokens)
          return a;
      }
      return r.length > 0 ? r[0] : null;
    });
  }
  function Hre(s, e) {
    const t = s.orderedGroups(e);
    return t.length > 0 ? t[0] : null;
  }
  class zre {
    constructor(e, t) {
      this.provider = e, this.tokens = t;
    }
  }
  function Ure(s, e) {
    return s.has(e);
  }
  function o8(s, e) {
    const t = s.orderedGroups(e);
    return t.length > 0 ? t[0] : [];
  }
  function QN(s, e, t, i) {
    return Oc(this, void 0, void 0, function* () {
      const n = o8(s, e), o = yield Promise.all(n.map((r) => Oc(this, void 0, void 0, function* () {
        let a;
        try {
          a = yield r.provideDocumentRangeSemanticTokens(e, t, i);
        } catch (l) {
          Xi(l), a = null;
        }
        return (!a || !ow(a)) && (a = null), new zre(r, a);
      })));
      for (const r of o)
        if (r.tokens)
          return r;
      return o.length > 0 ? o[0] : null;
    });
  }
  lt.registerCommand("_provideDocumentSemanticTokensLegend", (s, ...e) => Oc(void 0, void 0, void 0, function* () {
    const [t] = e;
    Nt(t instanceof Ee);
    const i = s.get(Qt).getModel(t);
    if (!i)
      return;
    const { documentSemanticTokensProvider: n } = s.get(me), o = Hre(n, i);
    return o ? o[0].getLegend() : s.get(wi).executeCommand("_provideDocumentRangeSemanticTokensLegend", t);
  }));
  lt.registerCommand("_provideDocumentSemanticTokens", (s, ...e) => Oc(void 0, void 0, void 0, function* () {
    const [t] = e;
    Nt(t instanceof Ee);
    const i = s.get(Qt).getModel(t);
    if (!i)
      return;
    const { documentSemanticTokensProvider: n } = s.get(me);
    if (!n8(n, i))
      return s.get(wi).executeCommand("_provideDocumentRangeSemanticTokens", t, i.getFullModelRange());
    const o = yield s8(n, i, null, null, Je.None);
    if (!o)
      return;
    const { provider: r, tokens: a } = o;
    if (!a || !ow(a))
      return;
    const l = t8({
      id: 0,
      type: "full",
      data: a.data
    });
    return a.resultId && r.releaseDocumentSemanticTokens(a.resultId), l;
  }));
  lt.registerCommand("_provideDocumentRangeSemanticTokensLegend", (s, ...e) => Oc(void 0, void 0, void 0, function* () {
    const [t, i] = e;
    Nt(t instanceof Ee);
    const n = s.get(Qt).getModel(t);
    if (!n)
      return;
    const { documentRangeSemanticTokensProvider: o } = s.get(me), r = o8(o, n);
    if (r.length === 0)
      return;
    if (r.length === 1)
      return r[0].getLegend();
    if (!i || !D.isIRange(i))
      return console.warn("provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in"), r[0].getLegend();
    const a = yield QN(o, n, D.lift(i), Je.None);
    if (!!a)
      return a.provider.getLegend();
  }));
  lt.registerCommand("_provideDocumentRangeSemanticTokens", (s, ...e) => Oc(void 0, void 0, void 0, function* () {
    const [t, i] = e;
    Nt(t instanceof Ee), Nt(D.isIRange(i));
    const n = s.get(Qt).getModel(t);
    if (!n)
      return;
    const { documentRangeSemanticTokensProvider: o } = s.get(me), r = yield QN(o, n, D.lift(i), Je.None);
    if (!(!r || !r.tokens))
      return t8({
        id: 0,
        type: "full",
        data: r.tokens.data
      });
  }));
  class Em {
    constructor(e, t) {
      this._startLineNumber = e, this._tokens = t, this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
    }
    static create(e, t) {
      return new Em(e, new Q1(t));
    }
    get startLineNumber() {
      return this._startLineNumber;
    }
    get endLineNumber() {
      return this._endLineNumber;
    }
    toString() {
      return this._tokens.toString(this._startLineNumber);
    }
    _updateEndLineNumber() {
      this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
    }
    isEmpty() {
      return this._tokens.isEmpty();
    }
    getLineTokens(e) {
      return this._startLineNumber <= e && e <= this._endLineNumber ? this._tokens.getLineTokens(e - this._startLineNumber) : null;
    }
    getRange() {
      const e = this._tokens.getRange();
      return e && new D(this._startLineNumber + e.startLineNumber, e.startColumn, this._startLineNumber + e.endLineNumber, e.endColumn);
    }
    removeTokens(e) {
      const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber;
      this._startLineNumber += this._tokens.removeTokens(t, e.startColumn - 1, i, e.endColumn - 1), this._updateEndLineNumber();
    }
    split(e) {
      const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber, [n, o, r] = this._tokens.split(t, e.startColumn - 1, i, e.endColumn - 1);
      return [new Em(this._startLineNumber, n), new Em(this._startLineNumber + r, o)];
    }
    applyEdit(e, t) {
      const [i, n, o] = eh(t);
      this.acceptEdit(e, i, n, o, t.length > 0 ? t.charCodeAt(0) : 0);
    }
    acceptEdit(e, t, i, n, o) {
      this._acceptDeleteRange(e), this._acceptInsertText(new V(e.startLineNumber, e.startColumn), t, i, n, o), this._updateEndLineNumber();
    }
    _acceptDeleteRange(e) {
      if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
        return;
      const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber;
      if (i < 0) {
        const o = i - t;
        this._startLineNumber -= o;
        return;
      }
      const n = this._tokens.getMaxDeltaLine();
      if (!(t >= n + 1)) {
        if (t < 0 && i >= n + 1) {
          this._startLineNumber = 0, this._tokens.clear();
          return;
        }
        if (t < 0) {
          const o = -t;
          this._startLineNumber -= o, this._tokens.acceptDeleteRange(e.startColumn - 1, 0, 0, i, e.endColumn - 1);
        } else
          this._tokens.acceptDeleteRange(0, t, e.startColumn - 1, i, e.endColumn - 1);
      }
    }
    _acceptInsertText(e, t, i, n, o) {
      if (t === 0 && i === 0)
        return;
      const r = e.lineNumber - this._startLineNumber;
      if (r < 0) {
        this._startLineNumber += t;
        return;
      }
      const a = this._tokens.getMaxDeltaLine();
      r >= a + 1 || this._tokens.acceptInsertText(r, e.column - 1, t, i, n, o);
    }
  }
  class Q1 {
    constructor(e) {
      this._tokens = e, this._tokenCount = e.length / 4;
    }
    toString(e) {
      const t = [];
      for (let i = 0; i < this._tokenCount; i++)
        t.push(`(${this._getDeltaLine(i) + e},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
      return `[${t.join(",")}]`;
    }
    getMaxDeltaLine() {
      const e = this._getTokenCount();
      return e === 0 ? -1 : this._getDeltaLine(e - 1);
    }
    getRange() {
      const e = this._getTokenCount();
      if (e === 0)
        return null;
      const t = this._getStartCharacter(0), i = this._getDeltaLine(e - 1), n = this._getEndCharacter(e - 1);
      return new D(0, t + 1, i, n + 1);
    }
    _getTokenCount() {
      return this._tokenCount;
    }
    _getDeltaLine(e) {
      return this._tokens[4 * e];
    }
    _getStartCharacter(e) {
      return this._tokens[4 * e + 1];
    }
    _getEndCharacter(e) {
      return this._tokens[4 * e + 2];
    }
    isEmpty() {
      return this._getTokenCount() === 0;
    }
    getLineTokens(e) {
      let t = 0, i = this._getTokenCount() - 1;
      for (; t < i; ) {
        const n = t + Math.floor((i - t) / 2), o = this._getDeltaLine(n);
        if (o < e)
          t = n + 1;
        else if (o > e)
          i = n - 1;
        else {
          let r = n;
          for (; r > t && this._getDeltaLine(r - 1) === e; )
            r--;
          let a = n;
          for (; a < i && this._getDeltaLine(a + 1) === e; )
            a++;
          return new dR(this._tokens.subarray(4 * r, 4 * a + 4));
        }
      }
      return this._getDeltaLine(t) === e ? new dR(this._tokens.subarray(4 * t, 4 * t + 4)) : null;
    }
    clear() {
      this._tokenCount = 0;
    }
    removeTokens(e, t, i, n) {
      const o = this._tokens, r = this._tokenCount;
      let a = 0, l = !1, c = 0;
      for (let d = 0; d < r; d++) {
        const h = 4 * d, u = o[h], f = o[h + 1], g = o[h + 2], _ = o[h + 3];
        if ((u > e || u === e && g >= t) && (u < i || u === i && f <= n))
          l = !0;
        else {
          if (a === 0 && (c = u), l) {
            const b = 4 * a;
            o[b] = u - c, o[b + 1] = f, o[b + 2] = g, o[b + 3] = _;
          }
          a++;
        }
      }
      return this._tokenCount = a, c;
    }
    split(e, t, i, n) {
      const o = this._tokens, r = this._tokenCount, a = [], l = [];
      let c = a, d = 0, h = 0;
      for (let u = 0; u < r; u++) {
        const f = 4 * u, g = o[f], _ = o[f + 1], b = o[f + 2], C = o[f + 3];
        if (g > e || g === e && b >= t) {
          if (g < i || g === i && _ <= n)
            continue;
          c !== l && (c = l, d = 0, h = g);
        }
        c[d++] = g - h, c[d++] = _, c[d++] = b, c[d++] = C;
      }
      return [new Q1(new Uint32Array(a)), new Q1(new Uint32Array(l)), h];
    }
    acceptDeleteRange(e, t, i, n, o) {
      const r = this._tokens, a = this._tokenCount, l = n - t;
      let c = 0, d = !1;
      for (let h = 0; h < a; h++) {
        const u = 4 * h;
        let f = r[u], g = r[u + 1], _ = r[u + 2];
        const b = r[u + 3];
        if (f < t || f === t && _ <= i) {
          c++;
          continue;
        } else if (f === t && g < i)
          f === n && _ > o ? _ -= o - i : _ = i;
        else if (f === t && g === i)
          if (f === n && _ > o)
            _ -= o - i;
          else {
            d = !0;
            continue;
          }
        else if (f < n || f === n && g < o)
          if (f === n && _ > o)
            f === t ? (g = i, _ = g + (_ - o)) : (g = 0, _ = g + (_ - o));
          else {
            d = !0;
            continue;
          }
        else if (f > n) {
          if (l === 0 && !d) {
            c = a;
            break;
          }
          f -= l;
        } else if (f === n && g >= o)
          e && f === 0 && (g += e, _ += e), f -= l, g -= o - i, _ -= o - i;
        else
          throw new Error("Not possible!");
        const C = 4 * c;
        r[C] = f, r[C + 1] = g, r[C + 2] = _, r[C + 3] = b, c++;
      }
      this._tokenCount = c;
    }
    acceptInsertText(e, t, i, n, o, r) {
      const a = i === 0 && n === 1 && (r >= 48 && r <= 57 || r >= 65 && r <= 90 || r >= 97 && r <= 122), l = this._tokens, c = this._tokenCount;
      for (let d = 0; d < c; d++) {
        const h = 4 * d;
        let u = l[h], f = l[h + 1], g = l[h + 2];
        if (!(u < e || u === e && g < t)) {
          if (u === e && g === t)
            if (a)
              g += 1;
            else
              continue;
          else if (u === e && f < t && t < g)
            i === 0 ? g += n : g = t;
          else {
            if (u === e && f === t && a)
              continue;
            if (u === e)
              if (u += i, i === 0)
                f += n, g += n;
              else {
                const _ = g - f;
                f = o + (f - t), g = f + _;
              }
            else
              u += i;
          }
          l[h] = u, l[h + 1] = f, l[h + 2] = g;
        }
      }
    }
  }
  class dR {
    constructor(e) {
      this._tokens = e;
    }
    getCount() {
      return this._tokens.length / 4;
    }
    getStartCharacter(e) {
      return this._tokens[4 * e + 1];
    }
    getEndCharacter(e) {
      return this._tokens[4 * e + 2];
    }
    getMetadata(e) {
      return this._tokens[4 * e + 3];
    }
  }
  var $re = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, gy = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let fD = class {
    constructor(e, t, i, n) {
      this._legend = e, this._themeService = t, this._languageService = i, this._logService = n, this._hashTable = new Ya(), this._hasWarnedOverlappingTokens = !1;
    }
    getMetadata(e, t, i) {
      const n = this._languageService.languageIdCodec.encodeLanguageId(i), o = this._hashTable.get(e, t, n);
      let r;
      if (o)
        r = o.metadata, this._logService.getLevel() === hr.Trace && this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${e} / ${t}: foreground ${In.getForeground(r)}, fontStyle ${In.getFontStyle(r).toString(2)}`);
      else {
        let a = this._legend.tokenTypes[e];
        const l = [];
        if (a) {
          let c = t;
          for (let h = 0; c > 0 && h < this._legend.tokenModifiers.length; h++)
            c & 1 && l.push(this._legend.tokenModifiers[h]), c = c >> 1;
          c > 0 && this._logService.getLevel() === hr.Trace && (this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${t.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`), l.push("not-in-legend"));
          const d = this._themeService.getColorTheme().getTokenStyleMetadata(a, l, i);
          typeof d > "u" ? r = 2147483647 : (r = 0, typeof d.italic < "u" && (r |= (d.italic ? 1 : 0) << 10 | 1), typeof d.bold < "u" && (r |= (d.bold ? 2 : 0) << 10 | 2), typeof d.underline < "u" && (r |= (d.underline ? 4 : 0) << 10 | 4), typeof d.strikethrough < "u" && (r |= (d.strikethrough ? 8 : 0) << 10 | 8), d.foreground && (r |= d.foreground << 14 | 16), r === 0 && (r = 2147483647));
        } else
          this._logService.getLevel() === hr.Trace && this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${e} for legend: ${JSON.stringify(this._legend.tokenTypes)}`), r = 2147483647, a = "not-in-legend";
        this._hashTable.add(e, t, n, r), this._logService.getLevel() === hr.Trace && this._logService.trace(`SemanticTokensProviderStyling ${e} (${a}) / ${t} (${l.join(" ")}): foreground ${In.getForeground(r)}, fontStyle ${In.getFontStyle(r).toString(2)}`);
      }
      return r;
    }
    warnOverlappingSemanticTokens(e, t) {
      this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, console.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
    }
  };
  fD = $re([
    gy(1, jt),
    gy(2, Jt),
    gy(3, Xo)
  ], fD);
  function r8(s, e, t) {
    const i = s.data, n = s.data.length / 5 | 0, o = Math.max(Math.ceil(n / 1024), 400), r = [];
    let a = 0, l = 1, c = 0;
    for (; a < n; ) {
      const d = a;
      let h = Math.min(d + o, n);
      if (h < n) {
        let w = h;
        for (; w - 1 > d && i[5 * w] === 0; )
          w--;
        if (w - 1 === d) {
          let S = h;
          for (; S + 1 < n && i[5 * S] === 0; )
            S++;
          h = S;
        } else
          h = w;
      }
      let u = new Uint32Array((h - d) * 4), f = 0, g = 0, _ = 0, b = 0, C = 0;
      for (; a < h; ) {
        const w = 5 * a, S = i[w], L = i[w + 1], x = l + S | 0, y = S === 0 ? c + L | 0 : L, k = i[w + 2], I = i[w + 3], F = i[w + 4], R = e.getMetadata(I, F, t);
        R !== 2147483647 && (g === 0 && (g = x), _ === x && C > y && (e.warnOverlappingSemanticTokens(x, y + 1), b < y ? u[f - 4 + 2] = y : f -= 4), u[f] = x - g, u[f + 1] = y, u[f + 2] = y + k, u[f + 3] = R, f += 4, _ = x, b = y, C = y + k), l = x, c = y, a++;
      }
      f !== u.length && (u = u.subarray(0, f));
      const v = Em.create(g, u);
      r.push(v);
    }
    return r;
  }
  class jre {
    constructor(e, t, i, n) {
      this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = n, this.next = null;
    }
  }
  class Ya {
    constructor() {
      this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = Ya._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Ya._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Ya._nullOutEntries(this._elements, this._currentLength);
    }
    static _nullOutEntries(e, t) {
      for (let i = 0; i < t; i++)
        e[i] = null;
    }
    _hash2(e, t) {
      return (e << 5) - e + t | 0;
    }
    _hashFunc(e, t, i) {
      return this._hash2(this._hash2(e, t), i) % this._currentLength;
    }
    get(e, t, i) {
      const n = this._hashFunc(e, t, i);
      let o = this._elements[n];
      for (; o; ) {
        if (o.tokenTypeIndex === e && o.tokenModifierSet === t && o.languageId === i)
          return o;
        o = o.next;
      }
      return null;
    }
    add(e, t, i, n) {
      if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
        const o = this._elements;
        this._currentLengthIndex++, this._currentLength = Ya._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Ya._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Ya._nullOutEntries(this._elements, this._currentLength);
        for (const r of o) {
          let a = r;
          for (; a; ) {
            const l = a.next;
            a.next = null, this._add(a), a = l;
          }
        }
      }
      this._add(new jre(e, t, i, n));
    }
    _add(e) {
      const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
      e.next = this._elements[t], this._elements[t] = e;
    }
  }
  Ya._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
  var JN = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, zn = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  function Ml(s) {
    return s.toString();
  }
  function hR(s) {
    const e = new SC(), t = s.createSnapshot();
    let i;
    for (; i = t.read(); )
      e.update(i);
    return e.digest();
  }
  class Kre {
    constructor(e, t, i) {
      this._modelEventListeners = new te(), this.model = e, this._languageSelection = null, this._languageSelectionListener = null, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((n) => i(e, n)));
    }
    _disposeLanguageSelection() {
      this._languageSelectionListener && (this._languageSelectionListener.dispose(), this._languageSelectionListener = null);
    }
    dispose() {
      this._modelEventListeners.dispose(), this._disposeLanguageSelection();
    }
    setLanguage(e) {
      this._disposeLanguageSelection(), this._languageSelection = e, this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(e.languageId)), this.model.setMode(e.languageId);
    }
  }
  const qre = Nn || Ye ? 1 : 2;
  class Gre {
    constructor(e, t, i, n, o, r, a, l) {
      this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = n, this.heapSize = o, this.sha1 = r, this.versionId = a, this.alternativeVersionId = l;
    }
  }
  let J1 = class em extends z {
    constructor(e, t, i, n, o, r, a, l, c) {
      super(), this._configurationService = e, this._resourcePropertiesService = t, this._themeService = i, this._logService = n, this._undoRedoService = o, this._languageService = r, this._languageConfigurationService = a, this._languageFeatureDebounceService = l, this._onModelAdded = this._register(new B()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new B()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new B()), this.onModelLanguageChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._semanticStyling = this._register(new Zre(this._themeService, this._languageService, this._logService)), this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions())), this._updateModelOptions(), this._register(new mD(this._semanticStyling, this, this._themeService, this._configurationService, this._languageFeatureDebounceService, c));
    }
    static _readModelOptions(e, t) {
      var i;
      let n = On.tabSize;
      if (e.editor && typeof e.editor.tabSize < "u") {
        const f = parseInt(e.editor.tabSize, 10);
        isNaN(f) || (n = f), n < 1 && (n = 1);
      }
      let o = n;
      if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
        const f = parseInt(e.editor.indentSize, 10);
        isNaN(f) || (o = f), o < 1 && (o = 1);
      }
      let r = On.insertSpaces;
      e.editor && typeof e.editor.insertSpaces < "u" && (r = e.editor.insertSpaces === "false" ? !1 : Boolean(e.editor.insertSpaces));
      let a = qre;
      const l = e.eol;
      l === `\r
` ? a = 2 : l === `
` && (a = 1);
      let c = On.trimAutoWhitespace;
      e.editor && typeof e.editor.trimAutoWhitespace < "u" && (c = e.editor.trimAutoWhitespace === "false" ? !1 : Boolean(e.editor.trimAutoWhitespace));
      let d = On.detectIndentation;
      e.editor && typeof e.editor.detectIndentation < "u" && (d = e.editor.detectIndentation === "false" ? !1 : Boolean(e.editor.detectIndentation));
      let h = On.largeFileOptimizations;
      e.editor && typeof e.editor.largeFileOptimizations < "u" && (h = e.editor.largeFileOptimizations === "false" ? !1 : Boolean(e.editor.largeFileOptimizations));
      let u = On.bracketPairColorizationOptions;
      return ((i = e.editor) === null || i === void 0 ? void 0 : i.bracketPairColorization) && typeof e.editor.bracketPairColorization == "object" && (u = {
        enabled: !!e.editor.bracketPairColorization.enabled
      }), {
        isForSimpleWidget: t,
        tabSize: n,
        indentSize: o,
        insertSpaces: r,
        detectIndentation: d,
        defaultEOL: a,
        trimAutoWhitespace: c,
        largeFileOptimizations: h,
        bracketPairColorizationOptions: u
      };
    }
    _getEOL(e, t) {
      if (e)
        return this._resourcePropertiesService.getEOL(e, t);
      const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
      return i && typeof i == "string" && i !== "auto" ? i : oo === 3 || oo === 2 ? `
` : `\r
`;
    }
    _shouldRestoreUndoStack() {
      const e = this._configurationService.getValue("files.restoreUndoStack");
      return typeof e == "boolean" ? e : !0;
    }
    getCreationOptions(e, t, i) {
      let n = this._modelCreationOptionsByLanguageAndResource[e + t];
      if (!n) {
        const o = this._configurationService.getValue("editor", { overrideIdentifier: e, resource: t }), r = this._getEOL(t, e);
        n = em._readModelOptions({ editor: o, eol: r }, i), this._modelCreationOptionsByLanguageAndResource[e + t] = n;
      }
      return n;
    }
    _updateModelOptions() {
      const e = this._modelCreationOptionsByLanguageAndResource;
      this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
      const t = Object.keys(this._models);
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i], r = this._models[o], a = r.model.getLanguageId(), l = r.model.uri, c = e[a + l], d = this.getCreationOptions(a, l, r.model.isForSimpleWidget);
        em._setModelOptionsForModel(r.model, d, c);
      }
    }
    static _setModelOptionsForModel(e, t, i) {
      i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(t.defaultEOL === 1 ? 0 : 1), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace && po(i.bracketPairColorizationOptions, t.bracketPairColorizationOptions)) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
        trimAutoWhitespace: t.trimAutoWhitespace,
        bracketColorizationOptions: t.bracketPairColorizationOptions
      })) : e.updateOptions({
        insertSpaces: t.insertSpaces,
        tabSize: t.tabSize,
        indentSize: t.indentSize,
        trimAutoWhitespace: t.trimAutoWhitespace,
        bracketColorizationOptions: t.bracketPairColorizationOptions
      }));
    }
    _insertDisposedModel(e) {
      this._disposedModels.set(Ml(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
    }
    _removeDisposedModel(e) {
      const t = this._disposedModels.get(Ml(e));
      return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(Ml(e)), t;
    }
    _ensureDisposedModelsHeapSize(e) {
      if (this._disposedModelsHeapSize > e) {
        const t = [];
        for (this._disposedModels.forEach((i) => {
          i.sharesUndoRedoStack || t.push(i);
        }), t.sort((i, n) => i.time - n.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
          const i = t.shift();
          this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
        }
      }
    }
    _createModelData(e, t, i, n) {
      const o = this.getCreationOptions(t, i, n), r = new gl(e, t, o, i, this._undoRedoService, this._languageService, this._languageConfigurationService);
      if (i && this._disposedModels.has(Ml(i))) {
        const c = this._removeDisposedModel(i), d = this._undoRedoService.getElements(i), h = hR(r) === c.sha1;
        if (h || c.sharesUndoRedoStack) {
          for (const u of d.past)
            qa(u) && u.matchesResource(i) && u.setModel(r);
          for (const u of d.future)
            qa(u) && u.matchesResource(i) && u.setModel(r);
          this._undoRedoService.setElementsValidFlag(i, !0, (u) => qa(u) && u.matchesResource(i)), h && (r._overwriteVersionId(c.versionId), r._overwriteAlternativeVersionId(c.alternativeVersionId), r._overwriteInitialUndoRedoSnapshot(c.initialUndoRedoSnapshot));
        } else
          c.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(c.initialUndoRedoSnapshot);
      }
      const a = Ml(r.uri);
      if (this._models[a])
        throw new Error("ModelService: Cannot add model because it already exists!");
      const l = new Kre(r, (c) => this._onWillDispose(c), (c, d) => this._onDidChangeLanguage(c, d));
      return this._models[a] = l, l;
    }
    createModel(e, t, i, n = !1) {
      let o;
      return t ? (o = this._createModelData(e, t.languageId, i, n), this.setMode(o.model, t)) : o = this._createModelData(e, ya, i, n), this._onModelAdded.fire(o.model), o.model;
    }
    setMode(e, t) {
      if (!t)
        return;
      const i = this._models[Ml(e.uri)];
      !i || i.setLanguage(t);
    }
    getModels() {
      const e = [], t = Object.keys(this._models);
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i];
        e.push(this._models[o].model);
      }
      return e;
    }
    getModel(e) {
      const t = Ml(e), i = this._models[t];
      return i ? i.model : null;
    }
    getSemanticTokensProviderStyling(e) {
      return this._semanticStyling.get(e);
    }
    _schemaShouldMaintainUndoRedoElements(e) {
      return e.scheme === ze.file || e.scheme === ze.vscodeRemote || e.scheme === ze.userData || e.scheme === ze.vscodeNotebookCell || e.scheme === "fake-fs";
    }
    _onWillDispose(e) {
      const t = Ml(e.uri), i = this._models[t], n = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
      let o = !1, r = 0;
      if (n || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(e.uri)) {
        const l = this._undoRedoService.getElements(e.uri);
        if (l.past.length > 0 || l.future.length > 0) {
          for (const c of l.past)
            qa(c) && c.matchesResource(e.uri) && (o = !0, r += c.heapSize(e.uri), c.setModel(e.uri));
          for (const c of l.future)
            qa(c) && c.matchesResource(e.uri) && (o = !0, r += c.heapSize(e.uri), c.setModel(e.uri));
        }
      }
      const a = em.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
      if (o)
        if (!n && r > a) {
          const l = i.model.getInitialUndoRedoSnapshot();
          l !== null && this._undoRedoService.restoreSnapshot(l);
        } else
          this._ensureDisposedModelsHeapSize(a - r), this._undoRedoService.setElementsValidFlag(e.uri, !1, (l) => qa(l) && l.matchesResource(e.uri)), this._insertDisposedModel(new Gre(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), n, r, hR(e), e.getVersionId(), e.getAlternativeVersionId()));
      else if (!n) {
        const l = i.model.getInitialUndoRedoSnapshot();
        l !== null && this._undoRedoService.restoreSnapshot(l);
      }
      delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageId() + e.uri], this._onModelRemoved.fire(e);
    }
    _onDidChangeLanguage(e, t) {
      const i = t.oldLanguage, n = e.getLanguageId(), o = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), r = this.getCreationOptions(n, e.uri, e.isForSimpleWidget);
      em._setModelOptionsForModel(e, r, o), this._onModelModeChanged.fire({ model: e, oldLanguageId: i });
    }
  };
  J1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
  J1 = JN([
    zn(0, At),
    zn(1, j9),
    zn(2, jt),
    zn(3, Xo),
    zn(4, uC),
    zn(5, Jt),
    zn(6, Mn),
    zn(7, Io),
    zn(8, me)
  ], J1);
  const e2 = "editor.semanticHighlighting";
  function gD(s, e, t) {
    var i;
    const n = (i = t.getValue(e2, { overrideIdentifier: s.getLanguageId(), resource: s.uri })) === null || i === void 0 ? void 0 : i.enabled;
    return typeof n == "boolean" ? n : e.getColorTheme().semanticHighlighting;
  }
  let mD = class extends z {
    constructor(e, t, i, n, o, r) {
      super(), this._watchers = /* @__PURE__ */ Object.create(null), this._semanticStyling = e;
      const a = (d) => {
        this._watchers[d.uri.toString()] = new Vp(d, this._semanticStyling, i, o, r);
      }, l = (d, h) => {
        h.dispose(), delete this._watchers[d.uri.toString()];
      }, c = () => {
        for (let d of t.getModels()) {
          const h = this._watchers[d.uri.toString()];
          gD(d, i, n) ? h || a(d) : h && l(d, h);
        }
      };
      this._register(t.onModelAdded((d) => {
        gD(d, i, n) && a(d);
      })), this._register(t.onModelRemoved((d) => {
        const h = this._watchers[d.uri.toString()];
        h && l(d, h);
      })), this._register(n.onDidChangeConfiguration((d) => {
        d.affectsConfiguration(e2) && c();
      })), this._register(i.onDidColorThemeChange(c));
    }
  };
  mD = JN([
    zn(1, Qt),
    zn(2, jt),
    zn(3, At),
    zn(4, Io),
    zn(5, me)
  ], mD);
  class Zre extends z {
    constructor(e, t, i) {
      super(), this._themeService = e, this._languageService = t, this._logService = i, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
        this._caches = /* @__PURE__ */ new WeakMap();
      }));
    }
    get(e) {
      return this._caches.has(e) || this._caches.set(e, new fD(e.getLegend(), this._themeService, this._languageService, this._logService)), this._caches.get(e);
    }
  }
  class Yre {
    constructor(e, t, i) {
      this.provider = e, this.resultId = t, this.data = i;
    }
    dispose() {
      this.provider.releaseDocumentSemanticTokens(this.resultId);
    }
  }
  let Vp = class od extends z {
    constructor(e, t, i, n, o) {
      super(), this._isDisposed = !1, this._model = e, this._semanticStyling = t, this._provider = o.documentSemanticTokensProvider, this._debounceInformation = n.for(this._provider, "DocumentSemanticTokens", { min: od.REQUEST_MIN_DELAY, max: od.REQUEST_MAX_DELAY }), this._fetchDocumentSemanticTokens = this._register(new It(() => this._fetchDocumentSemanticTokensNow(), od.REQUEST_MIN_DELAY)), this._currentDocumentResponse = null, this._currentDocumentRequestCancellationTokenSource = null, this._documentProvidersChangeListeners = [], this._register(this._model.onDidChangeContent(() => {
        this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      })), this._register(this._model.onDidChangeLanguage(() => {
        this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(0);
      }));
      const r = () => {
        at(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [];
        for (const a of this._provider.all(e))
          typeof a.onDidChange == "function" && this._documentProvidersChangeListeners.push(a.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));
      };
      r(), this._register(this._provider.onDidChange(() => {
        r(), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      })), this._register(i.onDidColorThemeChange((a) => {
        this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      })), this._fetchDocumentSemanticTokens.schedule(0);
    }
    dispose() {
      this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._isDisposed = !0, super.dispose();
    }
    _fetchDocumentSemanticTokensNow() {
      if (this._currentDocumentRequestCancellationTokenSource)
        return;
      if (!n8(this._provider, this._model)) {
        this._currentDocumentResponse && this._model.setSemanticTokens(null, !1);
        return;
      }
      const e = new bn(), t = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null, i = this._currentDocumentResponse && this._currentDocumentResponse.resultId || null, n = s8(this._provider, this._model, t, i, e.token);
      this._currentDocumentRequestCancellationTokenSource = e;
      const o = [], r = this._model.onDidChangeContent((l) => {
        o.push(l);
      }), a = new hs(!1);
      n.then((l) => {
        if (this._debounceInformation.update(this._model, a.elapsed()), this._currentDocumentRequestCancellationTokenSource = null, r.dispose(), !l)
          this._setDocumentSemanticTokens(null, null, null, o);
        else {
          const { provider: c, tokens: d } = l, h = this._semanticStyling.get(c);
          this._setDocumentSemanticTokens(c, d || null, h, o);
        }
      }, (l) => {
        l && (va(l) || typeof l.message == "string" && l.message.indexOf("busy") !== -1) || We(l), this._currentDocumentRequestCancellationTokenSource = null, r.dispose(), o.length > 0 && (this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model)));
      });
    }
    static _copy(e, t, i, n, o) {
      for (let r = 0; r < o; r++)
        i[n + r] = e[t + r];
    }
    _setDocumentSemanticTokens(e, t, i, n) {
      const o = this._currentDocumentResponse, r = () => {
        n.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled() && this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      };
      if (this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._isDisposed) {
        e && t && e.releaseDocumentSemanticTokens(t.resultId);
        return;
      }
      if (!e || !i) {
        this._model.setSemanticTokens(null, !1);
        return;
      }
      if (!t) {
        this._model.setSemanticTokens(null, !0), r();
        return;
      }
      if (i8(t)) {
        if (!o) {
          this._model.setSemanticTokens(null, !0);
          return;
        }
        if (t.edits.length === 0)
          t = {
            resultId: t.resultId,
            data: o.data
          };
        else {
          let a = 0;
          for (const u of t.edits)
            a += (u.data ? u.data.length : 0) - u.deleteCount;
          const l = o.data, c = new Uint32Array(l.length + a);
          let d = l.length, h = c.length;
          for (let u = t.edits.length - 1; u >= 0; u--) {
            const f = t.edits[u], g = d - (f.start + f.deleteCount);
            g > 0 && (od._copy(l, d - g, c, h - g, g), h -= g), f.data && (od._copy(f.data, 0, c, h - f.data.length, f.data.length), h -= f.data.length), d = f.start;
          }
          d > 0 && od._copy(l, 0, c, 0, d), t = {
            resultId: t.resultId,
            data: c
          };
        }
      }
      if (ow(t)) {
        this._currentDocumentResponse = new Yre(e, t.resultId, t.data);
        const a = r8(t, i, this._model.getLanguageId());
        if (n.length > 0)
          for (const l of n)
            for (const c of a)
              for (const d of l.changes)
                c.applyEdit(d.range, d.text);
        this._model.setSemanticTokens(a, !0);
      } else
        this._model.setSemanticTokens(null, !0);
      r();
    }
  };
  Vp.REQUEST_MIN_DELAY = 300;
  Vp.REQUEST_MAX_DELAY = 2e3;
  Vp = JN([
    zn(2, jt),
    zn(3, Io),
    zn(4, me)
  ], Vp);
  var Xre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Fg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Hp = class extends z {
    constructor(e, t, i, n, o, r) {
      super(), this._modelService = t, this._themeService = i, this._configurationService = n, this._editor = e, this._provider = r.documentRangeSemanticTokensProvider, this._debounceInformation = o.for(this._provider, "DocumentRangeSemanticTokens", { min: 100, max: 500 }), this._tokenizeViewport = this._register(new It(() => this._tokenizeViewportNow(), 100)), this._outstandingRequests = [];
      const a = () => {
        this._editor.hasModel() && this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
      };
      this._register(this._editor.onDidScrollChange(() => {
        a();
      })), this._register(this._editor.onDidChangeModel(() => {
        this._cancelAll(), a();
      })), this._register(this._editor.onDidChangeModelContent((l) => {
        this._cancelAll(), a();
      })), this._register(this._provider.onDidChange(() => {
        this._cancelAll(), a();
      })), this._register(this._configurationService.onDidChangeConfiguration((l) => {
        l.affectsConfiguration(e2) && (this._cancelAll(), a());
      })), this._register(this._themeService.onDidColorThemeChange(() => {
        this._cancelAll(), a();
      }));
    }
    _cancelAll() {
      for (const e of this._outstandingRequests)
        e.cancel();
      this._outstandingRequests = [];
    }
    _removeOutstandingRequest(e) {
      for (let t = 0, i = this._outstandingRequests.length; t < i; t++)
        if (this._outstandingRequests[t] === e) {
          this._outstandingRequests.splice(t, 1);
          return;
        }
    }
    _tokenizeViewportNow() {
      if (!this._editor.hasModel())
        return;
      const e = this._editor.getModel();
      if (e.hasCompleteSemanticTokens())
        return;
      if (!gD(e, this._themeService, this._configurationService)) {
        e.hasSomeSemanticTokens() && e.setSemanticTokens(null, !1);
        return;
      }
      if (!Ure(this._provider, e)) {
        e.hasSomeSemanticTokens() && e.setSemanticTokens(null, !1);
        return;
      }
      const t = this._editor.getVisibleRangesPlusViewportAboveBelow();
      this._outstandingRequests = this._outstandingRequests.concat(t.map((i) => this._requestRange(e, i)));
    }
    _requestRange(e, t) {
      const i = e.getVersionId(), n = an((r) => Promise.resolve(QN(this._provider, e, t, r))), o = new hs(!1);
      return n.then((r) => {
        if (this._debounceInformation.update(e, o.elapsed()), !r || !r.tokens || e.isDisposed() || e.getVersionId() !== i)
          return;
        const { provider: a, tokens: l } = r, c = this._modelService.getSemanticTokensProviderStyling(a);
        e.setPartialSemanticTokens(t, r8(l, c, e.getLanguageId()));
      }).then(() => this._removeOutstandingRequest(n), () => this._removeOutstandingRequest(n)), n;
    }
  };
  Hp.ID = "editor.contrib.viewportSemanticTokens";
  Hp = Xre([
    Fg(1, Qt),
    Fg(2, jt),
    Fg(3, At),
    Fg(4, Io),
    Fg(5, me)
  ], Hp);
  vt(Hp.ID, Hp);
  var Qre = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, uR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Jre = M("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hc: null }, m("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), !0), eae = M("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hc: null }, m("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), !0), tae = M("editor.wordHighlightBorder", { light: null, dark: null, hc: Bn }, m("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable.")), iae = M("editor.wordHighlightStrongBorder", { light: null, dark: null, hc: Bn }, m("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable.")), nae = M("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC" }, m("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), !0), sae = M("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hc: "#C0A0C0CC" }, m("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), !0), rw = new ue("hasWordHighlights", !1);
  function a8(s, e, t, i) {
    const n = s.ordered(e);
    return iP(n.map((o) => () => Promise.resolve(o.provideDocumentHighlights(e, t, i)).then(void 0, Xi)), Ds);
  }
  class l8 {
    constructor(e, t, i) {
      this._model = e, this._selection = t, this._wordSeparators = i, this._wordRange = this._getCurrentWordRange(e, t), this._result = null;
    }
    get result() {
      return this._result || (this._result = an((e) => this._compute(this._model, this._selection, this._wordSeparators, e))), this._result;
    }
    _getCurrentWordRange(e, t) {
      const i = e.getWordAtPosition(t.getPosition());
      return i ? new D(t.startLineNumber, i.startColumn, t.startLineNumber, i.endColumn) : null;
    }
    isValid(e, t, i) {
      const n = t.startLineNumber, o = t.startColumn, r = t.endColumn, a = this._getCurrentWordRange(e, t);
      let l = Boolean(this._wordRange && this._wordRange.equalsRange(a));
      for (let c = 0, d = i.length; !l && c < d; c++) {
        let h = e.getDecorationRange(i[c]);
        h && h.startLineNumber === n && h.startColumn <= o && h.endColumn >= r && (l = !0);
      }
      return l;
    }
    cancel() {
      this.result.cancel();
    }
  }
  class oae extends l8 {
    constructor(e, t, i, n) {
      super(e, t, i), this._providers = n;
    }
    _compute(e, t, i, n) {
      return a8(this._providers, e, t.getPosition(), n).then((o) => o || []);
    }
  }
  class rae extends l8 {
    constructor(e, t, i) {
      super(e, t, i), this._selectionIsEmpty = t.isEmpty();
    }
    _compute(e, t, i, n) {
      return gc(250, n).then(() => {
        if (!t.isEmpty())
          return [];
        const o = e.getWordAtPosition(t.getPosition());
        return !o || o.word.length > 1e3 ? [] : e.findMatches(o.word, !0, !1, !0, i, !1).map((a) => ({
          range: a.range,
          kind: Xm.Text
        }));
      });
    }
    isValid(e, t, i) {
      const n = t.isEmpty();
      return this._selectionIsEmpty !== n ? !1 : super.isValid(e, t, i);
    }
  }
  function aae(s, e, t, i) {
    return s.has(e) ? new oae(e, t, i, s) : new rae(e, t, i);
  }
  wa("_executeDocumentHighlights", (s, e, t) => {
    const i = s.get(me);
    return a8(i.documentHighlightProvider, e, t, Je.None);
  });
  class mg {
    constructor(e, t, i) {
      this.toUnhook = new te(), this.workerRequestTokenId = 0, this.workerRequestCompleted = !1, this.workerRequestValue = [], this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1, this.editor = e, this.providers = t, this._hasWordHighlights = rw.bindTo(i), this._ignorePositionChangeEvent = !1, this.occurrencesHighlight = this.editor.getOption(72), this.model = this.editor.getModel(), this.toUnhook.add(e.onDidChangeCursorPosition((n) => {
        this._ignorePositionChangeEvent || !this.occurrencesHighlight || this._onPositionChanged(n);
      })), this.toUnhook.add(e.onDidChangeModelContent((n) => {
        this._stopAll();
      })), this.toUnhook.add(e.onDidChangeConfiguration((n) => {
        let o = this.editor.getOption(72);
        this.occurrencesHighlight !== o && (this.occurrencesHighlight = o, this._stopAll());
      })), this._decorationIds = [], this.workerRequestTokenId = 0, this.workerRequest = null, this.workerRequestCompleted = !1, this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1;
    }
    hasDecorations() {
      return this._decorationIds.length > 0;
    }
    restore() {
      !this.occurrencesHighlight || this._run();
    }
    _getSortedHighlights() {
      return Nh(this._decorationIds.map((e) => this.model.getDecorationRange(e)).sort(D.compareRangesUsingStarts));
    }
    moveNext() {
      let e = this._getSortedHighlights(), i = (e.findIndex((o) => o.containsPosition(this.editor.getPosition())) + 1) % e.length, n = e[i];
      try {
        this._ignorePositionChangeEvent = !0, this.editor.setPosition(n.getStartPosition()), this.editor.revealRangeInCenterIfOutsideViewport(n);
        const o = this._getWord();
        if (o) {
          const r = this.editor.getModel().getLineContent(n.startLineNumber);
          pn(`${r}, ${i + 1} of ${e.length} for '${o.word}'`);
        }
      } finally {
        this._ignorePositionChangeEvent = !1;
      }
    }
    moveBack() {
      let e = this._getSortedHighlights(), i = (e.findIndex((o) => o.containsPosition(this.editor.getPosition())) - 1 + e.length) % e.length, n = e[i];
      try {
        this._ignorePositionChangeEvent = !0, this.editor.setPosition(n.getStartPosition()), this.editor.revealRangeInCenterIfOutsideViewport(n);
        const o = this._getWord();
        if (o) {
          const r = this.editor.getModel().getLineContent(n.startLineNumber);
          pn(`${r}, ${i + 1} of ${e.length} for '${o.word}'`);
        }
      } finally {
        this._ignorePositionChangeEvent = !1;
      }
    }
    _removeDecorations() {
      this._decorationIds.length > 0 && (this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []), this._hasWordHighlights.set(!1));
    }
    _stopAll() {
      this._removeDecorations(), this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1), this.workerRequest !== null && (this.workerRequest.cancel(), this.workerRequest = null), this.workerRequestCompleted || (this.workerRequestTokenId++, this.workerRequestCompleted = !0);
    }
    _onPositionChanged(e) {
      if (!this.occurrencesHighlight) {
        this._stopAll();
        return;
      }
      if (e.reason !== 3) {
        this._stopAll();
        return;
      }
      this._run();
    }
    _getWord() {
      let e = this.editor.getSelection(), t = e.startLineNumber, i = e.startColumn;
      return this.model.getWordAtPosition({
        lineNumber: t,
        column: i
      });
    }
    _run() {
      let e = this.editor.getSelection();
      if (e.startLineNumber !== e.endLineNumber) {
        this._stopAll();
        return;
      }
      let t = e.startColumn, i = e.endColumn;
      const n = this._getWord();
      if (!n || n.startColumn > t || n.endColumn < i) {
        this._stopAll();
        return;
      }
      const o = this.workerRequest && this.workerRequest.isValid(this.model, e, this._decorationIds);
      if (this.lastCursorPositionChangeTime = new Date().getTime(), o)
        this.workerRequestCompleted && this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1, this._beginRenderDecorations());
      else {
        this._stopAll();
        let r = ++this.workerRequestTokenId;
        this.workerRequestCompleted = !1, this.workerRequest = aae(this.providers, this.model, this.editor.getSelection(), this.editor.getOption(117)), this.workerRequest.result.then((a) => {
          r === this.workerRequestTokenId && (this.workerRequestCompleted = !0, this.workerRequestValue = a || [], this._beginRenderDecorations());
        }, We);
      }
    }
    _beginRenderDecorations() {
      let e = new Date().getTime(), t = this.lastCursorPositionChangeTime + 250;
      e >= t ? (this.renderDecorationsTimer = -1, this.renderDecorations()) : this.renderDecorationsTimer = setTimeout(() => {
        this.renderDecorations();
      }, t - e);
    }
    renderDecorations() {
      this.renderDecorationsTimer = -1;
      let e = [];
      for (const t of this.workerRequestValue)
        t.range && e.push({
          range: t.range,
          options: mg._getDecorationOptions(t.kind)
        });
      this._decorationIds = this.editor.deltaDecorations(this._decorationIds, e), this._hasWordHighlights.set(this.hasDecorations());
    }
    static _getDecorationOptions(e) {
      return e === Xm.Write ? this._WRITE_OPTIONS : e === Xm.Text ? this._TEXT_OPTIONS : this._REGULAR_OPTIONS;
    }
    dispose() {
      this._stopAll(), this.toUnhook.dispose();
    }
  }
  mg._WRITE_OPTIONS = $e.register({
    description: "word-highlight-strong",
    stickiness: 1,
    className: "wordHighlightStrong",
    overviewRuler: {
      color: ai(sae),
      position: Lo.Center
    },
    minimap: {
      color: ai(eC),
      position: _o.Inline
    }
  });
  mg._TEXT_OPTIONS = $e.register({
    description: "selection-highlight",
    stickiness: 1,
    className: "selectionHighlight",
    overviewRuler: {
      color: ai(I5),
      position: Lo.Center
    },
    minimap: {
      color: ai(eC),
      position: _o.Inline
    }
  });
  mg._REGULAR_OPTIONS = $e.register({
    description: "word-highlight",
    stickiness: 1,
    className: "wordHighlight",
    overviewRuler: {
      color: ai(nae),
      position: Lo.Center
    },
    minimap: {
      color: ai(eC),
      position: _o.Inline
    }
  });
  let wh = class c8 extends z {
    constructor(e, t, i) {
      super(), this.wordHighlighter = null;
      const n = () => {
        e.hasModel() && (this.wordHighlighter = new mg(e, i.documentHighlightProvider, t));
      };
      this._register(e.onDidChangeModel((o) => {
        this.wordHighlighter && (this.wordHighlighter.dispose(), this.wordHighlighter = null), n();
      })), n();
    }
    static get(e) {
      return e.getContribution(c8.ID);
    }
    saveViewState() {
      return !!(this.wordHighlighter && this.wordHighlighter.hasDecorations());
    }
    moveNext() {
      this.wordHighlighter && this.wordHighlighter.moveNext();
    }
    moveBack() {
      this.wordHighlighter && this.wordHighlighter.moveBack();
    }
    restoreViewState(e) {
      this.wordHighlighter && e && this.wordHighlighter.restore();
    }
    dispose() {
      this.wordHighlighter && (this.wordHighlighter.dispose(), this.wordHighlighter = null), super.dispose();
    }
  };
  wh.ID = "editor.contrib.wordHighlighter";
  wh = Qre([
    uR(1, Fe),
    uR(2, me)
  ], wh);
  class d8 extends ge {
    constructor(e, t) {
      super(t), this._isNext = e;
    }
    run(e, t) {
      const i = wh.get(t);
      !i || (this._isNext ? i.moveNext() : i.moveBack());
    }
  }
  class lae extends d8 {
    constructor() {
      super(!0, {
        id: "editor.action.wordHighlight.next",
        label: m("wordHighlight.next.label", "Go to Next Symbol Highlight"),
        alias: "Go to Next Symbol Highlight",
        precondition: rw,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 65,
          weight: 100
        }
      });
    }
  }
  class cae extends d8 {
    constructor() {
      super(!1, {
        id: "editor.action.wordHighlight.prev",
        label: m("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
        alias: "Go to Previous Symbol Highlight",
        precondition: rw,
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 1089,
          weight: 100
        }
      });
    }
  }
  class dae extends ge {
    constructor() {
      super({
        id: "editor.action.wordHighlight.trigger",
        label: m("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
        alias: "Trigger Symbol Highlight",
        precondition: rw.toNegated(),
        kbOpts: {
          kbExpr: T.editorTextFocus,
          primary: 0,
          weight: 100
        }
      });
    }
    run(e, t, i) {
      const n = wh.get(t);
      !n || n.restoreViewState(!0);
    }
  }
  vt(wh.ID, wh);
  oe(lae);
  oe(cae);
  oe(dae);
  Vt((s, e) => {
    const t = s.getColor(tE);
    t && (e.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${t}; }`), e.addRule(`.monaco-editor .selectionHighlight { background-color: ${t.transparent(0.5)}; }`));
    const i = s.getColor(Jre);
    i && e.addRule(`.monaco-editor .wordHighlight { background-color: ${i}; }`);
    const n = s.getColor(eae);
    n && e.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${n}; }`);
    const o = s.getColor(Oz);
    o && e.addRule(`.monaco-editor .selectionHighlight { border: 1px ${s.type === "hc" ? "dotted" : "solid"} ${o}; box-sizing: border-box; }`);
    const r = s.getColor(tae);
    r && e.addRule(`.monaco-editor .wordHighlight { border: 1px ${s.type === "hc" ? "dashed" : "solid"} ${r}; box-sizing: border-box; }`);
    const a = s.getColor(iae);
    a && e.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${s.type === "hc" ? "dashed" : "solid"} ${a}; box-sizing: border-box; }`);
  });
  class aw extends wn {
    constructor(e) {
      super(e), this._inSelectionMode = e.inSelectionMode, this._wordNavigationType = e.wordNavigationType;
    }
    runEditorCommand(e, t, i) {
      if (!t.hasModel())
        return;
      const n = yo(t.getOption(117)), o = t.getModel(), a = t.getSelections().map((l) => {
        const c = new V(l.positionLineNumber, l.positionColumn), d = this._move(n, o, c, this._wordNavigationType);
        return this._moveTo(l, d, this._inSelectionMode);
      });
      if (o.pushStackElement(), t._getViewModel().setCursorStates("moveWordCommand", 3, a.map((l) => Ze.fromModelSelection(l))), a.length === 1) {
        const l = new V(a[0].positionLineNumber, a[0].positionColumn);
        t.revealPosition(l, 0);
      }
    }
    _moveTo(e, t, i) {
      return i ? new ae(e.selectionStartLineNumber, e.selectionStartColumn, t.lineNumber, t.column) : new ae(t.lineNumber, t.column, t.lineNumber, t.column);
    }
  }
  class zc extends aw {
    _move(e, t, i, n) {
      return ct.moveWordLeft(e, t, i, n);
    }
  }
  class Uc extends aw {
    _move(e, t, i, n) {
      return ct.moveWordRight(e, t, i, n);
    }
  }
  class hae extends zc {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 0,
        id: "cursorWordStartLeft",
        precondition: void 0
      });
    }
  }
  class uae extends zc {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 2,
        id: "cursorWordEndLeft",
        precondition: void 0
      });
    }
  }
  class fae extends zc {
    constructor() {
      var e;
      super({
        inSelectionMode: !1,
        wordNavigationType: 1,
        id: "cursorWordLeft",
        precondition: void 0,
        kbOpts: {
          kbExpr: ce.and(T.textInputFocus, (e = ce.and(l_, IC)) === null || e === void 0 ? void 0 : e.negate()),
          primary: 2063,
          mac: { primary: 527 },
          weight: 100
        }
      });
    }
  }
  class gae extends zc {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 0,
        id: "cursorWordStartLeftSelect",
        precondition: void 0
      });
    }
  }
  class mae extends zc {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 2,
        id: "cursorWordEndLeftSelect",
        precondition: void 0
      });
    }
  }
  class pae extends zc {
    constructor() {
      var e;
      super({
        inSelectionMode: !0,
        wordNavigationType: 1,
        id: "cursorWordLeftSelect",
        precondition: void 0,
        kbOpts: {
          kbExpr: ce.and(T.textInputFocus, (e = ce.and(l_, IC)) === null || e === void 0 ? void 0 : e.negate()),
          primary: 3087,
          mac: { primary: 1551 },
          weight: 100
        }
      });
    }
  }
  class _ae extends zc {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 3,
        id: "cursorWordAccessibilityLeft",
        precondition: void 0
      });
    }
    _move(e, t, i, n) {
      return super._move(yo(yr.wordSeparators.defaultValue), t, i, n);
    }
  }
  class bae extends zc {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 3,
        id: "cursorWordAccessibilityLeftSelect",
        precondition: void 0
      });
    }
    _move(e, t, i, n) {
      return super._move(yo(yr.wordSeparators.defaultValue), t, i, n);
    }
  }
  class vae extends Uc {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 0,
        id: "cursorWordStartRight",
        precondition: void 0
      });
    }
  }
  class Cae extends Uc {
    constructor() {
      var e;
      super({
        inSelectionMode: !1,
        wordNavigationType: 2,
        id: "cursorWordEndRight",
        precondition: void 0,
        kbOpts: {
          kbExpr: ce.and(T.textInputFocus, (e = ce.and(l_, IC)) === null || e === void 0 ? void 0 : e.negate()),
          primary: 2065,
          mac: { primary: 529 },
          weight: 100
        }
      });
    }
  }
  class wae extends Uc {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 2,
        id: "cursorWordRight",
        precondition: void 0
      });
    }
  }
  class Sae extends Uc {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 0,
        id: "cursorWordStartRightSelect",
        precondition: void 0
      });
    }
  }
  class yae extends Uc {
    constructor() {
      var e;
      super({
        inSelectionMode: !0,
        wordNavigationType: 2,
        id: "cursorWordEndRightSelect",
        precondition: void 0,
        kbOpts: {
          kbExpr: ce.and(T.textInputFocus, (e = ce.and(l_, IC)) === null || e === void 0 ? void 0 : e.negate()),
          primary: 3089,
          mac: { primary: 1553 },
          weight: 100
        }
      });
    }
  }
  class Lae extends Uc {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 2,
        id: "cursorWordRightSelect",
        precondition: void 0
      });
    }
  }
  class kae extends Uc {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 3,
        id: "cursorWordAccessibilityRight",
        precondition: void 0
      });
    }
    _move(e, t, i, n) {
      return super._move(yo(yr.wordSeparators.defaultValue), t, i, n);
    }
  }
  class Dae extends Uc {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 3,
        id: "cursorWordAccessibilityRightSelect",
        precondition: void 0
      });
    }
    _move(e, t, i, n) {
      return super._move(yo(yr.wordSeparators.defaultValue), t, i, n);
    }
  }
  class lw extends wn {
    constructor(e) {
      super(e), this._whitespaceHeuristics = e.whitespaceHeuristics, this._wordNavigationType = e.wordNavigationType;
    }
    runEditorCommand(e, t, i) {
      const n = e.get(Mn);
      if (!t.hasModel())
        return;
      const o = yo(t.getOption(117)), r = t.getModel(), a = t.getSelections(), l = t.getOption(5), c = t.getOption(8), d = n.getLanguageConfiguration(r.getLanguageId()).getAutoClosingPairs(), h = t._getViewModel(), u = a.map((f) => {
        const g = this._delete({
          wordSeparators: o,
          model: r,
          selection: f,
          whitespaceHeuristics: this._whitespaceHeuristics,
          autoClosingDelete: t.getOption(6),
          autoClosingBrackets: l,
          autoClosingQuotes: c,
          autoClosingPairs: d,
          autoClosedCharacters: h.getCursorAutoClosedCharacters()
        }, this._wordNavigationType);
        return new fn(g, "");
      });
      t.pushUndoStop(), t.executeCommands(this.id, u), t.pushUndoStop();
    }
  }
  class t2 extends lw {
    _delete(e, t) {
      let i = ct.deleteWordLeft(e, t);
      return i || new D(1, 1, 1, 1);
    }
  }
  class i2 extends lw {
    _delete(e, t) {
      let i = ct.deleteWordRight(e, t);
      if (i)
        return i;
      const n = e.model.getLineCount(), o = e.model.getLineMaxColumn(n);
      return new D(n, o, n, o);
    }
  }
  class xae extends t2 {
    constructor() {
      super({
        whitespaceHeuristics: !1,
        wordNavigationType: 0,
        id: "deleteWordStartLeft",
        precondition: T.writable
      });
    }
  }
  class Iae extends t2 {
    constructor() {
      super({
        whitespaceHeuristics: !1,
        wordNavigationType: 2,
        id: "deleteWordEndLeft",
        precondition: T.writable
      });
    }
  }
  class Eae extends t2 {
    constructor() {
      super({
        whitespaceHeuristics: !0,
        wordNavigationType: 0,
        id: "deleteWordLeft",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 2049,
          mac: { primary: 513 },
          weight: 100
        }
      });
    }
  }
  class Nae extends i2 {
    constructor() {
      super({
        whitespaceHeuristics: !1,
        wordNavigationType: 0,
        id: "deleteWordStartRight",
        precondition: T.writable
      });
    }
  }
  class Tae extends i2 {
    constructor() {
      super({
        whitespaceHeuristics: !1,
        wordNavigationType: 2,
        id: "deleteWordEndRight",
        precondition: T.writable
      });
    }
  }
  class Mae extends i2 {
    constructor() {
      super({
        whitespaceHeuristics: !0,
        wordNavigationType: 2,
        id: "deleteWordRight",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 2068,
          mac: { primary: 532 },
          weight: 100
        }
      });
    }
  }
  class Aae extends ge {
    constructor() {
      super({
        id: "deleteInsideWord",
        precondition: T.writable,
        label: m("deleteInsideWord", "Delete Word"),
        alias: "Delete Word"
      });
    }
    run(e, t, i) {
      if (!t.hasModel())
        return;
      const n = yo(t.getOption(117)), o = t.getModel(), a = t.getSelections().map((l) => {
        const c = ct.deleteInsideWord(n, o, l);
        return new fn(c, "");
      });
      t.pushUndoStop(), t.executeCommands(this.id, a), t.pushUndoStop();
    }
  }
  se(new hae());
  se(new uae());
  se(new fae());
  se(new gae());
  se(new mae());
  se(new pae());
  se(new vae());
  se(new Cae());
  se(new wae());
  se(new Sae());
  se(new yae());
  se(new Lae());
  se(new _ae());
  se(new bae());
  se(new kae());
  se(new Dae());
  se(new xae());
  se(new Iae());
  se(new Eae());
  se(new Nae());
  se(new Tae());
  se(new Mae());
  oe(Aae);
  class Rae extends lw {
    constructor() {
      super({
        whitespaceHeuristics: !0,
        wordNavigationType: 0,
        id: "deleteWordPartLeft",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 769 },
          weight: 100
        }
      });
    }
    _delete(e, t) {
      let i = zv.deleteWordPartLeft(e);
      return i || new D(1, 1, 1, 1);
    }
  }
  class Oae extends lw {
    constructor() {
      super({
        whitespaceHeuristics: !0,
        wordNavigationType: 2,
        id: "deleteWordPartRight",
        precondition: T.writable,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 788 },
          weight: 100
        }
      });
    }
    _delete(e, t) {
      let i = zv.deleteWordPartRight(e);
      if (i)
        return i;
      const n = e.model.getLineCount(), o = e.model.getLineMaxColumn(n);
      return new D(n, o, n, o);
    }
  }
  class h8 extends aw {
    _move(e, t, i, n) {
      return zv.moveWordPartLeft(e, t, i);
    }
  }
  class Pae extends h8 {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 0,
        id: "cursorWordPartLeft",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 783 },
          weight: 100
        }
      });
    }
  }
  lt.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
  class Fae extends h8 {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 0,
        id: "cursorWordPartLeftSelect",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 1807 },
          weight: 100
        }
      });
    }
  }
  lt.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
  class u8 extends aw {
    _move(e, t, i, n) {
      return zv.moveWordPartRight(e, t, i);
    }
  }
  class Bae extends u8 {
    constructor() {
      super({
        inSelectionMode: !1,
        wordNavigationType: 2,
        id: "cursorWordPartRight",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 785 },
          weight: 100
        }
      });
    }
  }
  class Wae extends u8 {
    constructor() {
      super({
        inSelectionMode: !0,
        wordNavigationType: 2,
        id: "cursorWordPartRightSelect",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.textInputFocus,
          primary: 0,
          mac: { primary: 1809 },
          weight: 100
        }
      });
    }
  }
  se(new Rae());
  se(new Oae());
  se(new Pae());
  se(new Fae());
  se(new Bae());
  se(new Wae());
  var ki;
  (function(s) {
    s.noSelection = m("noSelection", "No selection"), s.singleSelectionRange = m("singleSelectionRange", "Line {0}, Column {1} ({2} selected)"), s.singleSelection = m("singleSelection", "Line {0}, Column {1}"), s.multiSelectionRange = m("multiSelectionRange", "{0} selections ({1} characters selected)"), s.multiSelection = m("multiSelection", "{0} selections"), s.emergencyConfOn = m("emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'."), s.openingDocs = m("openingDocs", "Now opening the Editor Accessibility documentation page."), s.readonlyDiffEditor = m("readonlyDiffEditor", " in a read-only pane of a diff editor."), s.editableDiffEditor = m("editableDiffEditor", " in a pane of a diff editor."), s.readonlyEditor = m("readonlyEditor", " in a read-only code editor"), s.editableEditor = m("editableEditor", " in a code editor"), s.changeConfigToOnMac = m("changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now."), s.changeConfigToOnWinLinux = m("changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now."), s.auto_on = m("auto_on", "The editor is configured to be optimized for usage with a Screen Reader."), s.auto_off = m("auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time."), s.tabFocusModeOnMsg = m("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}."), s.tabFocusModeOnMsgNoKb = m("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding."), s.tabFocusModeOffMsg = m("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}."), s.tabFocusModeOffMsgNoKb = m("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding."), s.openDocMac = m("openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility."), s.openDocWinLinux = m("openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility."), s.outroMsg = m("outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape."), s.showAccessibilityHelpAction = m("showAccessibilityHelpAction", "Show Accessibility Help");
  })(ki || (ki = {}));
  var pD;
  (function(s) {
    s.inspectTokensAction = m("inspectTokens", "Developer: Inspect Tokens");
  })(pD || (pD = {}));
  var ev;
  (function(s) {
    s.gotoLineActionLabel = m("gotoLineActionLabel", "Go to Line/Column...");
  })(ev || (ev = {}));
  var _D;
  (function(s) {
    s.helpQuickAccessActionLabel = m("helpQuickAccess", "Show all Quick Access Providers");
  })(_D || (_D = {}));
  var tv;
  (function(s) {
    s.quickCommandActionLabel = m("quickCommandActionLabel", "Command Palette"), s.quickCommandHelp = m("quickCommandActionHelp", "Show And Run Commands");
  })(tv || (tv = {}));
  var zp;
  (function(s) {
    s.quickOutlineActionLabel = m("quickOutlineActionLabel", "Go to Symbol..."), s.quickOutlineByCategoryActionLabel = m("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
  })(zp || (zp = {}));
  var iv;
  (function(s) {
    s.editorViewAccessibleLabel = m("editorViewAccessibleLabel", "Editor content"), s.accessibilityHelpMessage = m("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
  })(iv || (iv = {}));
  var fR;
  (function(s) {
    s.toggleHighContrast = m("toggleHighContrast", "Toggle High Contrast Theme");
  })(fR || (fR = {}));
  var bD;
  (function(s) {
    s.bulkEditServiceSummary = m("bulkEditServiceSummary", "Made {0} edits in {1} files");
  })(bD || (bD = {}));
  var f8 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, D0 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const g8 = new ue("accessibilityHelpWidgetVisible", !1);
  let Sh = class m8 extends z {
    constructor(e, t) {
      super(), this._editor = e, this._widget = this._register(t.createInstance(Uf, this._editor));
    }
    static get(e) {
      return e.getContribution(m8.ID);
    }
    show() {
      this._widget.show();
    }
    hide() {
      this._widget.hide();
    }
  };
  Sh.ID = "editor.contrib.accessibilityHelpController";
  Sh = f8([
    D0(1, et)
  ], Sh);
  function Vae(s, e) {
    return !s || s.length === 0 ? ki.noSelection : s.length === 1 ? e ? uo(ki.singleSelectionRange, s[0].positionLineNumber, s[0].positionColumn, e) : uo(ki.singleSelection, s[0].positionLineNumber, s[0].positionColumn) : e ? uo(ki.multiSelectionRange, s.length, e) : s.length > 0 ? uo(ki.multiSelection, s.length) : "";
  }
  let Uf = class x0 extends Qo {
    constructor(e, t, i, n) {
      super(), this._contextKeyService = t, this._keybindingService = i, this._openerService = n, this._editor = e, this._isVisibleKey = g8.bindTo(this._contextKeyService), this._domNode = dt(document.createElement("div")), this._domNode.setClassName("accessibilityHelpWidget"), this._domNode.setDisplay("none"), this._domNode.setAttribute("role", "dialog"), this._domNode.setAttribute("aria-hidden", "true"), this._contentDomNode = dt(document.createElement("div")), this._contentDomNode.setAttribute("role", "document"), this._domNode.appendChild(this._contentDomNode), this._isVisible = !1, this._register(this._editor.onDidLayoutChange(() => {
        this._isVisible && this._layout();
      })), this._register(on(this._contentDomNode.domNode, "keydown", (o) => {
        if (!!this._isVisible && (o.equals(2083) && (pn(ki.emergencyConfOn), this._editor.updateOptions({
          accessibilitySupport: "on"
        }), Bi(this._contentDomNode.domNode), this._buildContent(), this._contentDomNode.domNode.focus(), o.preventDefault(), o.stopPropagation()), o.equals(2086))) {
          pn(ki.openingDocs);
          let r = this._editor.getRawOptions().accessibilityHelpUrl;
          typeof r > "u" && (r = "https://go.microsoft.com/fwlink/?linkid=852450"), this._openerService.open(Ee.parse(r)), o.preventDefault(), o.stopPropagation();
        }
      })), this.onblur(this._contentDomNode.domNode, () => {
        this.hide();
      }), this._editor.addOverlayWidget(this);
    }
    dispose() {
      this._editor.removeOverlayWidget(this), super.dispose();
    }
    getId() {
      return x0.ID;
    }
    getDomNode() {
      return this._domNode.domNode;
    }
    getPosition() {
      return {
        preference: null
      };
    }
    show() {
      this._isVisible || (this._isVisible = !0, this._isVisibleKey.set(!0), this._layout(), this._domNode.setDisplay("block"), this._domNode.setAttribute("aria-hidden", "false"), this._contentDomNode.domNode.tabIndex = 0, this._buildContent(), this._contentDomNode.domNode.focus());
    }
    _descriptionForCommand(e, t, i) {
      const n = this._keybindingService.lookupKeybinding(e);
      return n ? uo(t, n.getAriaLabel()) : uo(i, e);
    }
    _buildContent() {
      const e = this._editor.getOptions(), t = this._editor.getSelections();
      let i = 0;
      if (t) {
        const a = this._editor.getModel();
        a && t.forEach((l) => {
          i += a.getValueLengthInRange(l);
        });
      }
      let n = Vae(t, i);
      e.get(54) ? e.get(81) ? n += ki.readonlyDiffEditor : n += ki.editableDiffEditor : e.get(81) ? n += ki.readonlyEditor : n += ki.editableEditor;
      const o = Ye ? ki.changeConfigToOnMac : ki.changeConfigToOnWinLinux;
      switch (e.get(2)) {
        case 0:
          n += `

 - ` + o;
          break;
        case 2:
          n += `

 - ` + ki.auto_on;
          break;
        case 1:
          n += `

 - ` + ki.auto_off, n += " " + o;
          break;
      }
      e.get(130) ? n += `

 - ` + this._descriptionForCommand(Vf.ID, ki.tabFocusModeOnMsg, ki.tabFocusModeOnMsgNoKb) : n += `

 - ` + this._descriptionForCommand(Vf.ID, ki.tabFocusModeOffMsg, ki.tabFocusModeOffMsgNoKb);
      const r = Ye ? ki.openDocMac : ki.openDocWinLinux;
      n += `

 - ` + r, n += `

` + ki.outroMsg, this._contentDomNode.domNode.appendChild(_7(n)), this._contentDomNode.domNode.setAttribute("aria-label", n);
    }
    hide() {
      !this._isVisible || (this._isVisible = !1, this._isVisibleKey.reset(), this._domNode.setDisplay("none"), this._domNode.setAttribute("aria-hidden", "true"), this._contentDomNode.domNode.tabIndex = -1, Bi(this._contentDomNode.domNode), this._editor.focus());
    }
    _layout() {
      const e = this._editor.getLayoutInfo(), t = Math.max(5, Math.min(x0.WIDTH, e.width - 40)), i = Math.max(5, Math.min(x0.HEIGHT, e.height - 40));
      this._domNode.setWidth(t), this._domNode.setHeight(i);
      const n = Math.round((e.height - i) / 2);
      this._domNode.setTop(n);
      const o = Math.round((e.width - t) / 2);
      this._domNode.setLeft(o);
    }
  };
  Uf.ID = "editor.contrib.accessibilityHelpWidget";
  Uf.WIDTH = 500;
  Uf.HEIGHT = 300;
  Uf = f8([
    D0(1, Fe),
    D0(2, ci),
    D0(3, No)
  ], Uf);
  class Hae extends ge {
    constructor() {
      super({
        id: "editor.action.showAccessibilityHelp",
        label: ki.showAccessibilityHelpAction,
        alias: "Show Accessibility Help",
        precondition: void 0,
        kbOpts: {
          primary: 571,
          weight: 100,
          linux: {
            primary: 1595,
            secondary: [571]
          }
        }
      });
    }
    run(e, t) {
      const i = Sh.get(t);
      i && i.show();
    }
  }
  vt(Sh.ID, Sh);
  oe(Hae);
  const zae = wn.bindToContribution(Sh.get);
  se(new zae({
    id: "closeAccessibilityHelp",
    precondition: g8,
    handler: (s) => s.hide(),
    kbOpts: {
      weight: 100 + 100,
      kbExpr: T.focus,
      primary: 9,
      secondary: [1033]
    }
  }));
  Vt((s, e) => {
    const t = s.getColor(Kn);
    t && e.addRule(`.monaco-editor .accessibilityHelpWidget { background-color: ${t}; }`);
    const i = s.getColor(ll);
    i && e.addRule(`.monaco-editor .accessibilityHelpWidget { color: ${i}; }`);
    const n = s.getColor(wc);
    n && e.addRule(`.monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px ${n}; }`);
    const o = s.getColor(qt);
    o && e.addRule(`.monaco-editor .accessibilityHelpWidget { border: 2px solid ${o}; }`);
  });
  const Mo = st("themeService");
  var Uae = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, gR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let $f = class p8 extends z {
    constructor(e, t, i) {
      super(), this._editor = e, this._languageService = i, this._widget = null, this._register(this._editor.onDidChangeModel((n) => this.stop())), this._register(this._editor.onDidChangeModelLanguage((n) => this.stop())), this._register(Yt.onDidChange((n) => this.stop())), this._register(this._editor.onKeyUp((n) => n.keyCode === 9 && this.stop()));
    }
    static get(e) {
      return e.getContribution(p8.ID);
    }
    dispose() {
      this.stop(), super.dispose();
    }
    launch() {
      this._widget || !this._editor.hasModel() || (this._widget = new cw(this._editor, this._languageService));
    }
    stop() {
      this._widget && (this._widget.dispose(), this._widget = null);
    }
  };
  $f.ID = "editor.contrib.inspectTokens";
  $f = Uae([
    gR(1, Mo),
    gR(2, Jt)
  ], $f);
  class $ae extends ge {
    constructor() {
      super({
        id: "editor.action.inspectTokens",
        label: pD.inspectTokensAction,
        alias: "Developer: Inspect Tokens",
        precondition: void 0
      });
    }
    run(e, t) {
      const i = $f.get(t);
      i && i.launch();
    }
  }
  function jae(s) {
    let e = "";
    for (let t = 0, i = s.length; t < i; t++) {
      const n = s.charCodeAt(t);
      switch (n) {
        case 9:
          e += "\u2192";
          break;
        case 32:
          e += "\xB7";
          break;
        default:
          e += String.fromCharCode(n);
      }
    }
    return e;
  }
  function Kae(s, e) {
    const t = Yt.get(e);
    if (t)
      return t;
    const i = s.encodeLanguageId(e);
    return {
      getInitialState: () => kf,
      tokenize: (n, o, r) => aF(e, r),
      tokenizeEncoded: (n, o, r) => CE(i, r)
    };
  }
  class cw extends z {
    constructor(e, t) {
      super(), this.allowEditorOverflow = !0, this._editor = e, this._languageService = t, this._model = this._editor.getModel(), this._domNode = document.createElement("div"), this._domNode.className = "tokens-inspect-widget", this._tokenizationSupport = Kae(this._languageService.languageIdCodec, this._model.getLanguageId()), this._compute(this._editor.getPosition()), this._register(this._editor.onDidChangeCursorPosition((i) => this._compute(this._editor.getPosition()))), this._editor.addContentWidget(this);
    }
    dispose() {
      this._editor.removeContentWidget(this), super.dispose();
    }
    getId() {
      return cw._ID;
    }
    _compute(e) {
      const t = this._getTokensAtLine(e.lineNumber);
      let i = 0;
      for (let l = t.tokens1.length - 1; l >= 0; l--) {
        const c = t.tokens1[l];
        if (e.column - 1 >= c.offset) {
          i = l;
          break;
        }
      }
      let n = 0;
      for (let l = t.tokens2.length >>> 1; l >= 0; l--)
        if (e.column - 1 >= t.tokens2[l << 1]) {
          n = l;
          break;
        }
      const o = this._model.getLineContent(e.lineNumber);
      let r = "";
      if (i < t.tokens1.length) {
        const l = t.tokens1[i].offset, c = i + 1 < t.tokens1.length ? t.tokens1[i + 1].offset : o.length;
        r = o.substring(l, c);
      }
      pc(this._domNode, J("h2.tm-token", void 0, jae(r), J("span.tm-token-length", void 0, `${r.length} ${r.length === 1 ? "char" : "chars"}`))), q(this._domNode, J("hr.tokens-inspect-separator", { style: "clear:both" }));
      const a = (n << 1) + 1 < t.tokens2.length ? this._decodeMetadata(t.tokens2[(n << 1) + 1]) : null;
      q(this._domNode, J("table.tm-metadata-table", void 0, J("tbody", void 0, J("tr", void 0, J("td.tm-metadata-key", void 0, "language"), J("td.tm-metadata-value", void 0, `${a ? a.languageId : "-?-"}`)), J("tr", void 0, J("td.tm-metadata-key", void 0, "token type"), J("td.tm-metadata-value", void 0, `${a ? this._tokenTypeToString(a.tokenType) : "-?-"}`)), J("tr", void 0, J("td.tm-metadata-key", void 0, "font style"), J("td.tm-metadata-value", void 0, `${a ? this._fontStyleToString(a.fontStyle) : "-?-"}`)), J("tr", void 0, J("td.tm-metadata-key", void 0, "foreground"), J("td.tm-metadata-value", void 0, `${a ? H.Format.CSS.formatHex(a.foreground) : "-?-"}`)), J("tr", void 0, J("td.tm-metadata-key", void 0, "background"), J("td.tm-metadata-value", void 0, `${a ? H.Format.CSS.formatHex(a.background) : "-?-"}`))))), q(this._domNode, J("hr.tokens-inspect-separator")), i < t.tokens1.length && q(this._domNode, J("span.tm-token-type", void 0, t.tokens1[i].type)), this._editor.layoutContentWidget(this);
    }
    _decodeMetadata(e) {
      const t = Yt.getColorMap(), i = In.getLanguageId(e), n = In.getTokenType(e), o = In.getFontStyle(e), r = In.getForeground(e), a = In.getBackground(e);
      return {
        languageId: this._languageService.languageIdCodec.decodeLanguageId(i),
        tokenType: n,
        fontStyle: o,
        foreground: t[r],
        background: t[a]
      };
    }
    _tokenTypeToString(e) {
      switch (e) {
        case 0:
          return "Other";
        case 1:
          return "Comment";
        case 2:
          return "String";
        case 3:
          return "RegEx";
        default:
          return "??";
      }
    }
    _fontStyleToString(e) {
      let t = "";
      return e & 1 && (t += "italic "), e & 2 && (t += "bold "), e & 4 && (t += "underline "), e & 8 && (t += "strikethrough "), t.length === 0 && (t = "---"), t;
    }
    _getTokensAtLine(e) {
      const t = this._getStateBeforeLine(e), i = this._tokenizationSupport.tokenize(this._model.getLineContent(e), !0, t), n = this._tokenizationSupport.tokenizeEncoded(this._model.getLineContent(e), !0, t);
      return {
        startState: t,
        tokens1: i.tokens,
        tokens2: n.tokens,
        endState: i.endState
      };
    }
    _getStateBeforeLine(e) {
      let t = this._tokenizationSupport.getInitialState();
      for (let i = 1; i < e; i++)
        t = this._tokenizationSupport.tokenize(this._model.getLineContent(i), !0, t).endState;
      return t;
    }
    getDomNode() {
      return this._domNode;
    }
    getPosition() {
      return {
        position: this._editor.getPosition(),
        preference: [2, 1]
      };
    }
  }
  cw._ID = "editor.contrib.inspectTokensWidget";
  vt($f.ID, $f);
  oe($ae);
  Vt((s, e) => {
    const t = s.getColor(nE);
    if (t) {
      const o = s.type === jo.HIGH_CONTRAST ? 2 : 1;
      e.addRule(`.monaco-editor .tokens-inspect-widget { border: ${o}px solid ${t}; }`), e.addRule(`.monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: ${t}; }`);
    }
    const i = s.getColor(Yd);
    i && e.addRule(`.monaco-editor .tokens-inspect-widget { background-color: ${i}; }`);
    const n = s.getColor(iE);
    n && e.addRule(`.monaco-editor .tokens-inspect-widget { color: ${n}; }`);
  });
  var vD;
  (function(s) {
    s[s.PRESERVE = 0] = "PRESERVE", s[s.LAST = 1] = "LAST";
  })(vD || (vD = {}));
  const qh = {
    Quickaccess: "workbench.contributions.quickaccess"
  };
  class qae {
    constructor() {
      this.providers = [], this.defaultProvider = void 0;
    }
    registerQuickAccessProvider(e) {
      return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), qe(() => {
        this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
      });
    }
    getQuickAccessProviders() {
      return Nh([this.defaultProvider, ...this.providers]);
    }
    getQuickAccessProvider(e) {
      return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
    }
  }
  Si.add(qh.Quickaccess, new qae());
  var Gae = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Zae = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let nv = class I0 {
    constructor(e) {
      this.quickInputService = e, this.registry = Si.as(qh.Quickaccess);
    }
    provide(e) {
      const t = new te();
      t.add(e.onDidAccept(() => {
        const [o] = e.selectedItems;
        o && this.quickInputService.quickAccess.show(o.prefix, { preserveValue: !0 });
      })), t.add(e.onDidChangeValue((o) => {
        const r = this.registry.getQuickAccessProvider(o.substr(I0.PREFIX.length));
        r && r.prefix && r.prefix !== I0.PREFIX && this.quickInputService.quickAccess.show(r.prefix, { preserveValue: !0 });
      }));
      const { editorProviders: i, globalProviders: n } = this.getQuickAccessProviders();
      return e.items = i.length === 0 || n.length === 0 ? [
        ...i.length === 0 ? n : i
      ] : [
        { label: m("globalCommands", "global commands"), type: "separator" },
        ...n,
        { label: m("editorCommands", "editor commands"), type: "separator" },
        ...i
      ], t;
    }
    getQuickAccessProviders() {
      const e = [], t = [];
      for (const i of this.registry.getQuickAccessProviders().sort((n, o) => n.prefix.localeCompare(o.prefix)))
        if (i.prefix !== I0.PREFIX)
          for (const n of i.helpEntries) {
            const o = n.prefix || i.prefix, r = o || "\u2026";
            (n.needsEditor ? t : e).push({
              prefix: o,
              label: r,
              ariaLabel: m("helpPickAriaLabel", "{0}, {1}", r, n.description),
              description: n.description
            });
          }
      return { editorProviders: t, globalProviders: e };
    }
  };
  nv.PREFIX = "?";
  nv = Gae([
    Zae(0, Sl)
  ], nv);
  Si.as(qh.Quickaccess).registerQuickAccessProvider({
    ctor: nv,
    prefix: "",
    helpEntries: [{ description: _D.helpQuickAccessActionLabel, needsEditor: !0 }]
  });
  class _8 {
    constructor(e) {
      this.options = e, this.rangeHighlightDecorationId = void 0;
    }
    provide(e, t) {
      var i;
      const n = new te();
      e.canAcceptInBackground = !!(!((i = this.options) === null || i === void 0) && i.canAcceptInBackground), e.matchOnLabel = e.matchOnDescription = e.matchOnDetail = e.sortByLabel = !1;
      const o = n.add(new Gn());
      return o.value = this.doProvide(e, t), n.add(this.onDidActiveTextEditorControlChange(() => {
        o.value = void 0, o.value = this.doProvide(e, t);
      })), n;
    }
    doProvide(e, t) {
      const i = new te(), n = this.activeTextEditorControl;
      if (n && this.canProvideWithTextEditor(n)) {
        const o = { editor: n }, r = x3(n);
        if (r) {
          let a = ys(n.saveViewState());
          i.add(r.onDidChangeCursorPosition(() => {
            a = ys(n.saveViewState());
          })), o.restoreViewState = () => {
            a && n === this.activeTextEditorControl && n.restoreViewState(a);
          }, i.add(ul(t.onCancellationRequested)(() => {
            var l;
            return (l = o.restoreViewState) === null || l === void 0 ? void 0 : l.call(o);
          }));
        }
        i.add(qe(() => this.clearDecorations(n))), i.add(this.provideWithTextEditor(o, e, t));
      } else
        i.add(this.provideWithoutTextEditor(e, t));
      return i;
    }
    canProvideWithTextEditor(e) {
      return !0;
    }
    gotoLocation({ editor: e }, t) {
      e.setSelection(t.range), e.revealRangeInCenter(t.range, 0), t.preserveFocus || e.focus();
    }
    getModel(e) {
      var t;
      return D3(e) ? (t = e.getModel()) === null || t === void 0 ? void 0 : t.modified : e.getModel();
    }
    addDecorations(e, t) {
      e.changeDecorations((i) => {
        const n = [];
        this.rangeHighlightDecorationId && (n.push(this.rangeHighlightDecorationId.overviewRulerDecorationId), n.push(this.rangeHighlightDecorationId.rangeHighlightId), this.rangeHighlightDecorationId = void 0);
        const o = [
          {
            range: t,
            options: {
              description: "quick-access-range-highlight",
              className: "rangeHighlight",
              isWholeLine: !0
            }
          },
          {
            range: t,
            options: {
              description: "quick-access-range-highlight-overview",
              overviewRuler: {
                color: ai(H$),
                position: Lo.Full
              }
            }
          }
        ], [r, a] = i.deltaDecorations(n, o);
        this.rangeHighlightDecorationId = { rangeHighlightId: r, overviewRulerDecorationId: a };
      });
    }
    clearDecorations(e) {
      const t = this.rangeHighlightDecorationId;
      t && (e.changeDecorations((i) => {
        i.deltaDecorations([
          t.overviewRulerDecorationId,
          t.rangeHighlightId
        ], []);
      }), this.rangeHighlightDecorationId = void 0);
    }
  }
  class dw extends _8 {
    constructor() {
      super({ canAcceptInBackground: !0 });
    }
    provideWithoutTextEditor(e) {
      const t = m("cannotRunGotoLine", "Open a text editor first to go to a line.");
      return e.items = [{ label: t }], e.ariaLabel = t, z.None;
    }
    provideWithTextEditor(e, t, i) {
      const n = e.editor, o = new te();
      o.add(t.onDidAccept((l) => {
        const [c] = t.selectedItems;
        if (c) {
          if (!this.isValidLineNumber(n, c.lineNumber))
            return;
          this.gotoLocation(e, { range: this.toRange(c.lineNumber, c.column), keyMods: t.keyMods, preserveFocus: l.inBackground }), l.inBackground || t.hide();
        }
      }));
      const r = () => {
        const l = this.parsePosition(n, t.value.trim().substr(dw.PREFIX.length)), c = this.getPickLabel(n, l.lineNumber, l.column);
        if (t.items = [{
          lineNumber: l.lineNumber,
          column: l.column,
          label: c
        }], t.ariaLabel = c, !this.isValidLineNumber(n, l.lineNumber)) {
          this.clearDecorations(n);
          return;
        }
        const d = this.toRange(l.lineNumber, l.column);
        n.revealRangeInCenter(d, 0), this.addDecorations(n, d);
      };
      r(), o.add(t.onDidChangeValue(() => r()));
      const a = x3(n);
      return a && a.getOptions().get(60).renderType === 2 && (a.updateOptions({ lineNumbers: "on" }), o.add(qe(() => a.updateOptions({ lineNumbers: "relative" })))), o;
    }
    toRange(e = 1, t = 1) {
      return {
        startLineNumber: e,
        startColumn: t,
        endLineNumber: e,
        endColumn: t
      };
    }
    parsePosition(e, t) {
      const i = t.split(/,|:|#/).map((o) => parseInt(o, 10)).filter((o) => !isNaN(o)), n = this.lineCount(e) + 1;
      return {
        lineNumber: i[0] > 0 ? i[0] : n + i[0],
        column: i[1]
      };
    }
    getPickLabel(e, t, i) {
      if (this.isValidLineNumber(e, t))
        return this.isValidColumn(e, t, i) ? m("gotoLineColumnLabel", "Go to line {0} and character {1}.", t, i) : m("gotoLineLabel", "Go to line {0}.", t);
      const n = e.getPosition() || { lineNumber: 1, column: 1 }, o = this.lineCount(e);
      return o > 1 ? m("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", n.lineNumber, n.column, o) : m("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", n.lineNumber, n.column);
    }
    isValidLineNumber(e, t) {
      return !t || typeof t != "number" ? !1 : t > 0 && t <= this.lineCount(e);
    }
    isValidColumn(e, t, i) {
      if (!i || typeof i != "number")
        return !1;
      const n = this.getModel(e);
      if (!n)
        return !1;
      const o = { lineNumber: t, column: i };
      return n.validatePosition(o).equals(o);
    }
    lineCount(e) {
      var t, i;
      return (i = (t = this.getModel(e)) === null || t === void 0 ? void 0 : t.getLineCount()) !== null && i !== void 0 ? i : 0;
    }
  }
  dw.PREFIX = ":";
  var Yae = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Xae = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Up = class extends dw {
    constructor(e) {
      super(), this.editorService = e, this.onDidActiveTextEditorControlChange = be.None;
    }
    get activeTextEditorControl() {
      return ys(this.editorService.getFocusedCodeEditor());
    }
  };
  Up = Yae([
    Xae(0, St)
  ], Up);
  Si.as(qh.Quickaccess).registerQuickAccessProvider({
    ctor: Up,
    prefix: Up.PREFIX,
    helpEntries: [{ description: ev.gotoLineActionLabel, needsEditor: !0 }]
  });
  class Qae extends ge {
    constructor() {
      super({
        id: "editor.action.gotoLine",
        label: ev.gotoLineActionLabel,
        alias: "Go to Line/Column...",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 2085,
          mac: { primary: 293 },
          weight: 100
        }
      });
    }
    run(e) {
      e.get(Sl).quickAccess.show(Up.PREFIX);
    }
  }
  oe(Qae);
  const b8 = [void 0, []];
  function my(s, e, t = 0, i = 0) {
    const n = e;
    return n.values && n.values.length > 1 ? Jae(s, n.values, t, i) : v8(s, e, t, i);
  }
  function Jae(s, e, t, i) {
    let n = 0;
    const o = [];
    for (const r of e) {
      const [a, l] = v8(s, r, t, i);
      if (typeof a != "number")
        return b8;
      n += a, o.push(...l);
    }
    return [n, ele(o)];
  }
  function v8(s, e, t, i) {
    const n = xf(e.original, e.originalLowercase, t, s, s.toLowerCase(), i, !0);
    return n ? [n[0], pC(n)] : b8;
  }
  Object.freeze({ score: 0 });
  function ele(s) {
    const e = s.sort((n, o) => n.start - o.start), t = [];
    let i;
    for (const n of e)
      !i || !tle(i, n) ? (i = n, t.push(n)) : (i.start = Math.min(i.start, n.start), i.end = Math.max(i.end, n.end));
    return t;
  }
  function tle(s, e) {
    return !(s.end < e.start || e.end < s.start);
  }
  function mR(s) {
    return s.startsWith('"') && s.endsWith('"');
  }
  const C8 = " ";
  function CD(s) {
    typeof s != "string" && (s = "");
    const e = s.toLowerCase(), { pathNormalized: t, normalized: i, normalizedLowercase: n } = pR(s), o = t.indexOf(ta) >= 0, r = mR(s);
    let a;
    const l = s.split(C8);
    if (l.length > 1)
      for (const c of l) {
        const d = mR(c), { pathNormalized: h, normalized: u, normalizedLowercase: f } = pR(c);
        u && (a || (a = []), a.push({
          original: c,
          originalLowercase: c.toLowerCase(),
          pathNormalized: h,
          normalized: u,
          normalizedLowercase: f,
          expectContiguousMatch: d
        }));
      }
    return { original: s, originalLowercase: e, pathNormalized: t, normalized: i, normalizedLowercase: n, values: a, containsPathSeparator: o, expectContiguousMatch: r };
  }
  function pR(s) {
    let e;
    rn ? e = s.replace(/\//g, ta) : e = s.replace(/\\/g, ta);
    const t = KW(e).replace(/\s|"/g, "");
    return {
      pathNormalized: e,
      normalized: t,
      normalizedLowercase: t.toLowerCase()
    };
  }
  function _R(s) {
    return Array.isArray(s) ? CD(s.map((e) => e.original).join(C8)) : CD(s.original);
  }
  var ile = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, bR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Bg = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Go = class wD extends _8 {
    constructor(e, t, i = /* @__PURE__ */ Object.create(null)) {
      super(i), this._languageFeaturesService = e, this._outlineModelService = t, this.options = i, this.options.canAcceptInBackground = !0;
    }
    provideWithoutTextEditor(e) {
      return this.provideLabelPick(e, m("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information.")), z.None;
    }
    provideWithTextEditor(e, t, i) {
      const n = e.editor, o = this.getModel(n);
      return o ? this._languageFeaturesService.documentSymbolProvider.has(o) ? this.doProvideWithEditorSymbols(e, o, t, i) : this.doProvideWithoutEditorSymbols(e, o, t, i) : z.None;
    }
    doProvideWithoutEditorSymbols(e, t, i, n) {
      const o = new te();
      return this.provideLabelPick(i, m("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information.")), Bg(this, void 0, void 0, function* () {
        !(yield this.waitForLanguageSymbolRegistry(t, o)) || n.isCancellationRequested || o.add(this.doProvideWithEditorSymbols(e, t, i, n));
      }), o;
    }
    provideLabelPick(e, t) {
      e.items = [{ label: t, index: 0, kind: 14 }], e.ariaLabel = t;
    }
    waitForLanguageSymbolRegistry(e, t) {
      return Bg(this, void 0, void 0, function* () {
        if (this._languageFeaturesService.documentSymbolProvider.has(e))
          return !0;
        const i = new wI(), n = t.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
          this._languageFeaturesService.documentSymbolProvider.has(e) && (n.dispose(), i.complete(!0));
        }));
        return t.add(qe(() => i.complete(!1))), i.p;
      });
    }
    doProvideWithEditorSymbols(e, t, i, n) {
      const o = e.editor, r = new te();
      r.add(i.onDidAccept((h) => {
        const [u] = i.selectedItems;
        u && u.range && (this.gotoLocation(e, { range: u.range.selection, keyMods: i.keyMods, preserveFocus: h.inBackground }), h.inBackground || i.hide());
      })), r.add(i.onDidTriggerItemButton(({ item: h }) => {
        h && h.range && (this.gotoLocation(e, { range: h.range.selection, keyMods: i.keyMods, forceSideBySide: !0 }), i.hide());
      }));
      const a = this.getDocumentSymbols(t, n);
      let l;
      const c = () => Bg(this, void 0, void 0, function* () {
        l?.dispose(!0), i.busy = !1, l = new bn(n), i.busy = !0;
        try {
          const h = CD(i.value.substr(wD.PREFIX.length).trim()), u = yield this.doGetSymbolPicks(a, h, void 0, l.token);
          if (n.isCancellationRequested)
            return;
          u.length > 0 ? i.items = u : h.original.length > 0 ? this.provideLabelPick(i, m("noMatchingSymbolResults", "No matching editor symbols")) : this.provideLabelPick(i, m("noSymbolResults", "No editor symbols"));
        } finally {
          n.isCancellationRequested || (i.busy = !1);
        }
      });
      r.add(i.onDidChangeValue(() => c())), c();
      let d = !0;
      return r.add(i.onDidChangeActive(() => {
        const [h] = i.activeItems;
        if (h && h.range) {
          if (d) {
            d = !1;
            return;
          }
          o.revealRangeInCenter(h.range.selection, 0), this.addDecorations(o, h.range.decoration);
        }
      })), r;
    }
    doGetSymbolPicks(e, t, i, n) {
      return Bg(this, void 0, void 0, function* () {
        const o = yield e;
        if (n.isCancellationRequested)
          return [];
        const r = t.original.indexOf(wD.SCOPE_PREFIX) === 0, a = r ? 1 : 0;
        let l, c;
        t.values && t.values.length > 1 ? (l = _R(t.values[0]), c = _R(t.values.slice(1))) : l = t;
        const d = [];
        for (let g = 0; g < o.length; g++) {
          const _ = o[g], b = $W(_.name), C = `$(${yL.toIcon(_.kind).id}) ${b}`, v = C.length - b.length;
          let w = _.containerName;
          i?.extraContainerLabel && (w ? w = `${i.extraContainerLabel} \u2022 ${w}` : w = i.extraContainerLabel);
          let S, L, x, y;
          if (t.original.length > a) {
            let I = !1;
            if (l !== t && ([S, L] = my(C, Object.assign(Object.assign({}, t), { values: void 0 }), a, v), typeof S == "number" && (I = !0)), typeof S != "number" && ([S, L] = my(C, l, a, v), typeof S != "number"))
              continue;
            if (!I && c) {
              if (w && c.original.length > 0 && ([x, y] = my(w, c)), typeof x != "number")
                continue;
              typeof S == "number" && (S += x);
            }
          }
          const k = _.tags && _.tags.indexOf(1) >= 0;
          d.push({
            index: g,
            kind: _.kind,
            score: S,
            label: C,
            ariaLabel: b,
            description: w,
            highlights: k ? void 0 : {
              label: L,
              description: y
            },
            range: {
              selection: D.collapseToStart(_.selectionRange),
              decoration: _.range
            },
            strikethrough: k,
            buttons: (() => {
              var I, F;
              const R = !((I = this.options) === null || I === void 0) && I.openSideBySideDirection ? (F = this.options) === null || F === void 0 ? void 0 : F.openSideBySideDirection() : void 0;
              if (!!R)
                return [
                  {
                    iconClass: R === "right" ? p.splitHorizontal.classNames : p.splitVertical.classNames,
                    tooltip: R === "right" ? m("openToSide", "Open to the Side") : m("openToBottom", "Open to the Bottom")
                  }
                ];
            })()
          });
        }
        const h = d.sort((g, _) => r ? this.compareByKindAndScore(g, _) : this.compareByScore(g, _));
        let u = [];
        if (r) {
          let C = function() {
            _ && typeof g == "number" && b > 0 && (_.label = uo(_y[g] || py, b));
          };
          var f = C;
          let g, _, b = 0;
          for (const v of h)
            g !== v.kind ? (C(), g = v.kind, b = 1, _ = { type: "separator" }, u.push(_)) : b++, u.push(v);
          C();
        } else
          h.length > 0 && (u = [
            { label: m("symbols", "symbols ({0})", d.length), type: "separator" },
            ...h
          ]);
        return u;
      });
    }
    compareByScore(e, t) {
      if (typeof e.score != "number" && typeof t.score == "number")
        return 1;
      if (typeof e.score == "number" && typeof t.score != "number")
        return -1;
      if (typeof e.score == "number" && typeof t.score == "number") {
        if (e.score > t.score)
          return -1;
        if (e.score < t.score)
          return 1;
      }
      return e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
    }
    compareByKindAndScore(e, t) {
      const i = _y[e.kind] || py, n = _y[t.kind] || py, o = i.localeCompare(n);
      return o === 0 ? this.compareByScore(e, t) : o;
    }
    getDocumentSymbols(e, t) {
      return Bg(this, void 0, void 0, function* () {
        const i = yield this._outlineModelService.getOrCreate(e, t);
        return t.isCancellationRequested ? [] : i.asListOfDocumentSymbols();
      });
    }
  };
  Go.PREFIX = "@";
  Go.SCOPE_PREFIX = ":";
  Go.PREFIX_BY_CATEGORY = `${Go.PREFIX}${Go.SCOPE_PREFIX}`;
  Go = ile([
    bR(0, me),
    bR(1, jC)
  ], Go);
  const py = m("property", "properties ({0})"), _y = {
    [5]: m("method", "methods ({0})"),
    [11]: m("function", "functions ({0})"),
    [8]: m("_constructor", "constructors ({0})"),
    [12]: m("variable", "variables ({0})"),
    [4]: m("class", "classes ({0})"),
    [22]: m("struct", "structs ({0})"),
    [23]: m("event", "events ({0})"),
    [24]: m("operator", "operators ({0})"),
    [10]: m("interface", "interfaces ({0})"),
    [2]: m("namespace", "namespaces ({0})"),
    [3]: m("package", "packages ({0})"),
    [25]: m("typeParameter", "type parameters ({0})"),
    [1]: m("modules", "modules ({0})"),
    [6]: m("property", "properties ({0})"),
    [9]: m("enum", "enumerations ({0})"),
    [21]: m("enumMember", "enumeration members ({0})"),
    [14]: m("string", "strings ({0})"),
    [0]: m("file", "files ({0})"),
    [17]: m("array", "arrays ({0})"),
    [15]: m("number", "numbers ({0})"),
    [16]: m("boolean", "booleans ({0})"),
    [18]: m("object", "objects ({0})"),
    [19]: m("key", "keys ({0})"),
    [7]: m("field", "fields ({0})"),
    [13]: m("constant", "constants ({0})")
  };
  var nle = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, by = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let SD = class extends Go {
    constructor(e, t, i) {
      super(t, i), this.editorService = e, this.onDidActiveTextEditorControlChange = be.None;
    }
    get activeTextEditorControl() {
      return ys(this.editorService.getFocusedCodeEditor());
    }
  };
  SD = nle([
    by(0, St),
    by(1, me),
    by(2, jC)
  ], SD);
  Si.as(qh.Quickaccess).registerQuickAccessProvider({
    ctor: SD,
    prefix: Go.PREFIX,
    helpEntries: [
      { description: zp.quickOutlineActionLabel, prefix: Go.PREFIX, needsEditor: !0 },
      { description: zp.quickOutlineByCategoryActionLabel, prefix: Go.PREFIX_BY_CATEGORY, needsEditor: !0 }
    ]
  });
  class sle extends ge {
    constructor() {
      super({
        id: "editor.action.quickOutline",
        label: zp.quickOutlineActionLabel,
        alias: "Go to Symbol...",
        precondition: T.hasDocumentSymbolProvider,
        kbOpts: {
          kbExpr: T.focus,
          primary: 3117,
          weight: 100
        },
        contextMenuOpts: {
          group: "navigation",
          order: 3
        }
      });
    }
    run(e) {
      e.get(Sl).quickAccess.show(Go.PREFIX);
    }
  }
  oe(sle);
  function vy(s, e) {
    return e && (s.stack || s.stacktrace) ? m("stackTrace.format", "{0}: {1}", CR(s), vR(s.stack) || vR(s.stacktrace)) : CR(s);
  }
  function vR(s) {
    return Array.isArray(s) ? s.join(`
`) : s;
  }
  function CR(s) {
    return typeof s.code == "string" && typeof s.errno == "number" && typeof s.syscall == "string" ? m("nodeExceptionMessage", "A system error occurred ({0})", s.message) : s.message || m("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  }
  function w8(s = null, e = !1) {
    if (!s)
      return m("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
    if (Array.isArray(s)) {
      const t = Nh(s), i = w8(t[0], e);
      return t.length > 1 ? m("error.moreErrors", "{0} ({1} errors in total)", i, t.length) : i;
    }
    if (vo(s))
      return s;
    if (s.detail) {
      const t = s.detail;
      if (t.error)
        return vy(t.error, e);
      if (t.exception)
        return vy(t.exception, e);
    }
    return s.stack ? vy(s, e) : s.message ? s.message : m("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  }
  var Fb = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, Ou;
  (function(s) {
    s[s.NO_ACTION = 0] = "NO_ACTION", s[s.CLOSE_PICKER = 1] = "CLOSE_PICKER", s[s.REFRESH_PICKER = 2] = "REFRESH_PICKER", s[s.REMOVE_ITEM = 3] = "REMOVE_ITEM";
  })(Ou || (Ou = {}));
  function Cy(s) {
    const e = s;
    return Array.isArray(e.items);
  }
  function ole(s) {
    const e = s;
    return !!e.picks && e.additionalPicks instanceof Promise;
  }
  class hw extends z {
    constructor(e, t) {
      super(), this.prefix = e, this.options = t;
    }
    provide(e, t) {
      var i;
      const n = new te();
      e.canAcceptInBackground = !!(!((i = this.options) === null || i === void 0) && i.canAcceptInBackground), e.matchOnLabel = e.matchOnDescription = e.matchOnDetail = e.sortByLabel = !1;
      let o;
      const r = n.add(new Gn()), a = () => Fb(this, void 0, void 0, function* () {
        const l = r.value = new te();
        o?.dispose(!0), e.busy = !1, o = new bn(t);
        const c = o.token, d = e.value.substr(this.prefix.length).trim(), h = this._getPicks(d, l, c), u = (f, g) => {
          var _;
          let b, C;
          if (Cy(f) ? (b = f.items, C = f.active) : b = f, b.length === 0) {
            if (g)
              return !1;
            d.length > 0 && ((_ = this.options) === null || _ === void 0 ? void 0 : _.noResultsPick) && (b = [this.options.noResultsPick]);
          }
          return e.items = b, C && (e.activeItems = [C]), !0;
        };
        if (h !== null)
          if (ole(h)) {
            let f = !1, g = !1;
            yield Promise.all([
              (() => Fb(this, void 0, void 0, function* () {
                yield gc(hw.FAST_PICKS_RACE_DELAY), !c.isCancellationRequested && (g || (f = u(h.picks, !0)));
              }))(),
              (() => Fb(this, void 0, void 0, function* () {
                e.busy = !0;
                try {
                  const _ = yield h.additionalPicks;
                  if (c.isCancellationRequested)
                    return;
                  let b, C;
                  Cy(h.picks) ? (b = h.picks.items, C = h.picks.active) : b = h.picks;
                  let v, w;
                  if (Cy(_) ? (v = _.items, w = _.active) : v = _, v.length > 0 || !f) {
                    let S;
                    if (!C && !w) {
                      const L = e.activeItems[0];
                      L && b.indexOf(L) !== -1 && (S = L);
                    }
                    u({
                      items: [...b, ...v],
                      active: C || w || S
                    });
                  }
                } finally {
                  c.isCancellationRequested || (e.busy = !1), g = !0;
                }
              }))()
            ]);
          } else if (!(h instanceof Promise))
            u(h);
          else {
            e.busy = !0;
            try {
              const f = yield h;
              if (c.isCancellationRequested)
                return;
              u(f);
            } finally {
              c.isCancellationRequested || (e.busy = !1);
            }
          }
      });
      return n.add(e.onDidChangeValue(() => a())), a(), n.add(e.onDidAccept((l) => {
        const [c] = e.selectedItems;
        typeof c?.accept == "function" && (l.inBackground || e.hide(), c.accept(e.keyMods, l));
      })), n.add(e.onDidTriggerItemButton(({ button: l, item: c }) => Fb(this, void 0, void 0, function* () {
        var d, h;
        if (typeof c.trigger == "function") {
          const u = (h = (d = c.buttons) === null || d === void 0 ? void 0 : d.indexOf(l)) !== null && h !== void 0 ? h : -1;
          if (u >= 0) {
            const f = c.trigger(u, e.keyMods), g = typeof f == "number" ? f : yield f;
            if (t.isCancellationRequested)
              return;
            switch (g) {
              case Ou.NO_ACTION:
                break;
              case Ou.CLOSE_PICKER:
                e.hide();
                break;
              case Ou.REFRESH_PICKER:
                a();
                break;
              case Ou.REMOVE_ITEM: {
                const _ = e.items.indexOf(c);
                if (_ !== -1) {
                  const b = e.items.slice(), C = b.splice(_, 1), v = e.activeItems.filter((S) => S !== C[0]), w = e.keepScrollPosition;
                  e.keepScrollPosition = !0, e.items = b, v && (e.activeItems = v), e.keepScrollPosition = w;
                }
                break;
              }
            }
          }
        }
      }))), n;
    }
  }
  hw.FAST_PICKS_RACE_DELAY = 200;
  var S8 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, fd = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, wR = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let $p = class E0 extends hw {
    constructor(e, t, i, n, o, r) {
      super(E0.PREFIX, e), this.instantiationService = t, this.keybindingService = i, this.commandService = n, this.telemetryService = o, this.dialogService = r, this.commandsHistory = this._register(this.instantiationService.createInstance(yh)), this.options = e;
    }
    _getPicks(e, t, i) {
      return wR(this, void 0, void 0, function* () {
        const n = yield this.getCommandPicks(t, i);
        if (i.isCancellationRequested)
          return [];
        const o = [];
        for (const c of n) {
          const d = ys(E0.WORD_FILTER(e, c.label)), h = c.commandAlias ? ys(E0.WORD_FILTER(e, c.commandAlias)) : void 0;
          d || h ? (c.highlights = {
            label: d,
            detail: this.options.showAlias ? h : void 0
          }, o.push(c)) : e === c.commandId && o.push(c);
        }
        const r = /* @__PURE__ */ new Map();
        for (const c of o) {
          const d = r.get(c.label);
          d ? (c.description = c.commandId, d.description = d.commandId) : r.set(c.label, c);
        }
        o.sort((c, d) => {
          const h = this.commandsHistory.peek(c.commandId), u = this.commandsHistory.peek(d.commandId);
          return h && u ? h > u ? -1 : 1 : h ? -1 : u ? 1 : c.label.localeCompare(d.label);
        });
        const a = [];
        let l = !1;
        for (let c = 0; c < o.length; c++) {
          const d = o[c], h = this.keybindingService.lookupKeybinding(d.commandId), u = h ? m("commandPickAriaLabelWithKeybinding", "{0}, {1}", d.label, h.getAriaLabel()) : d.label;
          c === 0 && this.commandsHistory.peek(d.commandId) && (a.push({ type: "separator", label: m("recentlyUsed", "recently used") }), l = !0), c !== 0 && l && !this.commandsHistory.peek(d.commandId) && (a.push({ type: "separator", label: m("morecCommands", "other commands") }), l = !1), a.push(Object.assign(Object.assign({}, d), { ariaLabel: u, detail: this.options.showAlias && d.commandAlias !== d.label ? d.commandAlias : void 0, keybinding: h, accept: () => wR(this, void 0, void 0, function* () {
            this.commandsHistory.push(d.commandId), this.telemetryService.publicLog2("workbenchActionExecuted", {
              id: d.commandId,
              from: "quick open"
            });
            try {
              yield this.commandService.executeCommand(d.commandId);
            } catch (f) {
              va(f) || this.dialogService.show(Zt.Error, m("canNotRun", "Command '{0}' resulted in an error ({1})", d.label, w8(f)));
            }
          }) }));
        }
        return a;
      });
    }
  };
  $p.PREFIX = ">";
  $p.WORD_FILTER = BE(gC, MZ, VF);
  $p = S8([
    fd(1, et),
    fd(2, ci),
    fd(3, wi),
    fd(4, Ca),
    fd(5, N_)
  ], $p);
  let yh = class zi extends z {
    constructor(e, t) {
      super(), this.storageService = e, this.configurationService = t, this.configuredCommandsHistoryLength = 0, this.updateConfiguration(), this.load(), this.registerListeners();
    }
    registerListeners() {
      this._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));
    }
    updateConfiguration() {
      this.configuredCommandsHistoryLength = zi.getConfiguredCommandHistoryLength(this.configurationService), zi.cache && zi.cache.limit !== this.configuredCommandsHistoryLength && (zi.cache.limit = this.configuredCommandsHistoryLength, zi.saveState(this.storageService));
    }
    load() {
      const e = this.storageService.get(zi.PREF_KEY_CACHE, 0);
      let t;
      if (e)
        try {
          t = JSON.parse(e);
        } catch {
        }
      const i = zi.cache = new Wc(this.configuredCommandsHistoryLength, 1);
      if (t) {
        let n;
        t.usesLRU ? n = t.entries : n = t.entries.sort((o, r) => o.value - r.value), n.forEach((o) => i.set(o.key, o.value));
      }
      zi.counter = this.storageService.getNumber(zi.PREF_KEY_COUNTER, 0, zi.counter);
    }
    push(e) {
      !zi.cache || (zi.cache.set(e, zi.counter++), zi.saveState(this.storageService));
    }
    peek(e) {
      var t;
      return (t = zi.cache) === null || t === void 0 ? void 0 : t.peek(e);
    }
    static saveState(e) {
      if (!zi.cache)
        return;
      const t = { usesLRU: !0, entries: [] };
      zi.cache.forEach((i, n) => t.entries.push({ key: n, value: i })), e.store(zi.PREF_KEY_CACHE, JSON.stringify(t), 0, 0), e.store(zi.PREF_KEY_COUNTER, zi.counter, 0, 0);
    }
    static getConfiguredCommandHistoryLength(e) {
      var t, i;
      const o = (i = (t = e.getValue().workbench) === null || t === void 0 ? void 0 : t.commandPalette) === null || i === void 0 ? void 0 : i.history;
      return typeof o == "number" ? o : zi.DEFAULT_COMMANDS_HISTORY_LENGTH;
    }
  };
  yh.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
  yh.PREF_KEY_CACHE = "commandPalette.mru.cache";
  yh.PREF_KEY_COUNTER = "commandPalette.mru.counter";
  yh.counter = 1;
  yh = S8([
    fd(0, La),
    fd(1, At)
  ], yh);
  class rle extends $p {
    constructor(e, t, i, n, o, r) {
      super(e, t, i, n, o, r);
    }
    getCodeEditorCommandPicks() {
      const e = this.activeTextEditorControl;
      if (!e)
        return [];
      const t = [];
      for (const i of e.getSupportedActions())
        t.push({
          commandId: i.id,
          commandAlias: i.alias,
          label: $E(i.label) || i.id
        });
      return t;
    }
  }
  var ale = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, uu = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, lle = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let jp = class extends rle {
    constructor(e, t, i, n, o, r) {
      super({ showAlias: !1 }, e, i, n, o, r), this.codeEditorService = t;
    }
    get activeTextEditorControl() {
      return ys(this.codeEditorService.getFocusedCodeEditor());
    }
    getCommandPicks() {
      return lle(this, void 0, void 0, function* () {
        return this.getCodeEditorCommandPicks();
      });
    }
  };
  jp = ale([
    uu(0, et),
    uu(1, St),
    uu(2, ci),
    uu(3, wi),
    uu(4, Ca),
    uu(5, N_)
  ], jp);
  Si.as(qh.Quickaccess).registerQuickAccessProvider({
    ctor: jp,
    prefix: jp.PREFIX,
    helpEntries: [{ description: tv.quickCommandHelp, needsEditor: !0 }]
  });
  class cle extends ge {
    constructor() {
      super({
        id: "editor.action.quickCommand",
        label: tv.quickCommandActionLabel,
        alias: "Command Palette",
        precondition: void 0,
        kbOpts: {
          kbExpr: T.focus,
          primary: 59,
          weight: 100
        },
        contextMenuOpts: {
          group: "z_commands",
          order: 1
        }
      });
    }
    run(e) {
      e.get(Sl).quickAccess.show(jp.PREFIX);
    }
  }
  oe(cle);
  var dle = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, fu = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let yD = class extends Ec {
    constructor(e, t, i, n, o, r, a) {
      super(!0, e, t, i, n, o, r, a);
    }
  };
  yD = dle([
    fu(1, Fe),
    fu(2, St),
    fu(3, yi),
    fu(4, et),
    fu(5, La),
    fu(6, At)
  ], yD);
  vt(Ec.ID, yD);
  var LD;
  (function(s) {
    s[s.Unknown = 0] = "Unknown", s[s.Disabled = 1] = "Disabled", s[s.Enabled = 2] = "Enabled";
  })(LD || (LD = {}));
  var kD;
  (function(s) {
    s[s.KeepWhitespace = 1] = "KeepWhitespace", s[s.InsertAsSnippet = 4] = "InsertAsSnippet";
  })(kD || (kD = {}));
  var DD;
  (function(s) {
    s[s.Method = 0] = "Method", s[s.Function = 1] = "Function", s[s.Constructor = 2] = "Constructor", s[s.Field = 3] = "Field", s[s.Variable = 4] = "Variable", s[s.Class = 5] = "Class", s[s.Struct = 6] = "Struct", s[s.Interface = 7] = "Interface", s[s.Module = 8] = "Module", s[s.Property = 9] = "Property", s[s.Event = 10] = "Event", s[s.Operator = 11] = "Operator", s[s.Unit = 12] = "Unit", s[s.Value = 13] = "Value", s[s.Constant = 14] = "Constant", s[s.Enum = 15] = "Enum", s[s.EnumMember = 16] = "EnumMember", s[s.Keyword = 17] = "Keyword", s[s.Text = 18] = "Text", s[s.Color = 19] = "Color", s[s.File = 20] = "File", s[s.Reference = 21] = "Reference", s[s.Customcolor = 22] = "Customcolor", s[s.Folder = 23] = "Folder", s[s.TypeParameter = 24] = "TypeParameter", s[s.User = 25] = "User", s[s.Issue = 26] = "Issue", s[s.Snippet = 27] = "Snippet";
  })(DD || (DD = {}));
  var xD;
  (function(s) {
    s[s.Deprecated = 1] = "Deprecated";
  })(xD || (xD = {}));
  var ID;
  (function(s) {
    s[s.Invoke = 0] = "Invoke", s[s.TriggerCharacter = 1] = "TriggerCharacter", s[s.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
  })(ID || (ID = {}));
  var ED;
  (function(s) {
    s[s.EXACT = 0] = "EXACT", s[s.ABOVE = 1] = "ABOVE", s[s.BELOW = 2] = "BELOW";
  })(ED || (ED = {}));
  var ND;
  (function(s) {
    s[s.NotSet = 0] = "NotSet", s[s.ContentFlush = 1] = "ContentFlush", s[s.RecoverFromMarkers = 2] = "RecoverFromMarkers", s[s.Explicit = 3] = "Explicit", s[s.Paste = 4] = "Paste", s[s.Undo = 5] = "Undo", s[s.Redo = 6] = "Redo";
  })(ND || (ND = {}));
  var TD;
  (function(s) {
    s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
  })(TD || (TD = {}));
  var MD;
  (function(s) {
    s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
  })(MD || (MD = {}));
  var AD;
  (function(s) {
    s[s.None = 0] = "None", s[s.Keep = 1] = "Keep", s[s.Brackets = 2] = "Brackets", s[s.Advanced = 3] = "Advanced", s[s.Full = 4] = "Full";
  })(AD || (AD = {}));
  var RD;
  (function(s) {
    s[s.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", s[s.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", s[s.accessibilitySupport = 2] = "accessibilitySupport", s[s.accessibilityPageSize = 3] = "accessibilityPageSize", s[s.ariaLabel = 4] = "ariaLabel", s[s.autoClosingBrackets = 5] = "autoClosingBrackets", s[s.autoClosingDelete = 6] = "autoClosingDelete", s[s.autoClosingOvertype = 7] = "autoClosingOvertype", s[s.autoClosingQuotes = 8] = "autoClosingQuotes", s[s.autoIndent = 9] = "autoIndent", s[s.automaticLayout = 10] = "automaticLayout", s[s.autoSurround = 11] = "autoSurround", s[s.bracketPairColorization = 12] = "bracketPairColorization", s[s.guides = 13] = "guides", s[s.codeLens = 14] = "codeLens", s[s.codeLensFontFamily = 15] = "codeLensFontFamily", s[s.codeLensFontSize = 16] = "codeLensFontSize", s[s.colorDecorators = 17] = "colorDecorators", s[s.columnSelection = 18] = "columnSelection", s[s.comments = 19] = "comments", s[s.contextmenu = 20] = "contextmenu", s[s.copyWithSyntaxHighlighting = 21] = "copyWithSyntaxHighlighting", s[s.cursorBlinking = 22] = "cursorBlinking", s[s.cursorSmoothCaretAnimation = 23] = "cursorSmoothCaretAnimation", s[s.cursorStyle = 24] = "cursorStyle", s[s.cursorSurroundingLines = 25] = "cursorSurroundingLines", s[s.cursorSurroundingLinesStyle = 26] = "cursorSurroundingLinesStyle", s[s.cursorWidth = 27] = "cursorWidth", s[s.disableLayerHinting = 28] = "disableLayerHinting", s[s.disableMonospaceOptimizations = 29] = "disableMonospaceOptimizations", s[s.domReadOnly = 30] = "domReadOnly", s[s.dragAndDrop = 31] = "dragAndDrop", s[s.emptySelectionClipboard = 32] = "emptySelectionClipboard", s[s.extraEditorClassName = 33] = "extraEditorClassName", s[s.fastScrollSensitivity = 34] = "fastScrollSensitivity", s[s.find = 35] = "find", s[s.fixedOverflowWidgets = 36] = "fixedOverflowWidgets", s[s.folding = 37] = "folding", s[s.foldingStrategy = 38] = "foldingStrategy", s[s.foldingHighlight = 39] = "foldingHighlight", s[s.foldingImportsByDefault = 40] = "foldingImportsByDefault", s[s.foldingMaximumRegions = 41] = "foldingMaximumRegions", s[s.unfoldOnClickAfterEndOfLine = 42] = "unfoldOnClickAfterEndOfLine", s[s.fontFamily = 43] = "fontFamily", s[s.fontInfo = 44] = "fontInfo", s[s.fontLigatures = 45] = "fontLigatures", s[s.fontSize = 46] = "fontSize", s[s.fontWeight = 47] = "fontWeight", s[s.formatOnPaste = 48] = "formatOnPaste", s[s.formatOnType = 49] = "formatOnType", s[s.glyphMargin = 50] = "glyphMargin", s[s.gotoLocation = 51] = "gotoLocation", s[s.hideCursorInOverviewRuler = 52] = "hideCursorInOverviewRuler", s[s.hover = 53] = "hover", s[s.inDiffEditor = 54] = "inDiffEditor", s[s.inlineSuggest = 55] = "inlineSuggest", s[s.letterSpacing = 56] = "letterSpacing", s[s.lightbulb = 57] = "lightbulb", s[s.lineDecorationsWidth = 58] = "lineDecorationsWidth", s[s.lineHeight = 59] = "lineHeight", s[s.lineNumbers = 60] = "lineNumbers", s[s.lineNumbersMinChars = 61] = "lineNumbersMinChars", s[s.linkedEditing = 62] = "linkedEditing", s[s.links = 63] = "links", s[s.matchBrackets = 64] = "matchBrackets", s[s.minimap = 65] = "minimap", s[s.mouseStyle = 66] = "mouseStyle", s[s.mouseWheelScrollSensitivity = 67] = "mouseWheelScrollSensitivity", s[s.mouseWheelZoom = 68] = "mouseWheelZoom", s[s.multiCursorMergeOverlapping = 69] = "multiCursorMergeOverlapping", s[s.multiCursorModifier = 70] = "multiCursorModifier", s[s.multiCursorPaste = 71] = "multiCursorPaste", s[s.occurrencesHighlight = 72] = "occurrencesHighlight", s[s.overviewRulerBorder = 73] = "overviewRulerBorder", s[s.overviewRulerLanes = 74] = "overviewRulerLanes", s[s.padding = 75] = "padding", s[s.parameterHints = 76] = "parameterHints", s[s.peekWidgetDefaultFocus = 77] = "peekWidgetDefaultFocus", s[s.definitionLinkOpensInPeek = 78] = "definitionLinkOpensInPeek", s[s.quickSuggestions = 79] = "quickSuggestions", s[s.quickSuggestionsDelay = 80] = "quickSuggestionsDelay", s[s.readOnly = 81] = "readOnly", s[s.renameOnType = 82] = "renameOnType", s[s.renderControlCharacters = 83] = "renderControlCharacters", s[s.renderFinalNewline = 84] = "renderFinalNewline", s[s.renderLineHighlight = 85] = "renderLineHighlight", s[s.renderLineHighlightOnlyWhenFocus = 86] = "renderLineHighlightOnlyWhenFocus", s[s.renderValidationDecorations = 87] = "renderValidationDecorations", s[s.renderWhitespace = 88] = "renderWhitespace", s[s.revealHorizontalRightPadding = 89] = "revealHorizontalRightPadding", s[s.roundedSelection = 90] = "roundedSelection", s[s.rulers = 91] = "rulers", s[s.scrollbar = 92] = "scrollbar", s[s.scrollBeyondLastColumn = 93] = "scrollBeyondLastColumn", s[s.scrollBeyondLastLine = 94] = "scrollBeyondLastLine", s[s.scrollPredominantAxis = 95] = "scrollPredominantAxis", s[s.selectionClipboard = 96] = "selectionClipboard", s[s.selectionHighlight = 97] = "selectionHighlight", s[s.selectOnLineNumbers = 98] = "selectOnLineNumbers", s[s.showFoldingControls = 99] = "showFoldingControls", s[s.showUnused = 100] = "showUnused", s[s.snippetSuggestions = 101] = "snippetSuggestions", s[s.smartSelect = 102] = "smartSelect", s[s.smoothScrolling = 103] = "smoothScrolling", s[s.stickyTabStops = 104] = "stickyTabStops", s[s.stopRenderingLineAfter = 105] = "stopRenderingLineAfter", s[s.suggest = 106] = "suggest", s[s.suggestFontSize = 107] = "suggestFontSize", s[s.suggestLineHeight = 108] = "suggestLineHeight", s[s.suggestOnTriggerCharacters = 109] = "suggestOnTriggerCharacters", s[s.suggestSelection = 110] = "suggestSelection", s[s.tabCompletion = 111] = "tabCompletion", s[s.tabIndex = 112] = "tabIndex", s[s.unicodeHighlighting = 113] = "unicodeHighlighting", s[s.unusualLineTerminators = 114] = "unusualLineTerminators", s[s.useShadowDOM = 115] = "useShadowDOM", s[s.useTabStops = 116] = "useTabStops", s[s.wordSeparators = 117] = "wordSeparators", s[s.wordWrap = 118] = "wordWrap", s[s.wordWrapBreakAfterCharacters = 119] = "wordWrapBreakAfterCharacters", s[s.wordWrapBreakBeforeCharacters = 120] = "wordWrapBreakBeforeCharacters", s[s.wordWrapColumn = 121] = "wordWrapColumn", s[s.wordWrapOverride1 = 122] = "wordWrapOverride1", s[s.wordWrapOverride2 = 123] = "wordWrapOverride2", s[s.wrappingIndent = 124] = "wrappingIndent", s[s.wrappingStrategy = 125] = "wrappingStrategy", s[s.showDeprecated = 126] = "showDeprecated", s[s.inlayHints = 127] = "inlayHints", s[s.editorClassName = 128] = "editorClassName", s[s.pixelRatio = 129] = "pixelRatio", s[s.tabFocusMode = 130] = "tabFocusMode", s[s.layoutInfo = 131] = "layoutInfo", s[s.wrappingInfo = 132] = "wrappingInfo";
  })(RD || (RD = {}));
  var OD;
  (function(s) {
    s[s.TextDefined = 0] = "TextDefined", s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
  })(OD || (OD = {}));
  var PD;
  (function(s) {
    s[s.LF = 0] = "LF", s[s.CRLF = 1] = "CRLF";
  })(PD || (PD = {}));
  var FD;
  (function(s) {
    s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
  })(FD || (FD = {}));
  var BD;
  (function(s) {
    s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
  })(BD || (BD = {}));
  var WD;
  (function(s) {
    s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
  })(WD || (WD = {}));
  var VD;
  (function(s) {
    s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
  })(VD || (VD = {}));
  var HD;
  (function(s) {
    s[s.DependsOnKbLayout = -1] = "DependsOnKbLayout", s[s.Unknown = 0] = "Unknown", s[s.Backspace = 1] = "Backspace", s[s.Tab = 2] = "Tab", s[s.Enter = 3] = "Enter", s[s.Shift = 4] = "Shift", s[s.Ctrl = 5] = "Ctrl", s[s.Alt = 6] = "Alt", s[s.PauseBreak = 7] = "PauseBreak", s[s.CapsLock = 8] = "CapsLock", s[s.Escape = 9] = "Escape", s[s.Space = 10] = "Space", s[s.PageUp = 11] = "PageUp", s[s.PageDown = 12] = "PageDown", s[s.End = 13] = "End", s[s.Home = 14] = "Home", s[s.LeftArrow = 15] = "LeftArrow", s[s.UpArrow = 16] = "UpArrow", s[s.RightArrow = 17] = "RightArrow", s[s.DownArrow = 18] = "DownArrow", s[s.Insert = 19] = "Insert", s[s.Delete = 20] = "Delete", s[s.Digit0 = 21] = "Digit0", s[s.Digit1 = 22] = "Digit1", s[s.Digit2 = 23] = "Digit2", s[s.Digit3 = 24] = "Digit3", s[s.Digit4 = 25] = "Digit4", s[s.Digit5 = 26] = "Digit5", s[s.Digit6 = 27] = "Digit6", s[s.Digit7 = 28] = "Digit7", s[s.Digit8 = 29] = "Digit8", s[s.Digit9 = 30] = "Digit9", s[s.KeyA = 31] = "KeyA", s[s.KeyB = 32] = "KeyB", s[s.KeyC = 33] = "KeyC", s[s.KeyD = 34] = "KeyD", s[s.KeyE = 35] = "KeyE", s[s.KeyF = 36] = "KeyF", s[s.KeyG = 37] = "KeyG", s[s.KeyH = 38] = "KeyH", s[s.KeyI = 39] = "KeyI", s[s.KeyJ = 40] = "KeyJ", s[s.KeyK = 41] = "KeyK", s[s.KeyL = 42] = "KeyL", s[s.KeyM = 43] = "KeyM", s[s.KeyN = 44] = "KeyN", s[s.KeyO = 45] = "KeyO", s[s.KeyP = 46] = "KeyP", s[s.KeyQ = 47] = "KeyQ", s[s.KeyR = 48] = "KeyR", s[s.KeyS = 49] = "KeyS", s[s.KeyT = 50] = "KeyT", s[s.KeyU = 51] = "KeyU", s[s.KeyV = 52] = "KeyV", s[s.KeyW = 53] = "KeyW", s[s.KeyX = 54] = "KeyX", s[s.KeyY = 55] = "KeyY", s[s.KeyZ = 56] = "KeyZ", s[s.Meta = 57] = "Meta", s[s.ContextMenu = 58] = "ContextMenu", s[s.F1 = 59] = "F1", s[s.F2 = 60] = "F2", s[s.F3 = 61] = "F3", s[s.F4 = 62] = "F4", s[s.F5 = 63] = "F5", s[s.F6 = 64] = "F6", s[s.F7 = 65] = "F7", s[s.F8 = 66] = "F8", s[s.F9 = 67] = "F9", s[s.F10 = 68] = "F10", s[s.F11 = 69] = "F11", s[s.F12 = 70] = "F12", s[s.F13 = 71] = "F13", s[s.F14 = 72] = "F14", s[s.F15 = 73] = "F15", s[s.F16 = 74] = "F16", s[s.F17 = 75] = "F17", s[s.F18 = 76] = "F18", s[s.F19 = 77] = "F19", s[s.NumLock = 78] = "NumLock", s[s.ScrollLock = 79] = "ScrollLock", s[s.Semicolon = 80] = "Semicolon", s[s.Equal = 81] = "Equal", s[s.Comma = 82] = "Comma", s[s.Minus = 83] = "Minus", s[s.Period = 84] = "Period", s[s.Slash = 85] = "Slash", s[s.Backquote = 86] = "Backquote", s[s.BracketLeft = 87] = "BracketLeft", s[s.Backslash = 88] = "Backslash", s[s.BracketRight = 89] = "BracketRight", s[s.Quote = 90] = "Quote", s[s.OEM_8 = 91] = "OEM_8", s[s.IntlBackslash = 92] = "IntlBackslash", s[s.Numpad0 = 93] = "Numpad0", s[s.Numpad1 = 94] = "Numpad1", s[s.Numpad2 = 95] = "Numpad2", s[s.Numpad3 = 96] = "Numpad3", s[s.Numpad4 = 97] = "Numpad4", s[s.Numpad5 = 98] = "Numpad5", s[s.Numpad6 = 99] = "Numpad6", s[s.Numpad7 = 100] = "Numpad7", s[s.Numpad8 = 101] = "Numpad8", s[s.Numpad9 = 102] = "Numpad9", s[s.NumpadMultiply = 103] = "NumpadMultiply", s[s.NumpadAdd = 104] = "NumpadAdd", s[s.NUMPAD_SEPARATOR = 105] = "NUMPAD_SEPARATOR", s[s.NumpadSubtract = 106] = "NumpadSubtract", s[s.NumpadDecimal = 107] = "NumpadDecimal", s[s.NumpadDivide = 108] = "NumpadDivide", s[s.KEY_IN_COMPOSITION = 109] = "KEY_IN_COMPOSITION", s[s.ABNT_C1 = 110] = "ABNT_C1", s[s.ABNT_C2 = 111] = "ABNT_C2", s[s.AudioVolumeMute = 112] = "AudioVolumeMute", s[s.AudioVolumeUp = 113] = "AudioVolumeUp", s[s.AudioVolumeDown = 114] = "AudioVolumeDown", s[s.BrowserSearch = 115] = "BrowserSearch", s[s.BrowserHome = 116] = "BrowserHome", s[s.BrowserBack = 117] = "BrowserBack", s[s.BrowserForward = 118] = "BrowserForward", s[s.MediaTrackNext = 119] = "MediaTrackNext", s[s.MediaTrackPrevious = 120] = "MediaTrackPrevious", s[s.MediaStop = 121] = "MediaStop", s[s.MediaPlayPause = 122] = "MediaPlayPause", s[s.LaunchMediaPlayer = 123] = "LaunchMediaPlayer", s[s.LaunchMail = 124] = "LaunchMail", s[s.LaunchApp2 = 125] = "LaunchApp2", s[s.Clear = 126] = "Clear", s[s.MAX_VALUE = 127] = "MAX_VALUE";
  })(HD || (HD = {}));
  var zD;
  (function(s) {
    s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
  })(zD || (zD = {}));
  var UD;
  (function(s) {
    s[s.Unnecessary = 1] = "Unnecessary", s[s.Deprecated = 2] = "Deprecated";
  })(UD || (UD = {}));
  var $D;
  (function(s) {
    s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
  })($D || ($D = {}));
  var jD;
  (function(s) {
    s[s.UNKNOWN = 0] = "UNKNOWN", s[s.TEXTAREA = 1] = "TEXTAREA", s[s.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", s[s.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", s[s.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", s[s.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", s[s.CONTENT_TEXT = 6] = "CONTENT_TEXT", s[s.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", s[s.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", s[s.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", s[s.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", s[s.SCROLLBAR = 11] = "SCROLLBAR", s[s.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", s[s.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
  })(jD || (jD = {}));
  var KD;
  (function(s) {
    s[s.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", s[s.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", s[s.TOP_CENTER = 2] = "TOP_CENTER";
  })(KD || (KD = {}));
  var qD;
  (function(s) {
    s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
  })(qD || (qD = {}));
  var GD;
  (function(s) {
    s[s.Left = 0] = "Left", s[s.Right = 1] = "Right", s[s.None = 2] = "None";
  })(GD || (GD = {}));
  var ZD;
  (function(s) {
    s[s.Off = 0] = "Off", s[s.On = 1] = "On", s[s.Relative = 2] = "Relative", s[s.Interval = 3] = "Interval", s[s.Custom = 4] = "Custom";
  })(ZD || (ZD = {}));
  var YD;
  (function(s) {
    s[s.None = 0] = "None", s[s.Text = 1] = "Text", s[s.Blocks = 2] = "Blocks";
  })(YD || (YD = {}));
  var XD;
  (function(s) {
    s[s.Smooth = 0] = "Smooth", s[s.Immediate = 1] = "Immediate";
  })(XD || (XD = {}));
  var QD;
  (function(s) {
    s[s.Auto = 1] = "Auto", s[s.Hidden = 2] = "Hidden", s[s.Visible = 3] = "Visible";
  })(QD || (QD = {}));
  var JD;
  (function(s) {
    s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL";
  })(JD || (JD = {}));
  var ex;
  (function(s) {
    s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
  })(ex || (ex = {}));
  var tx;
  (function(s) {
    s[s.File = 0] = "File", s[s.Module = 1] = "Module", s[s.Namespace = 2] = "Namespace", s[s.Package = 3] = "Package", s[s.Class = 4] = "Class", s[s.Method = 5] = "Method", s[s.Property = 6] = "Property", s[s.Field = 7] = "Field", s[s.Constructor = 8] = "Constructor", s[s.Enum = 9] = "Enum", s[s.Interface = 10] = "Interface", s[s.Function = 11] = "Function", s[s.Variable = 12] = "Variable", s[s.Constant = 13] = "Constant", s[s.String = 14] = "String", s[s.Number = 15] = "Number", s[s.Boolean = 16] = "Boolean", s[s.Array = 17] = "Array", s[s.Object = 18] = "Object", s[s.Key = 19] = "Key", s[s.Null = 20] = "Null", s[s.EnumMember = 21] = "EnumMember", s[s.Struct = 22] = "Struct", s[s.Event = 23] = "Event", s[s.Operator = 24] = "Operator", s[s.TypeParameter = 25] = "TypeParameter";
  })(tx || (tx = {}));
  var ix;
  (function(s) {
    s[s.Deprecated = 1] = "Deprecated";
  })(ix || (ix = {}));
  var nx;
  (function(s) {
    s[s.Hidden = 0] = "Hidden", s[s.Blink = 1] = "Blink", s[s.Smooth = 2] = "Smooth", s[s.Phase = 3] = "Phase", s[s.Expand = 4] = "Expand", s[s.Solid = 5] = "Solid";
  })(nx || (nx = {}));
  var sx;
  (function(s) {
    s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
  })(sx || (sx = {}));
  var ox;
  (function(s) {
    s[s.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", s[s.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", s[s.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", s[s.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
  })(ox || (ox = {}));
  var rx;
  (function(s) {
    s[s.None = 0] = "None", s[s.Same = 1] = "Same", s[s.Indent = 2] = "Indent", s[s.DeepIndent = 3] = "DeepIndent";
  })(rx || (rx = {}));
  class T_ {
    static chord(e, t) {
      return Qi(e, t);
    }
  }
  T_.CtrlCmd = 2048;
  T_.Shift = 1024;
  T_.Alt = 512;
  T_.WinCtrl = 256;
  function y8() {
    return {
      editor: void 0,
      languages: void 0,
      CancellationTokenSource: bn,
      Emitter: B,
      KeyCode: HD,
      KeyMod: T_,
      Position: V,
      Range: D,
      Selection: ae,
      SelectionDirection: JD,
      MarkerSeverity: zD,
      MarkerTag: UD,
      Uri: Ee,
      Token: Zm
    };
  }
  const hle = "$initialize";
  let SR = !1;
  function ax(s) {
    !Pc || (SR || (SR = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(s.message));
  }
  class ule {
    constructor(e, t, i, n) {
      this.vsWorker = e, this.req = t, this.method = i, this.args = n, this.type = 0;
    }
  }
  class yR {
    constructor(e, t, i, n) {
      this.vsWorker = e, this.seq = t, this.res = i, this.err = n, this.type = 1;
    }
  }
  class fle {
    constructor(e, t, i, n) {
      this.vsWorker = e, this.req = t, this.eventName = i, this.arg = n, this.type = 2;
    }
  }
  class gle {
    constructor(e, t, i) {
      this.vsWorker = e, this.req = t, this.event = i, this.type = 3;
    }
  }
  class mle {
    constructor(e, t) {
      this.vsWorker = e, this.req = t, this.type = 4;
    }
  }
  class ple {
    constructor(e) {
      this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
    }
    setWorkerId(e) {
      this._workerId = e;
    }
    sendMessage(e, t) {
      const i = String(++this._lastSentReq);
      return new Promise((n, o) => {
        this._pendingReplies[i] = {
          resolve: n,
          reject: o
        }, this._send(new ule(this._workerId, i, e, t));
      });
    }
    listen(e, t) {
      let i = null;
      const n = new B({
        onFirstListenerAdd: () => {
          i = String(++this._lastSentReq), this._pendingEmitters.set(i, n), this._send(new fle(this._workerId, i, e, t));
        },
        onLastListenerRemove: () => {
          this._pendingEmitters.delete(i), this._send(new mle(this._workerId, i)), i = null;
        }
      });
      return n.event;
    }
    handleMessage(e) {
      !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
    }
    _handleMessage(e) {
      switch (e.type) {
        case 1:
          return this._handleReplyMessage(e);
        case 0:
          return this._handleRequestMessage(e);
        case 2:
          return this._handleSubscribeEventMessage(e);
        case 3:
          return this._handleEventMessage(e);
        case 4:
          return this._handleUnsubscribeEventMessage(e);
      }
    }
    _handleReplyMessage(e) {
      if (!this._pendingReplies[e.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      let t = this._pendingReplies[e.seq];
      if (delete this._pendingReplies[e.seq], e.err) {
        let i = e.err;
        e.err.$isError && (i = new Error(), i.name = e.err.name, i.message = e.err.message, i.stack = e.err.stack), t.reject(i);
        return;
      }
      t.resolve(e.res);
    }
    _handleRequestMessage(e) {
      let t = e.req;
      this._handler.handleMessage(e.method, e.args).then((n) => {
        this._send(new yR(this._workerId, t, n, void 0));
      }, (n) => {
        n.detail instanceof Error && (n.detail = D2(n.detail)), this._send(new yR(this._workerId, t, void 0, D2(n)));
      });
    }
    _handleSubscribeEventMessage(e) {
      const t = e.req, i = this._handler.handleEvent(e.eventName, e.arg)((n) => {
        this._send(new gle(this._workerId, t, n));
      });
      this._pendingEvents.set(t, i);
    }
    _handleEventMessage(e) {
      if (!this._pendingEmitters.has(e.req)) {
        console.warn("Got event for unknown req");
        return;
      }
      this._pendingEmitters.get(e.req).fire(e.event);
    }
    _handleUnsubscribeEventMessage(e) {
      if (!this._pendingEvents.has(e.req)) {
        console.warn("Got unsubscribe for unknown req");
        return;
      }
      this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
    }
    _send(e) {
      let t = [];
      if (e.type === 0)
        for (let i = 0; i < e.args.length; i++)
          e.args[i] instanceof ArrayBuffer && t.push(e.args[i]);
      else
        e.type === 1 && e.res instanceof ArrayBuffer && t.push(e.res);
      this._handler.sendMessage(e, t);
    }
  }
  class _le extends z {
    constructor(e, t, i) {
      super();
      let n = null;
      this._worker = this._register(e.create("vs/base/common/worker/simpleWorker", (c) => {
        this._protocol.handleMessage(c);
      }, (c) => {
        n && n(c);
      })), this._protocol = new ple({
        sendMessage: (c, d) => {
          this._worker.postMessage(c, d);
        },
        handleMessage: (c, d) => {
          if (typeof i[c] != "function")
            return Promise.reject(new Error("Missing method " + c + " on main thread host."));
          try {
            return Promise.resolve(i[c].apply(i, d));
          } catch (h) {
            return Promise.reject(h);
          }
        },
        handleEvent: (c, d) => {
          if (k8(c)) {
            const h = i[c].call(i, d);
            if (typeof h != "function")
              throw new Error(`Missing dynamic event ${c} on main thread host.`);
            return h;
          }
          if (L8(c)) {
            const h = i[c];
            if (typeof h != "function")
              throw new Error(`Missing event ${c} on main thread host.`);
            return h;
          }
          throw new Error(`Malformed event name ${c}`);
        }
      }), this._protocol.setWorkerId(this._worker.getId());
      let o = null;
      typeof gi.require < "u" && typeof gi.require.getConfig == "function" ? o = gi.require.getConfig() : typeof gi.requirejs < "u" && (o = gi.requirejs.s.contexts._.config);
      const r = pI(i);
      this._onModuleLoaded = this._protocol.sendMessage(hle, [
        this._worker.getId(),
        JSON.parse(JSON.stringify(o)),
        t,
        r
      ]);
      const a = (c, d) => this._request(c, d), l = (c, d) => this._protocol.listen(c, d);
      this._lazyProxy = new Promise((c, d) => {
        n = d, this._onModuleLoaded.then((h) => {
          c(ble(h, a, l));
        }, (h) => {
          d(h), this._onError("Worker failed to load " + t, h);
        });
      });
    }
    getProxyObject() {
      return this._lazyProxy;
    }
    _request(e, t) {
      return new Promise((i, n) => {
        this._onModuleLoaded.then(() => {
          this._protocol.sendMessage(e, t).then(i, n);
        }, n);
      });
    }
    _onError(e, t) {
      console.error(e), console.info(t);
    }
  }
  function L8(s) {
    return s[0] === "o" && s[1] === "n" && Wr(s.charCodeAt(2));
  }
  function k8(s) {
    return /^onDynamic/.test(s) && Wr(s.charCodeAt(9));
  }
  function ble(s, e, t) {
    const i = (r) => function() {
      const a = Array.prototype.slice.call(arguments, 0);
      return e(r, a);
    }, n = (r) => function(a) {
      return t(r, a);
    };
    let o = {};
    for (const r of s) {
      if (k8(r)) {
        o[r] = n(r);
        continue;
      }
      if (L8(r)) {
        o[r] = t(r, void 0);
        continue;
      }
      o[r] = i(r);
    }
    return o;
  }
  var wy;
  const LR = (wy = window.trustedTypes) === null || wy === void 0 ? void 0 : wy.createPolicy("defaultWorkerFactory", { createScriptURL: (s) => s });
  function vle(s) {
    if (gi.MonacoEnvironment) {
      if (typeof gi.MonacoEnvironment.getWorker == "function")
        return gi.MonacoEnvironment.getWorker("workerMain.js", s);
      if (typeof gi.MonacoEnvironment.getWorkerUrl == "function") {
        const e = gi.MonacoEnvironment.getWorkerUrl("workerMain.js", s);
        return new Worker(LR ? LR.createScriptURL(e) : e, { name: s });
      }
    }
    throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
  }
  function Cle(s) {
    return typeof s.then == "function";
  }
  class wle {
    constructor(e, t, i, n, o) {
      this.id = t;
      const r = vle(i);
      Cle(r) ? this.worker = r : this.worker = Promise.resolve(r), this.postMessage(e, []), this.worker.then((a) => {
        a.onmessage = function(l) {
          n(l.data);
        }, a.onmessageerror = o, typeof a.addEventListener == "function" && a.addEventListener("error", o);
      });
    }
    getId() {
      return this.id;
    }
    postMessage(e, t) {
      this.worker && this.worker.then((i) => i.postMessage(e, t));
    }
    dispose() {
      this.worker && this.worker.then((e) => e.terminate()), this.worker = null;
    }
  }
  class uw {
    constructor(e) {
      this._label = e, this._webWorkerFailedBeforeError = !1;
    }
    create(e, t, i) {
      let n = ++uw.LAST_WORKER_ID;
      if (this._webWorkerFailedBeforeError)
        throw this._webWorkerFailedBeforeError;
      return new wle(e, n, this._label || "anonymous" + n, t, (o) => {
        ax(o), this._webWorkerFailedBeforeError = o, i(o);
      });
    }
  }
  uw.LAST_WORKER_ID = 0;
  const Sle = 3;
  function D8(s, e, t, i) {
    return new Yr(s, e, t).ComputeDiff(i);
  }
  class kR {
    constructor(e) {
      const t = [], i = [];
      for (let n = 0, o = e.length; n < o; n++)
        t[n] = lx(e[n], 1), i[n] = cx(e[n], 1);
      this.lines = e, this._startColumns = t, this._endColumns = i;
    }
    getElements() {
      const e = [];
      for (let t = 0, i = this.lines.length; t < i; t++)
        e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
      return e;
    }
    getStrictElement(e) {
      return this.lines[e];
    }
    getStartLineNumber(e) {
      return e + 1;
    }
    getEndLineNumber(e) {
      return e + 1;
    }
    createCharSequence(e, t, i) {
      const n = [], o = [], r = [];
      let a = 0;
      for (let l = t; l <= i; l++) {
        const c = this.lines[l], d = e ? this._startColumns[l] : 1, h = e ? this._endColumns[l] : c.length + 1;
        for (let u = d; u < h; u++)
          n[a] = c.charCodeAt(u - 1), o[a] = l + 1, r[a] = u, a++;
      }
      return new yle(n, o, r);
    }
  }
  class yle {
    constructor(e, t, i) {
      this._charCodes = e, this._lineNumbers = t, this._columns = i;
    }
    getElements() {
      return this._charCodes;
    }
    getStartLineNumber(e) {
      return this._lineNumbers[e];
    }
    getStartColumn(e) {
      return this._columns[e];
    }
    getEndLineNumber(e) {
      return this._lineNumbers[e];
    }
    getEndColumn(e) {
      return this._columns[e] + 1;
    }
  }
  class Kp {
    constructor(e, t, i, n, o, r, a, l) {
      this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = n, this.modifiedStartLineNumber = o, this.modifiedStartColumn = r, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
    }
    static createFromDiffChange(e, t, i) {
      let n, o, r, a, l, c, d, h;
      return e.originalLength === 0 ? (n = 0, o = 0, r = 0, a = 0) : (n = t.getStartLineNumber(e.originalStart), o = t.getStartColumn(e.originalStart), r = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1)), e.modifiedLength === 0 ? (l = 0, c = 0, d = 0, h = 0) : (l = i.getStartLineNumber(e.modifiedStart), c = i.getStartColumn(e.modifiedStart), d = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), h = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1)), new Kp(n, o, r, a, l, c, d, h);
    }
  }
  function Lle(s) {
    if (s.length <= 1)
      return s;
    const e = [s[0]];
    let t = e[0];
    for (let i = 1, n = s.length; i < n; i++) {
      const o = s[i], r = o.originalStart - (t.originalStart + t.originalLength), a = o.modifiedStart - (t.modifiedStart + t.modifiedLength);
      Math.min(r, a) < Sle ? (t.originalLength = o.originalStart + o.originalLength - t.originalStart, t.modifiedLength = o.modifiedStart + o.modifiedLength - t.modifiedStart) : (e.push(o), t = o);
    }
    return e;
  }
  class Nm {
    constructor(e, t, i, n, o) {
      this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = n, this.charChanges = o;
    }
    static createFromDiffResult(e, t, i, n, o, r, a) {
      let l, c, d, h, u;
      if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, c = 0) : (l = i.getStartLineNumber(t.originalStart), c = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (d = n.getStartLineNumber(t.modifiedStart) - 1, h = 0) : (d = n.getStartLineNumber(t.modifiedStart), h = n.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), r && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && o()) {
        const f = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), g = n.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
        let _ = D8(f, g, o, !0).changes;
        a && (_ = Lle(_)), u = [];
        for (let b = 0, C = _.length; b < C; b++)
          u.push(Kp.createFromDiffChange(_[b], f, g));
      }
      return new Nm(l, c, d, h, u);
    }
  }
  class kle {
    constructor(e, t, i) {
      this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new kR(e), this.modified = new kR(t), this.continueLineDiff = DR(i.maxComputationTime), this.continueCharDiff = DR(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
    }
    computeDiff() {
      if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
        return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
          quitEarly: !1,
          changes: []
        } : {
          quitEarly: !1,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: 1,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: this.modified.lines.length,
            charChanges: [{
              modifiedEndColumn: 0,
              modifiedEndLineNumber: 0,
              modifiedStartColumn: 0,
              modifiedStartLineNumber: 0,
              originalEndColumn: 0,
              originalEndLineNumber: 0,
              originalStartColumn: 0,
              originalStartLineNumber: 0
            }]
          }]
        };
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
        return {
          quitEarly: !1,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: this.original.lines.length,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: 1,
            charChanges: [{
              modifiedEndColumn: 0,
              modifiedEndLineNumber: 0,
              modifiedStartColumn: 0,
              modifiedStartLineNumber: 0,
              originalEndColumn: 0,
              originalEndLineNumber: 0,
              originalStartColumn: 0,
              originalStartLineNumber: 0
            }]
          }]
        };
      const e = D8(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
      if (this.shouldIgnoreTrimWhitespace) {
        const a = [];
        for (let l = 0, c = t.length; l < c; l++)
          a.push(Nm.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        return {
          quitEarly: i,
          changes: a
        };
      }
      const n = [];
      let o = 0, r = 0;
      for (let a = -1, l = t.length; a < l; a++) {
        const c = a + 1 < l ? t[a + 1] : null, d = c ? c.originalStart : this.originalLines.length, h = c ? c.modifiedStart : this.modifiedLines.length;
        for (; o < d && r < h; ) {
          const u = this.originalLines[o], f = this.modifiedLines[r];
          if (u !== f) {
            {
              let g = lx(u, 1), _ = lx(f, 1);
              for (; g > 1 && _ > 1; ) {
                const b = u.charCodeAt(g - 2), C = f.charCodeAt(_ - 2);
                if (b !== C)
                  break;
                g--, _--;
              }
              (g > 1 || _ > 1) && this._pushTrimWhitespaceCharChange(n, o + 1, 1, g, r + 1, 1, _);
            }
            {
              let g = cx(u, 1), _ = cx(f, 1);
              const b = u.length + 1, C = f.length + 1;
              for (; g < b && _ < C; ) {
                const v = u.charCodeAt(g - 1), w = u.charCodeAt(_ - 1);
                if (v !== w)
                  break;
                g++, _++;
              }
              (g < b || _ < C) && this._pushTrimWhitespaceCharChange(n, o + 1, g, b, r + 1, _, C);
            }
          }
          o++, r++;
        }
        c && (n.push(Nm.createFromDiffResult(this.shouldIgnoreTrimWhitespace, c, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), o += c.originalLength, r += c.modifiedLength);
      }
      return {
        quitEarly: i,
        changes: n
      };
    }
    _pushTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
      if (this._mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a))
        return;
      let l;
      this.shouldComputeCharChanges && (l = [new Kp(t, i, t, n, o, r, o, a)]), e.push(new Nm(t, t, o, o, l));
    }
    _mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
      const l = e.length;
      if (l === 0)
        return !1;
      const c = e[l - 1];
      return c.originalEndLineNumber === 0 || c.modifiedEndLineNumber === 0 ? !1 : c.originalEndLineNumber + 1 === t && c.modifiedEndLineNumber + 1 === o ? (c.originalEndLineNumber = t, c.modifiedEndLineNumber = o, this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new Kp(t, i, t, n, o, r, o, a)), !0) : !1;
    }
  }
  function lx(s, e) {
    const t = jn(s);
    return t === -1 ? e : t + 1;
  }
  function cx(s, e) {
    const t = ia(s);
    return t === -1 ? e : t + 2;
  }
  function DR(s) {
    if (s === 0)
      return () => !0;
    const e = Date.now();
    return () => Date.now() - e < s;
  }
  class Dle {
    constructor(e, t, i, n) {
      this._uri = e, this._lines = t, this._eol = i, this._versionId = n, this._lineStarts = null, this._cachedTextValue = null;
    }
    dispose() {
      this._lines.length = 0;
    }
    get version() {
      return this._versionId;
    }
    getText() {
      return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
    }
    onEvents(e) {
      e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
      const t = e.changes;
      for (const i of t)
        this._acceptDeleteRange(i.range), this._acceptInsertText(new V(i.range.startLineNumber, i.range.startColumn), i.text);
      this._versionId = e.versionId, this._cachedTextValue = null;
    }
    _ensureLineStarts() {
      if (!this._lineStarts) {
        const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
        for (let n = 0; n < t; n++)
          i[n] = this._lines[n].length + e;
        this._lineStarts = new bG(i);
      }
    }
    _setLineText(e, t) {
      this._lines[e] = t, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
    }
    _acceptDeleteRange(e) {
      if (e.startLineNumber === e.endLineNumber) {
        if (e.startColumn === e.endColumn)
          return;
        this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
        return;
      }
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
    }
    _acceptInsertText(e, t) {
      if (t.length === 0)
        return;
      const i = da(t);
      if (i.length === 1) {
        this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
        return;
      }
      i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
      const n = new Uint32Array(i.length - 1);
      for (let o = 1; o < i.length; o++)
        this._lines.splice(e.lineNumber + o - 1, 0, i[o]), n[o - 1] = i[o].length + this._eol.length;
      this._lineStarts && this._lineStarts.insertValues(e.lineNumber, n);
    }
  }
  class xle {
    constructor(e, t, i) {
      const n = new Uint8Array(e * t);
      for (let o = 0, r = e * t; o < r; o++)
        n[o] = i;
      this._data = n, this.rows = e, this.cols = t;
    }
    get(e, t) {
      return this._data[e * this.cols + t];
    }
    set(e, t, i) {
      this._data[e * this.cols + t] = i;
    }
  }
  class Ile {
    constructor(e) {
      let t = 0, i = 0;
      for (let o = 0, r = e.length; o < r; o++) {
        const [a, l, c] = e[o];
        l > t && (t = l), a > i && (i = a), c > i && (i = c);
      }
      t++, i++;
      const n = new xle(i, t, 0);
      for (let o = 0, r = e.length; o < r; o++) {
        const [a, l, c] = e[o];
        n.set(a, l, c);
      }
      this._states = n, this._maxCharCode = t;
    }
    nextState(e, t) {
      return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
    }
  }
  let Sy = null;
  function Ele() {
    return Sy === null && (Sy = new Ile([
      [1, 104, 2],
      [1, 72, 2],
      [1, 102, 6],
      [1, 70, 6],
      [2, 116, 3],
      [2, 84, 3],
      [3, 116, 4],
      [3, 84, 4],
      [4, 112, 5],
      [4, 80, 5],
      [5, 115, 9],
      [5, 83, 9],
      [5, 58, 10],
      [6, 105, 7],
      [6, 73, 7],
      [7, 108, 8],
      [7, 76, 8],
      [8, 101, 9],
      [8, 69, 9],
      [9, 58, 10],
      [10, 47, 11],
      [11, 47, 12]
    ])), Sy;
  }
  let Wg = null;
  function Nle() {
    if (Wg === null) {
      Wg = new eg(0);
      const s = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let t = 0; t < s.length; t++)
        Wg.set(s.charCodeAt(t), 1);
      const e = ".,;";
      for (let t = 0; t < e.length; t++)
        Wg.set(e.charCodeAt(t), 2);
    }
    return Wg;
  }
  class sv {
    static _createLink(e, t, i, n, o) {
      let r = o - 1;
      do {
        const a = t.charCodeAt(r);
        if (e.get(a) !== 2)
          break;
        r--;
      } while (r > n);
      if (n > 0) {
        const a = t.charCodeAt(n - 1), l = t.charCodeAt(r);
        (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && r--;
      }
      return {
        range: {
          startLineNumber: i,
          startColumn: n + 1,
          endLineNumber: i,
          endColumn: r + 2
        },
        url: t.substring(n, r + 1)
      };
    }
    static computeLinks(e, t = Ele()) {
      const i = Nle(), n = [];
      for (let o = 1, r = e.getLineCount(); o <= r; o++) {
        const a = e.getLineContent(o), l = a.length;
        let c = 0, d = 0, h = 0, u = 1, f = !1, g = !1, _ = !1, b = !1;
        for (; c < l; ) {
          let C = !1;
          const v = a.charCodeAt(c);
          if (u === 13) {
            let w;
            switch (v) {
              case 40:
                f = !0, w = 0;
                break;
              case 41:
                w = f ? 0 : 1;
                break;
              case 91:
                _ = !0, g = !0, w = 0;
                break;
              case 93:
                _ = !1, w = g ? 0 : 1;
                break;
              case 123:
                b = !0, w = 0;
                break;
              case 125:
                w = b ? 0 : 1;
                break;
              case 39:
                w = h === 34 || h === 96 ? 0 : 1;
                break;
              case 34:
                w = h === 39 || h === 96 ? 0 : 1;
                break;
              case 96:
                w = h === 39 || h === 34 ? 0 : 1;
                break;
              case 42:
                w = h === 42 ? 1 : 0;
                break;
              case 124:
                w = h === 124 ? 1 : 0;
                break;
              case 32:
                w = _ ? 0 : 1;
                break;
              default:
                w = i.get(v);
            }
            w === 1 && (n.push(sv._createLink(i, a, o, d, c)), C = !0);
          } else if (u === 12) {
            let w;
            v === 91 ? (g = !0, w = 0) : w = i.get(v), w === 1 ? C = !0 : u = 13;
          } else
            u = t.nextState(u, v), u === 0 && (C = !0);
          C && (u = 1, f = !1, g = !1, b = !1, d = c + 1, h = v), c++;
        }
        u === 13 && n.push(sv._createLink(i, a, o, d, l));
      }
      return n;
    }
  }
  function Tle(s) {
    return !s || typeof s.getLineCount != "function" || typeof s.getLineContent != "function" ? [] : sv.computeLinks(s);
  }
  class dx {
    constructor() {
      this._defaultValueSet = [
        ["true", "false"],
        ["True", "False"],
        ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
        ["public", "protected", "private"]
      ];
    }
    navigateValueSet(e, t, i, n, o) {
      if (e && t) {
        const r = this.doNavigateValueSet(t, o);
        if (r)
          return {
            range: e,
            value: r
          };
      }
      if (i && n) {
        const r = this.doNavigateValueSet(n, o);
        if (r)
          return {
            range: i,
            value: r
          };
      }
      return null;
    }
    doNavigateValueSet(e, t) {
      const i = this.numberReplace(e, t);
      return i !== null ? i : this.textReplace(e, t);
    }
    numberReplace(e, t) {
      const i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
      let n = Number(e), o = parseFloat(e);
      return !isNaN(n) && !isNaN(o) && n === o ? n === 0 && !t ? null : (n = Math.floor(n * i), n += t ? i : -i, String(n / i)) : null;
    }
    textReplace(e, t) {
      return this.valueSetsReplace(this._defaultValueSet, e, t);
    }
    valueSetsReplace(e, t, i) {
      let n = null;
      for (let o = 0, r = e.length; n === null && o < r; o++)
        n = this.valueSetReplace(e[o], t, i);
      return n;
    }
    valueSetReplace(e, t, i) {
      let n = e.indexOf(t);
      return n >= 0 ? (n += i ? 1 : -1, n < 0 ? n = e.length - 1 : n %= e.length, e[n]) : null;
    }
  }
  dx.INSTANCE = new dx();
  var ed = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class Mle extends Dle {
    get uri() {
      return this._uri;
    }
    get eol() {
      return this._eol;
    }
    getValue() {
      return this.getText();
    }
    getLinesContent() {
      return this._lines.slice(0);
    }
    getLineCount() {
      return this._lines.length;
    }
    getLineContent(e) {
      return this._lines[e - 1];
    }
    getWordAtPosition(e, t) {
      const i = $m(e.column, $P(t), this._lines[e.lineNumber - 1], 0);
      return i ? new D(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
    }
    words(e) {
      const t = this._lines, i = this._wordenize.bind(this);
      let n = 0, o = "", r = 0, a = [];
      return {
        *[Symbol.iterator]() {
          for (; ; )
            if (r < a.length) {
              const l = o.substring(a[r].start, a[r].end);
              r += 1, yield l;
            } else if (n < t.length)
              o = t[n], a = i(o, e), r = 0, n += 1;
            else
              break;
        }
      };
    }
    getLineWords(e, t) {
      const i = this._lines[e - 1], n = this._wordenize(i, t), o = [];
      for (const r of n)
        o.push({
          word: i.substring(r.start, r.end),
          startColumn: r.start + 1,
          endColumn: r.end + 1
        });
      return o;
    }
    _wordenize(e, t) {
      const i = [];
      let n;
      for (t.lastIndex = 0; (n = t.exec(e)) && n[0].length !== 0; )
        i.push({ start: n.index, end: n.index + n[0].length });
      return i;
    }
    getValueInRange(e) {
      if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
        return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
      const t = this._eol, i = e.startLineNumber - 1, n = e.endLineNumber - 1, o = [];
      o.push(this._lines[i].substring(e.startColumn - 1));
      for (let r = i + 1; r < n; r++)
        o.push(this._lines[r]);
      return o.push(this._lines[n].substring(0, e.endColumn - 1)), o.join(t);
    }
    offsetAt(e) {
      return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
    }
    positionAt(e) {
      e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
      const t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
      return {
        lineNumber: 1 + t.index,
        column: 1 + Math.min(t.remainder, i)
      };
    }
    _validateRange(e) {
      const t = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
      return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
        startLineNumber: t.lineNumber,
        startColumn: t.column,
        endLineNumber: i.lineNumber,
        endColumn: i.column
      } : e;
    }
    _validatePosition(e) {
      if (!V.isIPosition(e))
        throw new Error("bad position");
      let { lineNumber: t, column: i } = e, n = !1;
      if (t < 1)
        t = 1, i = 1, n = !0;
      else if (t > this._lines.length)
        t = this._lines.length, i = this._lines[t - 1].length + 1, n = !0;
      else {
        const o = this._lines[t - 1].length + 1;
        i < 1 ? (i = 1, n = !0) : i > o && (i = o, n = !0);
      }
      return n ? { lineNumber: t, column: i } : e;
    }
  }
  class Lh {
    constructor(e, t) {
      this._host = e, this._models = /* @__PURE__ */ Object.create(null), this._foreignModuleFactory = t, this._foreignModule = null;
    }
    dispose() {
      this._models = /* @__PURE__ */ Object.create(null);
    }
    _getModel(e) {
      return this._models[e];
    }
    _getModels() {
      const e = [];
      return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
    }
    acceptNewModel(e) {
      this._models[e.url] = new Mle(Ee.parse(e.url), e.lines, e.EOL, e.versionId);
    }
    acceptModelChanged(e, t) {
      if (!this._models[e])
        return;
      this._models[e].onEvents(t);
    }
    acceptRemovedModel(e) {
      !this._models[e] || delete this._models[e];
    }
    computeUnicodeHighlights(e, t, i) {
      return ed(this, void 0, void 0, function* () {
        const n = this._getModel(e);
        return n ? YN.computeUnicodeHighlights(n, t, i) : { ranges: [], hasMore: !1, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
      });
    }
    computeDiff(e, t, i, n) {
      return ed(this, void 0, void 0, function* () {
        const o = this._getModel(e), r = this._getModel(t);
        if (!o || !r)
          return null;
        const a = o.getLinesContent(), l = r.getLinesContent(), d = new kle(a, l, {
          shouldComputeCharChanges: !0,
          shouldPostProcessCharChanges: !0,
          shouldIgnoreTrimWhitespace: i,
          shouldMakePrettyDiff: !0,
          maxComputationTime: n
        }).computeDiff(), h = d.changes.length > 0 ? !1 : this._modelsAreIdentical(o, r);
        return {
          quitEarly: d.quitEarly,
          identical: h,
          changes: d.changes
        };
      });
    }
    _modelsAreIdentical(e, t) {
      const i = e.getLineCount(), n = t.getLineCount();
      if (i !== n)
        return !1;
      for (let o = 1; o <= i; o++) {
        const r = e.getLineContent(o), a = t.getLineContent(o);
        if (r !== a)
          return !1;
      }
      return !0;
    }
    computeMoreMinimalEdits(e, t) {
      return ed(this, void 0, void 0, function* () {
        const i = this._getModel(e);
        if (!i)
          return t;
        const n = [];
        let o;
        t = t.slice(0).sort((r, a) => {
          if (r.range && a.range)
            return D.compareRangesUsingStarts(r.range, a.range);
          const l = r.range ? 0 : 1, c = a.range ? 0 : 1;
          return l - c;
        });
        for (let { range: r, text: a, eol: l } of t) {
          if (typeof l == "number" && (o = l), D.isEmpty(r) && !a)
            continue;
          const c = i.getValueInRange(r);
          if (a = a.replace(/\r\n|\n|\r/g, i.eol), c === a)
            continue;
          if (Math.max(a.length, c.length) > Lh._diffLimit) {
            n.push({ range: r, text: a });
            continue;
          }
          const d = SQ(c, a, !1), h = i.offsetAt(D.lift(r).getStartPosition());
          for (const u of d) {
            const f = i.positionAt(h + u.originalStart), g = i.positionAt(h + u.originalStart + u.originalLength), _ = {
              text: a.substr(u.modifiedStart, u.modifiedLength),
              range: { startLineNumber: f.lineNumber, startColumn: f.column, endLineNumber: g.lineNumber, endColumn: g.column }
            };
            i.getValueInRange(_.range) !== _.text && n.push(_);
          }
        }
        return typeof o == "number" && n.push({ eol: o, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), n;
      });
    }
    computeLinks(e) {
      return ed(this, void 0, void 0, function* () {
        const t = this._getModel(e);
        return t ? Tle(t) : null;
      });
    }
    textualSuggest(e, t, i, n) {
      return ed(this, void 0, void 0, function* () {
        const o = new hs(!0), r = new RegExp(i, n), a = /* @__PURE__ */ new Set();
        e:
          for (let l of e) {
            const c = this._getModel(l);
            if (!!c) {
              for (let d of c.words(r))
                if (!(d === t || !isNaN(Number(d))) && (a.add(d), a.size > Lh._suggestionsLimit))
                  break e;
            }
          }
        return { words: Array.from(a), duration: o.elapsed() };
      });
    }
    computeWordRanges(e, t, i, n) {
      return ed(this, void 0, void 0, function* () {
        const o = this._getModel(e);
        if (!o)
          return /* @__PURE__ */ Object.create(null);
        const r = new RegExp(i, n), a = /* @__PURE__ */ Object.create(null);
        for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
          const c = o.getLineWords(l, r);
          for (const d of c) {
            if (!isNaN(Number(d.word)))
              continue;
            let h = a[d.word];
            h || (h = [], a[d.word] = h), h.push({
              startLineNumber: l,
              startColumn: d.startColumn,
              endLineNumber: l,
              endColumn: d.endColumn
            });
          }
        }
        return a;
      });
    }
    navigateValueSet(e, t, i, n, o) {
      return ed(this, void 0, void 0, function* () {
        const r = this._getModel(e);
        if (!r)
          return null;
        const a = new RegExp(n, o);
        t.startColumn === t.endColumn && (t = {
          startLineNumber: t.startLineNumber,
          startColumn: t.startColumn,
          endLineNumber: t.endLineNumber,
          endColumn: t.endColumn + 1
        });
        const l = r.getValueInRange(t), c = r.getWordAtPosition({ lineNumber: t.startLineNumber, column: t.startColumn }, a);
        if (!c)
          return null;
        const d = r.getValueInRange(c);
        return dx.INSTANCE.navigateValueSet(t, l, c, d, i);
      });
    }
    loadForeignModule(e, t, i) {
      const r = {
        host: VB(i, (a, l) => this._host.fhr(a, l)),
        getMirrorModels: () => this._getModels()
      };
      return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(r, t), Promise.resolve(pI(this._foreignModule))) : Promise.reject(new Error("Unexpected usage"));
    }
    fmr(e, t) {
      if (!this._foreignModule || typeof this._foreignModule[e] != "function")
        return Promise.reject(new Error("Missing requestHandler or method: " + e));
      try {
        return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
      } catch (i) {
        return Promise.reject(i);
      }
    }
  }
  Lh._diffLimit = 1e5;
  Lh._suggestionsLimit = 1e4;
  typeof importScripts == "function" && (gi.monaco = y8());
  var Ale = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Vg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, hx = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const xR = 60 * 1e3, IR = 5 * 60 * 1e3;
  function gd(s, e) {
    const t = s.getModel(e);
    return !(!t || t.isTooLargeForSyncing());
  }
  let ux = class extends z {
    constructor(e, t, i, n, o) {
      super(), this._modelService = e, this._workerManager = this._register(new Ole(this._modelService, n)), this._logService = i, this._register(o.linkProvider.register({ language: "*", hasAccessToAllModels: !0 }, {
        provideLinks: (r, a) => gd(this._modelService, r.uri) ? this._workerManager.withWorker().then((l) => l.computeLinks(r.uri)).then((l) => l && { links: l }) : Promise.resolve({ links: [] })
      })), this._register(o.completionProvider.register("*", new Rle(this._workerManager, t, this._modelService, n)));
    }
    dispose() {
      super.dispose();
    }
    canComputeUnicodeHighlights(e) {
      return gd(this._modelService, e);
    }
    computedUnicodeHighlights(e, t, i) {
      return this._workerManager.withWorker().then((n) => n.computedUnicodeHighlights(e, t, i));
    }
    computeDiff(e, t, i, n) {
      return this._workerManager.withWorker().then((o) => o.computeDiff(e, t, i, n));
    }
    computeMoreMinimalEdits(e, t) {
      if (Ds(t)) {
        if (!gd(this._modelService, e))
          return Promise.resolve(t);
        const i = hs.create(!0), n = this._workerManager.withWorker().then((o) => o.computeMoreMinimalEdits(e, t));
        return n.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), i.elapsed())), Promise.race([n, gc(1e3).then(() => t)]);
      } else
        return Promise.resolve(void 0);
    }
    canNavigateValueSet(e) {
      return gd(this._modelService, e);
    }
    navigateValueSet(e, t, i) {
      return this._workerManager.withWorker().then((n) => n.navigateValueSet(e, t, i));
    }
    canComputeWordRanges(e) {
      return gd(this._modelService, e);
    }
    computeWordRanges(e, t) {
      return this._workerManager.withWorker().then((i) => i.computeWordRanges(e, t));
    }
  };
  ux = Ale([
    Vg(0, Qt),
    Vg(1, KN),
    Vg(2, Xo),
    Vg(3, Mn),
    Vg(4, me)
  ], ux);
  class Rle {
    constructor(e, t, i, n) {
      this.languageConfigurationService = n, this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
    }
    provideCompletionItems(e, t) {
      return hx(this, void 0, void 0, function* () {
        const i = this._configurationService.getValue(e.uri, t, "editor");
        if (!i.wordBasedSuggestions)
          return;
        const n = [];
        if (i.wordBasedSuggestionsMode === "currentDocument")
          gd(this._modelService, e.uri) && n.push(e.uri);
        else
          for (const h of this._modelService.getModels())
            !gd(this._modelService, h.uri) || (h === e ? n.unshift(h.uri) : (i.wordBasedSuggestionsMode === "allDocuments" || h.getLanguageId() === e.getLanguageId()) && n.push(h.uri));
        if (n.length === 0)
          return;
        const o = this.languageConfigurationService.getLanguageConfiguration(e.getLanguageId()).getWordDefinition(), r = e.getWordAtPosition(t), a = r ? new D(t.lineNumber, r.startColumn, t.lineNumber, r.endColumn) : D.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), d = yield (yield this._workerManager.withWorker()).textualSuggest(n, r?.word, o);
        if (!!d)
          return {
            duration: d.duration,
            suggestions: d.words.map((h) => ({
              kind: 18,
              label: h,
              insertText: h,
              range: { insert: l, replace: a }
            }))
          };
      });
    }
  }
  class Ole extends z {
    constructor(e, t) {
      super(), this.languageConfigurationService = t, this._modelService = e, this._editorWorkerClient = null, this._lastWorkerUsedTime = new Date().getTime(), this._register(new o_()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(IR / 2)), this._register(this._modelService.onModelRemoved((n) => this._checkStopEmptyWorker()));
    }
    dispose() {
      this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
    }
    _checkStopEmptyWorker() {
      if (!this._editorWorkerClient)
        return;
      this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
    }
    _checkStopIdleWorker() {
      if (!this._editorWorkerClient)
        return;
      new Date().getTime() - this._lastWorkerUsedTime > IR && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
    }
    withWorker() {
      return this._lastWorkerUsedTime = new Date().getTime(), this._editorWorkerClient || (this._editorWorkerClient = new x8(this._modelService, !1, "editorWorkerService", this.languageConfigurationService)), Promise.resolve(this._editorWorkerClient);
    }
  }
  class Ple extends z {
    constructor(e, t, i) {
      if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
        const n = new o_();
        n.cancelAndSet(() => this._checkStopModelSync(), Math.round(xR / 2)), this._register(n);
      }
    }
    dispose() {
      for (let e in this._syncedModels)
        at(this._syncedModels[e]);
      this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
    }
    ensureSyncedResources(e, t) {
      for (const i of e) {
        const n = i.toString();
        this._syncedModels[n] || this._beginModelSync(i, t), this._syncedModels[n] && (this._syncedModelsLastUsedTime[n] = new Date().getTime());
      }
    }
    _checkStopModelSync() {
      const e = new Date().getTime(), t = [];
      for (let i in this._syncedModelsLastUsedTime)
        e - this._syncedModelsLastUsedTime[i] > xR && t.push(i);
      for (const i of t)
        this._stopModelSync(i);
    }
    _beginModelSync(e, t) {
      const i = this._modelService.getModel(e);
      if (!i || !t && i.isTooLargeForSyncing())
        return;
      const n = e.toString();
      this._proxy.acceptNewModel({
        url: i.uri.toString(),
        lines: i.getLinesContent(),
        EOL: i.getEOL(),
        versionId: i.getVersionId()
      });
      const o = new te();
      o.add(i.onDidChangeContent((r) => {
        this._proxy.acceptModelChanged(n.toString(), r);
      })), o.add(i.onWillDispose(() => {
        this._stopModelSync(n);
      })), o.add(qe(() => {
        this._proxy.acceptRemovedModel(n);
      })), this._syncedModels[n] = o;
    }
    _stopModelSync(e) {
      const t = this._syncedModels[e];
      delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], at(t);
    }
  }
  class ER {
    constructor(e) {
      this._instance = e, this._proxyObj = Promise.resolve(this._instance);
    }
    dispose() {
      this._instance.dispose();
    }
    getProxyObject() {
      return this._proxyObj;
    }
  }
  class yy {
    constructor(e) {
      this._workerClient = e;
    }
    fhr(e, t) {
      return this._workerClient.fhr(e, t);
    }
  }
  class x8 extends z {
    constructor(e, t, i, n) {
      super(), this.languageConfigurationService = n, this._disposed = !1, this._modelService = e, this._keepIdleModels = t, this._workerFactory = new uw(i), this._worker = null, this._modelManager = null;
    }
    fhr(e, t) {
      throw new Error("Not implemented!");
    }
    _getOrCreateWorker() {
      if (!this._worker)
        try {
          this._worker = this._register(new _le(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new yy(this)));
        } catch (e) {
          ax(e), this._worker = new ER(new Lh(new yy(this), null));
        }
      return this._worker;
    }
    _getProxy() {
      return this._getOrCreateWorker().getProxyObject().then(void 0, (e) => (ax(e), this._worker = new ER(new Lh(new yy(this), null)), this._getOrCreateWorker().getProxyObject()));
    }
    _getOrCreateModelManager(e) {
      return this._modelManager || (this._modelManager = this._register(new Ple(e, this._modelService, this._keepIdleModels))), this._modelManager;
    }
    _withSyncedResources(e, t = !1) {
      return hx(this, void 0, void 0, function* () {
        return this._disposed ? Promise.reject(aI()) : this._getProxy().then((i) => (this._getOrCreateModelManager(i).ensureSyncedResources(e, t), i));
      });
    }
    computedUnicodeHighlights(e, t, i) {
      return this._withSyncedResources([e]).then((n) => n.computeUnicodeHighlights(e.toString(), t, i));
    }
    computeDiff(e, t, i, n) {
      return this._withSyncedResources([e, t], !0).then((o) => o.computeDiff(e.toString(), t.toString(), i, n));
    }
    computeMoreMinimalEdits(e, t) {
      return this._withSyncedResources([e]).then((i) => i.computeMoreMinimalEdits(e.toString(), t));
    }
    computeLinks(e) {
      return this._withSyncedResources([e]).then((t) => t.computeLinks(e.toString()));
    }
    textualSuggest(e, t, i) {
      return hx(this, void 0, void 0, function* () {
        const n = yield this._withSyncedResources(e), o = i.source, r = Tw(i);
        return n.textualSuggest(e.map((a) => a.toString()), t, o, r);
      });
    }
    computeWordRanges(e, t) {
      return this._withSyncedResources([e]).then((i) => {
        const n = this._modelService.getModel(e);
        if (!n)
          return Promise.resolve(null);
        const o = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId()).getWordDefinition(), r = o.source, a = Tw(o);
        return i.computeWordRanges(e.toString(), t, r, a);
      });
    }
    navigateValueSet(e, t, i) {
      return this._withSyncedResources([e]).then((n) => {
        const o = this._modelService.getModel(e);
        if (!o)
          return null;
        const r = this.languageConfigurationService.getLanguageConfiguration(o.getLanguageId()).getWordDefinition(), a = r.source, l = Tw(r);
        return n.navigateValueSet(e.toString(), t, i, a, l);
      });
    }
    dispose() {
      super.dispose(), this._disposed = !0;
    }
  }
  function Fle(s, e, t) {
    return new Ble(s, e, t);
  }
  class Ble extends x8 {
    constructor(e, t, i) {
      super(e, i.keepIdleModels || !1, i.label, t), this._foreignModuleId = i.moduleId, this._foreignModuleCreateData = i.createData || null, this._foreignModuleHost = i.host || null, this._foreignProxy = null;
    }
    fhr(e, t) {
      if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
        return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
      try {
        return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
      } catch (i) {
        return Promise.reject(i);
      }
    }
    _getForeignProxy() {
      return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
        const t = this._foreignModuleHost ? pI(this._foreignModuleHost) : [];
        return e.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
          this._foreignModuleCreateData = null;
          const n = (a, l) => e.fmr(a, l), o = (a, l) => function() {
            const c = Array.prototype.slice.call(arguments, 0);
            return l(a, c);
          }, r = {};
          for (const a of i)
            r[a] = o(a, n);
          return r;
        });
      })), this._foreignProxy;
    }
    getProxy() {
      return this._getForeignProxy();
    }
    withSyncedResources(e) {
      return this._withSyncedResources(e).then((t) => this.getProxy());
    }
  }
  function Wle(s) {
    return Array.isArray(s);
  }
  function Vle(s) {
    return !Wle(s);
  }
  function I8(s) {
    return typeof s == "string";
  }
  function NR(s) {
    return !I8(s);
  }
  function Cu(s) {
    return !s;
  }
  function uc(s, e) {
    return s.ignoreCase && e ? e.toLowerCase() : e;
  }
  function TR(s) {
    return s.replace(/[&<>'"_]/g, "-");
  }
  function Hle(s, e) {
    console.log(`${s.languageId}: ${e}`);
  }
  function Pt(s, e) {
    return new Error(`${s.languageId}: ${e}`);
  }
  function Ul(s, e, t, i, n) {
    const o = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
    let r = null;
    return e.replace(o, function(a, l, c, d, h, u, f, g, _) {
      return Cu(c) ? Cu(d) ? !Cu(h) && h < i.length ? uc(s, i[h]) : !Cu(f) && s && typeof s[f] == "string" ? s[f] : (r === null && (r = n.split("."), r.unshift(n)), !Cu(u) && u < r.length ? uc(s, r[u]) : "") : uc(s, t) : "$";
    });
  }
  function Bb(s, e) {
    let t = e;
    for (; t && t.length > 0; ) {
      const i = s.tokenizer[t];
      if (i)
        return i;
      const n = t.lastIndexOf(".");
      n < 0 ? t = null : t = t.substr(0, n);
    }
    return null;
  }
  function zle(s, e) {
    let t = e;
    for (; t && t.length > 0; ) {
      if (s.stateNames[t])
        return !0;
      const n = t.lastIndexOf(".");
      n < 0 ? t = null : t = t.substr(0, n);
    }
    return !1;
  }
  const E8 = 5;
  class qp {
    constructor(e) {
      this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
    }
    static create(e, t) {
      return this._INSTANCE.create(e, t);
    }
    create(e, t) {
      if (e !== null && e.depth >= this._maxCacheDepth)
        return new af(e, t);
      let i = af.getStackElementId(e);
      i.length > 0 && (i += "|"), i += t;
      let n = this._entries[i];
      return n || (n = new af(e, t), this._entries[i] = n, n);
    }
  }
  qp._INSTANCE = new qp(E8);
  class af {
    constructor(e, t) {
      this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
    }
    static getStackElementId(e) {
      let t = "";
      for (; e !== null; )
        t.length > 0 && (t += "|"), t += e.state, e = e.parent;
      return t;
    }
    static _equals(e, t) {
      for (; e !== null && t !== null; ) {
        if (e === t)
          return !0;
        if (e.state !== t.state)
          return !1;
        e = e.parent, t = t.parent;
      }
      return e === null && t === null;
    }
    equals(e) {
      return af._equals(this, e);
    }
    push(e) {
      return qp.create(this, e);
    }
    pop() {
      return this.parent;
    }
    popall() {
      let e = this;
      for (; e.parent; )
        e = e.parent;
      return e;
    }
    switchTo(e) {
      return qp.create(this.parent, e);
    }
  }
  class Pu {
    constructor(e, t) {
      this.languageId = e, this.state = t;
    }
    equals(e) {
      return this.languageId === e.languageId && this.state.equals(e.state);
    }
    clone() {
      return this.state.clone() === this.state ? this : new Pu(this.languageId, this.state);
    }
  }
  class $l {
    constructor(e) {
      this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
    }
    static create(e, t) {
      return this._INSTANCE.create(e, t);
    }
    create(e, t) {
      if (t !== null)
        return new Tm(e, t);
      if (e !== null && e.depth >= this._maxCacheDepth)
        return new Tm(e, t);
      const i = af.getStackElementId(e);
      let n = this._entries[i];
      return n || (n = new Tm(e, null), this._entries[i] = n, n);
    }
  }
  $l._INSTANCE = new $l(E8);
  class Tm {
    constructor(e, t) {
      this.stack = e, this.embeddedLanguageData = t;
    }
    clone() {
      return (this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null) === this.embeddedLanguageData ? this : $l.create(this.stack, this.embeddedLanguageData);
    }
    equals(e) {
      return !(e instanceof Tm) || !this.stack.equals(e.stack) ? !1 : this.embeddedLanguageData === null && e.embeddedLanguageData === null ? !0 : this.embeddedLanguageData === null || e.embeddedLanguageData === null ? !1 : this.embeddedLanguageData.equals(e.embeddedLanguageData);
    }
  }
  class Ule {
    constructor() {
      this._tokens = [], this._languageId = null, this._lastTokenType = null, this._lastTokenLanguage = null;
    }
    enterLanguage(e) {
      this._languageId = e;
    }
    emit(e, t) {
      this._lastTokenType === t && this._lastTokenLanguage === this._languageId || (this._lastTokenType = t, this._lastTokenLanguage = this._languageId, this._tokens.push(new Zm(e, t, this._languageId)));
    }
    nestedLanguageTokenize(e, t, i, n) {
      const o = i.languageId, r = i.state, a = Yt.get(o);
      if (!a)
        return this.enterLanguage(o), this.emit(n, ""), r;
      const l = a.tokenize(e, t, r);
      if (n !== 0)
        for (const c of l.tokens)
          this._tokens.push(new Zm(c.offset + n, c.type, c.language));
      else
        this._tokens = this._tokens.concat(l.tokens);
      return this._lastTokenType = null, this._lastTokenLanguage = null, this._languageId = null, l.endState;
    }
    finalize(e) {
      return new dE(this._tokens, e);
    }
  }
  class ov {
    constructor(e, t) {
      this._languageService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
    }
    enterLanguage(e) {
      this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(e);
    }
    emit(e, t) {
      const i = this._theme.match(this._currentLanguageId, t);
      this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
    }
    static _merge(e, t, i) {
      const n = e !== null ? e.length : 0, o = t.length, r = i !== null ? i.length : 0;
      if (n === 0 && o === 0 && r === 0)
        return new Uint32Array(0);
      if (n === 0 && o === 0)
        return i;
      if (o === 0 && r === 0)
        return e;
      const a = new Uint32Array(n + o + r);
      e !== null && a.set(e);
      for (let l = 0; l < o; l++)
        a[n + l] = t[l];
      return i !== null && a.set(i, n + o), a;
    }
    nestedLanguageTokenize(e, t, i, n) {
      const o = i.languageId, r = i.state, a = Yt.get(o);
      if (!a)
        return this.enterLanguage(o), this.emit(n, ""), r;
      const l = a.tokenizeEncoded(e, t, r);
      if (n !== 0)
        for (let c = 0, d = l.tokens.length; c < d; c += 2)
          l.tokens[c] += n;
      return this._prependTokens = ov._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
    }
    finalize(e) {
      return new aC(ov._merge(this._prependTokens, this._tokens, null), e);
    }
  }
  class M_ {
    constructor(e, t, i, n) {
      this._languageService = e, this._standaloneThemeService = t, this._languageId = i, this._lexer = n, this._embeddedLanguages = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
      let o = !1;
      this._tokenizationRegistryListener = Yt.onDidChange((r) => {
        if (o)
          return;
        let a = !1;
        for (let l = 0, c = r.changedLanguages.length; l < c; l++) {
          const d = r.changedLanguages[l];
          if (this._embeddedLanguages[d]) {
            a = !0;
            break;
          }
        }
        a && (o = !0, Yt.fire([this._languageId]), o = !1);
      });
    }
    dispose() {
      this._tokenizationRegistryListener.dispose();
    }
    getLoadStatus() {
      const e = [];
      for (let t in this._embeddedLanguages) {
        const i = Yt.get(t);
        if (i) {
          if (i instanceof M_) {
            const n = i.getLoadStatus();
            n.loaded === !1 && e.push(n.promise);
          }
          continue;
        }
        Yt.isResolved(t) || e.push(Yt.getOrCreate(t));
      }
      return e.length === 0 ? {
        loaded: !0
      } : {
        loaded: !1,
        promise: Promise.all(e).then((t) => {
        })
      };
    }
    getInitialState() {
      const e = qp.create(null, this._lexer.start);
      return $l.create(e, null);
    }
    tokenize(e, t, i) {
      const n = new Ule(), o = this._tokenize(e, t, i, n);
      return n.finalize(o);
    }
    tokenizeEncoded(e, t, i) {
      const n = new ov(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme), o = this._tokenize(e, t, i, n);
      return n.finalize(o);
    }
    _tokenize(e, t, i, n) {
      return i.embeddedLanguageData ? this._nestedTokenize(e, t, i, 0, n) : this._myTokenize(e, t, i, 0, n);
    }
    _findLeavingNestedLanguageOffset(e, t) {
      let i = this._lexer.tokenizer[t.stack.state];
      if (!i && (i = Bb(this._lexer, t.stack.state), !i))
        throw Pt(this._lexer, "tokenizer state is not defined: " + t.stack.state);
      let n = -1, o = !1;
      for (const r of i) {
        if (!NR(r.action) || r.action.nextEmbedded !== "@pop")
          continue;
        o = !0;
        let a = r.regex;
        const l = r.regex.source;
        if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
          const d = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
          a = new RegExp(l.substr(4, l.length - 5), d);
        }
        const c = e.search(a);
        c === -1 || c !== 0 && r.matchOnlyAtLineStart || (n === -1 || c < n) && (n = c);
      }
      if (!o)
        throw Pt(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
      return n;
    }
    _nestedTokenize(e, t, i, n, o) {
      const r = this._findLeavingNestedLanguageOffset(e, i);
      if (r === -1) {
        const c = o.nestedLanguageTokenize(e, t, i.embeddedLanguageData, n);
        return $l.create(i.stack, new Pu(i.embeddedLanguageData.languageId, c));
      }
      const a = e.substring(0, r);
      a.length > 0 && o.nestedLanguageTokenize(a, !1, i.embeddedLanguageData, n);
      const l = e.substring(r);
      return this._myTokenize(l, t, i, n + r, o);
    }
    _safeRuleName(e) {
      return e ? e.name : "(unknown)";
    }
    _myTokenize(e, t, i, n, o) {
      o.enterLanguage(this._languageId);
      const r = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
      let c = i.embeddedLanguageData, d = i.stack, h = 0, u = null, f = !0;
      for (; f || h < l; ) {
        const g = h, _ = d.depth, b = u ? u.groups.length : 0, C = d.state;
        let v = null, w = null, S = null, L = null, x = null;
        if (u) {
          v = u.matches;
          const I = u.groups.shift();
          w = I.matched, S = I.action, L = u.rule, u.groups.length === 0 && (u = null);
        } else {
          if (!f && h >= l)
            break;
          f = !1;
          let I = this._lexer.tokenizer[C];
          if (!I && (I = Bb(this._lexer, C), !I))
            throw Pt(this._lexer, "tokenizer state is not defined: " + C);
          let F = a.substr(h);
          for (const R of I)
            if ((h === 0 || !R.matchOnlyAtLineStart) && (v = F.match(R.regex), v)) {
              w = v[0], S = R.action;
              break;
            }
        }
        if (v || (v = [""], w = ""), S || (h < l && (v = [a.charAt(h)], w = v[0]), S = this._lexer.defaultToken), w === null)
          break;
        for (h += w.length; Vle(S) && NR(S) && S.test; )
          S = S.test(w, v, C, h === l);
        let y = null;
        if (typeof S == "string" || Array.isArray(S))
          y = S;
        else if (S.group)
          y = S.group;
        else if (S.token !== null && S.token !== void 0) {
          if (S.tokenSubst ? y = Ul(this._lexer, S.token, w, v, C) : y = S.token, S.nextEmbedded)
            if (S.nextEmbedded === "@pop") {
              if (!c)
                throw Pt(this._lexer, "cannot pop embedded language if not inside one");
              c = null;
            } else {
              if (c)
                throw Pt(this._lexer, "cannot enter embedded language from within an embedded language");
              x = Ul(this._lexer, S.nextEmbedded, w, v, C);
            }
          if (S.goBack && (h = Math.max(0, h - S.goBack)), S.switchTo && typeof S.switchTo == "string") {
            let I = Ul(this._lexer, S.switchTo, w, v, C);
            if (I[0] === "@" && (I = I.substr(1)), Bb(this._lexer, I))
              d = d.switchTo(I);
            else
              throw Pt(this._lexer, "trying to switch to a state '" + I + "' that is undefined in rule: " + this._safeRuleName(L));
          } else {
            if (S.transform && typeof S.transform == "function")
              throw Pt(this._lexer, "action.transform not supported");
            if (S.next)
              if (S.next === "@push") {
                if (d.depth >= this._lexer.maxStack)
                  throw Pt(this._lexer, "maximum tokenizer stack size reached: [" + d.state + "," + d.parent.state + ",...]");
                d = d.push(C);
              } else if (S.next === "@pop") {
                if (d.depth <= 1)
                  throw Pt(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(L));
                d = d.pop();
              } else if (S.next === "@popall")
                d = d.popall();
              else {
                let I = Ul(this._lexer, S.next, w, v, C);
                if (I[0] === "@" && (I = I.substr(1)), Bb(this._lexer, I))
                  d = d.push(I);
                else
                  throw Pt(this._lexer, "trying to set a next state '" + I + "' that is undefined in rule: " + this._safeRuleName(L));
              }
          }
          S.log && typeof S.log == "string" && Hle(this._lexer, this._lexer.languageId + ": " + Ul(this._lexer, S.log, w, v, C));
        }
        if (y === null)
          throw Pt(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(L));
        const k = (I) => {
          const F = this._languageService.getLanguageIdByLanguageName(I) || this._languageService.getLanguageIdByMimeType(I) || I, R = this._getNestedEmbeddedLanguageData(F);
          if (h < l) {
            const $ = e.substr(h);
            return this._nestedTokenize($, t, $l.create(d, R), n + h, o);
          } else
            return $l.create(d, R);
        };
        if (Array.isArray(y)) {
          if (u && u.groups.length > 0)
            throw Pt(this._lexer, "groups cannot be nested: " + this._safeRuleName(L));
          if (v.length !== y.length + 1)
            throw Pt(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(L));
          let I = 0;
          for (let F = 1; F < v.length; F++)
            I += v[F].length;
          if (I !== w.length)
            throw Pt(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(L));
          u = {
            rule: L,
            matches: v,
            groups: []
          };
          for (let F = 0; F < y.length; F++)
            u.groups[F] = {
              action: y[F],
              matched: v[F + 1]
            };
          h -= w.length;
          continue;
        } else {
          if (y === "@rematch" && (h -= w.length, w = "", v = null, y = "", x !== null))
            return k(x);
          if (w.length === 0) {
            if (l === 0 || _ !== d.depth || C !== d.state || (u ? u.groups.length : 0) !== b)
              continue;
            throw Pt(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(L));
          }
          let I = null;
          if (I8(y) && y.indexOf("@brackets") === 0) {
            const F = y.substr(9), R = $le(this._lexer, w);
            if (!R)
              throw Pt(this._lexer, "@brackets token returned but no bracket defined as: " + w);
            I = TR(R.token + F);
          } else {
            const F = y === "" ? "" : y + this._lexer.tokenPostfix;
            I = TR(F);
          }
          g < r && o.emit(g + n, I);
        }
        if (x !== null)
          return k(x);
      }
      return $l.create(d, c);
    }
    _getNestedEmbeddedLanguageData(e) {
      if (!this._languageService.isRegisteredLanguageId(e))
        return new Pu(e, kf);
      e !== this._languageId && (Yt.getOrCreate(e), this._embeddedLanguages[e] = !0);
      const t = Yt.get(e);
      return t ? new Pu(e, t.getInitialState()) : new Pu(e, kf);
    }
  }
  function $le(s, e) {
    if (!e)
      return null;
    e = uc(s, e);
    const t = s.brackets;
    for (const i of t) {
      if (i.open === e)
        return { token: i.token, bracketType: 1 };
      if (i.close === e)
        return { token: i.token, bracketType: -1 };
    }
    return null;
  }
  var jle = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  }, Ly;
  const ky = (Ly = window.trustedTypes) === null || Ly === void 0 ? void 0 : Ly.createPolicy("standaloneColorizer", { createHTML: (s) => s });
  class n2 {
    static colorizeElement(e, t, i, n) {
      n = n || {};
      const o = n.theme || "vs", r = n.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
      if (!r)
        return console.error("Mode not detected"), Promise.resolve();
      const a = t.getLanguageIdByMimeType(r) || r;
      e.setTheme(o);
      const l = i.firstChild ? i.firstChild.nodeValue : "";
      i.className += " " + o;
      const c = (d) => {
        var h;
        const u = (h = ky?.createHTML(d)) !== null && h !== void 0 ? h : d;
        i.innerHTML = u;
      };
      return this.colorize(t, l || "", a, n).then(c, (d) => console.error(d));
    }
    static colorize(e, t, i, n) {
      return jle(this, void 0, void 0, function* () {
        const o = e.languageIdCodec;
        let r = 4;
        n && typeof n.tabSize == "number" && (r = n.tabSize), PI(t) && (t = t.substr(1));
        const a = da(t);
        if (!e.isRegisteredLanguageId(i))
          return MR(a, r, o);
        const l = yield Yt.getOrCreate(i);
        return l ? Kle(a, r, l, o) : MR(a, r, o);
      });
    }
    static colorizeLine(e, t, i, n, o = 4) {
      const r = Js.isBasicASCII(e, t), a = Js.containsRTL(e, r, i);
      return nC(new Rh(!1, !0, e, !1, r, a, 0, n, [], o, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
    }
    static colorizeModelLine(e, t, i = 4) {
      const n = e.getLineContent(t);
      e.forceTokenization(t);
      const r = e.getLineTokens(t).inflate();
      return this.colorizeLine(n, e.mightContainNonBasicASCII(), e.mightContainRTL(), r, i);
    }
  }
  function Kle(s, e, t, i) {
    return new Promise((n, o) => {
      const r = () => {
        const a = qle(s, e, t, i);
        if (t instanceof M_) {
          const l = t.getLoadStatus();
          if (l.loaded === !1) {
            l.promise.then(r, o);
            return;
          }
        }
        n(a);
      };
      r();
    });
  }
  function MR(s, e, t) {
    let i = [];
    const o = new Uint32Array(2);
    o[0] = 0, o[1] = 16793600;
    for (let r = 0, a = s.length; r < a; r++) {
      const l = s[r];
      o[0] = l.length;
      const c = new Fi(o, l, t), d = Js.isBasicASCII(l, !0), h = Js.containsRTL(l, d, !0), u = nC(new Rh(!1, !0, l, !1, d, h, 0, c, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
      i = i.concat(u.html), i.push("<br/>");
    }
    return i.join("");
  }
  function qle(s, e, t, i) {
    let n = [], o = t.getInitialState();
    for (let r = 0, a = s.length; r < a; r++) {
      const l = s[r], c = t.tokenizeEncoded(l, !0, o);
      Fi.convertToEndOffset(c.tokens, l.length);
      const d = new Fi(c.tokens, l, i), h = Js.isBasicASCII(l, !0), u = Js.containsRTL(l, h, !0), f = nC(new Rh(!1, !0, l, !1, h, u, 0, d.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
      n = n.concat(f.html), n.push("<br/>"), o = c.endState;
    }
    return n.join("");
  }
  var Gle = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Zle = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let fx = class extends z {
    constructor(e) {
      super(), this._themeService = e, this._onCodeEditorAdd = this._register(new B()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new B()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onDiffEditorAdd = this._register(new B()), this.onDiffEditorAdd = this._onDiffEditorAdd.event, this._onDiffEditorRemove = this._register(new B()), this.onDiffEditorRemove = this._onDiffEditorRemove.event, this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null), this._globalStyleSheet = null;
    }
    addCodeEditor(e) {
      this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
    }
    removeCodeEditor(e) {
      delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
    }
    listCodeEditors() {
      return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
    }
    addDiffEditor(e) {
      this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
    }
    removeDiffEditor(e) {
      delete this._diffEditors[e.getId()] && this._onDiffEditorRemove.fire(e);
    }
    listDiffEditors() {
      return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
    }
    getFocusedCodeEditor() {
      let e = null;
      const t = this.listCodeEditors();
      for (const i of t) {
        if (i.hasTextFocus())
          return i;
        i.hasWidgetFocus() && (e = i);
      }
      return e;
    }
    removeDecorationType(e) {
      const t = this._decorationOptionProviders.get(e);
      t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorations(e))));
    }
    setModelProperty(e, t, i) {
      const n = e.toString();
      let o;
      this._modelProperties.has(n) ? o = this._modelProperties.get(n) : (o = /* @__PURE__ */ new Map(), this._modelProperties.set(n, o)), o.set(t, i);
    }
    getModelProperty(e, t) {
      const i = e.toString();
      if (this._modelProperties.has(i))
        return this._modelProperties.get(i).get(t);
    }
  };
  fx = Gle([
    Zle(0, jt)
  ], fx);
  var Yle = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, AR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let rv = class extends fx {
    constructor(e, t) {
      super(t), this.onCodeEditorAdd(() => this._checkContextKey()), this.onCodeEditorRemove(() => this._checkContextKey()), this._editorIsOpen = e.createKey("editorIsOpen", !1), this._activeCodeEditor = null;
    }
    _checkContextKey() {
      let e = !1;
      for (const t of this.listCodeEditors())
        if (!t.isSimpleWidget) {
          e = !0;
          break;
        }
      this._editorIsOpen.set(e);
    }
    setActiveCodeEditor(e) {
      this._activeCodeEditor = e;
    }
    getActiveCodeEditor() {
      return this._activeCodeEditor;
    }
    openCodeEditor(e, t, i) {
      return t ? Promise.resolve(this.doOpenEditor(t, e)) : Promise.resolve(null);
    }
    doOpenEditor(e, t) {
      if (!this.findModel(e, t.resource)) {
        if (t.resource) {
          const o = t.resource.scheme;
          if (o === ze.http || o === ze.https)
            return wP(t.resource.toString()), e;
        }
        return null;
      }
      const n = t.options ? t.options.selection : null;
      if (n)
        if (typeof n.endLineNumber == "number" && typeof n.endColumn == "number")
          e.setSelection(n), e.revealRangeInCenter(n, 1);
        else {
          const o = {
            lineNumber: n.startLineNumber,
            column: n.startColumn
          };
          e.setPosition(o), e.revealPositionInCenter(o, 1);
        }
      return e;
    }
    findModel(e, t) {
      const i = e.getModel();
      return i && i.uri.toString() !== t.toString() ? null : i;
    }
  };
  rv = Yle([
    AR(0, Fe),
    AR(1, jt)
  ], rv);
  ht(St, rv);
  const A_ = st("layoutService");
  var N8 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, T8 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let av = class {
    constructor(e) {
      this._codeEditorService = e, this.onDidLayout = be.None;
    }
    get dimension() {
      return this._dimension || (this._dimension = Nv(window.document.body)), this._dimension;
    }
    get hasContainer() {
      return !1;
    }
    get container() {
      throw new Error("ILayoutService.container is not available in the standalone editor!");
    }
    focus() {
      var e;
      (e = this._codeEditorService.getFocusedCodeEditor()) === null || e === void 0 || e.focus();
    }
  };
  av = N8([
    T8(0, St)
  ], av);
  let gx = class extends av {
    constructor(e, t) {
      super(t), this._container = e;
    }
    get hasContainer() {
      return !1;
    }
    get container() {
      return this._container;
    }
  };
  gx = N8([
    T8(1, St)
  ], gx);
  ht(A_, av);
  var Xle = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, RR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Wb = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function Vb(s) {
    return s.scheme === ze.file ? s.fsPath : s.path;
  }
  let M8 = 0;
  class Hb {
    constructor(e, t, i, n, o, r, a) {
      this.id = ++M8, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.isValid = !0;
    }
    setValid(e) {
      this.isValid = e;
    }
    toString() {
      return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
    }
  }
  class OR {
    constructor(e, t) {
      this.resourceLabel = e, this.reason = t;
    }
  }
  class PR {
    constructor() {
      this.elements = /* @__PURE__ */ new Map();
    }
    createMessage() {
      const e = [], t = [];
      for (const [, n] of this.elements)
        (n.reason === 0 ? e : t).push(n.resourceLabel);
      let i = [];
      return e.length > 0 && i.push(m({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(m({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
    }
    get size() {
      return this.elements.size;
    }
    has(e) {
      return this.elements.has(e);
    }
    set(e, t) {
      this.elements.set(e, t);
    }
    delete(e) {
      return this.elements.delete(e);
    }
  }
  class Qle {
    constructor(e, t, i, n, o, r, a) {
      this.id = ++M8, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
    }
    canSplit() {
      return typeof this.actual.split == "function";
    }
    removeResource(e, t, i) {
      this.removedResources || (this.removedResources = new PR()), this.removedResources.has(t) || this.removedResources.set(t, new OR(e, i));
    }
    setValid(e, t, i) {
      i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new PR()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new OR(e, 0)));
    }
    toString() {
      return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
    }
  }
  class A8 {
    constructor(e, t) {
      this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
    }
    dispose() {
      for (const e of this._past)
        e.type === 1 && e.removeResource(this.resourceLabel, this.strResource, 0);
      for (const e of this._future)
        e.type === 1 && e.removeResource(this.resourceLabel, this.strResource, 0);
      this.versionId++;
    }
    toString() {
      let e = [];
      e.push(`* ${this.strResource}:`);
      for (let t = 0; t < this._past.length; t++)
        e.push(`   * [UNDO] ${this._past[t]}`);
      for (let t = this._future.length - 1; t >= 0; t--)
        e.push(`   * [REDO] ${this._future[t]}`);
      return e.join(`
`);
    }
    flushAllElements() {
      this._past = [], this._future = [], this.versionId++;
    }
    _setElementValidFlag(e, t) {
      e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
    }
    setElementsValidFlag(e, t) {
      for (const i of this._past)
        t(i.actual) && this._setElementValidFlag(i, e);
      for (const i of this._future)
        t(i.actual) && this._setElementValidFlag(i, e);
    }
    pushElement(e) {
      for (const t of this._future)
        t.type === 1 && t.removeResource(this.resourceLabel, this.strResource, 1);
      this._future = [], this._past.push(e), this.versionId++;
    }
    createSnapshot(e) {
      const t = [];
      for (let i = 0, n = this._past.length; i < n; i++)
        t.push(this._past[i].id);
      for (let i = this._future.length - 1; i >= 0; i--)
        t.push(this._future[i].id);
      return new kF(e, t);
    }
    restoreSnapshot(e) {
      const t = e.elements.length;
      let i = !0, n = 0, o = -1;
      for (let a = 0, l = this._past.length; a < l; a++, n++) {
        const c = this._past[a];
        i && (n >= t || c.id !== e.elements[n]) && (i = !1, o = 0), !i && c.type === 1 && c.removeResource(this.resourceLabel, this.strResource, 0);
      }
      let r = -1;
      for (let a = this._future.length - 1; a >= 0; a--, n++) {
        const l = this._future[a];
        i && (n >= t || l.id !== e.elements[n]) && (i = !1, r = a), !i && l.type === 1 && l.removeResource(this.resourceLabel, this.strResource, 0);
      }
      o !== -1 && (this._past = this._past.slice(0, o)), r !== -1 && (this._future = this._future.slice(r + 1)), this.versionId++;
    }
    getElements() {
      const e = [], t = [];
      for (const i of this._past)
        e.push(i.actual);
      for (const i of this._future)
        t.push(i.actual);
      return { past: e, future: t };
    }
    getClosestPastElement() {
      return this._past.length === 0 ? null : this._past[this._past.length - 1];
    }
    getSecondClosestPastElement() {
      return this._past.length < 2 ? null : this._past[this._past.length - 2];
    }
    getClosestFutureElement() {
      return this._future.length === 0 ? null : this._future[this._future.length - 1];
    }
    hasPastElements() {
      return this._past.length > 0;
    }
    hasFutureElements() {
      return this._future.length > 0;
    }
    splitPastWorkspaceElement(e, t) {
      for (let i = this._past.length - 1; i >= 0; i--)
        if (this._past[i] === e) {
          t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
          break;
        }
      this.versionId++;
    }
    splitFutureWorkspaceElement(e, t) {
      for (let i = this._future.length - 1; i >= 0; i--)
        if (this._future[i] === e) {
          t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
          break;
        }
      this.versionId++;
    }
    moveBackward(e) {
      this._past.pop(), this._future.push(e), this.versionId++;
    }
    moveForward(e) {
      this._future.pop(), this._past.push(e), this.versionId++;
    }
  }
  class Dy {
    constructor(e) {
      this.editStacks = e, this._versionIds = [];
      for (let t = 0, i = this.editStacks.length; t < i; t++)
        this._versionIds[t] = this.editStacks[t].versionId;
    }
    isValid() {
      for (let e = 0, t = this.editStacks.length; e < t; e++)
        if (this._versionIds[e] !== this.editStacks[e].versionId)
          return !1;
      return !0;
    }
  }
  const R8 = new A8("", "");
  R8.locked = !0;
  let mx = class {
    constructor(e, t) {
      this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
    }
    getUriComparisonKey(e) {
      for (const t of this._uriComparisonKeyComputers)
        if (t[0] === e.scheme)
          return t[1].getComparisonKey(e);
      return e.toString();
    }
    _print(e) {
      console.log("------------------------------------"), console.log(`AFTER ${e}: `);
      let t = [];
      for (const i of this._editStacks)
        t.push(i[1].toString());
      console.log(t.join(`
`));
    }
    pushElement(e, t = Df.None, i = Gr.None) {
      if (e.type === 0) {
        const n = Vb(e.resource), o = this.getUriComparisonKey(e.resource);
        this._pushElement(new Hb(e, n, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
      } else {
        const n = /* @__PURE__ */ new Set(), o = [], r = [];
        for (const a of e.resources) {
          const l = Vb(a), c = this.getUriComparisonKey(a);
          n.has(c) || (n.add(c), o.push(l), r.push(c));
        }
        o.length === 1 ? this._pushElement(new Hb(e, o[0], r[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new Qle(e, o, r, t.id, t.nextOrder(), i.id, i.nextOrder()));
      }
    }
    _pushElement(e) {
      for (let t = 0, i = e.strResources.length; t < i; t++) {
        const n = e.resourceLabels[t], o = e.strResources[t];
        let r;
        this._editStacks.has(o) ? r = this._editStacks.get(o) : (r = new A8(n, o), this._editStacks.set(o, r)), r.pushElement(e);
      }
    }
    getLastElement(e) {
      const t = this.getUriComparisonKey(e);
      if (this._editStacks.has(t)) {
        const i = this._editStacks.get(t);
        if (i.hasFutureElements())
          return null;
        const n = i.getClosestPastElement();
        return n ? n.actual : null;
      }
      return null;
    }
    _splitPastWorkspaceElement(e, t) {
      const i = e.actual.split(), n = /* @__PURE__ */ new Map();
      for (const o of i) {
        const r = Vb(o.resource), a = this.getUriComparisonKey(o.resource), l = new Hb(o, r, a, 0, 0, 0, 0);
        n.set(l.strResource, l);
      }
      for (const o of e.strResources) {
        if (t && t.has(o))
          continue;
        this._editStacks.get(o).splitPastWorkspaceElement(e, n);
      }
    }
    _splitFutureWorkspaceElement(e, t) {
      const i = e.actual.split(), n = /* @__PURE__ */ new Map();
      for (const o of i) {
        const r = Vb(o.resource), a = this.getUriComparisonKey(o.resource), l = new Hb(o, r, a, 0, 0, 0, 0);
        n.set(l.strResource, l);
      }
      for (const o of e.strResources) {
        if (t && t.has(o))
          continue;
        this._editStacks.get(o).splitFutureWorkspaceElement(e, n);
      }
    }
    removeElements(e) {
      const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
      this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
    }
    setElementsValidFlag(e, t, i) {
      const n = this.getUriComparisonKey(e);
      this._editStacks.has(n) && this._editStacks.get(n).setElementsValidFlag(t, i);
    }
    createSnapshot(e) {
      const t = this.getUriComparisonKey(e);
      return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new kF(e, []);
    }
    restoreSnapshot(e) {
      const t = this.getUriComparisonKey(e.resource);
      if (this._editStacks.has(t)) {
        const i = this._editStacks.get(t);
        i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
      }
    }
    getElements(e) {
      const t = this.getUriComparisonKey(e);
      return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
    }
    _findClosestUndoElementWithSource(e) {
      if (!e)
        return [null, null];
      let t = null, i = null;
      for (const [n, o] of this._editStacks) {
        const r = o.getClosestPastElement();
        !r || r.sourceId === e && (!t || r.sourceOrder > t.sourceOrder) && (t = r, i = n);
      }
      return [t, i];
    }
    canUndo(e) {
      if (e instanceof Gr) {
        const [, i] = this._findClosestUndoElementWithSource(e.id);
        return !!i;
      }
      const t = this.getUriComparisonKey(e);
      return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
    }
    _onError(e, t) {
      We(e);
      for (const i of t.strResources)
        this.removeElements(i);
      this._notificationService.error(e);
    }
    _acquireLocks(e) {
      for (const t of e.editStacks)
        if (t.locked)
          throw new Error("Cannot acquire edit stack lock");
      for (const t of e.editStacks)
        t.locked = !0;
      return () => {
        for (const t of e.editStacks)
          t.locked = !1;
      };
    }
    _safeInvokeWithLocks(e, t, i, n, o) {
      const r = this._acquireLocks(i);
      let a;
      try {
        a = t();
      } catch (l) {
        return r(), n.dispose(), this._onError(l, e);
      }
      return a ? a.then(() => (r(), n.dispose(), o()), (l) => (r(), n.dispose(), this._onError(l, e))) : (r(), n.dispose(), o());
    }
    _invokeWorkspacePrepare(e) {
      return Wb(this, void 0, void 0, function* () {
        if (typeof e.actual.prepareUndoRedo > "u")
          return z.None;
        const t = e.actual.prepareUndoRedo();
        return typeof t > "u" ? z.None : t;
      });
    }
    _invokeResourcePrepare(e, t) {
      if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
        return t(z.None);
      const i = e.actual.prepareUndoRedo();
      return i ? lI(i) ? t(i) : i.then((n) => t(n)) : t(z.None);
    }
    _getAffectedEditStacks(e) {
      const t = [];
      for (const i of e.strResources)
        t.push(this._editStacks.get(i) || R8);
      return new Dy(t);
    }
    _tryToSplitAndUndo(e, t, i, n) {
      if (t.canSplit())
        return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(n), new zb(this._undo(e, 0, !0));
      for (const o of t.strResources)
        this.removeElements(o);
      return this._notificationService.warn(n), new zb();
    }
    _checkWorkspaceUndo(e, t, i, n) {
      if (t.removedResources)
        return this._tryToSplitAndUndo(e, t, t.removedResources, m({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
      if (n && t.invalidatedResources)
        return this._tryToSplitAndUndo(e, t, t.invalidatedResources, m({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
      const o = [];
      for (const a of i.editStacks)
        a.getClosestPastElement() !== t && o.push(a.resourceLabel);
      if (o.length > 0)
        return this._tryToSplitAndUndo(e, t, null, m({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
      const r = [];
      for (const a of i.editStacks)
        a.locked && r.push(a.resourceLabel);
      return r.length > 0 ? this._tryToSplitAndUndo(e, t, null, m({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, m({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
    }
    _workspaceUndo(e, t, i) {
      const n = this._getAffectedEditStacks(t), o = this._checkWorkspaceUndo(e, t, n, !1);
      return o ? o.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, n, i);
    }
    _isPartOfUndoGroup(e) {
      if (!e.groupId)
        return !1;
      for (const [, t] of this._editStacks) {
        const i = t.getClosestPastElement();
        if (!!i) {
          if (i === e) {
            const n = t.getSecondClosestPastElement();
            if (n && n.groupId === e.groupId)
              return !0;
          }
          if (i.groupId === e.groupId)
            return !0;
        }
      }
      return !1;
    }
    _confirmAndExecuteWorkspaceUndo(e, t, i, n) {
      return Wb(this, void 0, void 0, function* () {
        if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
          const a = yield this._dialogService.show(Zt.Info, m("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label), [
            m({ key: "ok", comment: ["{0} denotes a number that is > 1"] }, "Undo in {0} Files", i.editStacks.length),
            m("nok", "Undo this File"),
            m("cancel", "Cancel")
          ], {
            cancelId: 2
          });
          if (a.choice === 2)
            return;
          if (a.choice === 1)
            return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
          const l = this._checkWorkspaceUndo(e, t, i, !1);
          if (l)
            return l.returnValue;
          n = !0;
        }
        let o;
        try {
          o = yield this._invokeWorkspacePrepare(t);
        } catch (a) {
          return this._onError(a, t);
        }
        const r = this._checkWorkspaceUndo(e, t, i, !0);
        if (r)
          return o.dispose(), r.returnValue;
        for (const a of i.editStacks)
          a.moveBackward(t);
        return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, o, () => this._continueUndoInGroup(t.groupId, n));
      });
    }
    _resourceUndo(e, t, i) {
      if (!t.isValid) {
        e.flushAllElements();
        return;
      }
      if (e.locked) {
        const n = m({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
        this._notificationService.warn(n);
        return;
      }
      return this._invokeResourcePrepare(t, (n) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new Dy([e]), n, () => this._continueUndoInGroup(t.groupId, i))));
    }
    _findClosestUndoElementInGroup(e) {
      if (!e)
        return [null, null];
      let t = null, i = null;
      for (const [n, o] of this._editStacks) {
        const r = o.getClosestPastElement();
        !r || r.groupId === e && (!t || r.groupOrder > t.groupOrder) && (t = r, i = n);
      }
      return [t, i];
    }
    _continueUndoInGroup(e, t) {
      if (!e)
        return;
      const [, i] = this._findClosestUndoElementInGroup(e);
      if (i)
        return this._undo(i, 0, t);
    }
    undo(e) {
      if (e instanceof Gr) {
        const [, t] = this._findClosestUndoElementWithSource(e.id);
        return t ? this._undo(t, e.id, !1) : void 0;
      }
      return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
    }
    _undo(e, t = 0, i) {
      if (!this._editStacks.has(e))
        return;
      const n = this._editStacks.get(e), o = n.getClosestPastElement();
      if (!o)
        return;
      if (o.groupId) {
        const [a, l] = this._findClosestUndoElementInGroup(o.groupId);
        if (o !== a && l)
          return this._undo(l, t, i);
      }
      if ((o.sourceId !== t || o.confirmBeforeUndo) && !i)
        return this._confirmAndContinueUndo(e, t, o);
      try {
        return o.type === 1 ? this._workspaceUndo(e, o, i) : this._resourceUndo(n, o, i);
      } finally {
      }
    }
    _confirmAndContinueUndo(e, t, i) {
      return Wb(this, void 0, void 0, function* () {
        if ((yield this._dialogService.show(Zt.Info, m("confirmDifferentSource", "Would you like to undo '{0}'?", i.label), [
          m("confirmDifferentSource.yes", "Yes"),
          m("confirmDifferentSource.no", "No")
        ], {
          cancelId: 1
        })).choice !== 1)
          return this._undo(e, t, !0);
      });
    }
    _findClosestRedoElementWithSource(e) {
      if (!e)
        return [null, null];
      let t = null, i = null;
      for (const [n, o] of this._editStacks) {
        const r = o.getClosestFutureElement();
        !r || r.sourceId === e && (!t || r.sourceOrder < t.sourceOrder) && (t = r, i = n);
      }
      return [t, i];
    }
    canRedo(e) {
      if (e instanceof Gr) {
        const [, i] = this._findClosestRedoElementWithSource(e.id);
        return !!i;
      }
      const t = this.getUriComparisonKey(e);
      return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
    }
    _tryToSplitAndRedo(e, t, i, n) {
      if (t.canSplit())
        return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(n), new zb(this._redo(e));
      for (const o of t.strResources)
        this.removeElements(o);
      return this._notificationService.warn(n), new zb();
    }
    _checkWorkspaceRedo(e, t, i, n) {
      if (t.removedResources)
        return this._tryToSplitAndRedo(e, t, t.removedResources, m({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
      if (n && t.invalidatedResources)
        return this._tryToSplitAndRedo(e, t, t.invalidatedResources, m({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
      const o = [];
      for (const a of i.editStacks)
        a.getClosestFutureElement() !== t && o.push(a.resourceLabel);
      if (o.length > 0)
        return this._tryToSplitAndRedo(e, t, null, m({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
      const r = [];
      for (const a of i.editStacks)
        a.locked && r.push(a.resourceLabel);
      return r.length > 0 ? this._tryToSplitAndRedo(e, t, null, m({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, m({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
    }
    _workspaceRedo(e, t) {
      const i = this._getAffectedEditStacks(t), n = this._checkWorkspaceRedo(e, t, i, !1);
      return n ? n.returnValue : this._executeWorkspaceRedo(e, t, i);
    }
    _executeWorkspaceRedo(e, t, i) {
      return Wb(this, void 0, void 0, function* () {
        let n;
        try {
          n = yield this._invokeWorkspacePrepare(t);
        } catch (r) {
          return this._onError(r, t);
        }
        const o = this._checkWorkspaceRedo(e, t, i, !0);
        if (o)
          return n.dispose(), o.returnValue;
        for (const r of i.editStacks)
          r.moveForward(t);
        return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, n, () => this._continueRedoInGroup(t.groupId));
      });
    }
    _resourceRedo(e, t) {
      if (!t.isValid) {
        e.flushAllElements();
        return;
      }
      if (e.locked) {
        const i = m({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
        this._notificationService.warn(i);
        return;
      }
      return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new Dy([e]), i, () => this._continueRedoInGroup(t.groupId))));
    }
    _findClosestRedoElementInGroup(e) {
      if (!e)
        return [null, null];
      let t = null, i = null;
      for (const [n, o] of this._editStacks) {
        const r = o.getClosestFutureElement();
        !r || r.groupId === e && (!t || r.groupOrder < t.groupOrder) && (t = r, i = n);
      }
      return [t, i];
    }
    _continueRedoInGroup(e) {
      if (!e)
        return;
      const [, t] = this._findClosestRedoElementInGroup(e);
      if (t)
        return this._redo(t);
    }
    redo(e) {
      if (e instanceof Gr) {
        const [, t] = this._findClosestRedoElementWithSource(e.id);
        return t ? this._redo(t) : void 0;
      }
      return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
    }
    _redo(e) {
      if (!this._editStacks.has(e))
        return;
      const t = this._editStacks.get(e), i = t.getClosestFutureElement();
      if (!!i) {
        if (i.groupId) {
          const [n, o] = this._findClosestRedoElementInGroup(i.groupId);
          if (i !== n && o)
            return this._redo(o);
        }
        try {
          return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
        } finally {
        }
      }
    }
  };
  mx = Xle([
    RR(0, N_),
    RR(1, yi)
  ], mx);
  class zb {
    constructor(e) {
      this.returnValue = e;
    }
  }
  ht(uC, mx);
  const Jle = Object.freeze({
    id: "editor",
    order: 5,
    type: "object",
    title: m("editorConfigurationTitle", "Editor"),
    scope: 5
  }), lv = Object.assign(Object.assign({}, Jle), { properties: {
    "editor.tabSize": {
      type: "number",
      default: On.tabSize,
      minimum: 1,
      markdownDescription: m("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
    },
    "editor.insertSpaces": {
      type: "boolean",
      default: On.insertSpaces,
      markdownDescription: m("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
    },
    "editor.detectIndentation": {
      type: "boolean",
      default: On.detectIndentation,
      markdownDescription: m("detectIndentation", "Controls whether `#editor.tabSize#` and `#editor.insertSpaces#` will be automatically detected when a file is opened based on the file contents.")
    },
    "editor.trimAutoWhitespace": {
      type: "boolean",
      default: On.trimAutoWhitespace,
      description: m("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
    },
    "editor.largeFileOptimizations": {
      type: "boolean",
      default: On.largeFileOptimizations,
      description: m("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
    },
    "editor.wordBasedSuggestions": {
      type: "boolean",
      default: !0,
      description: m("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document.")
    },
    "editor.wordBasedSuggestionsMode": {
      enum: ["currentDocument", "matchingDocuments", "allDocuments"],
      default: "matchingDocuments",
      enumDescriptions: [
        m("wordBasedSuggestionsMode.currentDocument", "Only suggest words from the active document."),
        m("wordBasedSuggestionsMode.matchingDocuments", "Suggest words from all open documents of the same language."),
        m("wordBasedSuggestionsMode.allDocuments", "Suggest words from all open documents.")
      ],
      description: m("wordBasedSuggestionsMode", "Controls from which documents word based completions are computed.")
    },
    "editor.semanticHighlighting.enabled": {
      enum: [!0, !1, "configuredByTheme"],
      enumDescriptions: [
        m("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
        m("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
        m("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
      ],
      default: "configuredByTheme",
      description: m("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
    },
    "editor.stablePeek": {
      type: "boolean",
      default: !1,
      markdownDescription: m("stablePeek", "Keep peek editors open even when double clicking their content or when hitting `Escape`.")
    },
    "editor.maxTokenizationLineLength": {
      type: "integer",
      default: 2e4,
      description: m("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
    },
    "editor.language.brackets": {
      type: "array",
      default: !1,
      description: m("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: m("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: m("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "editor.language.colorizedBracketPairs": {
      type: "array",
      default: !1,
      description: m("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: m("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: m("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "diffEditor.maxComputationTime": {
      type: "number",
      default: 5e3,
      description: m("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
    },
    "diffEditor.maxFileSize": {
      type: "number",
      default: 50,
      description: m("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
    },
    "diffEditor.renderSideBySide": {
      type: "boolean",
      default: !0,
      description: m("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
    },
    "diffEditor.ignoreTrimWhitespace": {
      type: "boolean",
      default: !0,
      description: m("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
    },
    "diffEditor.renderIndicators": {
      type: "boolean",
      default: !0,
      description: m("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
    },
    "diffEditor.codeLens": {
      type: "boolean",
      default: !1,
      description: m("codeLens", "Controls whether the editor shows CodeLens.")
    },
    "diffEditor.wordWrap": {
      type: "string",
      enum: ["off", "on", "inherit"],
      default: "inherit",
      markdownEnumDescriptions: [
        m("wordWrap.off", "Lines will never wrap."),
        m("wordWrap.on", "Lines will wrap at the viewport width."),
        m("wordWrap.inherit", "Lines will wrap according to the `#editor.wordWrap#` setting.")
      ]
    }
  } });
  function ece(s) {
    return typeof s.type < "u" || typeof s.anyOf < "u";
  }
  for (const s of xu) {
    const e = s.schema;
    if (typeof e < "u")
      if (ece(e))
        lv.properties[`editor.${s.name}`] = e;
      else
        for (const t in e)
          Object.hasOwnProperty.call(e, t) && (lv.properties[t] = e[t]);
  }
  let Ub = null;
  function O8() {
    return Ub === null && (Ub = /* @__PURE__ */ Object.create(null), Object.keys(lv.properties).forEach((s) => {
      Ub[s] = !0;
    })), Ub;
  }
  function tce(s) {
    return O8()[`editor.${s}`] || !1;
  }
  function ice(s) {
    return O8()[`diffEditor.${s}`] || !1;
  }
  const nce = Si.as(Oh.Configuration);
  nce.registerConfiguration(lv);
  class so {
    constructor(e = {}, t = [], i = []) {
      this._contents = e, this._keys = t, this._overrides = i, this.isFrozen = !1, this.overrideConfigurations = /* @__PURE__ */ new Map();
    }
    get contents() {
      return this.checkAndFreeze(this._contents);
    }
    get overrides() {
      return this.checkAndFreeze(this._overrides);
    }
    get keys() {
      return this.checkAndFreeze(this._keys);
    }
    isEmpty() {
      return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
    }
    getValue(e) {
      return e ? q2(this.contents, e) : this.contents;
    }
    getOverrideValue(e, t) {
      const i = this.getContentsForOverrideIdentifer(t);
      return i ? e ? q2(i, e) : i : void 0;
    }
    override(e) {
      let t = this.overrideConfigurations.get(e);
      return t || (t = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, t)), t;
    }
    merge(...e) {
      const t = ja(this.contents), i = ja(this.overrides), n = [...this.keys];
      for (const o of e) {
        this.mergeContents(t, o.contents);
        for (const r of o.overrides) {
          const [a] = i.filter((l) => Gs(l.identifiers, r.identifiers));
          a ? (this.mergeContents(a.contents, r.contents), a.keys.push(...r.keys), a.keys = Cc(a.keys)) : i.push(ja(r));
        }
        for (const r of o.keys)
          n.indexOf(r) === -1 && n.push(r);
      }
      return new so(t, n, i);
    }
    freeze() {
      return this.isFrozen = !0, this;
    }
    createOverrideConfigurationModel(e) {
      const t = this.getContentsForOverrideIdentifer(e);
      if (!t || typeof t != "object" || !Object.keys(t).length)
        return this;
      let i = {};
      for (const n of Cc([...Object.keys(this.contents), ...Object.keys(t)])) {
        let o = this.contents[n], r = t[n];
        r && (typeof o == "object" && typeof r == "object" ? (o = ja(o), this.mergeContents(o, r)) : o = r), i[n] = o;
      }
      return new so(i, this.keys, this.overrides);
    }
    mergeContents(e, t) {
      for (const i of Object.keys(t)) {
        if (i in e && ls(e[i]) && ls(t[i])) {
          this.mergeContents(e[i], t[i]);
          continue;
        }
        e[i] = ja(t[i]);
      }
    }
    checkAndFreeze(e) {
      return this.isFrozen && !Object.isFrozen(e) ? hH(e) : e;
    }
    getContentsForOverrideIdentifer(e) {
      let t = null, i = null;
      const n = (o) => {
        o && (i ? this.mergeContents(i, o) : i = ja(o));
      };
      for (const o of this.overrides)
        Gs(o.identifiers, [e]) ? t = o.contents : o.identifiers.includes(e) && n(o.contents);
      return n(t), i;
    }
    toJSON() {
      return {
        contents: this.contents,
        overrides: this.overrides,
        keys: this.keys
      };
    }
    setValue(e, t) {
      this.addKey(e), qI(this.contents, e, t, (i) => {
        throw new Error(i);
      });
    }
    removeValue(e) {
      this.removeKey(e) && tH(this.contents, e);
    }
    addKey(e) {
      let t = this.keys.length;
      for (let i = 0; i < t; i++)
        e.indexOf(this.keys[i]) === 0 && (t = i);
      this.keys.splice(t, 1, e);
    }
    removeKey(e) {
      let t = this.keys.indexOf(e);
      return t !== -1 ? (this.keys.splice(t, 1), !0) : !1;
    }
  }
  class sce extends so {
    constructor(e = {}) {
      const t = Si.as(Oh.Configuration).getConfigurationProperties(), i = Object.keys(t), n = /* @__PURE__ */ Object.create(null), o = [];
      for (const r in t) {
        const a = e[r], l = a !== void 0 ? a : t[r].default;
        qI(n, r, l, (c) => console.error(`Conflict in default settings: ${c}`));
      }
      for (const r of Object.keys(n))
        rp.test(r) && o.push({
          identifiers: oF(r),
          keys: Object.keys(n[r]),
          contents: i5(n[r], (a) => console.error(`Conflict in default settings file: ${a}`))
        });
      super(n, i, o);
    }
  }
  class fw {
    constructor(e, t, i = new so(), n = new so(), o = new $n(), r = new so(), a = new $n(), l = !0) {
      this._defaultConfiguration = e, this._localUserConfiguration = t, this._remoteUserConfiguration = i, this._workspaceConfiguration = n, this._folderConfigurations = o, this._memoryConfiguration = r, this._memoryConfigurationByResource = a, this._freeze = l, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new $n(), this._userConfiguration = null;
    }
    getValue(e, t, i) {
      return this.getConsolidateConfigurationModel(t, i).getValue(e);
    }
    updateValue(e, t, i = {}) {
      let n;
      i.resource ? (n = this._memoryConfigurationByResource.get(i.resource), n || (n = new so(), this._memoryConfigurationByResource.set(i.resource, n))) : n = this._memoryConfiguration, t === void 0 ? n.removeValue(e) : n.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
    }
    inspect(e, t, i) {
      const n = this.getConsolidateConfigurationModel(t, i), o = this.getFolderConfigurationModelForResource(t.resource, i), r = t.resource ? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration : this._memoryConfiguration, a = t.overrideIdentifier ? this._defaultConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this._defaultConfiguration.freeze().getValue(e), l = t.overrideIdentifier ? this.userConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this.userConfiguration.freeze().getValue(e), c = t.overrideIdentifier ? this.localUserConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this.localUserConfiguration.freeze().getValue(e), d = t.overrideIdentifier ? this.remoteUserConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this.remoteUserConfiguration.freeze().getValue(e), h = i ? t.overrideIdentifier ? this._workspaceConfiguration.freeze().override(t.overrideIdentifier).getValue(e) : this._workspaceConfiguration.freeze().getValue(e) : void 0, u = o ? t.overrideIdentifier ? o.freeze().override(t.overrideIdentifier).getValue(e) : o.freeze().getValue(e) : void 0, f = t.overrideIdentifier ? r.override(t.overrideIdentifier).getValue(e) : r.getValue(e), g = n.getValue(e), _ = Cc($I(n.overrides.map((b) => b.identifiers))).filter((b) => n.getOverrideValue(e, b) !== void 0);
      return {
        defaultValue: a,
        userValue: l,
        userLocalValue: c,
        userRemoteValue: d,
        workspaceValue: h,
        workspaceFolderValue: u,
        memoryValue: f,
        value: g,
        default: a !== void 0 ? { value: this._defaultConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this._defaultConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
        user: l !== void 0 ? { value: this.userConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this.userConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
        userLocal: c !== void 0 ? { value: this.localUserConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this.localUserConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
        userRemote: d !== void 0 ? { value: this.remoteUserConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this.remoteUserConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
        workspace: h !== void 0 ? { value: this._workspaceConfiguration.freeze().getValue(e), override: t.overrideIdentifier ? this._workspaceConfiguration.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
        workspaceFolder: u !== void 0 ? { value: o?.freeze().getValue(e), override: t.overrideIdentifier ? o?.freeze().getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
        memory: f !== void 0 ? { value: r.getValue(e), override: t.overrideIdentifier ? r.getOverrideValue(e, t.overrideIdentifier) : void 0 } : void 0,
        overrideIdentifiers: _.length ? _ : void 0
      };
    }
    get userConfiguration() {
      return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration), this._freeze && this._userConfiguration.freeze()), this._userConfiguration;
    }
    get localUserConfiguration() {
      return this._localUserConfiguration;
    }
    get remoteUserConfiguration() {
      return this._remoteUserConfiguration;
    }
    getConsolidateConfigurationModel(e, t) {
      let i = this.getConsolidatedConfigurationModelForResource(e, t);
      return e.overrideIdentifier ? i.override(e.overrideIdentifier) : i;
    }
    getConsolidatedConfigurationModelForResource({ resource: e }, t) {
      let i = this.getWorkspaceConsolidatedConfiguration();
      if (t && e) {
        const n = t.getFolder(e);
        n && (i = this.getFolderConsolidatedConfiguration(n.uri) || i);
        const o = this._memoryConfigurationByResource.get(e);
        o && (i = i.merge(o));
      }
      return i;
    }
    getWorkspaceConsolidatedConfiguration() {
      return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration), this._freeze && (this._workspaceConfiguration = this._workspaceConfiguration.freeze())), this._workspaceConsolidatedConfiguration;
    }
    getFolderConsolidatedConfiguration(e) {
      let t = this._foldersConsolidatedConfigurations.get(e);
      if (!t) {
        const i = this.getWorkspaceConsolidatedConfiguration(), n = this._folderConfigurations.get(e);
        n ? (t = i.merge(n), this._freeze && (t = t.freeze()), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
      }
      return t;
    }
    getFolderConfigurationModelForResource(e, t) {
      if (t && e) {
        const i = t.getFolder(e);
        if (i)
          return this._folderConfigurations.get(i.uri);
      }
    }
    toData() {
      return {
        defaults: {
          contents: this._defaultConfiguration.contents,
          overrides: this._defaultConfiguration.overrides,
          keys: this._defaultConfiguration.keys
        },
        user: {
          contents: this.userConfiguration.contents,
          overrides: this.userConfiguration.overrides,
          keys: this.userConfiguration.keys
        },
        workspace: {
          contents: this._workspaceConfiguration.contents,
          overrides: this._workspaceConfiguration.overrides,
          keys: this._workspaceConfiguration.keys
        },
        folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
          const { contents: i, overrides: n, keys: o } = this._folderConfigurations.get(t);
          return e.push([t, { contents: i, overrides: n, keys: o }]), e;
        }, [])
      };
    }
    static parse(e) {
      const t = this.parseConfigurationModel(e.defaults), i = this.parseConfigurationModel(e.user), n = this.parseConfigurationModel(e.workspace), o = e.folders.reduce((r, a) => (r.set(Ee.revive(a[0]), this.parseConfigurationModel(a[1])), r), new $n());
      return new fw(t, i, new so(), n, o, new so(), new $n(), !1);
    }
    static parseConfigurationModel(e) {
      return new so(e.contents, e.keys, e.overrides).freeze();
    }
  }
  class oce {
    constructor(e, t, i, n) {
      this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = n, this._previousConfiguration = void 0;
      const o = /* @__PURE__ */ new Set();
      e.keys.forEach((a) => o.add(a)), e.overrides.forEach(([, a]) => a.forEach((l) => o.add(l))), this.affectedKeys = [...o.values()];
      const r = new so();
      this.affectedKeys.forEach((a) => r.setValue(a, {})), this.affectedKeysTree = r.contents;
    }
    get previousConfiguration() {
      return !this._previousConfiguration && this.previous && (this._previousConfiguration = fw.parse(this.previous.data)), this._previousConfiguration;
    }
    affectsConfiguration(e, t) {
      var i;
      if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, e)) {
        if (t) {
          const n = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (i = this.previous) === null || i === void 0 ? void 0 : i.workspace) : void 0, o = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
          return !po(n, o);
        }
        return !0;
      }
      return !1;
    }
    doesAffectedKeysTreeContains(e, t) {
      let i = i5({ [t]: !0 }, () => {
      }), n;
      for (; typeof i == "object" && (n = Object.keys(i)[0]); ) {
        if (e = e[n], !e)
          return !1;
        i = i[n];
      }
      return !0;
    }
  }
  const rce = /^(cursor|delete)/;
  class ace extends z {
    constructor(e, t, i, n, o) {
      super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = n, this._logService = o, this._onDidUpdateKeybindings = this._register(new B()), this._currentChord = null, this._currentChordChecker = new o_(), this._currentChordStatusMessage = null, this._ignoreSingleModifiers = Fu.EMPTY, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new Ns(), this._logging = !1;
    }
    get onDidUpdateKeybindings() {
      return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : be.None;
    }
    dispose() {
      super.dispose();
    }
    _log(e) {
      this._logging && this._logService.info(`[KeybindingService]: ${e}`);
    }
    getKeybindings() {
      return this._getResolver().getKeybindings();
    }
    lookupKeybinding(e, t) {
      const i = this._getResolver().lookupPrimaryKeybinding(e, t || this._contextKeyService);
      if (!!i)
        return i.resolvedKeybinding;
    }
    dispatchEvent(e, t) {
      return this._dispatch(e, t);
    }
    softDispatch(e, t) {
      const i = this.resolveKeyboardEvent(e);
      if (i.isChord())
        return console.warn("Unexpected keyboard event mapped to a chord"), null;
      const [n] = i.getDispatchParts();
      if (n === null)
        return null;
      const o = this._contextKeyService.getContext(t), r = this._currentChord ? this._currentChord.keypress : null;
      return this._getResolver().resolve(o, r, n);
    }
    _enterChordMode(e, t) {
      this._currentChord = {
        keypress: e,
        label: t
      }, this._currentChordStatusMessage = this._notificationService.status(m("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
      const i = Date.now();
      this._currentChordChecker.cancelAndSet(() => {
        if (!this._documentHasFocus()) {
          this._leaveChordMode();
          return;
        }
        Date.now() - i > 5e3 && this._leaveChordMode();
      }, 500);
    }
    _leaveChordMode() {
      this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChord = null;
    }
    _dispatch(e, t) {
      return this._doDispatch(this.resolveKeyboardEvent(e), t, !1);
    }
    _singleModifierDispatch(e, t) {
      const i = this.resolveKeyboardEvent(e), [n] = i.getSingleModifierDispatchParts();
      if (n)
        return this._ignoreSingleModifiers.has(n) ? (this._log(`+ Ignoring single modifier ${n} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = Fu.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1) : (this._ignoreSingleModifiers = Fu.EMPTY, this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${n}.`), this._currentSingleModifier = n, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
          this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
        }, 300), !1) : n === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${n} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(i, t, !0)) : (this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1));
      const [o] = i.getParts();
      return this._ignoreSingleModifiers = new Fu(o), this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up."), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1;
    }
    _doDispatch(e, t, i = !1) {
      let n = !1;
      if (e.isChord())
        return console.warn("Unexpected keyboard event mapped to a chord"), !1;
      let o = null, r = null;
      if (i) {
        const [d] = e.getSingleModifierDispatchParts();
        o = d, r = d;
      } else
        [o] = e.getDispatchParts(), r = this._currentChord ? this._currentChord.keypress : null;
      if (o === null)
        return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), n;
      const a = this._contextKeyService.getContext(t), l = e.getLabel(), c = this._getResolver().resolve(a, r, o);
      return this._logService.trace("KeybindingService#dispatch", l, c?.commandId), c && c.enterChord ? (n = !0, this._enterChordMode(o, l), n) : (this._currentChord && (!c || !c.commandId) && (this._notificationService.status(m("missing.chord", "The key combination ({0}, {1}) is not a command.", this._currentChord.label, l), { hideAfter: 10 * 1e3 }), n = !0), this._leaveChordMode(), c && c.commandId && (c.bubble || (n = !0), typeof c.commandArgs > "u" ? this._commandService.executeCommand(c.commandId).then(void 0, (d) => this._notificationService.warn(d)) : this._commandService.executeCommand(c.commandId, c.commandArgs).then(void 0, (d) => this._notificationService.warn(d)), rce.test(c.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", { id: c.commandId, from: "keybinding" })), n);
    }
    mightProducePrintableCharacter(e) {
      return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
    }
  }
  class Fu {
    constructor(e) {
      this._ctrlKey = e ? e.ctrlKey : !1, this._shiftKey = e ? e.shiftKey : !1, this._altKey = e ? e.altKey : !1, this._metaKey = e ? e.metaKey : !1;
    }
    has(e) {
      switch (e) {
        case "ctrl":
          return this._ctrlKey;
        case "shift":
          return this._shiftKey;
        case "alt":
          return this._altKey;
        case "meta":
          return this._metaKey;
      }
    }
  }
  Fu.EMPTY = new Fu(null);
  class Mm {
    constructor(e, t, i) {
      this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
      for (const n of e) {
        const o = n.command;
        o && o.charAt(0) !== "-" && this._defaultBoundCommands.set(o, !0);
      }
      this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = Mm.handleRemovals([].concat(e).concat(t));
      for (let n = 0, o = this._keybindings.length; n < o; n++) {
        let r = this._keybindings[n];
        r.keypressParts.length !== 0 && (r.when && r.when.type === 0 || this._addKeyPress(r.keypressParts[0], r));
      }
    }
    static _isTargetedForRemoval(e, t, i, n) {
      return !(t && e.keypressParts[0] !== t || i && e.keypressParts[1] !== i || n && (!e.when || !rV(n, e.when)));
    }
    static handleRemovals(e) {
      const t = /* @__PURE__ */ new Map();
      for (let n = 0, o = e.length; n < o; n++) {
        const r = e[n];
        if (r.command && r.command.charAt(0) === "-") {
          const a = r.command.substring(1);
          t.has(a) ? t.get(a).push(r) : t.set(a, [r]);
        }
      }
      if (t.size === 0)
        return e;
      const i = [];
      for (let n = 0, o = e.length; n < o; n++) {
        const r = e[n];
        if (!r.command || r.command.length === 0) {
          i.push(r);
          continue;
        }
        if (r.command.charAt(0) === "-")
          continue;
        const a = t.get(r.command);
        if (!a || !r.isDefault) {
          i.push(r);
          continue;
        }
        let l = !1;
        for (const c of a) {
          const d = c.keypressParts[0], h = c.keypressParts[1], u = c.when;
          if (this._isTargetedForRemoval(r, d, h, u)) {
            l = !0;
            break;
          }
        }
        if (!l) {
          i.push(r);
          continue;
        }
      }
      return i;
    }
    _addKeyPress(e, t) {
      const i = this._map.get(e);
      if (typeof i > "u") {
        this._map.set(e, [t]), this._addToLookupMap(t);
        return;
      }
      for (let n = i.length - 1; n >= 0; n--) {
        let o = i[n];
        if (o.command === t.command)
          continue;
        const r = o.keypressParts.length > 1, a = t.keypressParts.length > 1;
        r && a && o.keypressParts[1] !== t.keypressParts[1] || Mm.whenIsEntirelyIncluded(o.when, t.when) && this._removeFromLookupMap(o);
      }
      i.push(t), this._addToLookupMap(t);
    }
    _addToLookupMap(e) {
      if (!e.command)
        return;
      let t = this._lookupMap.get(e.command);
      typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
    }
    _removeFromLookupMap(e) {
      if (!e.command)
        return;
      let t = this._lookupMap.get(e.command);
      if (!(typeof t > "u")) {
        for (let i = 0, n = t.length; i < n; i++)
          if (t[i] === e) {
            t.splice(i, 1);
            return;
          }
      }
    }
    static whenIsEntirelyIncluded(e, t) {
      return !t || t.type === 1 ? !0 : !e || e.type === 1 ? !1 : MP(e, t);
    }
    getKeybindings() {
      return this._keybindings;
    }
    lookupPrimaryKeybinding(e, t) {
      const i = this._lookupMap.get(e);
      if (typeof i > "u" || i.length === 0)
        return null;
      if (i.length === 1)
        return i[0];
      for (let n = i.length - 1; n >= 0; n--) {
        const o = i[n];
        if (t.contextMatchesRules(o.when))
          return o;
      }
      return i[i.length - 1];
    }
    resolve(e, t, i) {
      this._log(`| Resolving ${i}${t ? ` chorded from ${t}` : ""}`);
      let n = null;
      if (t !== null) {
        const r = this._map.get(t);
        if (typeof r > "u")
          return this._log("\\ No keybinding entries."), null;
        n = [];
        for (let a = 0, l = r.length; a < l; a++) {
          let c = r[a];
          c.keypressParts[1] === i && n.push(c);
        }
      } else {
        const r = this._map.get(i);
        if (typeof r > "u")
          return this._log("\\ No keybinding entries."), null;
        n = r;
      }
      let o = this._findCommand(e, n);
      return o ? t === null && o.keypressParts.length > 1 && o.keypressParts[1] !== null ? (this._log(`\\ From ${n.length} keybinding entries, matched chord, when: ${FR(o.when)}, source: ${BR(o)}.`), {
        enterChord: !0,
        leaveChord: !1,
        commandId: null,
        commandArgs: null,
        bubble: !1
      }) : (this._log(`\\ From ${n.length} keybinding entries, matched ${o.command}, when: ${FR(o.when)}, source: ${BR(o)}.`), {
        enterChord: !1,
        leaveChord: o.keypressParts.length > 1,
        commandId: o.command,
        commandArgs: o.commandArgs,
        bubble: o.bubble
      }) : (this._log(`\\ From ${n.length} keybinding entries, no when clauses matched the context.`), null);
    }
    _findCommand(e, t) {
      for (let i = t.length - 1; i >= 0; i--) {
        let n = t[i];
        if (!!Mm._contextMatchesRules(e, n.when))
          return n;
      }
      return null;
    }
    static _contextMatchesRules(e, t) {
      return t ? t.evaluate(e) : !0;
    }
  }
  function FR(s) {
    return s ? `${s.serialize()}` : "no when condition";
  }
  function BR(s) {
    return s.extensionId ? s.isBuiltinExtension ? `built-in extension ${s.extensionId}` : `user extension ${s.extensionId}` : s.isDefault ? "built-in" : "user";
  }
  class WR {
    constructor(e, t, i, n, o, r, a) {
      this._resolvedKeybindingItemBrand = void 0, this.resolvedKeybinding = e, this.keypressParts = e ? px(e.getDispatchParts()) : [], e && this.keypressParts.length === 0 && (this.keypressParts = px(e.getSingleModifierDispatchParts())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = n, this.isDefault = o, this.extensionId = r, this.isBuiltinExtension = a;
    }
  }
  function px(s) {
    let e = [];
    for (let t = 0, i = s.length; t < i; t++) {
      const n = s[t];
      if (!n)
        return e;
      e.push(n);
    }
    return e;
  }
  class lce extends $B {
    constructor(e, t) {
      if (super(), t.length === 0)
        throw fr("parts");
      this._os = e, this._parts = t;
    }
    getLabel() {
      return sN.toLabel(this._os, this._parts, (e) => this._getLabel(e));
    }
    getAriaLabel() {
      return RX.toLabel(this._os, this._parts, (e) => this._getAriaLabel(e));
    }
    getElectronAccelerator() {
      return this._parts.length > 1 || this._parts[0].isDuplicateModifierCase() ? null : OX.toLabel(this._os, this._parts, (e) => this._getElectronAccelerator(e));
    }
    isChord() {
      return this._parts.length > 1;
    }
    getParts() {
      return this._parts.map((e) => this._getPart(e));
    }
    _getPart(e) {
      return new UB(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
    }
    getDispatchParts() {
      return this._parts.map((e) => this._getDispatchPart(e));
    }
    getSingleModifierDispatchParts() {
      return this._parts.map((e) => this._getSingleModifierDispatchPart(e));
    }
  }
  class Gp extends lce {
    constructor(e, t) {
      super(t, e.parts);
    }
    _keyCodeToUILabel(e) {
      if (this._os === 2)
        switch (e) {
          case 15:
            return "\u2190";
          case 16:
            return "\u2191";
          case 17:
            return "\u2192";
          case 18:
            return "\u2193";
        }
      return bd.toString(e);
    }
    _getLabel(e) {
      return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
    }
    _getAriaLabel(e) {
      return e.isDuplicateModifierCase() ? "" : bd.toString(e.keyCode);
    }
    _getElectronAccelerator(e) {
      return bd.toElectronAccelerator(e.keyCode);
    }
    _getDispatchPart(e) {
      return Gp.getDispatchStr(e);
    }
    static getDispatchStr(e) {
      if (e.isModifierKey())
        return null;
      let t = "";
      return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += bd.toString(e.keyCode), t;
    }
    _getSingleModifierDispatchPart(e) {
      return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
    }
    static _scanCodeToKeyCode(e) {
      const t = vI[e];
      if (t !== -1)
        return t;
      switch (e) {
        case 10:
          return 31;
        case 11:
          return 32;
        case 12:
          return 33;
        case 13:
          return 34;
        case 14:
          return 35;
        case 15:
          return 36;
        case 16:
          return 37;
        case 17:
          return 38;
        case 18:
          return 39;
        case 19:
          return 40;
        case 20:
          return 41;
        case 21:
          return 42;
        case 22:
          return 43;
        case 23:
          return 44;
        case 24:
          return 45;
        case 25:
          return 46;
        case 26:
          return 47;
        case 27:
          return 48;
        case 28:
          return 49;
        case 29:
          return 50;
        case 30:
          return 51;
        case 31:
          return 52;
        case 32:
          return 53;
        case 33:
          return 54;
        case 34:
          return 55;
        case 35:
          return 56;
        case 36:
          return 22;
        case 37:
          return 23;
        case 38:
          return 24;
        case 39:
          return 25;
        case 40:
          return 26;
        case 41:
          return 27;
        case 42:
          return 28;
        case 43:
          return 29;
        case 44:
          return 30;
        case 45:
          return 21;
        case 51:
          return 83;
        case 52:
          return 81;
        case 53:
          return 87;
        case 54:
          return 89;
        case 55:
          return 88;
        case 56:
          return 0;
        case 57:
          return 80;
        case 58:
          return 90;
        case 59:
          return 86;
        case 60:
          return 82;
        case 61:
          return 84;
        case 62:
          return 85;
        case 106:
          return 92;
      }
      return 0;
    }
    static _resolveSimpleUserBinding(e) {
      if (!e)
        return null;
      if (e instanceof Ud)
        return e;
      const t = this._scanCodeToKeyCode(e.scanCode);
      return t === 0 ? null : new Ud(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, t);
    }
    static resolveUserBinding(e, t) {
      const i = px(e.map((n) => this._resolveSimpleUserBinding(n)));
      return i.length > 0 ? [new Gp(new W0(i), t)] : [];
    }
  }
  var Xl;
  (function(s) {
    s[s.AVOID = 0] = "AVOID", s[s.ALIGN = 1] = "ALIGN";
  })(Xl || (Xl = {}));
  function Bu(s, e, t) {
    const i = t.mode === Xl.ALIGN ? t.offset : t.offset + t.size, n = t.mode === Xl.ALIGN ? t.offset + t.size : t.offset;
    return t.position === 0 ? e <= s - i ? i : e <= n ? n - e : Math.max(s - e, 0) : e <= n ? n - e : e <= s - i ? i : 0;
  }
  class jf extends z {
    constructor(e, t) {
      super(), this.container = null, this.delegate = null, this.toDisposeOnClean = z.None, this.toDisposeOnSetContainer = z.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = J(".context-view"), this.useFixedPosition = !1, this.useShadowDOM = !1, os(this.view), this.setContainer(e, t), this._register(qe(() => this.setContainer(null, 1)));
    }
    setContainer(e, t) {
      var i;
      if (this.container && (this.toDisposeOnSetContainer.dispose(), this.shadowRoot ? (this.shadowRoot.removeChild(this.view), this.shadowRoot = null, (i = this.shadowRootHostElement) === null || i === void 0 || i.remove(), this.shadowRootHostElement = null) : this.container.removeChild(this.view), this.container = null), e) {
        if (this.container = e, this.useFixedPosition = t !== 1, this.useShadowDOM = t === 3, this.useShadowDOM) {
          this.shadowRootHostElement = J(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
          const o = document.createElement("style");
          o.textContent = cce, this.shadowRoot.appendChild(o), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(J("slot"));
        } else
          this.container.appendChild(this.view);
        const n = new te();
        jf.BUBBLE_UP_EVENTS.forEach((o) => {
          n.add(on(this.container, o, (r) => {
            this.onDOMEvent(r, !1);
          }));
        }), jf.BUBBLE_DOWN_EVENTS.forEach((o) => {
          n.add(on(this.container, o, (r) => {
            this.onDOMEvent(r, !0);
          }, !0));
        }), this.toDisposeOnSetContainer = n;
      }
    }
    show(e) {
      this.isVisible() && this.hide(), Bi(this.view), this.view.className = "context-view", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = "2500", this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", Vs(this.view), this.toDisposeOnClean = e.render(this.view) || z.None, this.delegate = e, this.doLayout(), this.delegate.focus && this.delegate.focus();
    }
    getViewElement() {
      return this.view;
    }
    layout() {
      if (!!this.isVisible()) {
        if (this.delegate.canRelayout === !1 && !(aa && Ev.pointerEvents)) {
          this.hide();
          return;
        }
        this.delegate.layout && this.delegate.layout(), this.doLayout();
      }
    }
    doLayout() {
      if (!this.isVisible())
        return;
      let e = this.delegate.getAnchor(), t;
      if (vP(e)) {
        let h = mn(e);
        t = {
          top: h.top,
          left: h.left,
          width: h.width,
          height: h.height
        };
      } else
        t = {
          top: e.y,
          left: e.x,
          width: e.width || 1,
          height: e.height || 2
        };
      const i = Bo(this.view), n = Yy(this.view), o = this.delegate.anchorPosition || 0, r = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
      let l, c;
      if (a === 0) {
        const h = { offset: t.top - window.pageYOffset, size: t.height, position: o === 0 ? 0 : 1 }, u = { offset: t.left, size: t.width, position: r === 0 ? 0 : 1, mode: Xl.ALIGN };
        l = Bu(window.innerHeight, n, h) + window.pageYOffset, Ln.intersects({ start: l, end: l + n }, { start: h.offset, end: h.offset + h.size }) && (u.mode = Xl.AVOID), c = Bu(window.innerWidth, i, u);
      } else {
        const h = { offset: t.left, size: t.width, position: r === 0 ? 0 : 1 }, u = { offset: t.top, size: t.height, position: o === 0 ? 0 : 1, mode: Xl.ALIGN };
        c = Bu(window.innerWidth, i, h), Ln.intersects({ start: c, end: c + i }, { start: h.offset, end: h.offset + h.size }) && (u.mode = Xl.AVOID), l = Bu(window.innerHeight, n, u) + window.pageYOffset;
      }
      this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(o === 0 ? "bottom" : "top"), this.view.classList.add(r === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
      const d = mn(this.container);
      this.view.style.top = `${l - (this.useFixedPosition ? mn(this.view).top : d.top)}px`, this.view.style.left = `${c - (this.useFixedPosition ? mn(this.view).left : d.left)}px`, this.view.style.width = "initial";
    }
    hide(e) {
      const t = this.delegate;
      this.delegate = null, t?.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), os(this.view);
    }
    isVisible() {
      return !!this.delegate;
    }
    onDOMEvent(e, t) {
      this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, document.activeElement) : t && !al(e.target, this.container) && this.hide());
    }
    dispose() {
      this.hide(), super.dispose();
    }
  }
  jf.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
  jf.BUBBLE_DOWN_EVENTS = ["click"];
  let cce = `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	@font-face {
		font-family: "codicon";
		font-display: block;
		src: url("./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6") format("truetype");
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`;
  var dce = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, hce = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let _x = class extends z {
    constructor(e) {
      super(), this.layoutService = e, this.currentViewDisposable = z.None, this.container = e.hasContainer ? e.container : null, this.contextView = this._register(new jf(this.container, 1)), this.layout(), this._register(e.onDidLayout(() => this.layout()));
    }
    setContainer(e, t) {
      this.contextView.setContainer(e, t || 1);
    }
    showContextView(e, t, i) {
      t ? t !== this.container && (this.container = t, this.setContainer(t, i ? 3 : 2)) : this.layoutService.hasContainer && this.container !== this.layoutService.container && (this.container = this.layoutService.container, this.setContainer(this.container, 1)), this.contextView.show(e);
      const n = qe(() => {
        this.currentViewDisposable === n && this.hideContextView();
      });
      return this.currentViewDisposable = n, n;
    }
    getContextViewElement() {
      return this.contextView.getViewElement();
    }
    layout() {
      this.contextView.layout();
    }
    hideContextView(e) {
      this.contextView.hide(e);
    }
  };
  _x = dce([
    hce(0, A_)
  ], _x);
  const xy = "**", VR = "/", N0 = "[/\\\\]", T0 = "[^/\\\\]", uce = /\//g;
  function HR(s) {
    switch (s) {
      case 0:
        return "";
      case 1:
        return `${T0}*?`;
      default:
        return `(?:${N0}|${T0}+${N0}|${N0}${T0}+)*?`;
    }
  }
  function zR(s, e) {
    if (!s)
      return [];
    const t = [];
    let i = !1, n = !1, o = "";
    for (const r of s) {
      switch (r) {
        case e:
          if (!i && !n) {
            t.push(o), o = "";
            continue;
          }
          break;
        case "{":
          i = !0;
          break;
        case "}":
          i = !1;
          break;
        case "[":
          n = !0;
          break;
        case "]":
          n = !1;
          break;
      }
      o += r;
    }
    return o && t.push(o), t;
  }
  function P8(s) {
    if (!s)
      return "";
    let e = "";
    const t = zR(s, VR);
    if (t.every((i) => i === xy))
      e = ".*";
    else {
      let i = !1;
      t.forEach((n, o) => {
        if (n === xy) {
          i || (e += HR(2), i = !0);
          return;
        }
        let r = !1, a = "", l = !1, c = "";
        for (const d of n) {
          if (d !== "}" && r) {
            a += d;
            continue;
          }
          if (l && (d !== "]" || !c)) {
            let h;
            d === "-" ? h = d : (d === "^" || d === "!") && !c ? h = "^" : d === VR ? h = "" : h = wo(d), c += h;
            continue;
          }
          switch (d) {
            case "{":
              r = !0;
              continue;
            case "[":
              l = !0;
              continue;
            case "}": {
              e += `(?:${zR(a, ",").map((f) => P8(f)).join("|")})`, r = !1, a = "";
              break;
            }
            case "]":
              e += "[" + c + "]", l = !1, c = "";
              break;
            case "?":
              e += T0;
              continue;
            case "*":
              e += HR(1);
              continue;
            default:
              e += wo(d);
          }
        }
        o < t.length - 1 && (t[o + 1] !== xy || o + 2 < t.length) && (e += N0), i = !1;
      });
    }
    return e;
  }
  const fce = /^\*\*\/\*\.[\w\.-]+$/, gce = /^\*\*\/([\w\.-]+)\/?$/, mce = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, pce = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, _ce = /^\*\*((\/[\w\.-]+)+)\/?$/, bce = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, UR = new Wc(1e4), $R = function() {
    return !1;
  }, ra = function() {
    return null;
  };
  function s2(s, e) {
    if (!s)
      return ra;
    let t;
    typeof s != "string" ? t = s.pattern : t = s, t = t.trim();
    const i = `${t}_${!!e.trimForExclusions}`;
    let n = UR.get(i);
    if (n)
      return jR(n, s);
    let o;
    if (fce.test(t)) {
      const r = t.substr(4);
      n = function(a, l) {
        return typeof a == "string" && a.endsWith(r) ? t : null;
      };
    } else
      (o = gce.exec(Iy(t, e))) ? n = vce(o[1], t) : (e.trimForExclusions ? pce : mce).test(t) ? n = Cce(t, e) : (o = _ce.exec(Iy(t, e))) ? n = KR(o[1].substr(1), t, !0) : (o = bce.exec(Iy(t, e))) ? n = KR(o[1], t, !1) : n = wce(t);
    return UR.set(i, n), jR(n, s);
  }
  function jR(s, e) {
    return typeof e == "string" ? s : function(t, i) {
      return ML(t, e.base, !Nn) ? s(t.substr(e.base.length + 1), i) : null;
    };
  }
  function Iy(s, e) {
    return e.trimForExclusions && s.endsWith("/**") ? s.substr(0, s.length - 2) : s;
  }
  function vce(s, e) {
    const t = `/${s}`, i = `\\${s}`, n = function(r, a) {
      return typeof r != "string" ? null : a ? a === s ? e : null : r === s || r.endsWith(t) || r.endsWith(i) ? e : null;
    }, o = [s];
    return n.basenames = o, n.patterns = [e], n.allBasenames = o, n;
  }
  function Cce(s, e) {
    const t = B8(s.slice(1, -1).split(",").map((a) => s2(a, e)).filter((a) => a !== ra), s), i = t.length;
    if (!i)
      return ra;
    if (i === 1)
      return t[0];
    const n = function(a, l) {
      for (let c = 0, d = t.length; c < d; c++)
        if (t[c](a, l))
          return s;
      return null;
    }, o = t.find((a) => !!a.allBasenames);
    o && (n.allBasenames = o.allBasenames);
    const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
    return r.length && (n.allPaths = r), n;
  }
  function KR(s, e, t) {
    const i = ta === Ci.sep, n = i ? s : s.replace(uce, ta), o = ta + n, r = Ci.sep + s, a = t ? function(l, c) {
      return typeof l == "string" && (l === n || l.endsWith(o) || !i && (l === s || l.endsWith(r))) ? e : null;
    } : function(l, c) {
      return typeof l == "string" && (l === n || !i && l === s) ? e : null;
    };
    return a.allPaths = [(t ? "*/" : "./") + s], a;
  }
  function wce(s) {
    try {
      const e = new RegExp(`^${P8(s)}$`);
      return function(t) {
        return e.lastIndex = 0, typeof t == "string" && e.test(t) ? s : null;
      };
    } catch {
      return ra;
    }
  }
  function Sce(s, e, t) {
    return !s || typeof e != "string" ? !1 : F8(s)(e, void 0, t);
  }
  function F8(s, e = {}) {
    if (!s)
      return $R;
    if (typeof s == "string" || yce(s)) {
      const t = s2(s, e);
      if (t === ra)
        return $R;
      const i = function(n, o) {
        return !!t(n, o);
      };
      return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
    }
    return Lce(s, e);
  }
  function yce(s) {
    const e = s;
    return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
  }
  function Lce(s, e) {
    const t = B8(Object.getOwnPropertyNames(s).map((a) => kce(a, s[a], e)).filter((a) => a !== ra)), i = t.length;
    if (!i)
      return ra;
    if (!t.some((a) => !!a.requiresSiblings)) {
      if (i === 1)
        return t[0];
      const a = function(d, h) {
        for (let u = 0, f = t.length; u < f; u++) {
          const g = t[u](d, h);
          if (g)
            return g;
        }
        return null;
      }, l = t.find((d) => !!d.allBasenames);
      l && (a.allBasenames = l.allBasenames);
      const c = t.reduce((d, h) => h.allPaths ? d.concat(h.allPaths) : d, []);
      return c.length && (a.allPaths = c), a;
    }
    const n = function(a, l, c) {
      let d;
      for (let h = 0, u = t.length; h < u; h++) {
        const f = t[h];
        f.requiresSiblings && c && (l || (l = kd(a)), d || (d = l.substr(0, l.length - uW(a).length)));
        const g = f(a, l, d, c);
        if (g)
          return g;
      }
      return null;
    }, o = t.find((a) => !!a.allBasenames);
    o && (n.allBasenames = o.allBasenames);
    const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
    return r.length && (n.allPaths = r), n;
  }
  function kce(s, e, t) {
    if (e === !1)
      return ra;
    const i = s2(s, t);
    if (i === ra)
      return ra;
    if (typeof e == "boolean")
      return i;
    if (e) {
      const n = e.when;
      if (typeof n == "string") {
        const o = (r, a, l, c) => {
          if (!c || !i(r, a))
            return null;
          const d = n.replace("$(basename)", l), h = c(d);
          return XB(h) ? h.then((u) => u ? s : null) : h ? s : null;
        };
        return o.requiresSiblings = !0, o;
      }
    }
    return i;
  }
  function B8(s, e) {
    const t = s.filter((a) => !!a.basenames);
    if (t.length < 2)
      return s;
    const i = t.reduce((a, l) => {
      const c = l.basenames;
      return c ? a.concat(c) : a;
    }, []);
    let n;
    if (e) {
      n = [];
      for (let a = 0, l = i.length; a < l; a++)
        n.push(e);
    } else
      n = t.reduce((a, l) => {
        const c = l.patterns;
        return c ? a.concat(c) : a;
      }, []);
    const o = function(a, l) {
      if (typeof a != "string")
        return null;
      if (!l) {
        let d;
        for (d = a.length; d > 0; d--) {
          const h = a.charCodeAt(d - 1);
          if (h === 47 || h === 92)
            break;
        }
        l = a.substr(d);
      }
      const c = i.indexOf(l);
      return c !== -1 ? n[c] : null;
    };
    o.basenames = i, o.patterns = n, o.allBasenames = i;
    const r = s.filter((a) => !a.basenames);
    return r.push(o), r;
  }
  let Kf = [], o2 = [], W8 = [];
  function $b(s, e = !1) {
    Dce(s, !1, e);
  }
  function Dce(s, e, t) {
    const i = xce(s, e);
    Kf.push(i), i.userConfigured ? W8.push(i) : o2.push(i), t && !i.userConfigured && Kf.forEach((n) => {
      n.mime === i.mime || n.userConfigured || (i.extension && n.extension === i.extension && console.warn(`Overwriting extension <<${i.extension}>> to now point to mime <<${i.mime}>>`), i.filename && n.filename === i.filename && console.warn(`Overwriting filename <<${i.filename}>> to now point to mime <<${i.mime}>>`), i.filepattern && n.filepattern === i.filepattern && console.warn(`Overwriting filepattern <<${i.filepattern}>> to now point to mime <<${i.mime}>>`), i.firstline && n.firstline === i.firstline && console.warn(`Overwriting firstline <<${i.firstline}>> to now point to mime <<${i.mime}>>`));
    });
  }
  function xce(s, e) {
    return {
      id: s.id,
      mime: s.mime,
      filename: s.filename,
      extension: s.extension,
      filepattern: s.filepattern,
      firstline: s.firstline,
      userConfigured: e,
      filenameLowercase: s.filename ? s.filename.toLowerCase() : void 0,
      extensionLowercase: s.extension ? s.extension.toLowerCase() : void 0,
      filepatternLowercase: s.filepattern ? F8(s.filepattern.toLowerCase()) : void 0,
      filepatternOnPath: s.filepattern ? s.filepattern.indexOf(Ci.sep) >= 0 : !1
    };
  }
  function Ice() {
    Kf = Kf.filter((s) => s.userConfigured), o2 = [];
  }
  function Ece(s, e) {
    let t;
    if (s)
      switch (s.scheme) {
        case ze.file:
          t = s.fsPath;
          break;
        case ze.data: {
          t = yc.parseMetaData(s).get(yc.META_DATA_LABEL);
          break;
        }
        default:
          t = s.path;
      }
    if (!t)
      return [cr.unknown];
    t = t.toLowerCase();
    const i = kd(t), n = qR(t, i, W8);
    if (n)
      return [n, cr.text];
    const o = qR(t, i, o2);
    if (o)
      return [o, cr.text];
    if (e) {
      const r = Nce(e);
      if (r)
        return [r, cr.text];
    }
    return [cr.unknown];
  }
  function qR(s, e, t) {
    var i;
    let n, o, r;
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a];
      if (e === l.filenameLowercase) {
        n = l;
        break;
      }
      if (l.filepattern && (!o || l.filepattern.length > o.filepattern.length)) {
        const c = l.filepatternOnPath ? s : e;
        !((i = l.filepatternLowercase) === null || i === void 0) && i.call(l, c) && (o = l);
      }
      l.extension && (!r || l.extension.length > r.extension.length) && e.endsWith(l.extensionLowercase) && (r = l);
    }
    if (n)
      return n.mime;
    if (o)
      return o.mime;
    if (r)
      return r.mime;
  }
  function Nce(s) {
    if (PI(s) && (s = s.substr(1)), s.length > 0)
      for (let e = Kf.length - 1; e >= 0; e--) {
        const t = Kf[e];
        if (!t.firstline)
          continue;
        const i = s.match(t.firstline);
        if (i && i.length > 0)
          return t.mime;
      }
  }
  const jb = Object.prototype.hasOwnProperty, bx = "vs.editor.nullLanguage";
  Di.register(bx, {});
  class Tce {
    constructor() {
      this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ new Map(), this._register(bx, 0), this._register(ya, 1), this._nextLanguageId = 2;
    }
    _register(e, t) {
      this._languageIdToLanguage[t] = e, this._languageToLanguageId.set(e, t);
    }
    register(e) {
      if (this._languageToLanguageId.has(e))
        return;
      const t = this._nextLanguageId++;
      this._register(e, t);
    }
    encodeLanguageId(e) {
      return this._languageToLanguageId.get(e) || 0;
    }
    decodeLanguageId(e) {
      return this._languageIdToLanguage[e] || bx;
    }
  }
  class Zp extends z {
    constructor(e = !0, t = !1) {
      super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, Zp.instanceCount++, this._warnOnOverwrite = t, this.languageIdCodec = new Tce(), this._dynamicLanguages = [], this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(Lf.onDidChangeLanguages((i) => {
        this._initializeFromRegistry();
      })));
    }
    dispose() {
      Zp.instanceCount--, super.dispose();
    }
    _initializeFromRegistry() {
      this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Ice();
      const e = [].concat(Lf.getLanguages()).concat(this._dynamicLanguages);
      this._registerLanguages(e);
    }
    _registerLanguages(e) {
      for (const t of e)
        this._registerLanguage(t);
      this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
        const i = this._languages[t];
        i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((n) => {
          this._lowercaseNameMap[n.toLowerCase()] = i.identifier;
        }), i.mimetypes.forEach((n) => {
          this._mimeTypesMap[n] = i.identifier;
        });
      }), Si.as(Oh.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds()), this._onDidChange.fire();
    }
    _registerLanguage(e) {
      const t = e.id;
      let i;
      jb.call(this._languages, t) ? i = this._languages[t] : (this.languageIdCodec.register(t), i = {
        identifier: t,
        name: null,
        mimetypes: [],
        aliases: [],
        extensions: [],
        filenames: [],
        configurationFiles: [],
        icons: []
      }, this._languages[t] = i), this._mergeLanguage(i, e);
    }
    _mergeLanguage(e, t) {
      const i = t.id;
      let n = null;
      if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), n = t.mimetypes[0]), n || (n = `text/x-${i}`, e.mimetypes.push(n)), Array.isArray(t.extensions)) {
        t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
        for (let a of t.extensions)
          $b({ id: i, mime: n, extension: a }, this._warnOnOverwrite);
      }
      if (Array.isArray(t.filenames))
        for (let a of t.filenames)
          $b({ id: i, mime: n, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
      if (Array.isArray(t.filenamePatterns))
        for (let a of t.filenamePatterns)
          $b({ id: i, mime: n, filepattern: a }, this._warnOnOverwrite);
      if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
        let a = t.firstLine;
        a.charAt(0) !== "^" && (a = "^" + a);
        try {
          const l = new RegExp(a);
          qW(l) || $b({ id: i, mime: n, firstline: l }, this._warnOnOverwrite);
        } catch (l) {
          We(l);
        }
      }
      e.aliases.push(i);
      let o = null;
      if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? o = [null] : o = t.aliases), o !== null)
        for (const a of o)
          !a || a.length === 0 || e.aliases.push(a);
      const r = o !== null && o.length > 0;
      if (!(r && o[0] === null)) {
        const a = (r ? o[0] : null) || i;
        (r || !e.name) && (e.name = a);
      }
      t.configuration && e.configurationFiles.push(t.configuration), t.icon && e.icons.push(t.icon);
    }
    isRegisteredLanguageId(e) {
      return e ? jb.call(this._languages, e) : !1;
    }
    getRegisteredLanguageIds() {
      return Object.keys(this._languages);
    }
    getLanguageIdByLanguageName(e) {
      const t = e.toLowerCase();
      return jb.call(this._lowercaseNameMap, t) ? this._lowercaseNameMap[t] : null;
    }
    getLanguageIdByMimeType(e) {
      return e && jb.call(this._mimeTypesMap, e) ? this._mimeTypesMap[e] : null;
    }
    guessLanguageIdByFilepathOrFirstLine(e, t) {
      if (!e && !t)
        return [];
      const i = Ece(e, t);
      return Nh(i.map((n) => this.getLanguageIdByMimeType(n)));
    }
  }
  Zp.instanceCount = 0;
  class Yp extends z {
    constructor(e = !1) {
      super(), this._onDidEncounterLanguage = this._register(new B()), this.onDidEncounterLanguage = this._onDidEncounterLanguage.event, this._onDidChange = this._register(new B({ leakWarningThreshold: 200 })), this.onDidChange = this._onDidChange.event, Yp.instanceCount++, this._encounteredLanguages = /* @__PURE__ */ new Set(), this._registry = this._register(new Zp(!0, e)), this.languageIdCodec = this._registry.languageIdCodec, this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
    }
    dispose() {
      Yp.instanceCount--, super.dispose();
    }
    isRegisteredLanguageId(e) {
      return this._registry.isRegisteredLanguageId(e);
    }
    getLanguageIdByLanguageName(e) {
      return this._registry.getLanguageIdByLanguageName(e);
    }
    getLanguageIdByMimeType(e) {
      return this._registry.getLanguageIdByMimeType(e);
    }
    guessLanguageIdByFilepathOrFirstLine(e, t) {
      const i = this._registry.guessLanguageIdByFilepathOrFirstLine(e, t);
      return qP(i, null);
    }
    createById(e) {
      return new GR(this.onDidChange, () => this._createAndGetLanguageIdentifier(e));
    }
    createByFilepathOrFirstLine(e, t) {
      return new GR(this.onDidChange, () => {
        const i = this.guessLanguageIdByFilepathOrFirstLine(e, t);
        return this._createAndGetLanguageIdentifier(i);
      });
    }
    _createAndGetLanguageIdentifier(e) {
      return (!e || !this.isRegisteredLanguageId(e)) && (e = ya), this._encounteredLanguages.has(e) || (this._encounteredLanguages.add(e), Yt.getOrCreate(e), this._onDidEncounterLanguage.fire(e)), e;
    }
  }
  Yp.instanceCount = 0;
  class GR {
    constructor(e, t) {
      this._onDidChangeLanguages = e, this._selector = t, this._listener = null, this._emitter = null, this.languageId = this._selector();
    }
    _dispose() {
      this._listener && (this._listener.dispose(), this._listener = null), this._emitter && (this._emitter.dispose(), this._emitter = null);
    }
    get onDidChange() {
      return this._listener || (this._listener = this._onDidChangeLanguages(() => this._evaluate())), this._emitter || (this._emitter = new B({
        onLastListenerRemove: () => {
          this._dispose();
        }
      })), this._emitter.event;
    }
    _evaluate() {
      const e = this._selector();
      e !== this.languageId && (this.languageId = e, this._emitter && this._emitter.fire(this.languageId));
    }
  }
  const vx = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, Ey = /(&amp;)?(&amp;)([^\s&])/g;
  var cv;
  (function(s) {
    s[s.Right = 0] = "Right", s[s.Left = 1] = "Left";
  })(cv || (cv = {}));
  class lf extends ga {
    constructor(e, t, i = {}) {
      e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
      const n = document.createElement("div");
      n.classList.add("monaco-menu"), n.setAttribute("role", "presentation"), super(n, {
        orientation: 1,
        actionViewItemProvider: (a) => this.doGetActionViewItem(a, i, o),
        context: i.context,
        actionRunner: i.actionRunner,
        ariaLabel: i.ariaLabel,
        focusOnlyEnabledItems: !0,
        triggerKeys: { keys: [3, ...Ye || Nn ? [10] : []], keyDown: !0 }
      }), this.menuElement = n, this.actionsList.setAttribute("role", "menu"), this.actionsList.tabIndex = 0, this.menuDisposables = this._register(new te()), this.initializeOrUpdateStyleSheet(e, {}), this._register(kt.addTarget(n)), ee(n, ye.KEY_DOWN, (a) => {
        new $t(a).equals(2) && a.preventDefault();
      }), i.enableMnemonics && this.menuDisposables.add(ee(n, ye.KEY_DOWN, (a) => {
        const l = a.key.toLocaleLowerCase();
        if (this.mnemonics.has(l)) {
          wt.stop(a, !0);
          const c = this.mnemonics.get(l);
          if (c.length === 1 && (c[0] instanceof ZR && c[0].container && this.focusItemByElement(c[0].container), c[0].onClick(a)), c.length > 1) {
            const d = c.shift();
            d && d.container && (this.focusItemByElement(d.container), c.push(d)), this.mnemonics.set(l, c);
          }
        }
      })), Nn && this._register(ee(n, ye.KEY_DOWN, (a) => {
        const l = new $t(a);
        l.equals(14) || l.equals(11) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), wt.stop(a, !0)) : (l.equals(13) || l.equals(12)) && (this.focusedItem = 0, this.focusPrevious(), wt.stop(a, !0));
      })), this._register(ee(this.domNode, ye.MOUSE_OUT, (a) => {
        let l = a.relatedTarget;
        al(l, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), a.stopPropagation());
      })), this._register(ee(this.actionsList, ye.MOUSE_OVER, (a) => {
        let l = a.target;
        if (!(!l || !al(l, this.actionsList) || l === this.actionsList)) {
          for (; l.parentElement !== this.actionsList && l.parentElement !== null; )
            l = l.parentElement;
          if (l.classList.contains("action-item")) {
            const c = this.focusedItem;
            this.setFocusedItem(l), c !== this.focusedItem && this.updateFocus();
          }
        }
      })), this._register(kt.addTarget(this.actionsList)), this._register(ee(this.actionsList, Bt.Tap, (a) => {
        let l = a.initialTarget;
        if (!(!l || !al(l, this.actionsList) || l === this.actionsList)) {
          for (; l.parentElement !== this.actionsList && l.parentElement !== null; )
            l = l.parentElement;
          if (l.classList.contains("action-item")) {
            const c = this.focusedItem;
            this.setFocusedItem(l), c !== this.focusedItem && this.updateFocus();
          }
        }
      }));
      let o = {
        parent: this
      };
      this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new u_(n, {
        alwaysConsumeMouseWheel: !0,
        horizontal: 2,
        vertical: 3,
        verticalScrollbarSize: 7,
        handleMouseWheel: !0,
        useShadows: !0
      }));
      const r = this.scrollableElement.getDomNode();
      r.style.position = "", this._register(ee(n, Bt.Change, (a) => {
        wt.stop(a, !0);
        const l = this.scrollableElement.getScrollPosition().scrollTop;
        this.scrollableElement.setScrollPosition({ scrollTop: l - a.translationY });
      })), this._register(ee(r, ye.MOUSE_UP, (a) => {
        a.preventDefault();
      })), n.style.maxHeight = `${Math.max(10, window.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((a) => {
        var l;
        return !((l = i.submenuIds) === null || l === void 0) && l.has(a.id) ? (console.warn(`Found submenu cycle: ${a.id}`), !1) : !0;
      }), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((a) => !(a instanceof Ny)).forEach((a, l, c) => {
        a.updatePositionInSet(l + 1, c.length);
      });
    }
    initializeOrUpdateStyleSheet(e, t) {
      this.styleSheet || (Vm(e) ? this.styleSheet = Co(e) : (lf.globalStyleSheet || (lf.globalStyleSheet = Co()), this.styleSheet = lf.globalStyleSheet)), this.styleSheet.textContent = Ace(t, Vm(e));
    }
    style(e) {
      const t = this.getContainer();
      this.initializeOrUpdateStyleSheet(t, e);
      const i = e.foregroundColor ? `${e.foregroundColor}` : "", n = e.backgroundColor ? `${e.backgroundColor}` : "", o = e.borderColor ? `1px solid ${e.borderColor}` : "", r = e.shadowColor ? `0 2px 4px ${e.shadowColor}` : "";
      t.style.border = o, this.domNode.style.color = i, this.domNode.style.backgroundColor = n, t.style.boxShadow = r, this.viewItems && this.viewItems.forEach((a) => {
        (a instanceof Cx || a instanceof Ny) && a.style(e);
      });
    }
    getContainer() {
      return this.scrollableElement.getDomNode();
    }
    get onScroll() {
      return this.scrollableElement.onScroll;
    }
    focusItemByElement(e) {
      const t = this.focusedItem;
      this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
    }
    setFocusedItem(e) {
      for (let t = 0; t < this.actionsList.children.length; t++) {
        let i = this.actionsList.children[t];
        if (e === i) {
          this.focusedItem = t;
          break;
        }
      }
    }
    updateFocus(e) {
      super.updateFocus(e, !0, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
        scrollTop: Math.round(this.menuElement.scrollTop)
      });
    }
    doGetActionViewItem(e, t, i) {
      if (e instanceof mo)
        return new Ny(t.context, e, { icon: !0 });
      if (e instanceof Tv) {
        const n = new ZR(e, e.actions, i, Object.assign(Object.assign({}, t), { submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }));
        if (t.enableMnemonics) {
          const o = n.getMnemonic();
          if (o && n.isEnabled()) {
            let r = [];
            this.mnemonics.has(o) && (r = this.mnemonics.get(o)), r.push(n), this.mnemonics.set(o, r);
          }
        }
        return n;
      } else {
        const n = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
        if (t.getKeyBinding) {
          const r = t.getKeyBinding(e);
          if (r) {
            const a = r.getLabel();
            a && (n.keybinding = a);
          }
        }
        const o = new Cx(t.context, e, n);
        if (t.enableMnemonics) {
          const r = o.getMnemonic();
          if (r && o.isEnabled()) {
            let a = [];
            this.mnemonics.has(r) && (a = this.mnemonics.get(r)), a.push(o), this.mnemonics.set(r, a);
          }
        }
        return o;
      }
    }
  }
  class Cx extends zr {
    constructor(e, t, i = {}) {
      if (i.isMenu = !0, super(t, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
        let n = this.getAction().label;
        if (n) {
          let o = vx.exec(n);
          o && (this.mnemonic = (o[1] ? o[1] : o[3]).toLocaleLowerCase());
        }
      }
      this.runOnceToEnableMouseUp = new It(() => {
        !this.element || (this._register(ee(this.element, ye.MOUSE_UP, (n) => {
          if (wt.stop(n, !0), Xs) {
            if (new ho(n).rightButton)
              return;
            this.onClick(n);
          } else
            setTimeout(() => {
              this.onClick(n);
            }, 0);
        })), this._register(ee(this.element, ye.CONTEXT_MENU, (n) => {
          wt.stop(n, !0);
        })));
      }, 100), this._register(this.runOnceToEnableMouseUp);
    }
    render(e) {
      super.render(e), this.element && (this.container = e, this.item = q(this.element, J("a.action-menu-item")), this._action.id === mo.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = q(this.item, J("span.menu-item-check" + p.menuSelection.cssSelector)), this.check.setAttribute("role", "none"), this.label = q(this.item, J("span.action-label")), this.options.label && this.options.keybinding && (q(this.item, J("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked());
    }
    blur() {
      super.blur(), this.applyStyle();
    }
    focus() {
      super.focus(), this.item && this.item.focus(), this.applyStyle();
    }
    updatePositionInSet(e, t) {
      this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
    }
    updateLabel() {
      if (!!this.label && this.options.label) {
        Bi(this.label);
        let e = $E(this.getAction().label);
        if (e) {
          const t = Mce(e);
          this.options.enableMnemonics || (e = t), this.label.setAttribute("aria-label", t.replace(/&&/g, "&"));
          const i = vx.exec(e);
          if (i) {
            e = II(e), Ey.lastIndex = 0;
            let n = Ey.exec(e);
            for (; n && n[1]; )
              n = Ey.exec(e);
            const o = (r) => r.replace(/&amp;&amp;/g, "&amp;");
            n ? this.label.append(EI(o(e.substr(0, n.index)), " "), J("u", { "aria-hidden": "true" }, n[3]), LP(o(e.substr(n.index + n[0].length)), " ")) : this.label.innerText = o(e).trim(), this.item && this.item.setAttribute("aria-keyshortcuts", (i[1] ? i[1] : i[3]).toLocaleLowerCase());
          } else
            this.label.innerText = e.replace(/&&/g, "&").trim();
        }
      }
    }
    updateTooltip() {
    }
    updateClass() {
      this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.getAction().class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
    }
    updateEnabled() {
      this.getAction().enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
    }
    updateChecked() {
      if (!this.item)
        return;
      const e = this.getAction().checked;
      this.item.classList.toggle("checked", !!e), e !== void 0 ? (this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", e ? "true" : "false")) : (this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", ""));
    }
    getMnemonic() {
      return this.mnemonic;
    }
    applyStyle() {
      if (!this.menuStyle)
        return;
      const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, n = e && this.menuStyle.selectionBorderColor ? `thin solid ${this.menuStyle.selectionBorderColor}` : "";
      this.item && (this.item.style.color = t ? t.toString() : "", this.item.style.backgroundColor = i ? i.toString() : ""), this.check && (this.check.style.color = t ? t.toString() : ""), this.container && (this.container.style.border = n);
    }
    style(e) {
      this.menuStyle = e, this.applyStyle();
    }
  }
  class ZR extends Cx {
    constructor(e, t, i, n) {
      super(e, e, n), this.submenuActions = t, this.parentData = i, this.submenuOptions = n, this.mysubmenu = null, this.submenuDisposables = this._register(new te()), this.mouseOver = !1, this.expandDirection = n && n.expandDirection !== void 0 ? n.expandDirection : cv.Right, this.showScheduler = new It(() => {
        this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
      }, 250), this.hideScheduler = new It(() => {
        this.element && !al(Uu(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
      }, 750);
    }
    render(e) {
      super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = q(this.item, J("span.submenu-indicator" + p.menuSubmenu.cssSelector)), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(ee(this.element, ye.KEY_UP, (t) => {
        let i = new $t(t);
        (i.equals(17) || i.equals(3)) && (wt.stop(t, !0), this.createSubmenu(!0));
      })), this._register(ee(this.element, ye.KEY_DOWN, (t) => {
        let i = new $t(t);
        Uu() === this.item && (i.equals(17) || i.equals(3)) && wt.stop(t, !0);
      })), this._register(ee(this.element, ye.MOUSE_OVER, (t) => {
        this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
      })), this._register(ee(this.element, ye.MOUSE_LEAVE, (t) => {
        this.mouseOver = !1;
      })), this._register(ee(this.element, ye.FOCUS_OUT, (t) => {
        this.element && !al(Uu(), this.element) && this.hideScheduler.schedule();
      })), this._register(this.parentData.parent.onScroll(() => {
        this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!1);
      })));
    }
    updateEnabled() {
    }
    onClick(e) {
      wt.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
    }
    cleanupExistingSubmenu(e) {
      if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
        try {
          this.parentData.submenu.dispose();
        } catch {
        }
        this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
      }
    }
    calculateSubmenuMenuLayout(e, t, i, n) {
      const o = { top: 0, left: 0 };
      return o.left = Bu(e.width, t.width, { position: n === cv.Right ? 0 : 1, offset: i.left, size: i.width }), o.left >= i.left && o.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (o.left = i.left + 10), i.top += 10, i.height = 0), o.top = Bu(e.height, t.height, { position: 0, offset: i.top, size: 0 }), o.top + t.height === i.top && o.top + i.height + t.height <= e.height && (o.top += i.height), o;
    }
    createSubmenu(e = !0) {
      if (!!this.element)
        if (this.parentData.submenu)
          this.parentData.submenu.focus(!1);
        else {
          this.updateAriaExpanded("true"), this.submenuContainer = q(this.element, J("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
          const t = getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
          this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new lf(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new Mv()], this.submenuOptions), this.menuStyle && this.parentData.submenu.style(this.menuStyle);
          const n = this.element.getBoundingClientRect(), o = {
            top: n.top - i,
            left: n.left,
            height: n.height + 2 * i,
            width: n.width
          }, r = this.submenuContainer.getBoundingClientRect(), { top: a, left: l } = this.calculateSubmenuMenuLayout(new Et(window.innerWidth, window.innerHeight), Et.lift(r), o, this.expandDirection);
          this.submenuContainer.style.left = `${l - r.left}px`, this.submenuContainer.style.top = `${a - r.top}px`, this.submenuDisposables.add(ee(this.submenuContainer, ye.KEY_UP, (c) => {
            new $t(c).equals(15) && (wt.stop(c, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
          })), this.submenuDisposables.add(ee(this.submenuContainer, ye.KEY_DOWN, (c) => {
            new $t(c).equals(15) && wt.stop(c, !0);
          })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
            this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
          })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
        }
    }
    updateAriaExpanded(e) {
      var t;
      this.item && ((t = this.item) === null || t === void 0 || t.setAttribute("aria-expanded", e));
    }
    applyStyle() {
      if (super.applyStyle(), !this.menuStyle)
        return;
      const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
      this.submenuIndicator && (this.submenuIndicator.style.color = t ? `${t}` : ""), this.parentData.submenu && this.parentData.submenu.style(this.menuStyle);
    }
    dispose() {
      super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
    }
  }
  class Ny extends up {
    style(e) {
      this.label && (this.label.style.borderBottomColor = e.separatorColor ? `${e.separatorColor}` : "");
    }
  }
  function Mce(s) {
    const e = vx, t = e.exec(s);
    if (!t)
      return s;
    const i = !t[1];
    return s.replace(e, i ? "$2$3" : "").trim();
  }
  function Ace(s, e) {
    let t = `
.monaco-menu {
	font-size: 13px;

}

${XA(p.menuSelection)}
${XA(p.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar.animated .action-item.active {
	transform: scale(1.272019649, 1.272019649); /* 1.272019649 = \u221A\u03C6 */
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	opacity: 0.4;
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid #bbb;
	padding-top: 1px;
	margin-left: .8em;
	margin-right: .8em;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	padding: 0.5em 0 0 0;
	margin-bottom: 0.5em;
	width: 100%;
	height: 0px !important;
	margin-left: .8em !important;
	margin-right: .8em !important;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	border: thin solid transparent; /* prevents jumping behaviour on hover or focus */
}


/* High Contrast Theming */
:host-context(.hc-black) .context-view.monaco-menu-container {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: .5em 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 1.8em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	padding: 0.2em 0 0 0;
	margin-bottom: 0.2em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`;
    if (e) {
      t += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
      const i = s.scrollbarShadow;
      i && (t += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${i} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${i} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${i} 6px 6px 6px -6px inset;
				}
			`);
      const n = s.scrollbarSliderBackground;
      n && (t += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${n};
				}
			`);
      const o = s.scrollbarSliderHoverBackground;
      o && (t += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${o};
				}
			`);
      const r = s.scrollbarSliderActiveBackground;
      r && (t += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${r};
				}
			`);
    }
    return t;
  }
  class Rce {
    constructor(e, t, i, n, o) {
      this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = n, this.themeService = o, this.focusToReturn = null, this.block = null, this.options = { blockMouse: !0 };
    }
    configure(e) {
      this.options = e;
    }
    showContextMenu(e) {
      const t = e.getActions();
      if (!t.length)
        return;
      this.focusToReturn = document.activeElement;
      let i, n = vP(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
      this.contextViewService.showContextView({
        getAnchor: () => e.getAnchor(),
        canRelayout: !1,
        anchorAlignment: e.anchorAlignment,
        anchorAxisAlignment: e.anchorAxisAlignment,
        render: (o) => {
          let r = e.getMenuClassName ? e.getMenuClassName() : "";
          r && (o.className += " " + r), this.options.blockMouse && (this.block = o.appendChild(J(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", ee(this.block, ye.MOUSE_DOWN, (c) => c.stopPropagation()));
          const a = new te(), l = e.actionRunner || new gf();
          return l.onBeforeRun(this.onActionRun, this, a), l.onDidRun(this.onDidActionRun, this, a), i = new lf(o, t, {
            actionViewItemProvider: e.getActionViewItem,
            context: e.getActionsContext ? e.getActionsContext() : null,
            actionRunner: l,
            getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (c) => this.keybindingService.lookupKeybinding(c.id)
          }), a.add(XQ(i, this.themeService)), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, a), a.add(ee(window, ye.BLUR, () => this.contextViewService.hideContextView(!0))), a.add(ee(window, ye.MOUSE_DOWN, (c) => {
            if (c.defaultPrevented)
              return;
            let d = new ho(c), h = d.target;
            if (!d.rightButton) {
              for (; h; ) {
                if (h === o)
                  return;
                h = h.parentElement;
              }
              this.contextViewService.hideContextView(!0);
            }
          })), ol(a, i);
        },
        focus: () => {
          i && i.focus(!!e.autoSelectFirstItem);
        },
        onHide: (o) => {
          e.onHide && e.onHide(!!o), this.block && (this.block.remove(), this.block = null), this.focusToReturn && this.focusToReturn.focus();
        }
      }, n, !!n);
    }
    onActionRun(e) {
      this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1), this.focusToReturn && this.focusToReturn.focus();
    }
    onDidActionRun(e) {
      e.error && !va(e.error) && this.notificationService.error(e.error);
    }
  }
  var Oce = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Hg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let wx = class extends z {
    constructor(e, t, i, n, o) {
      super(), this._onDidShowContextMenu = new B(), this._onDidHideContextMenu = new B(), this.contextMenuHandler = new Rce(i, e, t, n, o);
    }
    configure(e) {
      this.contextMenuHandler.configure(e);
    }
    showContextMenu(e) {
      this.contextMenuHandler.showContextMenu(Object.assign(Object.assign({}, e), { onHide: (t) => {
        e.onHide && e.onHide(t), this._onDidHideContextMenu.fire();
      } })), vd.getInstance().resetKeyStatus(), this._onDidShowContextMenu.fire();
    }
  };
  wx = Oce([
    Hg(0, Ca),
    Hg(1, yi),
    Hg(2, m_),
    Hg(3, ci),
    Hg(4, jt)
  ], wx);
  var dv;
  (function(s) {
    s[s.API = 0] = "API", s[s.USER = 1] = "USER";
  })(dv || (dv = {}));
  var r2 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, hv = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, md = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Sx = class {
    constructor(e) {
      this._commandService = e;
    }
    open(e, t) {
      return md(this, void 0, void 0, function* () {
        if (!R7(e, ze.command))
          return !1;
        if (!t?.allowCommands)
          return !0;
        typeof e == "string" && (e = Ee.parse(e));
        let i = [];
        try {
          i = Dk(decodeURIComponent(e.query));
        } catch {
          try {
            i = Dk(e.query);
          } catch {
          }
        }
        return Array.isArray(i) || (i = [i]), yield this._commandService.executeCommand(e.path, ...i), !0;
      });
    }
  };
  Sx = r2([
    hv(0, wi)
  ], Sx);
  let yx = class {
    constructor(e) {
      this._editorService = e;
    }
    open(e, t) {
      return md(this, void 0, void 0, function* () {
        typeof e == "string" && (e = Ee.parse(e));
        const { selection: i, uri: n } = Dee(e);
        return e = n, e.scheme === ze.file && (e = xq(e)), yield this._editorService.openCodeEditor({
          resource: e,
          options: Object.assign({ selection: i, source: t?.fromUserGesture ? dv.USER : dv.API }, t?.editorOptions)
        }, this._editorService.getFocusedCodeEditor(), t?.openToSide), !0;
      });
    }
  };
  yx = r2([
    hv(0, St)
  ], yx);
  let Lx = class {
    constructor(e, t) {
      this._openers = new $s(), this._validators = new $s(), this._resolvers = new $s(), this._resolvedUriTargets = new $n((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new $s(), this._defaultExternalOpener = {
        openExternal: (i) => md(this, void 0, void 0, function* () {
          return SA(i, ze.http, ze.https) ? wP(i) : window.location.href = i, !0;
        })
      }, this._openers.push({
        open: (i, n) => md(this, void 0, void 0, function* () {
          return n?.openExternal || SA(i, ze.mailto, ze.http, ze.https, ze.vsls) ? (yield this._doOpenExternal(i, n), !0) : !1;
        })
      }), this._openers.push(new Sx(t)), this._openers.push(new yx(e));
    }
    registerOpener(e) {
      return { dispose: this._openers.unshift(e) };
    }
    registerValidator(e) {
      return { dispose: this._validators.push(e) };
    }
    registerExternalUriResolver(e) {
      return { dispose: this._resolvers.push(e) };
    }
    setDefaultExternalOpener(e) {
      this._defaultExternalOpener = e;
    }
    registerExternalOpener(e) {
      return { dispose: this._externalOpeners.push(e) };
    }
    open(e, t) {
      var i;
      return md(this, void 0, void 0, function* () {
        const n = typeof e == "string" ? Ee.parse(e) : e, o = (i = this._resolvedUriTargets.get(n)) !== null && i !== void 0 ? i : e;
        for (const r of this._validators)
          if (!(yield r.shouldOpen(o)))
            return !1;
        for (const r of this._openers)
          if (yield r.open(e, t))
            return !0;
        return !1;
      });
    }
    resolveExternalUri(e, t) {
      return md(this, void 0, void 0, function* () {
        for (const i of this._resolvers)
          try {
            const n = yield i.resolveExternalUri(e, t);
            if (n)
              return this._resolvedUriTargets.has(n.resolved) || this._resolvedUriTargets.set(n.resolved, e), n;
          } catch {
          }
        throw new Error("Could not resolve external URI: " + e.toString());
      });
    }
    _doOpenExternal(e, t) {
      return md(this, void 0, void 0, function* () {
        const i = typeof e == "string" ? Ee.parse(e) : e;
        let n;
        try {
          n = (yield this.resolveExternalUri(i, t)).resolved;
        } catch {
          n = i;
        }
        let o;
        if (typeof e == "string" && i.toString() === n.toString() ? o = e : o = encodeURI(n.toString(!0)), t?.allowContributedOpeners) {
          const r = typeof t?.allowContributedOpeners == "string" ? t?.allowContributedOpeners : void 0;
          for (const a of this._externalOpeners)
            if (yield a.openExternal(o, {
              sourceUri: i,
              preferredOpenerId: r
            }, Je.None))
              return !0;
        }
        return this._defaultExternalOpener.openExternal(o, { sourceUri: i }, Je.None);
      });
    }
    dispose() {
      this._validators.clear();
    }
  };
  Lx = r2([
    hv(0, St),
    hv(1, wi)
  ], Lx);
  var Pce = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, YR = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  class Fce extends z {
    constructor(e) {
      super(), this.model = e, this._markersData = /* @__PURE__ */ new Map(), this._register(qe(() => {
        this.model.deltaDecorations([...this._markersData.keys()], []), this._markersData.clear();
      }));
    }
    update(e, t) {
      const i = [...this._markersData.keys()];
      this._markersData.clear();
      const n = this.model.deltaDecorations(i, t);
      for (let o = 0; o < n.length; o++)
        this._markersData.set(n[o], e[o]);
      return i.length !== 0 || n.length !== 0;
    }
    getMarker(e) {
      return this._markersData.get(e.id);
    }
  }
  let kx = class extends z {
    constructor(e, t) {
      super(), this._markerService = t, this._onDidChangeMarker = this._register(new B()), this._markerDecorations = new $n(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
    }
    dispose() {
      super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
    }
    getMarker(e, t) {
      const i = this._markerDecorations.get(e);
      return i && i.getMarker(t) || null;
    }
    _handleMarkerChange(e) {
      e.forEach((t) => {
        const i = this._markerDecorations.get(t);
        i && this._updateDecorations(i);
      });
    }
    _onModelAdded(e) {
      const t = new Fce(e);
      this._markerDecorations.set(e.uri, t), this._updateDecorations(t);
    }
    _onModelRemoved(e) {
      const t = this._markerDecorations.get(e.uri);
      t && (t.dispose(), this._markerDecorations.delete(e.uri)), (e.uri.scheme === ze.inMemory || e.uri.scheme === ze.internal || e.uri.scheme === ze.vscode) && this._markerService && this._markerService.read({ resource: e.uri }).map((i) => i.owner).forEach((i) => this._markerService.remove(i, [e.uri]));
    }
    _updateDecorations(e) {
      const t = this._markerService.read({ resource: e.model.uri, take: 500 }), i = t.map((n) => ({
        range: this._createDecorationRange(e.model, n),
        options: this._createDecorationOption(n)
      }));
      e.update(t, i) && this._onDidChangeMarker.fire(e.model);
    }
    _createDecorationRange(e, t) {
      let i = D.lift(t);
      if (t.severity === Xt.Hint && !this._hasMarkerTag(t, 1) && !this._hasMarkerTag(t, 2) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
        const n = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
        if (n === 1 || i.endColumn >= n)
          return i;
        const o = e.getWordAtPosition(i.getStartPosition());
        o && (i = new D(i.startLineNumber, o.startColumn, i.endLineNumber, o.endColumn));
      } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
        let n = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
        n < i.endColumn && (i = new D(i.startLineNumber, n, i.endLineNumber, i.endColumn), t.startColumn = n);
      }
      return i;
    }
    _createDecorationOption(e) {
      let t, i, n, o, r;
      switch (e.severity) {
        case Xt.Hint:
          this._hasMarkerTag(e, 2) ? t = void 0 : this._hasMarkerTag(e, 1) ? t = "squiggly-unnecessary" : t = "squiggly-hint", n = 0;
          break;
        case Xt.Warning:
          t = "squiggly-warning", i = ai(U$), n = 20, r = {
            color: ai(EU),
            position: _o.Inline
          };
          break;
        case Xt.Info:
          t = "squiggly-info", i = ai($$), n = 10;
          break;
        case Xt.Error:
        default:
          t = "squiggly-error", i = ai(z$), n = 30, r = {
            color: ai(IU),
            position: _o.Inline
          };
          break;
      }
      return e.tags && (e.tags.indexOf(1) !== -1 && (o = "squiggly-inline-unnecessary"), e.tags.indexOf(2) !== -1 && (o = "squiggly-inline-deprecated")), {
        description: "marker-decoration",
        stickiness: 1,
        className: t,
        showIfCollapsed: !0,
        overviewRuler: {
          color: i,
          position: Lo.Right
        },
        minimap: r,
        zIndex: n,
        inlineClassName: o
      };
    }
    _hasMarkerTag(e, t) {
      return e.tags ? e.tags.indexOf(t) >= 0 : !1;
    }
  };
  kx = Pce([
    YR(0, Qt),
    YR(1, wl)
  ], kx);
  const Bce = {
    buttonBackground: H.fromHex("#0E639C"),
    buttonHoverBackground: H.fromHex("#006BB3"),
    buttonForeground: H.white
  };
  class XR extends z {
    constructor(e, t) {
      super(), this._onDidClick = this._register(new B()), this.options = t || /* @__PURE__ */ Object.create(null), Sa(this.options, Bce, !1), this.buttonForeground = this.options.buttonForeground, this.buttonBackground = this.options.buttonBackground, this.buttonHoverBackground = this.options.buttonHoverBackground, this.buttonSecondaryForeground = this.options.buttonSecondaryForeground, this.buttonSecondaryBackground = this.options.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground, this.buttonBorder = this.options.buttonBorder, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), e.appendChild(this._element), this._register(kt.addTarget(this._element)), [ye.CLICK, Bt.Tap].forEach((i) => {
        this._register(ee(this._element, i, (n) => {
          if (!this.enabled) {
            wt.stop(n);
            return;
          }
          this._onDidClick.fire(n);
        }));
      }), this._register(ee(this._element, ye.KEY_DOWN, (i) => {
        const n = new $t(i);
        let o = !1;
        this.enabled && (n.equals(3) || n.equals(10)) ? (this._onDidClick.fire(i), o = !0) : n.equals(9) && (this._element.blur(), o = !0), o && wt.stop(n, !0);
      })), this._register(ee(this._element, ye.MOUSE_OVER, (i) => {
        this._element.classList.contains("disabled") || this.setHoverBackground();
      })), this._register(ee(this._element, ye.MOUSE_OUT, (i) => {
        this.applyStyles();
      })), this.focusTracker = this._register(ff(this._element)), this._register(this.focusTracker.onDidFocus(() => this.setHoverBackground())), this._register(this.focusTracker.onDidBlur(() => this.applyStyles())), this.applyStyles();
    }
    get onDidClick() {
      return this._onDidClick.event;
    }
    setHoverBackground() {
      let e;
      this.options.secondary ? e = this.buttonSecondaryHoverBackground ? this.buttonSecondaryHoverBackground.toString() : null : e = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null, e && (this._element.style.backgroundColor = e);
    }
    style(e) {
      this.buttonForeground = e.buttonForeground, this.buttonBackground = e.buttonBackground, this.buttonHoverBackground = e.buttonHoverBackground, this.buttonSecondaryForeground = e.buttonSecondaryForeground, this.buttonSecondaryBackground = e.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = e.buttonSecondaryHoverBackground, this.buttonBorder = e.buttonBorder, this.applyStyles();
    }
    applyStyles() {
      if (this._element) {
        let e, t;
        this.options.secondary ? (t = this.buttonSecondaryForeground ? this.buttonSecondaryForeground.toString() : "", e = this.buttonSecondaryBackground ? this.buttonSecondaryBackground.toString() : "") : (t = this.buttonForeground ? this.buttonForeground.toString() : "", e = this.buttonBackground ? this.buttonBackground.toString() : "");
        const i = this.buttonBorder ? this.buttonBorder.toString() : "";
        this._element.style.color = t, this._element.style.backgroundColor = e, this._element.style.borderWidth = i ? "1px" : "", this._element.style.borderStyle = i ? "solid" : "", this._element.style.borderColor = i;
      }
    }
    get element() {
      return this._element;
    }
    set label(e) {
      this._element.classList.add("monaco-text-button"), this.options.supportIcons ? pc(this._element, ...Pd(e)) : this._element.textContent = e, typeof this.options.title == "string" ? this._element.title = this.options.title : this.options.title && (this._element.title = e);
    }
    set enabled(e) {
      e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
    }
    get enabled() {
      return !this._element.classList.contains("disabled");
    }
  }
  const QR = "done", JR = "active", Ty = "infinite", My = "infinite-long-running", eO = "discrete", Wce = {
    progressBarBackground: H.fromHex("#0E70C0")
  };
  class gw extends z {
    constructor(e, t) {
      super(), this.options = t || /* @__PURE__ */ Object.create(null), Sa(this.options, Wce, !1), this.workedVal = 0, this.progressBarBackground = this.options.progressBarBackground, this.showDelayedScheduler = this._register(new It(() => Vs(this.element), 0)), this.longRunningScheduler = this._register(new It(() => this.infiniteLongRunning(), gw.LONG_RUNNING_INFINITE_THRESHOLD)), this.create(e);
    }
    create(e) {
      this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.element.appendChild(this.bit), this.applyStyles();
    }
    off() {
      this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(JR, Ty, My, eO), this.workedVal = 0, this.totalWork = void 0, this.longRunningScheduler.cancel();
    }
    stop() {
      return this.doDone(!1);
    }
    doDone(e) {
      return this.element.classList.add(QR), this.element.classList.contains(Ty) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
    }
    infinite() {
      return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(eO, QR, My), this.element.classList.add(JR, Ty), this.longRunningScheduler.schedule(), this;
    }
    infiniteLongRunning() {
      this.element.classList.add(My);
    }
    getContainer() {
      return this.element;
    }
    style(e) {
      this.progressBarBackground = e.progressBarBackground, this.applyStyles();
    }
    applyStyles() {
      if (this.bit) {
        const e = this.progressBarBackground ? this.progressBarBackground.toString() : "";
        this.bit.style.backgroundColor = e;
      }
    }
  }
  gw.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;
  const Ay = {}, Vce = new nN("quick-input-button-icon-");
  function Dx(s) {
    if (!s)
      return;
    let e;
    const t = s.dark.toString();
    return Ay[t] ? e = Ay[t] : (e = Vce.nextId(), Xy(`.${e}`, `background-image: ${jd(s.light || s.dark)}`), Xy(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${jd(s.dark)}`), Ay[t] = e), e;
  }
  const Hce = J;
  class zce extends z {
    constructor(e) {
      super(), this.parent = e, this.onKeyDown = (t) => ee(this.inputBox.inputElement, ye.KEY_DOWN, (i) => {
        t(new $t(i));
      }), this.onMouseDown = (t) => ee(this.inputBox.inputElement, ye.MOUSE_DOWN, (i) => {
        t(new ho(i));
      }), this.onDidChange = (t) => this.inputBox.onDidChange(t), this.container = q(this.parent, Hce(".quick-input-box")), this.inputBox = this._register(new v7(this.container, void 0));
    }
    get value() {
      return this.inputBox.value;
    }
    set value(e) {
      this.inputBox.value = e;
    }
    select(e = null) {
      this.inputBox.select(e);
    }
    isSelectionAtEnd() {
      return this.inputBox.isSelectionAtEnd();
    }
    get placeholder() {
      return this.inputBox.inputElement.getAttribute("placeholder") || "";
    }
    set placeholder(e) {
      this.inputBox.setPlaceHolder(e);
    }
    get ariaLabel() {
      return this.inputBox.getAriaLabel();
    }
    set ariaLabel(e) {
      this.inputBox.setAriaLabel(e);
    }
    get password() {
      return this.inputBox.inputElement.type === "password";
    }
    set password(e) {
      this.inputBox.inputElement.type = e ? "password" : "text";
    }
    setAttribute(e, t) {
      this.inputBox.inputElement.setAttribute(e, t);
    }
    removeAttribute(e) {
      this.inputBox.inputElement.removeAttribute(e);
    }
    showDecoration(e) {
      e === Zt.Ignore ? this.inputBox.hideMessage() : this.inputBox.showMessage({ type: e === Zt.Info ? 1 : e === Zt.Warning ? 2 : 3, content: "" });
    }
    stylesForType(e) {
      return this.inputBox.stylesForType(e === Zt.Info ? 1 : e === Zt.Warning ? 2 : 3);
    }
    setFocus() {
      this.inputBox.focus();
    }
    layout() {
      this.inputBox.layout();
    }
    style(e) {
      this.inputBox.style(e);
    }
  }
  const Kb = J;
  class a2 {
    constructor(e, t, i) {
      this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null), this.labelBackground = this.options.keybindingLabelBackground, this.labelForeground = this.options.keybindingLabelForeground, this.labelBorder = this.options.keybindingLabelBorder, this.labelBottomBorder = this.options.keybindingLabelBottomBorder, this.labelShadow = this.options.keybindingLabelShadow, this.domNode = q(e, Kb(".monaco-keybinding")), this.didEverRender = !1, e.appendChild(this.domNode);
    }
    get element() {
      return this.domNode;
    }
    set(e, t) {
      this.didEverRender && this.keybinding === e && a2.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
    }
    render() {
      if (this.clear(), this.keybinding) {
        let [e, t] = this.keybinding.getParts();
        e && this.renderPart(this.domNode, e, this.matches ? this.matches.firstPart : null), t && (q(this.domNode, Kb("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderPart(this.domNode, t, this.matches ? this.matches.chordPart : null)), this.domNode.title = this.keybinding.getAriaLabel() || "";
      } else
        this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
      this.applyStyles(), this.didEverRender = !0;
    }
    clear() {
      Bi(this.domNode), this.keyElements.clear();
    }
    renderPart(e, t, i) {
      const n = sN.modifierLabels[this.os];
      t.ctrlKey && this.renderKey(e, n.ctrlKey, Boolean(i?.ctrlKey), n.separator), t.shiftKey && this.renderKey(e, n.shiftKey, Boolean(i?.shiftKey), n.separator), t.altKey && this.renderKey(e, n.altKey, Boolean(i?.altKey), n.separator), t.metaKey && this.renderKey(e, n.metaKey, Boolean(i?.metaKey), n.separator);
      const o = t.keyLabel;
      o && this.renderKey(e, o, Boolean(i?.keyCode), "");
    }
    renderKey(e, t, i, n) {
      q(e, this.createKeyElement(t, i ? ".highlight" : "")), n && q(e, Kb("span.monaco-keybinding-key-separator", void 0, n));
    }
    renderUnbound(e) {
      q(e, this.createKeyElement(m("unbound", "Unbound")));
    }
    createKeyElement(e, t = "") {
      const i = Kb("span.monaco-keybinding-key" + t, void 0, e);
      return this.keyElements.add(i), i;
    }
    style(e) {
      this.labelBackground = e.keybindingLabelBackground, this.labelForeground = e.keybindingLabelForeground, this.labelBorder = e.keybindingLabelBorder, this.labelBottomBorder = e.keybindingLabelBottomBorder, this.labelShadow = e.keybindingLabelShadow, this.applyStyles();
    }
    applyStyles() {
      var e;
      if (this.element) {
        for (const t of this.keyElements)
          this.labelBackground && (t.style.backgroundColor = (e = this.labelBackground) === null || e === void 0 ? void 0 : e.toString()), this.labelBorder && (t.style.borderColor = this.labelBorder.toString()), this.labelBottomBorder && (t.style.borderBottomColor = this.labelBottomBorder.toString()), this.labelShadow && (t.style.boxShadow = `inset 0 -1px 0 ${this.labelShadow}`);
        this.labelForeground && (this.element.style.color = this.labelForeground.toString());
      }
    }
    static areSame(e, t) {
      return e === t || !e && !t ? !0 : !!e && !!t && po(e.firstPart, t.firstPart) && po(e.chordPart, t.chordPart);
    }
  }
  const tO = new Jl(() => {
    const s = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
    return {
      collator: s,
      collatorIsNumeric: s.resolvedOptions().numeric
    };
  });
  new Jl(() => ({
    collator: new Intl.Collator(void 0, { numeric: !0 })
  }));
  new Jl(() => ({
    collator: new Intl.Collator(void 0, { numeric: !0, sensitivity: "accent" })
  }));
  function Uce(s, e, t = !1) {
    const i = s || "", n = e || "", o = tO.value.collator.compare(i, n);
    return tO.value.collatorIsNumeric && o === 0 && i !== n ? i < n ? -1 : 1 : o;
  }
  function $ce(s, e, t) {
    const i = s.toLowerCase(), n = e.toLowerCase(), o = jce(s, e, t);
    if (o)
      return o;
    const r = i.endsWith(t), a = n.endsWith(t);
    if (r !== a)
      return r ? -1 : 1;
    const l = Uce(i, n);
    return l !== 0 ? l : i.localeCompare(n);
  }
  function jce(s, e, t) {
    const i = s.toLowerCase(), n = e.toLowerCase(), o = i.startsWith(t), r = n.startsWith(t);
    if (o !== r)
      return o ? -1 : 1;
    if (o && r) {
      if (i.length < n.length)
        return -1;
      if (i.length > n.length)
        return 1;
    }
    return 0;
  }
  var V8 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Kce = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const Rr = J;
  class qce {
    constructor(e) {
      this.hidden = !1, this._onChecked = new B(), this.onChecked = this._onChecked.event, Object.assign(this, e);
    }
    get checked() {
      return !!this._checked;
    }
    set checked(e) {
      e !== this._checked && (this._checked = e, this._onChecked.fire(e));
    }
    dispose() {
      this._onChecked.dispose();
    }
  }
  class R_ {
    get templateId() {
      return R_.ID;
    }
    renderTemplate(e) {
      const t = /* @__PURE__ */ Object.create(null);
      t.toDisposeElement = [], t.toDisposeTemplate = [], t.entry = q(e, Rr(".quick-input-list-entry"));
      const i = q(t.entry, Rr("label.quick-input-list-label"));
      t.toDisposeTemplate.push(on(i, ye.CLICK, (c) => {
        t.checkbox.offsetParent || c.preventDefault();
      })), t.checkbox = q(i, Rr("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox", t.toDisposeTemplate.push(on(t.checkbox, ye.CHANGE, (c) => {
        t.element.checked = t.checkbox.checked;
      }));
      const n = q(i, Rr(".quick-input-list-rows")), o = q(n, Rr(".quick-input-list-row")), r = q(n, Rr(".quick-input-list-row"));
      t.label = new B1(o, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0 });
      const a = q(o, Rr(".quick-input-list-entry-keybinding"));
      t.keybinding = new a2(a, oo);
      const l = q(r, Rr(".quick-input-list-label-meta"));
      return t.detail = new B1(l, { supportHighlights: !0, supportIcons: !0 }), t.separator = q(t.entry, Rr(".quick-input-list-separator")), t.actionBar = new ga(t.entry), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.push(t.actionBar), t;
    }
    renderElement(e, t, i) {
      i.toDisposeElement = at(i.toDisposeElement), i.element = e, i.checkbox.checked = e.checked, i.toDisposeElement.push(e.onChecked((c) => i.checkbox.checked = c));
      const { labelHighlights: n, descriptionHighlights: o, detailHighlights: r } = e, a = /* @__PURE__ */ Object.create(null);
      a.matches = n || [], a.descriptionTitle = e.saneDescription, a.descriptionMatches = o || [], a.extraClasses = e.item.iconClasses, a.italic = e.item.italic, a.strikethrough = e.item.strikethrough, i.label.setLabel(e.saneLabel, e.saneDescription, a), i.keybinding.set(e.item.keybinding), e.saneDetail && i.detail.setLabel(e.saneDetail, void 0, {
        matches: r,
        title: e.saneDetail
      }), e.separator && e.separator.label ? (i.separator.textContent = e.separator.label, i.separator.style.display = "") : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!e.separator), i.actionBar.clear();
      const l = e.item.buttons;
      l && l.length ? (i.actionBar.push(l.map((c, d) => {
        let h = c.iconClass || (c.iconPath ? Dx(c.iconPath) : void 0);
        c.alwaysVisible && (h = h ? `${h} always-visible` : "always-visible");
        const u = new ks(`id-${d}`, "", h, !0, () => Kce(this, void 0, void 0, function* () {
          e.fireButtonTriggered({
            button: c,
            item: e.item
          });
        }));
        return u.tooltip = c.tooltip || "", u;
      }), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
    }
    disposeElement(e, t, i) {
      i.toDisposeElement = at(i.toDisposeElement);
    }
    disposeTemplate(e) {
      e.toDisposeElement = at(e.toDisposeElement), e.toDisposeTemplate = at(e.toDisposeTemplate);
    }
  }
  R_.ID = "listelement";
  class Gce {
    getHeight(e) {
      return e.saneDetail ? 44 : 22;
    }
    getTemplateId(e) {
      return R_.ID;
    }
  }
  var pi;
  (function(s) {
    s[s.First = 1] = "First", s[s.Second = 2] = "Second", s[s.Last = 3] = "Last", s[s.Next = 4] = "Next", s[s.Previous = 5] = "Previous", s[s.NextPage = 6] = "NextPage", s[s.PreviousPage = 7] = "PreviousPage";
  })(pi || (pi = {}));
  class l2 {
    constructor(e, t, i) {
      this.parent = e, this.inputElements = [], this.elements = [], this.elementsToIndexes = /* @__PURE__ */ new Map(), this.matchOnDescription = !1, this.matchOnDetail = !1, this.matchOnLabel = !0, this.matchOnMeta = !0, this.sortByLabel = !0, this._onChangedAllVisibleChecked = new B(), this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event, this._onChangedCheckedCount = new B(), this.onChangedCheckedCount = this._onChangedCheckedCount.event, this._onChangedVisibleCount = new B(), this.onChangedVisibleCount = this._onChangedVisibleCount.event, this._onChangedCheckedElements = new B(), this.onChangedCheckedElements = this._onChangedCheckedElements.event, this._onButtonTriggered = new B(), this.onButtonTriggered = this._onButtonTriggered.event, this._onKeyDown = new B(), this.onKeyDown = this._onKeyDown.event, this._onLeave = new B(), this.onLeave = this._onLeave.event, this._fireCheckedEvents = !0, this.elementDisposables = [], this.disposables = [], this.id = t, this.container = q(this.parent, Rr(".quick-input-list"));
      const n = new Gce(), o = new Yce();
      this.list = i.createList("QuickInput", this.container, n, [new R_()], {
        identityProvider: { getId: (r) => r.saneLabel },
        setRowLineHeight: !1,
        multipleSelectionSupport: !1,
        horizontalScrolling: !1,
        accessibilityProvider: o
      }), this.list.getHTMLElement().id = t, this.disposables.push(this.list), this.disposables.push(this.list.onKeyDown((r) => {
        const a = new $t(r);
        switch (a.keyCode) {
          case 10:
            this.toggleCheckbox();
            break;
          case 31:
            (Ye ? r.metaKey : r.ctrlKey) && this.list.setFocus(Vn(this.list.length));
            break;
          case 16: {
            const l = this.list.getFocus();
            l.length === 1 && l[0] === 0 && this._onLeave.fire();
            break;
          }
          case 18: {
            const l = this.list.getFocus();
            l.length === 1 && l[0] === this.list.length - 1 && this._onLeave.fire();
            break;
          }
        }
        this._onKeyDown.fire(a);
      })), this.disposables.push(this.list.onMouseDown((r) => {
        r.browserEvent.button !== 2 && r.browserEvent.preventDefault();
      })), this.disposables.push(ee(this.container, ye.CLICK, (r) => {
        (r.x || r.y) && this._onLeave.fire();
      })), this.disposables.push(this.list.onMouseMiddleClick((r) => {
        this._onLeave.fire();
      })), this.disposables.push(this.list.onContextMenu((r) => {
        typeof r.index == "number" && (r.browserEvent.preventDefault(), this.list.setSelection([r.index]));
      })), this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onLeave, this._onKeyDown);
    }
    get onDidChangeFocus() {
      return be.map(this.list.onDidChangeFocus, (e) => e.elements.map((t) => t.item));
    }
    get onDidChangeSelection() {
      return be.map(this.list.onDidChangeSelection, (e) => ({ items: e.elements.map((t) => t.item), event: e.browserEvent }));
    }
    get scrollTop() {
      return this.list.scrollTop;
    }
    set scrollTop(e) {
      this.list.scrollTop = e;
    }
    getAllVisibleChecked() {
      return this.allVisibleChecked(this.elements, !1);
    }
    allVisibleChecked(e, t = !0) {
      for (let i = 0, n = e.length; i < n; i++) {
        const o = e[i];
        if (!o.hidden)
          if (o.checked)
            t = !0;
          else
            return !1;
      }
      return t;
    }
    getCheckedCount() {
      let e = 0;
      const t = this.elements;
      for (let i = 0, n = t.length; i < n; i++)
        t[i].checked && e++;
      return e;
    }
    getVisibleCount() {
      let e = 0;
      const t = this.elements;
      for (let i = 0, n = t.length; i < n; i++)
        t[i].hidden || e++;
      return e;
    }
    setAllVisibleChecked(e) {
      try {
        this._fireCheckedEvents = !1, this.elements.forEach((t) => {
          t.hidden || (t.checked = e);
        });
      } finally {
        this._fireCheckedEvents = !0, this.fireCheckedEvents();
      }
    }
    setElements(e) {
      this.elementDisposables = at(this.elementDisposables);
      const t = (i) => this.fireButtonTriggered(i);
      this.inputElements = e, this.elements = e.reduce((i, n, o) => {
        var r, a, l;
        if (n.type !== "separator") {
          const c = o && e[o - 1], d = n.label && n.label.replace(/\r?\n/g, " "), h = n.meta && n.meta.replace(/\r?\n/g, " "), u = n.description && n.description.replace(/\r?\n/g, " "), f = n.detail && n.detail.replace(/\r?\n/g, " "), g = n.ariaLabel || [d, u, f].map((b) => HW(b)).filter((b) => !!b).join(", "), _ = this.parent.classList.contains("show-checkboxes");
          i.push(new qce({
            hasCheckbox: _,
            index: o,
            item: n,
            saneLabel: d,
            saneMeta: h,
            saneAriaLabel: g,
            saneDescription: u,
            saneDetail: f,
            labelHighlights: (r = n.highlights) === null || r === void 0 ? void 0 : r.label,
            descriptionHighlights: (a = n.highlights) === null || a === void 0 ? void 0 : a.description,
            detailHighlights: (l = n.highlights) === null || l === void 0 ? void 0 : l.detail,
            checked: !1,
            separator: c && c.type === "separator" ? c : void 0,
            fireButtonTriggered: t
          }));
        }
        return i;
      }, []), this.elementDisposables.push(...this.elements), this.elementDisposables.push(...this.elements.map((i) => i.onChecked(() => this.fireCheckedEvents()))), this.elementsToIndexes = this.elements.reduce((i, n, o) => (i.set(n.item, o), i), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length), this.list.splice(0, this.list.length, this.elements), this._onChangedVisibleCount.fire(this.elements.length);
    }
    getFocusedElements() {
      return this.list.getFocusedElements().map((e) => e.item);
    }
    setFocusedElements(e) {
      if (this.list.setFocus(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t))), e.length > 0) {
        const t = this.list.getFocus()[0];
        typeof t == "number" && this.list.reveal(t);
      }
    }
    getActiveDescendant() {
      return this.list.getHTMLElement().getAttribute("aria-activedescendant");
    }
    setSelectedElements(e) {
      this.list.setSelection(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t)));
    }
    getCheckedElements() {
      return this.elements.filter((e) => e.checked).map((e) => e.item);
    }
    setCheckedElements(e) {
      try {
        this._fireCheckedEvents = !1;
        const t = /* @__PURE__ */ new Set();
        for (const i of e)
          t.add(i);
        for (const i of this.elements)
          i.checked = t.has(i.item);
      } finally {
        this._fireCheckedEvents = !0, this.fireCheckedEvents();
      }
    }
    set enabled(e) {
      this.list.getHTMLElement().style.pointerEvents = e ? "" : "none";
    }
    focus(e) {
      if (!this.list.length)
        return;
      switch (e === pi.Next && this.list.getFocus()[0] === this.list.length - 1 && (e = pi.First), e === pi.Previous && this.list.getFocus()[0] === 0 && (e = pi.Last), e === pi.Second && this.list.length < 2 && (e = pi.First), e) {
        case pi.First:
          this.list.focusFirst();
          break;
        case pi.Second:
          this.list.focusNth(1);
          break;
        case pi.Last:
          this.list.focusLast();
          break;
        case pi.Next:
          this.list.focusNext();
          break;
        case pi.Previous:
          this.list.focusPrevious();
          break;
        case pi.NextPage:
          this.list.focusNextPage();
          break;
        case pi.PreviousPage:
          this.list.focusPreviousPage();
          break;
      }
      const t = this.list.getFocus()[0];
      typeof t == "number" && this.list.reveal(t);
    }
    clearFocus() {
      this.list.setFocus([]);
    }
    domFocus() {
      this.list.domFocus();
    }
    layout(e) {
      this.list.getHTMLElement().style.maxHeight = e ? `calc(${Math.floor(e / 44) * 44}px)` : "", this.list.layout();
    }
    filter(e) {
      if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
        return this.list.layout(), !1;
      if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
        this.elements.forEach((i) => {
          i.labelHighlights = void 0, i.descriptionHighlights = void 0, i.detailHighlights = void 0, i.hidden = !1;
          const n = i.index && this.inputElements[i.index - 1];
          i.separator = n && n.type === "separator" ? n : void 0;
        });
      else {
        let i;
        this.elements.forEach((n) => {
          const o = this.matchOnLabel ? ys(fb(e, ub(n.saneLabel))) : void 0, r = this.matchOnDescription ? ys(fb(e, ub(n.saneDescription || ""))) : void 0, a = this.matchOnDetail ? ys(fb(e, ub(n.saneDetail || ""))) : void 0, l = this.matchOnMeta ? ys(fb(e, ub(n.saneMeta || ""))) : void 0;
          if (o || r || a || l ? (n.labelHighlights = o, n.descriptionHighlights = r, n.detailHighlights = a, n.hidden = !1) : (n.labelHighlights = void 0, n.descriptionHighlights = void 0, n.detailHighlights = void 0, n.hidden = !n.item.alwaysShow), n.separator = void 0, !this.sortByLabel) {
            const c = n.index && this.inputElements[n.index - 1];
            i = c && c.type === "separator" ? c : i, i && !n.hidden && (n.separator = i, i = void 0);
          }
        });
      }
      const t = this.elements.filter((i) => !i.hidden);
      if (this.sortByLabel && e) {
        const i = e.toLowerCase();
        t.sort((n, o) => Zce(n, o, i));
      }
      return this.elementsToIndexes = t.reduce((i, n, o) => (i.set(n.item, o), i), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length, t), this.list.setFocus([]), this.list.layout(), this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedVisibleCount.fire(t.length), !0;
    }
    toggleCheckbox() {
      try {
        this._fireCheckedEvents = !1;
        const e = this.list.getFocusedElements(), t = this.allVisibleChecked(e);
        for (const i of e)
          i.checked = !t;
      } finally {
        this._fireCheckedEvents = !0, this.fireCheckedEvents();
      }
    }
    display(e) {
      this.container.style.display = e ? "" : "none";
    }
    isDisplayed() {
      return this.container.style.display !== "none";
    }
    dispose() {
      this.elementDisposables = at(this.elementDisposables), this.disposables = at(this.disposables);
    }
    fireCheckedEvents() {
      this._fireCheckedEvents && (this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedCheckedCount.fire(this.getCheckedCount()), this._onChangedCheckedElements.fire(this.getCheckedElements()));
    }
    fireButtonTriggered(e) {
      this._onButtonTriggered.fire(e);
    }
    style(e) {
      this.list.style(e);
    }
  }
  V8([
    Ai
  ], l2.prototype, "onDidChangeFocus", null);
  V8([
    Ai
  ], l2.prototype, "onDidChangeSelection", null);
  function Zce(s, e, t) {
    const i = s.labelHighlights || [], n = e.labelHighlights || [];
    return i.length && !n.length ? -1 : !i.length && n.length ? 1 : i.length === 0 && n.length === 0 ? 0 : $ce(s.saneLabel, e.saneLabel, t);
  }
  class Yce {
    getWidgetAriaLabel() {
      return m("quickInput", "Quick Input");
    }
    getAriaLabel(e) {
      return e.saneAriaLabel;
    }
    getWidgetRole() {
      return "listbox";
    }
    getRole(e) {
      return e.hasCheckbox ? "checkbox" : "option";
    }
    isChecked(e) {
      if (!!e.hasCheckbox)
        return {
          value: e.checked,
          onDidChange: e.onChecked
        };
    }
  }
  var iO = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  const Os = J, xx = {
    iconClass: p.quickInputBack.classNames,
    tooltip: m("quickInput.back", "Back"),
    handle: -1
  };
  class mw extends z {
    constructor(e) {
      super(), this.ui = e, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._buttons = [], this.noValidationMessage = mw.noPromptMessage, this._severity = Zt.Ignore, this.buttonsUpdated = !1, this.onDidTriggerButtonEmitter = this._register(new B()), this.onDidHideEmitter = this._register(new B()), this.onDisposeEmitter = this._register(new B()), this.visibleDisposables = this._register(new te()), this.onDidHide = this.onDidHideEmitter.event;
    }
    get title() {
      return this._title;
    }
    set title(e) {
      this._title = e, this.update();
    }
    get description() {
      return this._description;
    }
    set description(e) {
      this._description = e, this.update();
    }
    get step() {
      return this._steps;
    }
    set step(e) {
      this._steps = e, this.update();
    }
    get totalSteps() {
      return this._totalSteps;
    }
    set totalSteps(e) {
      this._totalSteps = e, this.update();
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e) {
      this._enabled = e, this.update();
    }
    get contextKey() {
      return this._contextKey;
    }
    set contextKey(e) {
      this._contextKey = e, this.update();
    }
    get busy() {
      return this._busy;
    }
    set busy(e) {
      this._busy = e, this.update();
    }
    get ignoreFocusOut() {
      return this._ignoreFocusOut;
    }
    set ignoreFocusOut(e) {
      const t = this._ignoreFocusOut !== e && !aa;
      this._ignoreFocusOut = e && !aa, t && this.update();
    }
    get buttons() {
      return this._buttons;
    }
    set buttons(e) {
      this._buttons = e, this.buttonsUpdated = !0, this.update();
    }
    get validationMessage() {
      return this._validationMessage;
    }
    set validationMessage(e) {
      this._validationMessage = e, this.update();
    }
    get severity() {
      return this._severity;
    }
    set severity(e) {
      this._severity = e, this.update();
    }
    show() {
      this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
        this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
      })), this.ui.show(this), this.visible = !0, this._lastValidationMessage = void 0, this._lastSeverity = void 0, this.buttons.length && (this.buttonsUpdated = !0), this.update());
    }
    hide() {
      !this.visible || this.ui.hide();
    }
    didHide(e = _p.Other) {
      this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
    }
    update() {
      if (!this.visible)
        return;
      const e = this.getTitle();
      e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = "\xA0");
      const t = this.getDescription();
      if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this.busy && !this.busyDelay && (this.busyDelay = new Ns(), this.busyDelay.setIfNotSet(() => {
        this.visible && this.ui.progressBar.infinite();
      }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
        this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
        const n = this.buttons.filter((r) => r === xx);
        this.ui.leftActionBar.push(n.map((r, a) => {
          const l = new ks(`id-${a}`, "", r.iconClass || Dx(r.iconPath), !0, () => iO(this, void 0, void 0, function* () {
            this.onDidTriggerButtonEmitter.fire(r);
          }));
          return l.tooltip = r.tooltip || "", l;
        }), { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
        const o = this.buttons.filter((r) => r !== xx);
        this.ui.rightActionBar.push(o.map((r, a) => {
          const l = new ks(`id-${a}`, "", r.iconClass || Dx(r.iconPath), !0, () => iO(this, void 0, void 0, function* () {
            this.onDidTriggerButtonEmitter.fire(r);
          }));
          return l.tooltip = r.tooltip || "", l;
        }), { icon: !0, label: !1 });
      }
      this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
      const i = this.validationMessage || this.noValidationMessage;
      this._lastValidationMessage !== i && (this._lastValidationMessage = i, pc(this.ui.message, ...Pd(i))), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
    }
    getTitle() {
      return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
    }
    getDescription() {
      return this.description || "";
    }
    getSteps() {
      return this.step && this.totalSteps ? m("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
    }
    showMessageDecoration(e) {
      if (this.ui.inputBox.showDecoration(e), e !== Zt.Ignore) {
        const t = this.ui.inputBox.stylesForType(e);
        this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.marginBottom = "-2px";
      } else
        this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.marginBottom = "";
    }
    dispose() {
      this.hide(), this.onDisposeEmitter.fire(), super.dispose();
    }
  }
  mw.noPromptMessage = m("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
  class Xp extends mw {
    constructor() {
      super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new B()), this.onWillAcceptEmitter = this._register(new B()), this.onDidAcceptEmitter = this._register(new B()), this.onDidCustomEmitter = this._register(new B()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._sortByLabel = !0, this._autoFocusOnList = !0, this._keepScrollPosition = !1, this._itemActivation = this.ui.isScreenReaderOptimized() ? sr.NONE : sr.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new B()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new B()), this.onDidTriggerItemButtonEmitter = this._register(new B()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
    }
    get quickNavigate() {
      return this._quickNavigate;
    }
    set quickNavigate(e) {
      this._quickNavigate = e, this.update();
    }
    get value() {
      return this._value;
    }
    set value(e) {
      this.doSetValue(e);
    }
    doSetValue(e, t) {
      this._value !== e && (this._value = e, t || this.update(), this.visible && this.ui.list.filter(this.filterValue(this._value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(this._value));
    }
    set ariaLabel(e) {
      this._ariaLabel = e, this.update();
    }
    get ariaLabel() {
      return this._ariaLabel;
    }
    get placeholder() {
      return this._placeholder;
    }
    set placeholder(e) {
      this._placeholder = e, this.update();
    }
    get items() {
      return this._items;
    }
    get scrollTop() {
      return this.ui.list.scrollTop;
    }
    set scrollTop(e) {
      this.ui.list.scrollTop = e;
    }
    set items(e) {
      this._items = e, this.itemsUpdated = !0, this.update();
    }
    get canSelectMany() {
      return this._canSelectMany;
    }
    set canSelectMany(e) {
      this._canSelectMany = e, this.update();
    }
    get canAcceptInBackground() {
      return this._canAcceptInBackground;
    }
    set canAcceptInBackground(e) {
      this._canAcceptInBackground = e;
    }
    get matchOnDescription() {
      return this._matchOnDescription;
    }
    set matchOnDescription(e) {
      this._matchOnDescription = e, this.update();
    }
    get matchOnDetail() {
      return this._matchOnDetail;
    }
    set matchOnDetail(e) {
      this._matchOnDetail = e, this.update();
    }
    get matchOnLabel() {
      return this._matchOnLabel;
    }
    set matchOnLabel(e) {
      this._matchOnLabel = e, this.update();
    }
    get sortByLabel() {
      return this._sortByLabel;
    }
    set sortByLabel(e) {
      this._sortByLabel = e, this.update();
    }
    get autoFocusOnList() {
      return this._autoFocusOnList;
    }
    set autoFocusOnList(e) {
      this._autoFocusOnList = e, this.update();
    }
    get keepScrollPosition() {
      return this._keepScrollPosition;
    }
    set keepScrollPosition(e) {
      this._keepScrollPosition = e;
    }
    get itemActivation() {
      return this._itemActivation;
    }
    set itemActivation(e) {
      this._itemActivation = e;
    }
    get activeItems() {
      return this._activeItems;
    }
    set activeItems(e) {
      this._activeItems = e, this.activeItemsUpdated = !0, this.update();
    }
    get selectedItems() {
      return this._selectedItems;
    }
    set selectedItems(e) {
      this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
    }
    get keyMods() {
      return this._quickNavigate ? oX : this.ui.keyMods;
    }
    set valueSelection(e) {
      this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
    }
    get customButton() {
      return this._customButton;
    }
    set customButton(e) {
      this._customButton = e, this.update();
    }
    get customLabel() {
      return this._customButtonLabel;
    }
    set customLabel(e) {
      this._customButtonLabel = e, this.update();
    }
    get customHover() {
      return this._customButtonHover;
    }
    set customHover(e) {
      this._customButtonHover = e, this.update();
    }
    get ok() {
      return this._ok;
    }
    set ok(e) {
      this._ok = e, this.update();
    }
    get hideInput() {
      return !!this._hideInput;
    }
    set hideInput(e) {
      this._hideInput = e, this.update();
    }
    trySelectFirst() {
      this.autoFocusOnList && (this.canSelectMany || this.ui.list.focus(pi.First));
    }
    show() {
      this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
        this.doSetValue(e, !0);
      })), this.visibleDisposables.add(this.ui.inputBox.onMouseDown((e) => {
        this.autoFocusOnList || this.ui.list.clearFocus();
      })), this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((e) => {
        switch (e.keyCode) {
          case 18:
            this.ui.list.focus(pi.Next), this.canSelectMany && this.ui.list.domFocus(), wt.stop(e, !0);
            break;
          case 16:
            this.ui.list.getFocusedElements().length ? this.ui.list.focus(pi.Previous) : this.ui.list.focus(pi.Last), this.canSelectMany && this.ui.list.domFocus(), wt.stop(e, !0);
            break;
          case 12:
            this.ui.list.focus(pi.NextPage), this.canSelectMany && this.ui.list.domFocus(), wt.stop(e, !0);
            break;
          case 11:
            this.ui.list.focus(pi.PreviousPage), this.canSelectMany && this.ui.list.domFocus(), wt.stop(e, !0);
            break;
          case 17:
            if (!this._canAcceptInBackground || !this.ui.inputBox.isSelectionAtEnd())
              return;
            this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!0));
            break;
          case 14:
            (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus(pi.First), wt.stop(e, !0));
            break;
          case 13:
            (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus(pi.Last), wt.stop(e, !0));
            break;
        }
      })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
        this.canSelectMany ? this.ui.list.getCheckedElements().length || (this._selectedItems = [], this.onDidChangeSelectionEmitter.fire(this.selectedItems)) : this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
      })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
        this.onDidCustomEmitter.fire();
      })), this.visibleDisposables.add(this.ui.list.onDidChangeFocus((e) => {
        this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && Gs(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
      })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
        if (this.canSelectMany) {
          e.length && this.ui.list.setSelectedElements([]);
          return;
        }
        this.selectedItemsToConfirm !== this._selectedItems && Gs(e, this._selectedItems, (i, n) => i === n) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(t instanceof MouseEvent && t.button === 1));
      })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
        !this.canSelectMany || this.selectedItemsToConfirm !== this._selectedItems && Gs(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e));
      })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
    }
    handleAccept(e) {
      let t = !1;
      this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
    }
    registerQuickNavigation() {
      return ee(this.ui.container, ye.KEY_UP, (e) => {
        if (this.canSelectMany || !this._quickNavigate)
          return;
        const t = new $t(e), i = t.keyCode;
        this._quickNavigate.keybindings.some((r) => {
          const [a, l] = r.getParts();
          return l ? !1 : a.shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a.altKey && i === 6 || a.ctrlKey && i === 5 || a.metaKey && i === 57);
        }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
      });
    }
    update() {
      if (!this.visible)
        return;
      const e = this.keepScrollPosition ? this.scrollTop : 0, t = !!this._hideInput && this._items.length > 0;
      this.ui.container.classList.toggle("hidden-input", t && !this.description);
      const i = {
        title: !!this.title || !!this.step || !!this.buttons.length,
        description: !!this.description,
        checkAll: this.canSelectMany && !this._hideCheckAll,
        checkBox: this.canSelectMany,
        inputBox: !t,
        progressBar: !t,
        visibleCount: !0,
        count: this.canSelectMany,
        ok: this.ok === "default" ? this.canSelectMany : this.ok,
        list: !0,
        message: !!this.validationMessage,
        customButton: this.customButton
      };
      this.ui.setVisibilities(i), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
      const n = this.ariaLabel || this.placeholder || Xp.DEFAULT_ARIA_LABEL;
      if (this.ui.inputBox.ariaLabel !== n && (this.ui.inputBox.ariaLabel = n), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated)
        switch (this.itemsUpdated = !1, this.ui.list.setElements(this.items), this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked(), this.ui.visibleCount.setCount(this.ui.list.getVisibleCount()), this.ui.count.setCount(this.ui.list.getCheckedCount()), this._itemActivation) {
          case sr.NONE:
            this._itemActivation = sr.FIRST;
            break;
          case sr.SECOND:
            this.ui.list.focus(pi.Second), this._itemActivation = sr.FIRST;
            break;
          case sr.LAST:
            this.ui.list.focus(pi.Last), this._itemActivation = sr.FIRST;
            break;
          default:
            this.trySelectFirst();
            break;
        }
      this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", this.ui.setComboboxAccessibility(!0), i.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(pi.First)), this.keepScrollPosition && (this.scrollTop = e);
    }
  }
  Xp.DEFAULT_ARIA_LABEL = m("quickInputBox.ariaLabel", "Type to narrow down results.");
  class pw extends z {
    constructor(e) {
      super(), this.options = e, this.comboboxAccessibility = !1, this.enabled = !0, this.onDidAcceptEmitter = this._register(new B()), this.onDidCustomEmitter = this._register(new B()), this.onDidTriggerButtonEmitter = this._register(new B()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new B()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new B()), this.onHide = this.onHideEmitter.event, this.idPrefix = e.idPrefix, this.parentElement = e.container, this.styles = e.styles, this.registerKeyModsListeners();
    }
    registerKeyModsListeners() {
      const e = (t) => {
        this.keyMods.ctrlCmd = t.ctrlKey || t.metaKey, this.keyMods.alt = t.altKey;
      };
      this._register(ee(window, ye.KEY_DOWN, e, !0)), this._register(ee(window, ye.KEY_UP, e, !0)), this._register(ee(window, ye.MOUSE_DOWN, e, !0));
    }
    getUI() {
      if (this.ui)
        return this.ui;
      const e = q(this.parentElement, Os(".quick-input-widget.show-file-icons"));
      e.tabIndex = -1, e.style.display = "none";
      const t = Co(e), i = q(e, Os(".quick-input-titlebar")), n = this._register(new ga(i));
      n.domNode.classList.add("quick-input-left-action-bar");
      const o = q(i, Os(".quick-input-title")), r = this._register(new ga(i));
      r.domNode.classList.add("quick-input-right-action-bar");
      const a = q(e, Os(".quick-input-description")), l = q(e, Os(".quick-input-header")), c = q(l, Os("input.quick-input-check-all"));
      c.type = "checkbox", this._register(on(c, ye.CHANGE, (F) => {
        const R = c.checked;
        y.setAllVisibleChecked(R);
      })), this._register(ee(c, ye.CLICK, (F) => {
        (F.x || F.y) && f.setFocus();
      }));
      const d = q(l, Os(".quick-input-description")), h = q(l, Os(".quick-input-and-message")), u = q(h, Os(".quick-input-filter")), f = this._register(new zce(u));
      f.setAttribute("aria-describedby", `${this.idPrefix}message`);
      const g = q(u, Os(".quick-input-visible-count"));
      g.setAttribute("aria-live", "polite"), g.setAttribute("aria-atomic", "true");
      const _ = new lk(g, { countFormat: m({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }), b = q(u, Os(".quick-input-count"));
      b.setAttribute("aria-live", "polite");
      const C = new lk(b, { countFormat: m({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }), v = q(l, Os(".quick-input-action")), w = new XR(v);
      w.label = m("ok", "OK"), this._register(w.onDidClick((F) => {
        this.onDidAcceptEmitter.fire();
      }));
      const S = q(l, Os(".quick-input-action")), L = new XR(S);
      L.label = m("custom", "Custom"), this._register(L.onDidClick((F) => {
        this.onDidCustomEmitter.fire();
      }));
      const x = q(h, Os(`#${this.idPrefix}message.quick-input-message`)), y = this._register(new l2(e, this.idPrefix + "list", this.options));
      this._register(y.onChangedAllVisibleChecked((F) => {
        c.checked = F;
      })), this._register(y.onChangedVisibleCount((F) => {
        _.setCount(F);
      })), this._register(y.onChangedCheckedCount((F) => {
        C.setCount(F);
      })), this._register(y.onLeave(() => {
        setTimeout(() => {
          f.setFocus(), this.controller instanceof Xp && this.controller.canSelectMany && y.clearFocus();
        }, 0);
      })), this._register(y.onDidChangeFocus(() => {
        this.comboboxAccessibility && this.getUI().inputBox.setAttribute("aria-activedescendant", this.getUI().list.getActiveDescendant() || "");
      }));
      const k = new gw(e);
      k.getContainer().classList.add("quick-input-progress");
      const I = ff(e);
      return this._register(I), this._register(ee(e, ye.FOCUS, (F) => {
        this.previousFocusElement = F.relatedTarget instanceof HTMLElement ? F.relatedTarget : void 0;
      }, !0)), this._register(I.onDidBlur(() => {
        !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(_p.Blur), this.previousFocusElement = void 0;
      })), this._register(ee(e, ye.FOCUS, (F) => {
        f.setFocus();
      })), this._register(ee(e, ye.KEY_DOWN, (F) => {
        const R = new $t(F);
        switch (R.keyCode) {
          case 3:
            wt.stop(F, !0), this.onDidAcceptEmitter.fire();
            break;
          case 9:
            wt.stop(F, !0), this.hide(_p.Gesture);
            break;
          case 2:
            if (!R.altKey && !R.ctrlKey && !R.metaKey) {
              const $ = [".action-label.codicon"];
              e.classList.contains("show-checkboxes") ? $.push("input") : $.push("input[type=text]"), this.getUI().list.isDisplayed() && $.push(".monaco-list");
              const j = e.querySelectorAll($.join(", "));
              R.shiftKey && R.target === j[0] ? (wt.stop(F, !0), j[j.length - 1].focus()) : !R.shiftKey && R.target === j[j.length - 1] && (wt.stop(F, !0), j[0].focus());
            }
            break;
        }
      })), this.ui = {
        container: e,
        styleSheet: t,
        leftActionBar: n,
        titleBar: i,
        title: o,
        description1: a,
        description2: d,
        rightActionBar: r,
        checkAll: c,
        filterContainer: u,
        inputBox: f,
        visibleCountContainer: g,
        visibleCount: _,
        countContainer: b,
        count: C,
        okContainer: v,
        ok: w,
        message: x,
        customButtonContainer: S,
        customButton: L,
        list: y,
        progressBar: k,
        onDidAccept: this.onDidAcceptEmitter.event,
        onDidCustom: this.onDidCustomEmitter.event,
        onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
        ignoreFocusOut: !1,
        keyMods: this.keyMods,
        isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),
        show: (F) => this.show(F),
        hide: () => this.hide(),
        setVisibilities: (F) => this.setVisibilities(F),
        setComboboxAccessibility: (F) => this.setComboboxAccessibility(F),
        setEnabled: (F) => this.setEnabled(F),
        setContextKey: (F) => this.options.setContextKey(F)
      }, this.updateStyles(), this.ui;
    }
    pick(e, t = {}, i = Je.None) {
      return new Promise((n, o) => {
        let r = (d) => {
          r = n, t.onKeyMods && t.onKeyMods(a.keyMods), n(d);
        };
        if (i.isCancellationRequested) {
          r(void 0);
          return;
        }
        const a = this.createQuickPick();
        let l;
        const c = [
          a,
          a.onDidAccept(() => {
            if (a.canSelectMany)
              r(a.selectedItems.slice()), a.hide();
            else {
              const d = a.activeItems[0];
              d && (r(d), a.hide());
            }
          }),
          a.onDidChangeActive((d) => {
            const h = d[0];
            h && t.onDidFocus && t.onDidFocus(h);
          }),
          a.onDidChangeSelection((d) => {
            if (!a.canSelectMany) {
              const h = d[0];
              h && (r(h), a.hide());
            }
          }),
          a.onDidTriggerItemButton((d) => t.onDidTriggerItemButton && t.onDidTriggerItemButton(Object.assign(Object.assign({}, d), { removeItem: () => {
            const h = a.items.indexOf(d.item);
            if (h !== -1) {
              const u = a.items.slice(), f = u.splice(h, 1), g = a.activeItems.filter((b) => b !== f[0]), _ = a.keepScrollPosition;
              a.keepScrollPosition = !0, a.items = u, g && (a.activeItems = g), a.keepScrollPosition = _;
            }
          } }))),
          a.onDidChangeValue((d) => {
            l && !d && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
          }),
          i.onCancellationRequested(() => {
            a.hide();
          }),
          a.onDidHide(() => {
            at(c), r(void 0);
          })
        ];
        a.title = t.title, a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.autoFocusOnList = t.autoFocusOnList === void 0 || t.autoFocusOnList, a.quickNavigate = t.quickNavigate, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([d, h]) => {
          l = h, a.busy = !1, a.items = d, a.canSelectMany && (a.selectedItems = d.filter((u) => u.type !== "separator" && u.picked)), l && (a.activeItems = [l]);
        }), a.show(), Promise.resolve(e).then(void 0, (d) => {
          o(d), a.hide();
        });
      });
    }
    createQuickPick() {
      const e = this.getUI();
      return new Xp(e);
    }
    show(e) {
      const t = this.getUI();
      this.onShowEmitter.fire();
      const i = this.controller;
      this.controller = e, i && i.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", t.rightActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(Zt.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), pc(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, this.setComboboxAccessibility(!1), t.inputBox.ariaLabel = "";
      const n = this.options.backKeybindingLabel();
      xx.tooltip = n ? m("quickInput.backWithKeybinding", "Back ({0})", n) : m("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus();
    }
    setVisibilities(e) {
      const t = this.getUI();
      t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.display(!!e.list), t.container.classList[e.checkBox ? "add" : "remove"]("show-checkboxes"), this.updateLayout();
    }
    setComboboxAccessibility(e) {
      if (e !== this.comboboxAccessibility) {
        const t = this.getUI();
        this.comboboxAccessibility = e, this.comboboxAccessibility ? (t.inputBox.setAttribute("role", "combobox"), t.inputBox.setAttribute("aria-haspopup", "true"), t.inputBox.setAttribute("aria-autocomplete", "list"), t.inputBox.setAttribute("aria-activedescendant", t.list.getActiveDescendant() || "")) : (t.inputBox.removeAttribute("role"), t.inputBox.removeAttribute("aria-haspopup"), t.inputBox.removeAttribute("aria-autocomplete"), t.inputBox.removeAttribute("aria-activedescendant"));
      }
    }
    setEnabled(e) {
      if (e !== this.enabled) {
        this.enabled = e;
        for (const t of this.getUI().leftActionBar.viewItems)
          t.getAction().enabled = e;
        for (const t of this.getUI().rightActionBar.viewItems)
          t.getAction().enabled = e;
        this.getUI().checkAll.disabled = !e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
      }
    }
    hide(e) {
      var t;
      const i = this.controller;
      if (i) {
        const n = !(!((t = this.ui) === null || t === void 0) && t.container.contains(document.activeElement));
        if (this.controller = null, this.onHideEmitter.fire(), this.getUI().container.style.display = "none", !n) {
          let o = this.previousFocusElement;
          for (; o && !o.offsetParent; )
            o = ys(o.parentElement);
          o?.offsetParent ? (o.focus(), this.previousFocusElement = void 0) : this.options.returnFocus();
        }
        i.didHide(e);
      }
    }
    layout(e, t) {
      this.dimension = e, this.titleBarOffset = t, this.updateLayout();
    }
    updateLayout() {
      if (this.ui) {
        this.ui.container.style.top = `${this.titleBarOffset}px`;
        const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, pw.MAX_WIDTH);
        e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
      }
    }
    applyStyles(e) {
      this.styles = e, this.updateStyles();
    }
    updateStyles() {
      if (this.ui) {
        const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, contrastBorder: n, widgetShadow: o } = this.styles.widget;
        this.ui.titleBar.style.backgroundColor = e ? e.toString() : "", this.ui.container.style.backgroundColor = t ? t.toString() : "", this.ui.container.style.color = i ? i.toString() : "", this.ui.container.style.border = n ? `1px solid ${n}` : "", this.ui.container.style.boxShadow = o ? `0 0 8px 2px ${o}` : "", this.ui.inputBox.style(this.styles.inputBox), this.ui.count.style(this.styles.countBadge), this.ui.ok.style(this.styles.button), this.ui.customButton.style(this.styles.button), this.ui.progressBar.style(this.styles.progressBar), this.ui.list.style(this.styles.list);
        const r = [];
        this.styles.list.pickerGroupBorder && r.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`), this.styles.list.pickerGroupForeground && r.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (r.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && r.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && r.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && r.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && r.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && r.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), r.push("}"));
        const a = r.join(`
`);
        a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
      }
    }
  }
  pw.MAX_WIDTH = 600;
  var Xce = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, nO = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Ix = class extends z {
    constructor(e, t) {
      super(), this.quickInputService = e, this.instantiationService = t, this.registry = Si.as(qh.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
    }
    show(e = "", t) {
      this.doShowOrPick(e, !1, t);
    }
    doShowOrPick(e, t, i) {
      var n;
      const [o, r] = this.getOrInstantiateProvider(e), a = this.visibleQuickAccess, l = a?.descriptor;
      if (a && r && l === r) {
        e !== r.prefix && !i?.preserveValue && (a.picker.value = e), this.adjustValueSelection(a.picker, r, i);
        return;
      }
      if (r && !i?.preserveValue) {
        let f;
        if (a && l && l !== r) {
          const g = a.value.substr(l.prefix.length);
          g && (f = `${r.prefix}${g}`);
        }
        if (!f) {
          const g = o?.defaultFilterValue;
          g === vD.LAST ? f = this.lastAcceptedPickerValues.get(r) : typeof g == "string" && (f = `${r.prefix}${g}`);
        }
        typeof f == "string" && (e = f);
      }
      const c = new te(), d = c.add(this.quickInputService.createQuickPick());
      d.value = e, this.adjustValueSelection(d, r, i), d.placeholder = r?.placeholder, d.quickNavigate = i?.quickNavigateConfiguration, d.hideInput = !!d.quickNavigate && !a, (typeof i?.itemActivation == "number" || i?.quickNavigateConfiguration) && (d.itemActivation = (n = i?.itemActivation) !== null && n !== void 0 ? n : sr.SECOND), d.contextKey = r?.contextKey, d.filterValue = (f) => f.substring(r ? r.prefix.length : 0), r?.placeholder && (d.ariaLabel = r?.placeholder);
      let h;
      t && (h = new wI(), c.add(ul(d.onWillAccept)((f) => {
        f.veto(), d.hide();
      }))), c.add(this.registerPickerListeners(d, o, r, e));
      const u = c.add(new bn());
      if (o && c.add(o.provide(d, u.token)), ul(d.onDidHide)(() => {
        d.selectedItems.length === 0 && u.cancel(), c.dispose(), h?.complete(d.selectedItems.slice(0));
      }), d.show(), t)
        return h?.p;
    }
    adjustValueSelection(e, t, i) {
      var n;
      let o;
      i?.preserveValue ? o = [e.value.length, e.value.length] : o = [(n = t?.prefix.length) !== null && n !== void 0 ? n : 0, e.value.length], e.valueSelection = o;
    }
    registerPickerListeners(e, t, i, n) {
      const o = new te(), r = this.visibleQuickAccess = { picker: e, descriptor: i, value: n };
      return o.add(qe(() => {
        r === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
      })), o.add(e.onDidChangeValue((a) => {
        const [l] = this.getOrInstantiateProvider(a);
        l !== t ? this.show(a, { preserveValue: !0 }) : r.value = a;
      })), i && o.add(e.onDidAccept(() => {
        this.lastAcceptedPickerValues.set(i, e.value);
      })), o;
    }
    getOrInstantiateProvider(e) {
      const t = this.registry.getQuickAccessProvider(e);
      if (!t)
        return [void 0, void 0];
      let i = this.mapProviderToDescriptor.get(t);
      return i || (i = this.instantiationService.createInstance(t.ctor), this.mapProviderToDescriptor.set(t, i)), [i, t];
    }
  };
  Ix = Xce([
    nO(0, Sl),
    nO(1, et)
  ], Ix);
  var Qce = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, zg = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Ex = class extends dV {
    constructor(e, t, i, n, o) {
      super(i), this.instantiationService = e, this.contextKeyService = t, this.accessibilityService = n, this.layoutService = o, this.contexts = /* @__PURE__ */ new Map();
    }
    get controller() {
      return this._controller || (this._controller = this._register(this.createController())), this._controller;
    }
    get quickAccess() {
      return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(Ix))), this._quickAccess;
    }
    createController(e = this.layoutService, t) {
      var i, n;
      const o = {
        idPrefix: "quickInput_",
        container: e.container,
        ignoreFocusOut: () => !1,
        isScreenReaderOptimized: () => this.accessibilityService.isScreenReaderOptimized(),
        backKeybindingLabel: () => {
        },
        setContextKey: (a) => this.setContextKey(a),
        returnFocus: () => e.focus(),
        createList: (a, l, c, d, h) => this.instantiationService.createInstance(rk, a, l, c, d, h),
        styles: this.computeStyles()
      }, r = this._register(new pw(Object.assign(Object.assign({}, o), t)));
      return r.layout(e.dimension, (n = (i = e.offset) === null || i === void 0 ? void 0 : i.top) !== null && n !== void 0 ? n : 0), this._register(e.onDidLayout((a) => {
        var l, c;
        return r.layout(a, (c = (l = e.offset) === null || l === void 0 ? void 0 : l.top) !== null && c !== void 0 ? c : 0);
      })), this._register(r.onShow(() => this.resetContextKeys())), this._register(r.onHide(() => this.resetContextKeys())), r;
    }
    setContextKey(e) {
      let t;
      e && (t = this.contexts.get(e), t || (t = new ue(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t && t.set(!0));
    }
    resetContextKeys() {
      this.contexts.forEach((e) => {
        e.get() && e.reset();
      });
    }
    pick(e, t = {}, i = Je.None) {
      return this.controller.pick(e, t, i);
    }
    createQuickPick() {
      return this.controller.createQuickPick();
    }
    updateStyles() {
      this.controller.applyStyles(this.computeStyles());
    }
    computeStyles() {
      return {
        widget: Object.assign({}, or(this.theme, {
          quickInputBackground: aT,
          quickInputForeground: Dz,
          quickInputTitleBackground: xz,
          contrastBorder: qt,
          widgetShadow: wc
        })),
        inputBox: or(this.theme, {
          inputForeground: XI,
          inputBackground: YI,
          inputBorder: QI,
          inputValidationInfoBackground: m5,
          inputValidationInfoForeground: p5,
          inputValidationInfoBorder: _5,
          inputValidationWarningBackground: b5,
          inputValidationWarningForeground: v5,
          inputValidationWarningBorder: C5,
          inputValidationErrorBackground: w5,
          inputValidationErrorForeground: S5,
          inputValidationErrorBorder: y5
        }),
        countBadge: or(this.theme, {
          badgeBackground: rm,
          badgeForeground: am,
          badgeBorder: qt
        }),
        button: or(this.theme, {
          buttonForeground: _z,
          buttonBackground: mL,
          buttonHoverBackground: bz,
          buttonBorder: qt
        }),
        progressBar: or(this.theme, {
          progressBarBackground: vz
        }),
        keybindingLabel: or(this.theme, {
          keybindingLabelBackground: Nz,
          keybindingLabelForeground: Tz,
          keybindingLabelBorder: Mz,
          keybindingLabelBottomBorder: Az,
          keybindingLabelShadow: wc
        }),
        list: or(this.theme, {
          listBackground: aT,
          listInactiveFocusForeground: a0,
          listInactiveSelectionIconForeground: l0,
          listInactiveFocusBackground: c0,
          listFocusOutline: Bn,
          listInactiveFocusOutline: Bn,
          pickerGroupBorder: Ez,
          pickerGroupForeground: Iz
        })
      };
    }
  };
  Ex = Qce([
    zg(0, et),
    zg(1, Fe),
    zg(2, jt),
    zg(3, Ts),
    zg(4, A_)
  ], Ex);
  var H8 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, pd = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Nx = class extends Ex {
    constructor(e, t, i, n, o, r) {
      super(t, i, n, o, new gx(e.getContainerDomNode(), r)), this.host = void 0;
      const a = qf.get(e);
      if (a) {
        const l = a.widget;
        this.host = {
          _serviceBrand: void 0,
          get hasContainer() {
            return !0;
          },
          get container() {
            return l.getDomNode();
          },
          get dimension() {
            return e.getLayoutInfo();
          },
          get onDidLayout() {
            return e.onDidLayoutChange;
          },
          focus: () => e.focus()
        };
      } else
        this.host = void 0;
    }
    createController() {
      return super.createController(this.host);
    }
  };
  Nx = H8([
    pd(1, et),
    pd(2, Fe),
    pd(3, jt),
    pd(4, Ts),
    pd(5, St)
  ], Nx);
  let Tx = class {
    constructor(e, t) {
      this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
    }
    get activeService() {
      const e = this.codeEditorService.getFocusedCodeEditor();
      if (!e)
        throw new Error("Quick input service needs a focused editor to work.");
      let t = this.mapEditorToService.get(e);
      if (!t) {
        const i = t = this.instantiationService.createInstance(Nx, e);
        this.mapEditorToService.set(e, t), ul(e.onDidDispose)(() => {
          i.dispose(), this.mapEditorToService.delete(e);
        });
      }
      return t;
    }
    get quickAccess() {
      return this.activeService.quickAccess;
    }
    pick(e, t = {}, i = Je.None) {
      return this.activeService.pick(e, t, i);
    }
    createQuickPick() {
      return this.activeService.createQuickPick();
    }
  };
  Tx = H8([
    pd(0, et),
    pd(1, St)
  ], Tx);
  class qf {
    constructor(e) {
      this.editor = e, this.widget = new _w(this.editor);
    }
    static get(e) {
      return e.getContribution(qf.ID);
    }
    dispose() {
      this.widget.dispose();
    }
  }
  qf.ID = "editor.controller.quickInput";
  class _w {
    constructor(e) {
      this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
    }
    getId() {
      return _w.ID;
    }
    getDomNode() {
      return this.domNode;
    }
    getPosition() {
      return { preference: 2 };
    }
    dispose() {
      this.codeEditor.removeOverlayWidget(this);
    }
  }
  _w.ID = "editor.contrib.quickInputWidget";
  vt(qf.ID, qf);
  class Jce {
    constructor(e, t, i, n, o) {
      this._parsedThemeRuleBrand = void 0, this.token = e, this.index = t, this.fontStyle = i, this.foreground = n, this.background = o;
    }
  }
  function ede(s) {
    if (!s || !Array.isArray(s))
      return [];
    const e = [];
    let t = 0;
    for (let i = 0, n = s.length; i < n; i++) {
      const o = s[i];
      let r = -1;
      if (typeof o.fontStyle == "string") {
        r = 0;
        const c = o.fontStyle.split(" ");
        for (let d = 0, h = c.length; d < h; d++)
          switch (c[d]) {
            case "italic":
              r = r | 1;
              break;
            case "bold":
              r = r | 2;
              break;
            case "underline":
              r = r | 4;
              break;
            case "strikethrough":
              r = r | 8;
              break;
          }
      }
      let a = null;
      typeof o.foreground == "string" && (a = o.foreground);
      let l = null;
      typeof o.background == "string" && (l = o.background), e[t++] = new Jce(o.token || "", i, r, a, l);
    }
    return e;
  }
  function tde(s, e) {
    s.sort((d, h) => {
      const u = rde(d.token, h.token);
      return u !== 0 ? u : d.index - h.index;
    });
    let t = 0, i = "000000", n = "ffffff";
    for (; s.length >= 1 && s[0].token === ""; ) {
      const d = s.shift();
      d.fontStyle !== -1 && (t = d.fontStyle), d.foreground !== null && (i = d.foreground), d.background !== null && (n = d.background);
    }
    const o = new nde();
    for (let d of e)
      o.getId(d);
    const r = o.getId(i), a = o.getId(n), l = new c2(t, r, a), c = new d2(l);
    for (let d = 0, h = s.length; d < h; d++) {
      const u = s[d];
      c.insert(u.token, u.fontStyle, o.getId(u.foreground), o.getId(u.background));
    }
    return new z8(o, c);
  }
  const ide = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
  class nde {
    constructor() {
      this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
    }
    getId(e) {
      if (e === null)
        return 0;
      const t = e.match(ide);
      if (!t)
        throw new Error("Illegal value for token color: " + e);
      e = t[1].toUpperCase();
      let i = this._color2id.get(e);
      return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = H.fromHex("#" + e), i);
    }
    getColorMap() {
      return this._id2color.slice(0);
    }
  }
  class z8 {
    constructor(e, t) {
      this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
    }
    static createFromRawTokenTheme(e, t) {
      return this.createFromParsedTokenTheme(ede(e), t);
    }
    static createFromParsedTokenTheme(e, t) {
      return tde(e, t);
    }
    getColorMap() {
      return this._colorMap.getColorMap();
    }
    _match(e) {
      return this._root.match(e);
    }
    match(e, t) {
      let i = this._cache.get(t);
      if (typeof i > "u") {
        const n = this._match(t), o = ode(t);
        i = (n.metadata | o << 8) >>> 0, this._cache.set(t, i);
      }
      return (i | e << 0) >>> 0;
    }
  }
  const sde = /\b(comment|string|regex|regexp)\b/;
  function ode(s) {
    const e = s.match(sde);
    if (!e)
      return 0;
    switch (e[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "regexp":
        return 3;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  function rde(s, e) {
    return s < e ? -1 : s > e ? 1 : 0;
  }
  class c2 {
    constructor(e, t, i) {
      this._themeTrieElementRuleBrand = void 0, this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 10 | this._foreground << 14 | this._background << 23) >>> 0;
    }
    clone() {
      return new c2(this._fontStyle, this._foreground, this._background);
    }
    acceptOverwrite(e, t, i) {
      e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 10 | this._foreground << 14 | this._background << 23) >>> 0;
    }
  }
  class d2 {
    constructor(e) {
      this._themeTrieElementBrand = void 0, this._mainRule = e, this._children = /* @__PURE__ */ new Map();
    }
    match(e) {
      if (e === "")
        return this._mainRule;
      const t = e.indexOf(".");
      let i, n;
      t === -1 ? (i = e, n = "") : (i = e.substring(0, t), n = e.substring(t + 1));
      const o = this._children.get(i);
      return typeof o < "u" ? o.match(n) : this._mainRule;
    }
    insert(e, t, i, n) {
      if (e === "") {
        this._mainRule.acceptOverwrite(t, i, n);
        return;
      }
      const o = e.indexOf(".");
      let r, a;
      o === -1 ? (r = e, a = "") : (r = e.substring(0, o), a = e.substring(o + 1));
      let l = this._children.get(r);
      typeof l > "u" && (l = new d2(this._mainRule.clone()), this._children.set(r, l)), l.insert(a, t, i, n);
    }
  }
  function ade(s) {
    const e = [];
    for (let t = 1, i = s.length; t < i; t++) {
      const n = s[t];
      e[t] = `.mtk${t} { color: ${n}; }`;
    }
    return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.push(".mtks { text-decoration: line-through; }"), e.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }"), e.join(`
`);
  }
  const lde = {
    base: "vs",
    inherit: !1,
    rules: [
      { token: "", foreground: "000000", background: "fffffe" },
      { token: "invalid", foreground: "cd3131" },
      { token: "emphasis", fontStyle: "italic" },
      { token: "strong", fontStyle: "bold" },
      { token: "variable", foreground: "001188" },
      { token: "variable.predefined", foreground: "4864AA" },
      { token: "constant", foreground: "dd0000" },
      { token: "comment", foreground: "008000" },
      { token: "number", foreground: "098658" },
      { token: "number.hex", foreground: "3030c0" },
      { token: "regexp", foreground: "800000" },
      { token: "annotation", foreground: "808080" },
      { token: "type", foreground: "008080" },
      { token: "delimiter", foreground: "000000" },
      { token: "delimiter.html", foreground: "383838" },
      { token: "delimiter.xml", foreground: "0000FF" },
      { token: "tag", foreground: "800000" },
      { token: "tag.id.pug", foreground: "4F76AC" },
      { token: "tag.class.pug", foreground: "4F76AC" },
      { token: "meta.scss", foreground: "800000" },
      { token: "metatag", foreground: "e00000" },
      { token: "metatag.content.html", foreground: "FF0000" },
      { token: "metatag.html", foreground: "808080" },
      { token: "metatag.xml", foreground: "808080" },
      { token: "metatag.php", fontStyle: "bold" },
      { token: "key", foreground: "863B00" },
      { token: "string.key.json", foreground: "A31515" },
      { token: "string.value.json", foreground: "0451A5" },
      { token: "attribute.name", foreground: "FF0000" },
      { token: "attribute.value", foreground: "0451A5" },
      { token: "attribute.value.number", foreground: "098658" },
      { token: "attribute.value.unit", foreground: "098658" },
      { token: "attribute.value.html", foreground: "0000FF" },
      { token: "attribute.value.xml", foreground: "0000FF" },
      { token: "string", foreground: "A31515" },
      { token: "string.html", foreground: "0000FF" },
      { token: "string.sql", foreground: "FF0000" },
      { token: "string.yaml", foreground: "0451A5" },
      { token: "keyword", foreground: "0000FF" },
      { token: "keyword.json", foreground: "0451A5" },
      { token: "keyword.flow", foreground: "AF00DB" },
      { token: "keyword.flow.scss", foreground: "0000FF" },
      { token: "operator.scss", foreground: "666666" },
      { token: "operator.sql", foreground: "778899" },
      { token: "operator.swift", foreground: "666666" },
      { token: "predefined.sql", foreground: "C700C7" }
    ],
    colors: {
      [cs]: "#FFFFFE",
      [nc]: "#000000",
      [eE]: "#E5EBF1",
      [oC]: "#D3D3D3",
      [rC]: "#939393",
      [tE]: "#ADD6FF4D"
    }
  }, cde = {
    base: "vs-dark",
    inherit: !1,
    rules: [
      { token: "", foreground: "D4D4D4", background: "1E1E1E" },
      { token: "invalid", foreground: "f44747" },
      { token: "emphasis", fontStyle: "italic" },
      { token: "strong", fontStyle: "bold" },
      { token: "variable", foreground: "74B0DF" },
      { token: "variable.predefined", foreground: "4864AA" },
      { token: "variable.parameter", foreground: "9CDCFE" },
      { token: "constant", foreground: "569CD6" },
      { token: "comment", foreground: "608B4E" },
      { token: "number", foreground: "B5CEA8" },
      { token: "number.hex", foreground: "5BB498" },
      { token: "regexp", foreground: "B46695" },
      { token: "annotation", foreground: "cc6666" },
      { token: "type", foreground: "3DC9B0" },
      { token: "delimiter", foreground: "DCDCDC" },
      { token: "delimiter.html", foreground: "808080" },
      { token: "delimiter.xml", foreground: "808080" },
      { token: "tag", foreground: "569CD6" },
      { token: "tag.id.pug", foreground: "4F76AC" },
      { token: "tag.class.pug", foreground: "4F76AC" },
      { token: "meta.scss", foreground: "A79873" },
      { token: "meta.tag", foreground: "CE9178" },
      { token: "metatag", foreground: "DD6A6F" },
      { token: "metatag.content.html", foreground: "9CDCFE" },
      { token: "metatag.html", foreground: "569CD6" },
      { token: "metatag.xml", foreground: "569CD6" },
      { token: "metatag.php", fontStyle: "bold" },
      { token: "key", foreground: "9CDCFE" },
      { token: "string.key.json", foreground: "9CDCFE" },
      { token: "string.value.json", foreground: "CE9178" },
      { token: "attribute.name", foreground: "9CDCFE" },
      { token: "attribute.value", foreground: "CE9178" },
      { token: "attribute.value.number.css", foreground: "B5CEA8" },
      { token: "attribute.value.unit.css", foreground: "B5CEA8" },
      { token: "attribute.value.hex.css", foreground: "D4D4D4" },
      { token: "string", foreground: "CE9178" },
      { token: "string.sql", foreground: "FF0000" },
      { token: "keyword", foreground: "569CD6" },
      { token: "keyword.flow", foreground: "C586C0" },
      { token: "keyword.json", foreground: "CE9178" },
      { token: "keyword.flow.scss", foreground: "569CD6" },
      { token: "operator.scss", foreground: "909090" },
      { token: "operator.sql", foreground: "778899" },
      { token: "operator.swift", foreground: "909090" },
      { token: "predefined.sql", foreground: "FF00FF" }
    ],
    colors: {
      [cs]: "#1E1E1E",
      [nc]: "#D4D4D4",
      [eE]: "#3A3D41",
      [oC]: "#404040",
      [rC]: "#707070",
      [tE]: "#ADD6FF26"
    }
  }, dde = {
    base: "hc-black",
    inherit: !1,
    rules: [
      { token: "", foreground: "FFFFFF", background: "000000" },
      { token: "invalid", foreground: "f44747" },
      { token: "emphasis", fontStyle: "italic" },
      { token: "strong", fontStyle: "bold" },
      { token: "variable", foreground: "1AEBFF" },
      { token: "variable.parameter", foreground: "9CDCFE" },
      { token: "constant", foreground: "569CD6" },
      { token: "comment", foreground: "608B4E" },
      { token: "number", foreground: "FFFFFF" },
      { token: "regexp", foreground: "C0C0C0" },
      { token: "annotation", foreground: "569CD6" },
      { token: "type", foreground: "3DC9B0" },
      { token: "delimiter", foreground: "FFFF00" },
      { token: "delimiter.html", foreground: "FFFF00" },
      { token: "tag", foreground: "569CD6" },
      { token: "tag.id.pug", foreground: "4F76AC" },
      { token: "tag.class.pug", foreground: "4F76AC" },
      { token: "meta", foreground: "D4D4D4" },
      { token: "meta.tag", foreground: "CE9178" },
      { token: "metatag", foreground: "569CD6" },
      { token: "metatag.content.html", foreground: "1AEBFF" },
      { token: "metatag.html", foreground: "569CD6" },
      { token: "metatag.xml", foreground: "569CD6" },
      { token: "metatag.php", fontStyle: "bold" },
      { token: "key", foreground: "9CDCFE" },
      { token: "string.key", foreground: "9CDCFE" },
      { token: "string.value", foreground: "CE9178" },
      { token: "attribute.name", foreground: "569CD6" },
      { token: "attribute.value", foreground: "3FF23F" },
      { token: "string", foreground: "CE9178" },
      { token: "string.sql", foreground: "FF0000" },
      { token: "keyword", foreground: "569CD6" },
      { token: "keyword.flow", foreground: "C586C0" },
      { token: "operator.sql", foreground: "778899" },
      { token: "operator.swift", foreground: "909090" },
      { token: "predefined.sql", foreground: "FF00FF" }
    ],
    colors: {
      [cs]: "#000000",
      [nc]: "#FFFFFF",
      [oC]: "#FFFFFF",
      [rC]: "#FFFFFF"
    }
  };
  function hde(s) {
    const e = new B(), t = TF();
    return t.onDidChange(() => e.fire()), s?.onDidProductIconThemeChange(() => e.fire()), {
      onDidChange: e.event,
      getCSS() {
        const i = s ? s.getProductIconTheme() : new U8(), n = {}, o = (a) => {
          const l = i.getIcon(a);
          if (!l)
            return;
          const c = l.font;
          return c ? (n[c.id] = c.definition, `.codicon-${a.id}:before { content: '${l.fontCharacter}'; font-family: ${F2(c.id)}; }`) : `.codicon-${a.id}:before { content: '${l.fontCharacter}'; }`;
        }, r = [];
        for (let a of t.getIcons()) {
          const l = o(a);
          l && r.push(l);
        }
        for (let a in n) {
          const l = n[a], c = l.weight ? `font-weight: ${l.weight};` : "", d = l.style ? `font-style: ${l.style};` : "", h = l.src.map((u) => `${jd(u.location)} format('${u.format}')`).join(", ");
          r.push(`@font-face { src: ${h}; font-family: ${F2(a)};${c}${d} font-display: block; }`);
        }
        return r.join(`
`);
      }
    };
  }
  class U8 {
    getIcon(e) {
      const t = TF();
      let i = e.defaults;
      for (; Tt.isThemeIcon(i); ) {
        const n = t.getIcon(i.id);
        if (!n)
          return;
        i = n.defaults;
      }
      return i;
    }
  }
  const Ld = "vs", uv = "vs-dark", cf = "hc-black", $8 = Si.as(f5.ColorContribution), ude = Si.as(AP.ThemingContribution);
  class j8 {
    constructor(e, t) {
      this.semanticHighlighting = !1, this.themeData = t;
      const i = t.base;
      e.length > 0 ? (M0(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
    }
    get base() {
      return this.themeData.base;
    }
    notifyBaseUpdated() {
      this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
    }
    getColors() {
      if (!this.colors) {
        const e = /* @__PURE__ */ new Map();
        for (let t in this.themeData.colors)
          e.set(t, H.fromHex(this.themeData.colors[t]));
        if (this.themeData.inherit) {
          const t = Mx(this.themeData.base);
          for (let i in t.colors)
            e.has(i) || e.set(i, H.fromHex(t.colors[i]));
        }
        this.colors = e;
      }
      return this.colors;
    }
    getColor(e, t) {
      const i = this.getColors().get(e);
      if (i)
        return i;
      if (t !== !1)
        return this.getDefault(e);
    }
    getDefault(e) {
      let t = this.defaultColors[e];
      return t || (t = $8.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
    }
    defines(e) {
      return Object.prototype.hasOwnProperty.call(this.getColors(), e);
    }
    get type() {
      switch (this.base) {
        case Ld:
          return jo.LIGHT;
        case cf:
          return jo.HIGH_CONTRAST;
        default:
          return jo.DARK;
      }
    }
    get tokenTheme() {
      if (!this._tokenTheme) {
        let e = [], t = [];
        if (this.themeData.inherit) {
          const o = Mx(this.themeData.base);
          e = o.rules, o.encodedTokensColors && (t = o.encodedTokensColors);
        }
        const i = this.themeData.colors["editor.foreground"], n = this.themeData.colors["editor.background"];
        if (i || n) {
          const o = { token: "" };
          i && (o.foreground = i), n && (o.background = n), e.push(o);
        }
        e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = z8.createFromRawTokenTheme(e, t);
      }
      return this._tokenTheme;
    }
    getTokenStyleMetadata(e, t, i) {
      const o = this.tokenTheme._match([e].concat(t).join(".")).metadata, r = In.getForeground(o), a = In.getFontStyle(o);
      return {
        foreground: r,
        italic: Boolean(a & 1),
        bold: Boolean(a & 2),
        underline: Boolean(a & 4),
        strikethrough: Boolean(a & 8)
      };
    }
  }
  function M0(s) {
    return s === Ld || s === uv || s === cf;
  }
  function Mx(s) {
    switch (s) {
      case Ld:
        return lde;
      case uv:
        return cde;
      case cf:
        return dde;
    }
  }
  function Ry(s) {
    const e = Mx(s);
    return new j8(s, e);
  }
  class fde extends z {
    constructor() {
      super(), this._onColorThemeChange = this._register(new B()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._onProductIconThemeChange = this._register(new B()), this.onDidProductIconThemeChange = this._onProductIconThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._builtInProductIconTheme = new U8(), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(Ld, Ry(Ld)), this._knownThemes.set(uv, Ry(uv)), this._knownThemes.set(cf, Ry(cf));
      const e = hde(this);
      this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(Ld), e.onDidChange(() => {
        this._codiconCSS = e.getCSS(), this._updateCSS();
      }), BW("(forced-colors: active)", () => {
        this._updateActualTheme();
      });
    }
    registerEditorContainer(e) {
      return Vm(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
    }
    _registerRegularEditorContainer() {
      return this._globalStyleElement || (this._globalStyleElement = Co(), this._globalStyleElement.className = "monaco-colors", this._globalStyleElement.textContent = this._allCSS, this._styleElements.push(this._globalStyleElement)), z.None;
    }
    _registerShadowDomContainer(e) {
      const t = Co(e);
      return t.className = "monaco-colors", t.textContent = this._allCSS, this._styleElements.push(t), {
        dispose: () => {
          for (let i = 0; i < this._styleElements.length; i++)
            if (this._styleElements[i] === t) {
              this._styleElements.splice(i, 1);
              return;
            }
        }
      };
    }
    defineTheme(e, t) {
      if (!/^[a-z0-9\-]+$/i.test(e))
        throw new Error("Illegal theme name!");
      if (!M0(t.base) && !M0(e))
        throw new Error("Illegal theme base!");
      this._knownThemes.set(e, new j8(e, t)), M0(e) && this._knownThemes.forEach((i) => {
        i.base === e && i.notifyBaseUpdated();
      }), this._theme.themeName === e && this.setTheme(e);
    }
    getColorTheme() {
      return this._theme;
    }
    setColorMapOverride(e) {
      this._colorMapOverride = e, this._updateThemeOrColorMap();
    }
    setTheme(e) {
      let t;
      this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(Ld), this._desiredTheme = t, this._updateActualTheme();
    }
    _updateActualTheme() {
      const e = this._autoDetectHighContrast && window.matchMedia("(forced-colors: active)").matches ? this._knownThemes.get(cf) : this._desiredTheme;
      this._theme !== e && (this._theme = e, this._updateThemeOrColorMap());
    }
    setAutoDetectHighContrast(e) {
      this._autoDetectHighContrast = e, this._updateActualTheme();
    }
    _updateThemeOrColorMap() {
      const e = [], t = {}, i = {
        addRule: (r) => {
          t[r] || (e.push(r), t[r] = !0);
        }
      };
      ude.getThemingParticipants().forEach((r) => r(this._theme, i, this._environment));
      const n = [];
      for (const r of $8.getColors()) {
        const a = this._theme.getColor(r.id, !0);
        a && n.push(`${u5(r.id)}: ${a.toString()};`);
      }
      i.addRule(`.monaco-editor { ${n.join(`
`)} }`);
      const o = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
      i.addRule(ade(o)), this._themeCSS = e.join(`
`), this._updateCSS(), Yt.setColorMap(o), this._onColorThemeChange.fire(this._theme);
    }
    _updateCSS() {
      this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
    }
    getFileIconTheme() {
      return {
        hasFileIcons: !1,
        hasFolderIcons: !1,
        hidesExplorerArrows: !1
      };
    }
    getProductIconTheme() {
      return this._builtInProductIconTheme;
    }
  }
  var gde = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, sO = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Ax = class extends z {
    constructor(e, t) {
      super(), this._contextKeyService = e, this._configurationService = t, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new B(), this._accessibilityModeEnabledContext = l_.bindTo(this._contextKeyService);
      const i = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
      this._register(this._configurationService.onDidChangeConfiguration((n) => {
        n.affectsConfiguration("editor.accessibilitySupport") && (i(), this._onDidChangeScreenReaderOptimized.fire());
      })), i(), this.onDidChangeScreenReaderOptimized(() => i());
    }
    get onDidChangeScreenReaderOptimized() {
      return this._onDidChangeScreenReaderOptimized.event;
    }
    isScreenReaderOptimized() {
      const e = this._configurationService.getValue("editor.accessibilitySupport");
      return e === "on" || e === "auto" && this._accessibilitySupport === 2;
    }
    getAccessibilitySupport() {
      return this._accessibilitySupport;
    }
  };
  Ax = gde([
    sO(0, Fe),
    sO(1, At)
  ], Ax);
  var K8 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, A0 = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Rx = class {
    constructor(e) {
      this._commandService = e;
    }
    createMenu(e, t, i) {
      return new Ox(e, Object.assign({ emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50 }, i), this._commandService, t, this);
    }
  };
  Rx = K8([
    A0(0, wi)
  ], Rx);
  let Ox = class wu {
    constructor(e, t, i, n, o) {
      this._id = e, this._options = t, this._commandService = i, this._contextKeyService = n, this._menuService = o, this._disposables = new te(), this._menuGroups = [], this._contextKeys = /* @__PURE__ */ new Set(), this._build();
      const r = new It(() => {
        this._build(), this._onDidChange.fire(this);
      }, t.eventDebounceDelay);
      this._disposables.add(r), this._disposables.add(qs.onDidChangeMenu((c) => {
        c.has(e) && r.schedule();
      }));
      const a = this._disposables.add(new te()), l = () => {
        const c = new It(() => this._onDidChange.fire(this), t.eventDebounceDelay);
        a.add(c), a.add(n.onDidChangeContext((d) => {
          d.affectsSome(this._contextKeys) && c.schedule();
        }));
      };
      this._onDidChange = new B({
        onFirstListenerAdd: l,
        onLastListenerRemove: a.clear.bind(a)
      }), this.onDidChange = this._onDidChange.event;
    }
    dispose() {
      this._disposables.dispose(), this._onDidChange.dispose();
    }
    _build() {
      this._menuGroups.length = 0, this._contextKeys.clear();
      const e = qs.getMenuItems(this._id);
      let t;
      e.sort(wu._compareMenuItems);
      for (const i of e) {
        const n = i.group || "";
        (!t || t[0] !== n) && (t = [n, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeys(i);
      }
    }
    _collectContextKeys(e) {
      if (wu._fillInKbExprKeys(e.when, this._contextKeys), yu(e)) {
        if (e.command.precondition && wu._fillInKbExprKeys(e.command.precondition, this._contextKeys), e.command.toggled) {
          const t = e.command.toggled.condition || e.command.toggled;
          wu._fillInKbExprKeys(t, this._contextKeys);
        }
      } else
        this._options.emitEventsForSubmenuChanges && qs.getMenuItems(e.submenu).forEach(this._collectContextKeys, this);
    }
    getActions(e) {
      const t = [];
      for (let i of this._menuGroups) {
        const [n, o] = i, r = [];
        for (const a of o)
          if (this._contextKeyService.contextMatchesRules(a.when)) {
            const l = yu(a) ? new vc(a.command, a.alt, e, this._contextKeyService, this._commandService) : new VI(a, this._menuService, this._contextKeyService, e);
            r.push(l);
          }
        r.length > 0 && t.push([n, r]);
      }
      return t;
    }
    static _fillInKbExprKeys(e, t) {
      if (e)
        for (let i of e.keys())
          t.add(i);
    }
    static _compareMenuItems(e, t) {
      let i = e.group, n = t.group;
      if (i !== n) {
        if (i) {
          if (!n)
            return -1;
        } else
          return 1;
        if (i === "navigation")
          return -1;
        if (n === "navigation")
          return 1;
        let a = i.localeCompare(n);
        if (a !== 0)
          return a;
      }
      let o = e.order || 0, r = t.order || 0;
      return o < r ? -1 : o > r ? 1 : wu._compareTitles(yu(e) ? e.command.title : e.title, yu(t) ? t.command.title : t.title);
    }
    static _compareTitles(e, t) {
      const i = typeof e == "string" ? e : e.original, n = typeof t == "string" ? t : t.original;
      return i.localeCompare(n);
    }
  };
  Ox = K8([
    A0(2, wi),
    A0(3, Fe),
    A0(4, Eh)
  ], Ox);
  var mde = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, oO = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Ug = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  let Px = class extends z {
    constructor(e, t) {
      super(), this.layoutService = e, this.logService = t, this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "", (Zo || gI) && this.installWebKitWriteTextWorkaround();
    }
    installWebKitWriteTextWorkaround() {
      const e = () => {
        const t = new wI();
        this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel(), this.webKitPendingClipboardWritePromise = t, navigator.clipboard.write([new ClipboardItem({
          "text/plain": t.p
        })]).catch((i) => Ug(this, void 0, void 0, function* () {
          (!(i instanceof Error) || i.name !== "NotAllowedError" || !t.isRejected) && this.logService.error(i);
        }));
      };
      this.layoutService.hasContainer && (this._register(ee(this.layoutService.container, "click", e)), this._register(ee(this.layoutService.container, "keydown", e)));
    }
    writeText(e, t) {
      return Ug(this, void 0, void 0, function* () {
        if (t) {
          this.mapTextToType.set(t, e);
          return;
        }
        if (this.webKitPendingClipboardWritePromise)
          return this.webKitPendingClipboardWritePromise.complete(e);
        try {
          return yield navigator.clipboard.writeText(e);
        } catch (o) {
          console.error(o);
        }
        const i = document.activeElement, n = document.body.appendChild(J("textarea", { "aria-hidden": !0 }));
        n.style.height = "1px", n.style.width = "1px", n.style.position = "absolute", n.value = e, n.focus(), n.select(), document.execCommand("copy"), i instanceof HTMLElement && i.focus(), document.body.removeChild(n);
      });
    }
    readText(e) {
      return Ug(this, void 0, void 0, function* () {
        if (e)
          return this.mapTextToType.get(e) || "";
        try {
          return yield navigator.clipboard.readText();
        } catch (t) {
          return console.error(t), "";
        }
      });
    }
    readFindText() {
      return Ug(this, void 0, void 0, function* () {
        return this.findText;
      });
    }
    writeFindText(e) {
      return Ug(this, void 0, void 0, function* () {
        this.findText = e;
      });
    }
  };
  Px = mde([
    oO(0, A_),
    oO(1, Xo)
  ], Px);
  var pde = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, _de = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  const Am = "data-keybinding-context";
  class h2 {
    constructor(e, t) {
      this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
    }
    setValue(e, t) {
      return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
    }
    removeValue(e) {
      return e in this._value ? (delete this._value[e], !0) : !1;
    }
    getValue(e) {
      const t = this._value[e];
      return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
    }
  }
  class Gf extends h2 {
    constructor() {
      super(-1, null);
    }
    setValue(e, t) {
      return !1;
    }
    removeValue(e) {
      return !1;
    }
    getValue(e) {
    }
  }
  Gf.INSTANCE = new Gf();
  class Qp extends h2 {
    constructor(e, t, i) {
      super(e, null), this._configurationService = t, this._values = nf.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((n) => {
        if (n.source === 6) {
          const o = Array.from(rt.map(this._values, ([r]) => r));
          this._values.clear(), i.fire(new aO(o));
        } else {
          const o = [];
          for (const r of n.affectedKeys) {
            const a = `config.${r}`, l = this._values.findSuperstr(a);
            l !== void 0 && (o.push(...rt.map(l, ([c]) => c)), this._values.deleteSuperstr(a)), this._values.has(a) && (o.push(a), this._values.delete(a));
          }
          i.fire(new aO(o));
        }
      });
    }
    dispose() {
      this._listener.dispose();
    }
    getValue(e) {
      if (e.indexOf(Qp._keyPrefix) !== 0)
        return super.getValue(e);
      if (this._values.has(e))
        return this._values.get(e);
      const t = e.substr(Qp._keyPrefix.length), i = this._configurationService.getValue(t);
      let n;
      switch (typeof i) {
        case "number":
        case "boolean":
        case "string":
          n = i;
          break;
        default:
          Array.isArray(i) ? n = JSON.stringify(i) : n = i;
      }
      return this._values.set(e, n), n;
    }
    setValue(e, t) {
      return super.setValue(e, t);
    }
    removeValue(e) {
      return super.removeValue(e);
    }
  }
  Qp._keyPrefix = "config.";
  class bde {
    constructor(e, t, i) {
      this._service = e, this._key = t, this._defaultValue = i, this.reset();
    }
    set(e) {
      this._service.setContext(this._key, e);
    }
    reset() {
      typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
    }
    get() {
      return this._service.getContextKeyValue(this._key);
    }
  }
  class rO {
    constructor(e) {
      this.key = e;
    }
    affectsSome(e) {
      return e.has(this.key);
    }
  }
  class aO {
    constructor(e) {
      this.keys = e;
    }
    affectsSome(e) {
      for (const t of this.keys)
        if (e.has(t))
          return !0;
      return !1;
    }
  }
  class vde {
    constructor(e) {
      this.events = e;
    }
    affectsSome(e) {
      for (const t of this.events)
        if (t.affectsSome(e))
          return !0;
      return !1;
    }
  }
  class q8 {
    constructor(e) {
      this._onDidChangeContext = new F0({ merge: (t) => new vde(t) }), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
    }
    createKey(e, t) {
      if (this._isDisposed)
        throw new Error("AbstractContextKeyService has been disposed");
      return new bde(this, e, t);
    }
    bufferChangeEvents(e) {
      this._onDidChangeContext.pause();
      try {
        e();
      } finally {
        this._onDidChangeContext.resume();
      }
    }
    createScoped(e) {
      if (this._isDisposed)
        throw new Error("AbstractContextKeyService has been disposed");
      return new Cde(this, e);
    }
    contextMatchesRules(e) {
      if (this._isDisposed)
        throw new Error("AbstractContextKeyService has been disposed");
      const t = this.getContextValuesContainer(this._myContextId);
      return e ? e.evaluate(t) : !0;
    }
    getContextKeyValue(e) {
      if (!this._isDisposed)
        return this.getContextValuesContainer(this._myContextId).getValue(e);
    }
    setContext(e, t) {
      if (this._isDisposed)
        return;
      const i = this.getContextValuesContainer(this._myContextId);
      !i || i.setValue(e, t) && this._onDidChangeContext.fire(new rO(e));
    }
    removeContext(e) {
      this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new rO(e));
    }
    getContext(e) {
      return this._isDisposed ? Gf.INSTANCE : this.getContextValuesContainer(wde(e));
    }
  }
  let Fx = class extends q8 {
    constructor(e) {
      super(0), this._contexts = /* @__PURE__ */ new Map(), this._toDispose = new te(), this._lastContextId = 0;
      const t = new Qp(this._myContextId, e, this._onDidChangeContext);
      this._contexts.set(this._myContextId, t), this._toDispose.add(t);
    }
    dispose() {
      this._onDidChangeContext.dispose(), this._isDisposed = !0, this._toDispose.dispose();
    }
    getContextValuesContainer(e) {
      return this._isDisposed ? Gf.INSTANCE : this._contexts.get(e) || Gf.INSTANCE;
    }
    createChildContext(e = this._myContextId) {
      if (this._isDisposed)
        throw new Error("ContextKeyService has been disposed");
      let t = ++this._lastContextId;
      return this._contexts.set(t, new h2(t, this.getContextValuesContainer(e))), t;
    }
    disposeContext(e) {
      this._isDisposed || this._contexts.delete(e);
    }
  };
  Fx = pde([
    _de(0, At)
  ], Fx);
  class Cde extends q8 {
    constructor(e, t) {
      if (super(e.createChildContext()), this._parentChangeListener = new Gn(), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(Am)) {
        let i = "";
        this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
      }
      this._domNode.setAttribute(Am, String(this._myContextId));
    }
    _updateParentChangeListener() {
      this._parentChangeListener.value = this._parent.onDidChangeContext(this._onDidChangeContext.fire, this._onDidChangeContext);
    }
    dispose() {
      this._isDisposed || (this._onDidChangeContext.dispose(), this._parent.disposeContext(this._myContextId), this._parentChangeListener.dispose(), this._domNode.removeAttribute(Am), this._isDisposed = !0);
    }
    getContextValuesContainer(e) {
      return this._isDisposed ? Gf.INSTANCE : this._parent.getContextValuesContainer(e);
    }
    createChildContext(e = this._myContextId) {
      if (this._isDisposed)
        throw new Error("ScopedContextKeyService has been disposed");
      return this._parent.createChildContext(e);
    }
    disposeContext(e) {
      this._isDisposed || this._parent.disposeContext(e);
    }
  }
  function wde(s) {
    for (; s; ) {
      if (s.hasAttribute(Am)) {
        const e = s.getAttribute(Am);
        return e ? parseInt(e, 10) : NaN;
      }
      s = s.parentElement;
    }
    return 0;
  }
  lt.registerCommand(aV, function(s, e, t) {
    s.get(Fe).createKey(String(e), t);
  });
  lt.registerCommand({
    id: "getContextKeyInfo",
    handler() {
      return [...ue.all()].sort((s, e) => s.key.localeCompare(e.key));
    },
    description: {
      description: m("getContextKeyInfo", "A command that returns information about context keys"),
      args: []
    }
  });
  lt.registerCommand("_generateContextKeyInfo", function() {
    const s = [], e = /* @__PURE__ */ new Set();
    for (let t of ue.all())
      e.has(t.key) || (e.add(t.key), s.push(t));
    s.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(s, void 0, 2));
  });
  class Sde {
    constructor(e) {
      this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map(), this.data = e;
    }
  }
  class yde {
    constructor(e) {
      this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
    }
    roots() {
      const e = [];
      for (let t of this._nodes.values())
        t.outgoing.size === 0 && e.push(t);
      return e;
    }
    insertEdge(e, t) {
      const i = this.lookupOrInsertNode(e), n = this.lookupOrInsertNode(t);
      i.outgoing.set(this._hashFn(t), n), n.incoming.set(this._hashFn(e), i);
    }
    removeNode(e) {
      const t = this._hashFn(e);
      this._nodes.delete(t);
      for (let i of this._nodes.values())
        i.outgoing.delete(t), i.incoming.delete(t);
    }
    lookupOrInsertNode(e) {
      const t = this._hashFn(e);
      let i = this._nodes.get(t);
      return i || (i = new Sde(e), this._nodes.set(t, i)), i;
    }
    isEmpty() {
      return this._nodes.size === 0;
    }
    toString() {
      let e = [];
      for (let [t, i] of this._nodes)
        e.push(`${t}, (incoming)[${[...i.incoming.keys()].join(", ")}], (outgoing)[${[...i.outgoing.keys()].join(",")}]`);
      return e.join(`
`);
    }
    findCycleSlow() {
      for (let [e, t] of this._nodes) {
        const i = /* @__PURE__ */ new Set([e]), n = this._findCycle(t, i);
        if (n)
          return n;
      }
    }
    _findCycle(e, t) {
      for (let [i, n] of e.outgoing) {
        if (t.has(i))
          return [...t, i].join(" -> ");
        t.add(i);
        const o = this._findCycle(n, t);
        if (o)
          return o;
        t.delete(i);
      }
    }
  }
  class lO extends Error {
    constructor(e) {
      var t;
      super("cyclic dependency between services"), this.message = (t = e.findCycleSlow()) !== null && t !== void 0 ? t : `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
    }
  }
  class u2 {
    constructor(e = new fC(), t = !1, i) {
      this._activeInstantiations = /* @__PURE__ */ new Set(), this._services = e, this._strict = t, this._parent = i, this._services.set(et, this);
    }
    createChild(e) {
      return new u2(e, this._strict, this);
    }
    invokeFunction(e, ...t) {
      let i = Uo.traceInvocation(e), n = !1;
      try {
        return e({
          get: (r) => {
            if (n)
              throw mB("service accessor is only valid during the invocation of its target method");
            const a = this._getOrCreateServiceInstance(r, i);
            if (!a)
              throw new Error(`[invokeFunction] unknown service '${r}'`);
            return a;
          }
        }, ...t);
      } finally {
        n = !0, i.stop();
      }
    }
    createInstance(e, ...t) {
      let i, n;
      return e instanceof Vr ? (i = Uo.traceCreation(e.ctor), n = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = Uo.traceCreation(e), n = this._createInstance(e, t, i)), i.stop(), n;
    }
    _createInstance(e, t = [], i) {
      let n = dr.getServiceDependencies(e).sort((a, l) => a.index - l.index), o = [];
      for (const a of n) {
        let l = this._getOrCreateServiceInstance(a.id, i);
        l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), o.push(l);
      }
      let r = n.length > 0 ? n[0].index : t.length;
      if (t.length !== r) {
        console.warn(`[createInstance] First service dependency of ${e.name} at position ${r + 1} conflicts with ${t.length} static arguments`);
        let a = r - t.length;
        a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, r);
      }
      return new e(...t, ...o);
    }
    _setServiceInstance(e, t) {
      if (this._services.get(e) instanceof Vr)
        this._services.set(e, t);
      else if (this._parent)
        this._parent._setServiceInstance(e, t);
      else
        throw new Error("illegalState - setting UNKNOWN service instance");
    }
    _getServiceInstanceOrDescriptor(e) {
      let t = this._services.get(e);
      return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
    }
    _getOrCreateServiceInstance(e, t) {
      let i = this._getServiceInstanceOrDescriptor(e);
      return i instanceof Vr ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
    }
    _safeCreateAndCacheServiceInstance(e, t, i) {
      if (this._activeInstantiations.has(e))
        throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
      this._activeInstantiations.add(e);
      try {
        return this._createAndCacheServiceInstance(e, t, i);
      } finally {
        this._activeInstantiations.delete(e);
      }
    }
    _createAndCacheServiceInstance(e, t, i) {
      const n = new yde((a) => a.id.toString());
      let o = 0;
      const r = [{ id: e, desc: t, _trace: i }];
      for (; r.length; ) {
        const a = r.pop();
        if (n.lookupOrInsertNode(a), o++ > 1e3)
          throw new lO(n);
        for (let l of dr.getServiceDependencies(a.desc.ctor)) {
          let c = this._getServiceInstanceOrDescriptor(l.id);
          if (c || this._throwIfStrict(`[createInstance] ${e} depends on ${l.id} which is NOT registered.`, !0), c instanceof Vr) {
            const d = { id: l.id, desc: c, _trace: a._trace.branch(l.id, !0) };
            n.insertEdge(a, d), r.push(d);
          }
        }
      }
      for (; ; ) {
        const a = n.roots();
        if (a.length === 0) {
          if (!n.isEmpty())
            throw new lO(n);
          break;
        }
        for (const { data: l } of a) {
          if (this._getServiceInstanceOrDescriptor(l.id) instanceof Vr) {
            const d = this._createServiceInstanceWithOwner(l.id, l.desc.ctor, l.desc.staticArguments, l.desc.supportsDelayedInstantiation, l._trace);
            this._setServiceInstance(l.id, d);
          }
          n.removeNode(l);
        }
      }
      return this._getServiceInstanceOrDescriptor(e);
    }
    _createServiceInstanceWithOwner(e, t, i = [], n, o) {
      if (this._services.get(e) instanceof Vr)
        return this._createServiceInstance(t, i, n, o);
      if (this._parent)
        return this._parent._createServiceInstanceWithOwner(e, t, i, n, o);
      throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
    }
    _createServiceInstance(e, t = [], i, n) {
      if (i) {
        const o = new Jl(() => this._createInstance(e, t, n));
        return new Proxy(/* @__PURE__ */ Object.create(null), {
          get(r, a) {
            if (a in r)
              return r[a];
            let l = o.value, c = l[a];
            return typeof c != "function" || (c = c.bind(l), r[a] = c), c;
          },
          set(r, a, l) {
            return o.value[a] = l, !0;
          }
        });
      } else
        return this._createInstance(e, t, n);
    }
    _throwIfStrict(e, t) {
      if (t && console.warn(t), this._strict)
        throw new Error(e);
    }
  }
  class Uo {
    constructor(e, t) {
      this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
    }
    static traceInvocation(e) {
      return Uo._None;
    }
    static traceCreation(e) {
      return Uo._None;
    }
    branch(e, t) {
      let i = new Uo(2, e.toString());
      return this._dep.push([e, t, i]), i;
    }
    stop() {
      let e = Date.now() - this._start;
      Uo._totals += e;
      let t = !1;
      function i(o, r) {
        let a = [], l = new Array(o + 1).join("	");
        for (const [c, d, h] of r._dep)
          if (d && h) {
            t = !0, a.push(`${l}CREATES -> ${c}`);
            let u = i(o + 1, h);
            u && a.push(u);
          } else
            a.push(`${l}uses -> ${c}`);
        return a.join(`
`);
      }
      let n = [
        `${this.type === 0 ? "CREATE" : "CALL"} ${this.name}`,
        `${i(1, this)}`,
        `DONE, took ${e.toFixed(2)}ms (grand total ${Uo._totals.toFixed(2)}ms)`
      ];
      (e > 2 || t) && console.log(n.join(`
`));
    }
  }
  Uo._None = new class extends Uo {
    constructor() {
      super(-1, null);
    }
    stop() {
    }
    branch() {
      return this;
    }
  }();
  Uo._totals = 0;
  class Lde {
    constructor() {
      this._byResource = new $n(), this._byOwner = /* @__PURE__ */ new Map();
    }
    set(e, t, i) {
      let n = this._byResource.get(e);
      n || (n = /* @__PURE__ */ new Map(), this._byResource.set(e, n)), n.set(t, i);
      let o = this._byOwner.get(t);
      o || (o = new $n(), this._byOwner.set(t, o)), o.set(e, i);
    }
    get(e, t) {
      let i = this._byResource.get(e);
      return i?.get(t);
    }
    delete(e, t) {
      let i = !1, n = !1, o = this._byResource.get(e);
      o && (i = o.delete(t));
      let r = this._byOwner.get(t);
      if (r && (n = r.delete(e)), i !== n)
        throw new Error("illegal state");
      return i && n;
    }
    values(e) {
      var t, i, n, o;
      return typeof e == "string" ? (i = (t = this._byOwner.get(e)) === null || t === void 0 ? void 0 : t.values()) !== null && i !== void 0 ? i : rt.empty() : Ee.isUri(e) ? (o = (n = this._byResource.get(e)) === null || n === void 0 ? void 0 : n.values()) !== null && o !== void 0 ? o : rt.empty() : rt.map(rt.concat(...this._byOwner.values()), (r) => r[1]);
    }
  }
  class kde {
    constructor(e) {
      this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new $n(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
    }
    dispose() {
      this._subscription.dispose();
    }
    _update(e) {
      for (const t of e) {
        const i = this._data.get(t);
        i && this._substract(i);
        const n = this._resourceStats(t);
        this._add(n), this._data.set(t, n);
      }
    }
    _resourceStats(e) {
      const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
      if (e.scheme === ze.inMemory || e.scheme === ze.walkThrough || e.scheme === ze.walkThroughSnippet)
        return t;
      for (const { severity: i } of this._service.read({ resource: e }))
        i === Xt.Error ? t.errors += 1 : i === Xt.Warning ? t.warnings += 1 : i === Xt.Info ? t.infos += 1 : t.unknowns += 1;
      return t;
    }
    _substract(e) {
      this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
    }
    _add(e) {
      this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
    }
  }
  class _d {
    constructor() {
      this._onMarkerChanged = new NB({
        delay: 0,
        merge: _d._merge
      }), this.onMarkerChanged = this._onMarkerChanged.event, this._data = new Lde(), this._stats = new kde(this);
    }
    dispose() {
      this._stats.dispose(), this._onMarkerChanged.dispose();
    }
    remove(e, t) {
      for (const i of t || [])
        this.changeOne(e, i, []);
    }
    changeOne(e, t, i) {
      if (KP(i))
        this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
      else {
        const n = [];
        for (const o of i) {
          const r = _d._toMarker(e, t, o);
          r && n.push(r);
        }
        this._data.set(t, e, n), this._onMarkerChanged.fire([t]);
      }
    }
    static _toMarker(e, t, i) {
      let { code: n, severity: o, message: r, source: a, startLineNumber: l, startColumn: c, endLineNumber: d, endColumn: h, relatedInformation: u, tags: f } = i;
      if (!!r)
        return l = l > 0 ? l : 1, c = c > 0 ? c : 1, d = d >= l ? d : l, h = h > 0 ? h : c, {
          resource: t,
          owner: e,
          code: n,
          severity: o,
          message: r,
          source: a,
          startLineNumber: l,
          startColumn: c,
          endLineNumber: d,
          endColumn: h,
          relatedInformation: u,
          tags: f
        };
    }
    read(e = /* @__PURE__ */ Object.create(null)) {
      let { owner: t, resource: i, severities: n, take: o } = e;
      if ((!o || o < 0) && (o = -1), t && i) {
        const r = this._data.get(i, t);
        if (r) {
          const a = [];
          for (const l of r)
            if (_d._accept(l, n)) {
              const c = a.push(l);
              if (o > 0 && c === o)
                break;
            }
          return a;
        } else
          return [];
      } else if (!t && !i) {
        const r = [];
        for (let a of this._data.values())
          for (let l of a)
            if (_d._accept(l, n)) {
              const c = r.push(l);
              if (o > 0 && c === o)
                return r;
            }
        return r;
      } else {
        const r = this._data.values(i ?? t), a = [];
        for (const l of r)
          for (const c of l)
            if (_d._accept(c, n)) {
              const d = a.push(c);
              if (o > 0 && d === o)
                return a;
            }
        return a;
      }
    }
    static _accept(e, t) {
      return t === void 0 || (t & e.severity) === e.severity;
    }
    static _merge(e) {
      const t = new $n();
      for (let i of e)
        for (let n of i)
          t.set(n, !0);
      return Array.from(t.keys());
    }
  }
  function G8(s, e, t, i, n) {
    if (Array.isArray(s)) {
      let o = 0;
      for (const r of s) {
        const a = G8(r, e, t, i, n);
        if (a === 10)
          return a;
        a > o && (o = a);
      }
      return o;
    } else {
      if (typeof s == "string")
        return i ? s === "*" ? 5 : s === t ? 10 : 0 : 0;
      if (s) {
        const { language: o, pattern: r, scheme: a, hasAccessToAllModels: l, notebookType: c } = s;
        if (!i && !l)
          return 0;
        let d = 0;
        if (a)
          if (a === e.scheme)
            d = 10;
          else if (a === "*")
            d = 5;
          else
            return 0;
        if (o)
          if (o === t)
            d = 10;
          else if (o === "*")
            d = Math.max(d, 5);
          else
            return 0;
        if (c)
          if (c === n)
            d = 10;
          else if (c === "*")
            d = Math.max(d, 5);
          else
            return 0;
        if (r) {
          let h;
          if (typeof r == "string" ? h = r : h = Object.assign(Object.assign({}, r), { base: SI(r.base) }), h === e.fsPath || Sce(h, e.fsPath))
            d = 10;
          else
            return 0;
        }
        return d;
      } else
        return 0;
    }
  }
  function Z8(s) {
    return typeof s == "string" ? !1 : Array.isArray(s) ? s.every(Z8) : !!s.exclusive;
  }
  class ui {
    constructor(e) {
      this._notebookTypeResolver = e, this._clock = 0, this._entries = [], this._onDidChange = new B(), this.onDidChange = this._onDidChange.event;
    }
    register(e, t) {
      let i = {
        selector: e,
        provider: t,
        _score: -1,
        _time: this._clock++
      };
      return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), qe(() => {
        if (i) {
          const n = this._entries.indexOf(i);
          n >= 0 && (this._entries.splice(n, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
        }
      });
    }
    has(e) {
      return this.all(e).length > 0;
    }
    all(e) {
      if (!e)
        return [];
      this._updateScores(e);
      const t = [];
      for (let i of this._entries)
        i._score > 0 && t.push(i.provider);
      return t;
    }
    ordered(e) {
      const t = [];
      return this._orderedForEach(e, (i) => t.push(i.provider)), t;
    }
    orderedGroups(e) {
      const t = [];
      let i, n;
      return this._orderedForEach(e, (o) => {
        i && n === o._score ? i.push(o.provider) : (n = o._score, i = [o.provider], t.push(i));
      }), t;
    }
    _orderedForEach(e, t) {
      if (!!e) {
        this._updateScores(e);
        for (const i of this._entries)
          i._score > 0 && t(i);
      }
    }
    _updateScores(e) {
      var t;
      const i = (t = this._notebookTypeResolver) === null || t === void 0 ? void 0 : t.call(this, e.uri), n = {
        uri: e.uri.toString(),
        language: e.getLanguageId(),
        notebookType: i
      };
      if (!(this._lastCandidate && this._lastCandidate.language === n.language && this._lastCandidate.uri === n.uri && this._lastCandidate.notebookType === n.notebookType)) {
        this._lastCandidate = n;
        for (let o of this._entries)
          if (o._score = G8(o.selector, e.uri, e.getLanguageId(), qj(e), i), Z8(o.selector) && o._score > 0) {
            for (let r of this._entries)
              r._score = 0;
            o._score = 1e3;
            break;
          }
        this._entries.sort(ui._compareByScoreAndTime);
      }
    }
    static _compareByScoreAndTime(e, t) {
      return e._score < t._score ? 1 : e._score > t._score ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
    }
  }
  class Dde {
    constructor() {
      this.referenceProvider = new ui(this._score.bind(this)), this.renameProvider = new ui(this._score.bind(this)), this.codeActionProvider = new ui(this._score.bind(this)), this.definitionProvider = new ui(this._score.bind(this)), this.typeDefinitionProvider = new ui(this._score.bind(this)), this.declarationProvider = new ui(this._score.bind(this)), this.implementationProvider = new ui(this._score.bind(this)), this.documentSymbolProvider = new ui(this._score.bind(this)), this.inlayHintsProvider = new ui(this._score.bind(this)), this.colorProvider = new ui(this._score.bind(this)), this.codeLensProvider = new ui(this._score.bind(this)), this.documentFormattingEditProvider = new ui(this._score.bind(this)), this.documentRangeFormattingEditProvider = new ui(this._score.bind(this)), this.onTypeFormattingEditProvider = new ui(this._score.bind(this)), this.signatureHelpProvider = new ui(this._score.bind(this)), this.hoverProvider = new ui(this._score.bind(this)), this.documentHighlightProvider = new ui(this._score.bind(this)), this.selectionRangeProvider = new ui(this._score.bind(this)), this.foldingRangeProvider = new ui(this._score.bind(this)), this.linkProvider = new ui(this._score.bind(this)), this.inlineCompletionsProvider = new ui(this._score.bind(this)), this.completionProvider = new ui(this._score.bind(this)), this.linkedEditingRangeProvider = new ui(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new ui(this._score.bind(this)), this.documentSemanticTokensProvider = new ui(this._score.bind(this));
    }
    _score(e) {
      var t;
      return (t = this._notebookTypeResolver) === null || t === void 0 ? void 0 : t.call(this, e);
    }
  }
  ht(me, Dde, !0);
  var $c = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Pn = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  }, Y8 = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  class xde {
    constructor(e) {
      this.disposed = !1, this.model = e, this._onWillDispose = new B();
    }
    get textEditorModel() {
      return this.model;
    }
    dispose() {
      this.disposed = !0, this._onWillDispose.fire();
    }
  }
  let Bx = class {
    constructor(e) {
      this.modelService = e;
    }
    createModelReference(e) {
      const t = this.modelService.getModel(e);
      return t ? Promise.resolve(new vB(new xde(t))) : Promise.reject(new Error("Model not found"));
    }
  };
  Bx = $c([
    Pn(0, Qt)
  ], Bx);
  class bw {
    show() {
      return bw.NULL_PROGRESS_RUNNER;
    }
    showWhile(e, t) {
      return Y8(this, void 0, void 0, function* () {
        yield e;
      });
    }
  }
  bw.NULL_PROGRESS_RUNNER = {
    done: () => {
    },
    total: () => {
    },
    worked: () => {
    }
  };
  class Ide {
    confirm(e) {
      return this.doConfirm(e).then((t) => ({
        confirmed: t,
        checkboxChecked: !1
      }));
    }
    doConfirm(e) {
      let t = e.message;
      return e.detail && (t = t + `

` + e.detail), Promise.resolve(window.confirm(t));
    }
    show(e, t, i, n) {
      return Promise.resolve({ choice: 0 });
    }
  }
  class vw {
    info(e) {
      return this.notify({ severity: Zt.Info, message: e });
    }
    warn(e) {
      return this.notify({ severity: Zt.Warning, message: e });
    }
    error(e) {
      return this.notify({ severity: Zt.Error, message: e });
    }
    notify(e) {
      switch (e.severity) {
        case Zt.Error:
          console.error(e.message);
          break;
        case Zt.Warning:
          console.warn(e.message);
          break;
        default:
          console.log(e.message);
          break;
      }
      return vw.NO_OP;
    }
    status(e, t) {
      return z.None;
    }
  }
  vw.NO_OP = new xG();
  let Wx = class {
    constructor(e) {
      this._onWillExecuteCommand = new B(), this._onDidExecuteCommand = new B(), this.onWillExecuteCommand = this._onWillExecuteCommand.event, this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
    }
    executeCommand(e, ...t) {
      const i = lt.getCommand(e);
      if (!i)
        return Promise.reject(new Error(`command '${e}' not found`));
      try {
        this._onWillExecuteCommand.fire({ commandId: e, args: t });
        const n = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
        return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(n);
      } catch (n) {
        return Promise.reject(n);
      }
    }
  };
  Wx = $c([
    Pn(0, et)
  ], Wx);
  let fv = class extends ace {
    constructor(e, t, i, n, o, r) {
      super(e, t, i, n, o), this._cachedResolver = null, this._dynamicKeybindings = [], this._domNodeListeners = [];
      const a = (f) => {
        const g = new te();
        g.add(ee(f, ye.KEY_DOWN, (_) => {
          const b = new $t(_);
          this._dispatch(b, b.target) && (b.preventDefault(), b.stopPropagation());
        })), g.add(ee(f, ye.KEY_UP, (_) => {
          const b = new $t(_);
          this._singleModifierDispatch(b, b.target) && b.preventDefault();
        })), this._domNodeListeners.push(new Ede(f, g));
      }, l = (f) => {
        for (let g = 0; g < this._domNodeListeners.length; g++) {
          const _ = this._domNodeListeners[g];
          _.domNode === f && (this._domNodeListeners.splice(g, 1), _.dispose());
        }
      }, c = (f) => {
        f.getOption(54) || a(f.getContainerDomNode());
      }, d = (f) => {
        f.getOption(54) || l(f.getContainerDomNode());
      };
      this._register(r.onCodeEditorAdd(c)), this._register(r.onCodeEditorRemove(d)), r.listCodeEditors().forEach(c);
      const h = (f) => {
        a(f.getContainerDomNode());
      }, u = (f) => {
        l(f.getContainerDomNode());
      };
      this._register(r.onDiffEditorAdd(h)), this._register(r.onDiffEditorRemove(u)), r.listDiffEditors().forEach(h);
    }
    addDynamicKeybinding(e, t, i, n) {
      const o = Uy(t, oo), r = new te();
      return o && (this._dynamicKeybindings.push({
        keybinding: o.parts,
        command: e,
        when: n,
        weight1: 1e3,
        weight2: 0,
        extensionId: null,
        isBuiltinExtension: !1
      }), r.add(qe(() => {
        for (let a = 0; a < this._dynamicKeybindings.length; a++)
          if (this._dynamicKeybindings[a].command === e) {
            this._dynamicKeybindings.splice(a, 1), this.updateResolver({ source: 1 });
            return;
          }
      }))), r.add(lt.registerCommand(e, i)), this.updateResolver({ source: 1 }), r;
    }
    updateResolver(e) {
      this._cachedResolver = null, this._onDidUpdateKeybindings.fire(e);
    }
    _getResolver() {
      if (!this._cachedResolver) {
        const e = this._toNormalizedKeybindingItems(Zn.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
        this._cachedResolver = new Mm(e, t, (i) => this._log(i));
      }
      return this._cachedResolver;
    }
    _documentHasFocus() {
      return document.hasFocus();
    }
    _toNormalizedKeybindingItems(e, t) {
      const i = [];
      let n = 0;
      for (const o of e) {
        const r = o.when || void 0, a = o.keybinding;
        if (!a)
          i[n++] = new WR(void 0, o.command, o.commandArgs, r, t, null, !1);
        else {
          const l = Gp.resolveUserBinding(a, oo);
          for (const c of l)
            i[n++] = new WR(c, o.command, o.commandArgs, r, t, null, !1);
        }
      }
      return i;
    }
    resolveKeyboardEvent(e) {
      const t = new Ud(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode).toChord();
      return new Gp(t, oo);
    }
  };
  fv = $c([
    Pn(0, Fe),
    Pn(1, wi),
    Pn(2, Ca),
    Pn(3, yi),
    Pn(4, Xo),
    Pn(5, St)
  ], fv);
  class Ede extends z {
    constructor(e, t) {
      super(), this.domNode = e, this._register(t);
    }
  }
  function cO(s) {
    return s && typeof s == "object" && (!s.overrideIdentifier || typeof s.overrideIdentifier == "string") && (!s.resource || s.resource instanceof Ee);
  }
  class X8 {
    constructor() {
      this._onDidChangeConfiguration = new B(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._configuration = new fw(new sce(), new so());
    }
    getValue(e, t) {
      const i = typeof e == "string" ? e : void 0, n = cO(e) ? e : cO(t) ? t : {};
      return this._configuration.getValue(i, n, void 0);
    }
    updateValues(e) {
      const t = { data: this._configuration.toData() }, i = [];
      for (const n of e) {
        const [o, r] = n;
        this.getValue(o) !== r && (this._configuration.updateValue(o, r), i.push(o));
      }
      if (i.length > 0) {
        const n = new oce({ keys: i, overrides: [] }, t, this._configuration);
        n.source = 7, n.sourceConfig = null, this._onDidChangeConfiguration.fire(n);
      }
      return Promise.resolve();
    }
    updateValue(e, t, i, n) {
      return this.updateValues([[e, t]]);
    }
    inspect(e, t = {}) {
      return this._configuration.inspect(e, t, void 0);
    }
  }
  let Vx = class {
    constructor(e) {
      this.configurationService = e, this._onDidChangeConfiguration = new B(), this.configurationService.onDidChangeConfiguration((t) => {
        this._onDidChangeConfiguration.fire({ affectedKeys: t.affectedKeys, affectsConfiguration: (i, n) => t.affectsConfiguration(n) });
      });
    }
    getValue(e, t, i) {
      const o = (V.isIPosition(t) ? t : null) ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0;
      return typeof o > "u" ? this.configurationService.getValue() : this.configurationService.getValue(o);
    }
  };
  Vx = $c([
    Pn(0, At)
  ], Vx);
  let Hx = class {
    constructor(e) {
      this.configurationService = e;
    }
    getEOL(e, t) {
      const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
      return i && typeof i == "string" && i !== "auto" ? i : Nn || Ye ? `
` : `\r
`;
    }
  };
  Hx = $c([
    Pn(0, At)
  ], Hx);
  class Nde {
    publicLog(e, t) {
      return Promise.resolve(void 0);
    }
    publicLog2(e, t) {
      return this.publicLog(e, t);
    }
  }
  class Cw {
    constructor() {
      const e = Ee.from({ scheme: Cw.SCHEME, authority: "model", path: "/" });
      this.workspace = { id: "4064f6ec-cb38-4ad0-af64-ee6467e63c82", folders: [new ine({ uri: e, name: "", index: 0 })] };
    }
    getWorkspace() {
      return this.workspace;
    }
  }
  Cw.SCHEME = "inmemory";
  function gv(s, e, t) {
    if (!e || !(s instanceof X8))
      return;
    const i = [];
    Object.keys(e).forEach((n) => {
      tce(n) && i.push([`editor.${n}`, e[n]]), t && ice(n) && i.push([`diffEditor.${n}`, e[n]]);
    }), i.length > 0 && s.updateValues(i);
  }
  let zx = class {
    constructor(e) {
      this._modelService = e;
    }
    hasPreviewHandler() {
      return !1;
    }
    apply(e, t) {
      return Y8(this, void 0, void 0, function* () {
        const i = /* @__PURE__ */ new Map();
        for (let r of e) {
          if (!(r instanceof e3))
            throw new Error("bad edit - only text edits are supported");
          const a = this._modelService.getModel(r.resource);
          if (!a)
            throw new Error("bad edit - model not found");
          if (typeof r.versionId == "number" && a.getVersionId() !== r.versionId)
            throw new Error("bad state - model changed in the meantime");
          let l = i.get(a);
          l || (l = [], i.set(a, l)), l.push(li.replaceMove(D.lift(r.textEdit.range), r.textEdit.text));
        }
        let n = 0, o = 0;
        for (const [r, a] of i)
          r.pushStackElement(), r.pushEditOperations([], a, () => []), r.pushStackElement(), o += 1, n += a.length;
        return {
          ariaSummary: uo(bD.bulkEditServiceSummary, n, o)
        };
      });
    }
  };
  zx = $c([
    Pn(0, Qt)
  ], zx);
  class Tde {
    getUriLabel(e, t) {
      return e.scheme === "file" ? e.fsPath : e.path;
    }
  }
  let Ux = class extends _x {
    constructor(e, t) {
      super(e), this._codeEditorService = t;
    }
    showContextView(e, t, i) {
      if (!t) {
        const n = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
        n && (t = n.getContainerDomNode());
      }
      return super.showContextView(e, t, i);
    }
  };
  Ux = $c([
    Pn(0, A_),
    Pn(1, St)
  ], Ux);
  class Mde {
    constructor() {
      this._neverEmitter = new B(), this.onDidChangeTrust = this._neverEmitter.event;
    }
    isWorkspaceTrusted() {
      return !0;
    }
  }
  class Ade extends Yp {
    constructor() {
      super();
    }
  }
  class Rde extends pV {
    constructor() {
      super(new mV());
    }
  }
  let $x = class extends wx {
    constructor(e, t, i, n, o) {
      super(e, t, i, n, o), this.configure({ blockMouse: !1 });
    }
  };
  $x = $c([
    Pn(0, Ca),
    Pn(1, yi),
    Pn(2, m_),
    Pn(3, ci),
    Pn(4, jt)
  ], $x);
  ht(At, X8);
  ht(KN, Vx);
  ht(j9, Hx);
  ht(u9, Cw);
  ht(w_, Tde);
  ht(Ca, Nde);
  ht(N_, Ide);
  ht(yi, vw);
  ht(wl, _d);
  ht(Jt, Ade);
  ht(Mo, fde);
  ht(Xo, Rde);
  ht(Qt, J1);
  ht(GI, kx);
  ht(Fe, Fx);
  ht(Bc, bw);
  ht(La, JY);
  ht(xo, ux);
  ht(KE, zx);
  ht(Q9, Mde);
  ht(fs, Bx);
  ht(Ts, Ax);
  ht(Eo, sk);
  ht(wi, Wx);
  ht(ci, fv);
  ht(Sl, Tx);
  ht(m_, Ux);
  ht(No, Lx);
  ht(Fh, Px);
  ht(Fc, $x);
  ht(Eh, Rx);
  var Be;
  (function(s) {
    const e = new fC();
    for (const [r, a] of G2())
      e.set(r, a);
    const t = new u2(e, !0);
    e.set(et, t);
    function i(r) {
      const a = e.get(r);
      if (!a)
        throw new Error("Missing service " + r);
      return a instanceof Vr ? t.invokeFunction((l) => l.get(r)) : a;
    }
    s.get = i;
    let n = !1;
    function o(r) {
      if (n)
        return t;
      n = !0;
      for (const [a, l] of G2())
        e.get(a) || e.set(a, l);
      for (const a in r)
        if (r.hasOwnProperty(a)) {
          const l = st(a);
          e.get(l) instanceof Vr && e.set(l, r[a]);
        }
      return t;
    }
    s.initialize = o;
  })(Be || (Be = {}));
  var f2 = globalThis && globalThis.__decorate || function(s, e, t, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      o = Reflect.decorate(s, e, t, i);
    else
      for (var a = s.length - 1; a >= 0; a--)
        (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
    return n > 3 && o && Object.defineProperty(e, t, o), o;
  }, Ut = globalThis && globalThis.__param || function(s, e) {
    return function(t, i) {
      e(t, i, s);
    };
  };
  let Ode = 0, dO = !1;
  function Pde(s) {
    if (!s) {
      if (dO)
        return;
      dO = !0;
    }
    WW(s || document.body);
  }
  let mv = class extends hp {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      const f = Object.assign({}, t);
      f.ariaLabel = f.ariaLabel || iv.editorViewAccessibleLabel, f.ariaLabel = f.ariaLabel + ";" + iv.accessibilityHelpMessage, super(e, f, {}, i, n, o, r, l, c, d, h, u), a instanceof fv ? this._standaloneKeybindingService = a : this._standaloneKeybindingService = null, Pde(f.ariaContainerElement);
    }
    addCommand(e, t, i) {
      if (!this._standaloneKeybindingService)
        return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
      const n = "DYNAMIC_" + ++Ode, o = ce.deserialize(i);
      return this._standaloneKeybindingService.addDynamicKeybinding(n, e, t, o), n;
    }
    createContextKey(e, t) {
      return this._contextKeyService.createKey(e, t);
    }
    addAction(e) {
      if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
        throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
      if (!this._standaloneKeybindingService)
        return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), z.None;
      const t = e.id, i = e.label, n = ce.and(ce.equals("editorId", this.getId()), ce.deserialize(e.precondition)), o = e.keybindings, r = ce.and(n, ce.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, c = (f, ...g) => Promise.resolve(e.run(this, ...g)), d = new te(), h = this.getId() + ":" + t;
      if (d.add(lt.registerCommand(h, c)), a) {
        const f = {
          command: {
            id: h,
            title: i
          },
          when: n,
          group: a,
          order: l
        };
        d.add(qs.appendMenuItem(A.EditorContext, f));
      }
      if (Array.isArray(o))
        for (const f of o)
          d.add(this._standaloneKeybindingService.addDynamicKeybinding(h, f, c, r));
      const u = new nF(h, i, i, n, c, this._contextKeyService);
      return this._actions[t] = u, d.add(qe(() => {
        delete this._actions[t];
      })), d;
    }
    _triggerCommand(e, t) {
      if (this._codeEditorService instanceof rv)
        try {
          this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
        } finally {
          this._codeEditorService.setActiveCodeEditor(null);
        }
      else
        super._triggerCommand(e, t);
    }
  };
  mv = f2([
    Ut(2, et),
    Ut(3, St),
    Ut(4, wi),
    Ut(5, Fe),
    Ut(6, ci),
    Ut(7, jt),
    Ut(8, yi),
    Ut(9, Ts),
    Ut(10, Mn),
    Ut(11, me)
  ], mv);
  let jx = class extends mv {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u, f, g, _) {
      const b = Object.assign({}, t);
      gv(d, b, !1);
      const C = l.registerEditorContainer(e);
      typeof b.theme == "string" && l.setTheme(b.theme), typeof b.autoDetectHighContrast < "u" && l.setAutoDetectHighContrast(Boolean(b.autoDetectHighContrast));
      const v = b.model;
      delete b.model, super(e, b, i, n, o, r, a, l, c, h, g, _), this._configurationService = d, this._standaloneThemeService = l, this._register(C);
      let w;
      if (typeof v > "u") {
        const S = f.getLanguageIdByMimeType(b.language) || b.language || ya;
        w = Q8(u, f, b.value || "", S, void 0), this._ownsModel = !0;
      } else
        w = v, this._ownsModel = !1;
      if (this._attachModel(w), w) {
        const S = {
          oldModelUrl: null,
          newModelUrl: w.uri
        };
        this._onDidChangeModel.fire(S);
      }
    }
    dispose() {
      super.dispose();
    }
    updateOptions(e) {
      gv(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(Boolean(e.autoDetectHighContrast)), super.updateOptions(e);
    }
    _postDetachModelCleanup(e) {
      super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
    }
  };
  jx = f2([
    Ut(2, et),
    Ut(3, St),
    Ut(4, wi),
    Ut(5, Fe),
    Ut(6, ci),
    Ut(7, Mo),
    Ut(8, yi),
    Ut(9, At),
    Ut(10, Ts),
    Ut(11, Qt),
    Ut(12, Jt),
    Ut(13, Mn),
    Ut(14, me)
  ], jx);
  let Kx = class extends Dc {
    constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
      const f = Object.assign({}, t);
      gv(c, f, !0);
      const g = a.registerEditorContainer(e);
      typeof f.theme == "string" && a.setTheme(f.theme), typeof f.autoDetectHighContrast < "u" && a.setAutoDetectHighContrast(Boolean(f.autoDetectHighContrast)), super(e, f, {}, u, o, n, i, r, a, l, d, h), this._configurationService = c, this._standaloneThemeService = a, this._register(g);
    }
    dispose() {
      super.dispose();
    }
    updateOptions(e) {
      gv(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(Boolean(e.autoDetectHighContrast)), super.updateOptions(e);
    }
    _createInnerEditor(e, t, i) {
      return e.createInstance(mv, t, i);
    }
    getOriginalEditor() {
      return super.getOriginalEditor();
    }
    getModifiedEditor() {
      return super.getModifiedEditor();
    }
    addCommand(e, t, i) {
      return this.getModifiedEditor().addCommand(e, t, i);
    }
    createContextKey(e, t) {
      return this.getModifiedEditor().createContextKey(e, t);
    }
    addAction(e) {
      return this.getModifiedEditor().addAction(e);
    }
  };
  Kx = f2([
    Ut(2, et),
    Ut(3, Fe),
    Ut(4, xo),
    Ut(5, St),
    Ut(6, Mo),
    Ut(7, yi),
    Ut(8, At),
    Ut(9, Fc),
    Ut(10, Bc),
    Ut(11, Fh)
  ], Kx);
  function Q8(s, e, t, i, n) {
    if (t = t || "", !i) {
      const o = t.indexOf(`
`);
      let r = t;
      return o !== -1 && (r = t.substring(0, o)), hO(s, t, e.createByFilepathOrFirstLine(n || null, r), n);
    }
    return hO(s, t, e.createById(i), n);
  }
  function hO(s, e, t, i) {
    return s.createModel(e, t, i);
  }
  function Fde(s, e, t) {
    return Be.initialize(t || {}).createInstance(jx, s, e);
  }
  function Bde(s) {
    return Be.get(St).onCodeEditorAdd((t) => {
      s(t);
    });
  }
  function Wde(s, e, t) {
    return Be.initialize(t || {}).createInstance(Kx, s, e);
  }
  function Vde(s, e) {
    return new vZ(s, e);
  }
  function Hde(s, e, t) {
    const i = Be.get(Jt), n = i.getLanguageIdByMimeType(e) || e;
    return Q8(Be.get(Qt), i, s, n, t);
  }
  function zde(s, e) {
    const t = Be.get(Jt);
    Be.get(Qt).setMode(s, t.createById(e));
  }
  function Ude(s, e, t) {
    s && Be.get(wl).changeOne(e, s.uri, t);
  }
  function $de(s) {
    return Be.get(wl).read(s);
  }
  function jde(s) {
    return Be.get(wl).onMarkerChanged(s);
  }
  function Kde(s) {
    return Be.get(Qt).getModel(s);
  }
  function qde() {
    return Be.get(Qt).getModels();
  }
  function Gde(s) {
    return Be.get(Qt).onModelAdded(s);
  }
  function Zde(s) {
    return Be.get(Qt).onModelRemoved(s);
  }
  function Yde(s) {
    return Be.get(Qt).onModelLanguageChanged((t) => {
      s({
        model: t.model,
        oldLanguage: t.oldLanguageId
      });
    });
  }
  function Xde(s) {
    return Fle(Be.get(Qt), Be.get(Mn), s);
  }
  function Qde(s, e) {
    const t = Be.get(Jt), i = Be.get(Mo);
    return i.registerEditorContainer(s), n2.colorizeElement(i, t, s, e);
  }
  function Jde(s, e, t) {
    const i = Be.get(Jt);
    return Be.get(Mo).registerEditorContainer(document.body), n2.colorize(i, s, e, t);
  }
  function ehe(s, e, t = 4) {
    return Be.get(Mo).registerEditorContainer(document.body), n2.colorizeModelLine(s, e, t);
  }
  function the(s) {
    const e = Yt.get(s);
    return e || {
      getInitialState: () => kf,
      tokenize: (t, i, n) => aF(s, n)
    };
  }
  function ihe(s, e) {
    Yt.getOrCreate(e);
    const t = the(e), i = da(s), n = [];
    let o = t.getInitialState();
    for (let r = 0, a = i.length; r < a; r++) {
      const l = i[r], c = t.tokenize(l, !0, o);
      n[r] = c.tokens, o = c.endState;
    }
    return n;
  }
  function nhe(s, e) {
    Be.get(Mo).defineTheme(s, e);
  }
  function she(s) {
    Be.get(Mo).setTheme(s);
  }
  function ohe() {
    dL.clearAllFontInfos();
  }
  function rhe(s, e) {
    return lt.registerCommand({ id: s, handler: e });
  }
  function ahe() {
    return {
      create: Fde,
      onDidCreateEditor: Bde,
      createDiffEditor: Wde,
      createDiffNavigator: Vde,
      createModel: Hde,
      setModelLanguage: zde,
      setModelMarkers: Ude,
      getModelMarkers: $de,
      onDidChangeMarkers: jde,
      getModels: qde,
      getModel: Kde,
      onDidCreateModel: Gde,
      onWillDisposeModel: Zde,
      onDidChangeModelLanguage: Yde,
      createWebWorker: Xde,
      colorizeElement: Qde,
      colorize: Jde,
      colorizeModelLine: ehe,
      tokenize: ihe,
      defineTheme: nhe,
      setTheme: she,
      remeasureFonts: ohe,
      registerCommand: rhe,
      AccessibilitySupport: LD,
      ContentWidgetPositionPreference: ED,
      CursorChangeReason: ND,
      DefaultEndOfLine: TD,
      EditorAutoIndentStrategy: AD,
      EditorOption: RD,
      EndOfLinePreference: OD,
      EndOfLineSequence: PD,
      MinimapPosition: $D,
      MouseTargetType: jD,
      OverlayWidgetPositionPreference: KD,
      OverviewRulerLane: qD,
      RenderLineNumbersType: ZD,
      RenderMinimap: YD,
      ScrollbarVisibility: QD,
      ScrollType: XD,
      TextEditorCursorBlinkingStyle: nx,
      TextEditorCursorStyle: sx,
      TrackedRangeStickiness: ox,
      WrappingIndent: rx,
      InjectedTextCursorStops: BD,
      PositionAffinity: GD,
      ConfigurationChangedEvent: d5,
      BareFontInfo: xd,
      FontInfo: cL,
      TextModelResolvedOptions: d0,
      FindMatch: tp,
      ApplyUpdateResult: nm,
      EditorType: g_,
      EditorOptions: yr
    };
  }
  function lhe(s, e) {
    if (!e || !Array.isArray(e))
      return !1;
    for (const t of e)
      if (!s(t))
        return !1;
    return !0;
  }
  function qb(s, e) {
    return typeof s == "boolean" ? s : e;
  }
  function uO(s, e) {
    return typeof s == "string" ? s : e;
  }
  function che(s) {
    const e = {};
    for (const t of s)
      e[t] = !0;
    return e;
  }
  function fO(s, e = !1) {
    e && (s = s.map(function(i) {
      return i.toLowerCase();
    }));
    const t = che(s);
    return e ? function(i) {
      return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
    } : function(i) {
      return t[i] !== void 0 && t.hasOwnProperty(i);
    };
  }
  function qx(s, e) {
    e = e.replace(/@@/g, "");
    let t = 0, i;
    do
      i = !1, e = e.replace(/@(\w+)/g, function(o, r) {
        i = !0;
        let a = "";
        if (typeof s[r] == "string")
          a = s[r];
        else if (s[r] && s[r] instanceof RegExp)
          a = s[r].source;
        else
          throw s[r] === void 0 ? Pt(s, "language definition does not contain attribute '" + r + "', used at: " + e) : Pt(s, "attribute reference '" + r + "' must be a string, used at: " + e);
        return Cu(a) ? "" : "(?:" + a + ")";
      }), t++;
    while (i && t < 5);
    e = e.replace(/\x01/g, "@");
    const n = (s.ignoreCase ? "i" : "") + (s.unicode ? "u" : "");
    return new RegExp(e, n);
  }
  function dhe(s, e, t, i) {
    if (i < 0)
      return s;
    if (i < e.length)
      return e[i];
    if (i >= 100) {
      i = i - 100;
      const n = t.split(".");
      if (n.unshift(t), i < n.length)
        return n[i];
    }
    return null;
  }
  function hhe(s, e, t, i) {
    let n = -1, o = t, r = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
    r && (r[3] && (n = parseInt(r[3]), r[2] && (n = n + 100)), o = r[4]);
    let a = "~", l = o;
    !o || o.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (r = o.match(/^(@|!@|~|!~|==|!=)(.*)$/), r && (a = r[1], l = r[2]));
    let c;
    if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
      const d = fO(l.split("|"), s.ignoreCase);
      c = function(h) {
        return a === "~" ? d(h) : !d(h);
      };
    } else if (a === "@" || a === "!@") {
      const d = s[l];
      if (!d)
        throw Pt(s, "the @ match target '" + l + "' is not defined, in rule: " + e);
      if (!lhe(function(u) {
        return typeof u == "string";
      }, d))
        throw Pt(s, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
      const h = fO(d, s.ignoreCase);
      c = function(u) {
        return a === "@" ? h(u) : !h(u);
      };
    } else if (a === "~" || a === "!~")
      if (l.indexOf("$") < 0) {
        const d = qx(s, "^" + l + "$");
        c = function(h) {
          return a === "~" ? d.test(h) : !d.test(h);
        };
      } else
        c = function(d, h, u, f) {
          return qx(s, "^" + Ul(s, l, h, u, f) + "$").test(d);
        };
    else if (l.indexOf("$") < 0) {
      const d = uc(s, l);
      c = function(h) {
        return a === "==" ? h === d : h !== d;
      };
    } else {
      const d = uc(s, l);
      c = function(h, u, f, g, _) {
        const b = Ul(s, d, u, f, g);
        return a === "==" ? h === b : h !== b;
      };
    }
    return n === -1 ? {
      name: t,
      value: i,
      test: function(d, h, u, f) {
        return c(d, d, h, u, f);
      }
    } : {
      name: t,
      value: i,
      test: function(d, h, u, f) {
        const g = dhe(d, h, u, n);
        return c(g || "", d, h, u, f);
      }
    };
  }
  function Gx(s, e, t) {
    if (t) {
      if (typeof t == "string")
        return t;
      if (t.token || t.token === "") {
        if (typeof t.token != "string")
          throw Pt(s, "a 'token' attribute must be of type string, in rule: " + e);
        {
          const i = { token: t.token };
          if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
            if (t.bracket === "@open")
              i.bracket = 1;
            else if (t.bracket === "@close")
              i.bracket = -1;
            else
              throw Pt(s, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
          if (t.next) {
            if (typeof t.next != "string")
              throw Pt(s, "the next state must be a string value in rule: " + e);
            {
              let n = t.next;
              if (!/^(@pop|@push|@popall)$/.test(n) && (n[0] === "@" && (n = n.substr(1)), n.indexOf("$") < 0 && !zle(s, Ul(s, n, "", [], ""))))
                throw Pt(s, "the next state '" + t.next + "' is not defined in rule: " + e);
              i.next = n;
            }
          }
          return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, s.usesEmbedded = !0), i;
        }
      } else if (Array.isArray(t)) {
        const i = [];
        for (let n = 0, o = t.length; n < o; n++)
          i[n] = Gx(s, e, t[n]);
        return { group: i };
      } else if (t.cases) {
        const i = [];
        for (let o in t.cases)
          if (t.cases.hasOwnProperty(o)) {
            const r = Gx(s, e, t.cases[o]);
            o === "@default" || o === "@" || o === "" ? i.push({ test: void 0, value: r, name: o }) : o === "@eos" ? i.push({ test: function(a, l, c, d) {
              return d;
            }, value: r, name: o }) : i.push(hhe(s, e, o, r));
          }
        const n = s.defaultToken;
        return {
          test: function(o, r, a, l) {
            for (const c of i)
              if (!c.test || c.test(o, r, a, l))
                return c.value;
            return n;
          }
        };
      } else
        throw Pt(s, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
    } else
      return { token: "" };
  }
  class uhe {
    constructor(e) {
      this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
    }
    setRegex(e, t) {
      let i;
      if (typeof t == "string")
        i = t;
      else if (t instanceof RegExp)
        i = t.source;
      else
        throw Pt(e, "rules must start with a match string or regular expression: " + this.name);
      this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = qx(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")");
    }
    setAction(e, t) {
      this.action = Gx(e, this.name, t);
    }
  }
  function J8(s, e) {
    if (!e || typeof e != "object")
      throw new Error("Monarch: expecting a language definition object");
    const t = {};
    t.languageId = s, t.includeLF = qb(e.includeLF, !1), t.noThrow = !1, t.maxStack = 100, t.start = typeof e.start == "string" ? e.start : null, t.ignoreCase = qb(e.ignoreCase, !1), t.unicode = qb(e.unicode, !1), t.tokenPostfix = uO(e.tokenPostfix, "." + t.languageId), t.defaultToken = uO(e.defaultToken, "source"), t.usesEmbedded = !1;
    const i = e;
    i.languageId = s, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
    function n(r, a, l) {
      for (const c of l) {
        let d = c.include;
        if (d) {
          if (typeof d != "string")
            throw Pt(t, "an 'include' attribute must be a string at: " + r);
          if (d[0] === "@" && (d = d.substr(1)), !e.tokenizer[d])
            throw Pt(t, "include target '" + d + "' is not defined at: " + r);
          n(r + "." + d, a, e.tokenizer[d]);
        } else {
          const h = new uhe(r);
          if (Array.isArray(c) && c.length >= 1 && c.length <= 3)
            if (h.setRegex(i, c[0]), c.length >= 3)
              if (typeof c[1] == "string")
                h.setAction(i, { token: c[1], next: c[2] });
              else if (typeof c[1] == "object") {
                const u = c[1];
                u.next = c[2], h.setAction(i, u);
              } else
                throw Pt(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + r);
            else
              h.setAction(i, c[1]);
          else {
            if (!c.regex)
              throw Pt(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + r);
            c.name && typeof c.name == "string" && (h.name = c.name), c.matchOnlyAtStart && (h.matchOnlyAtLineStart = qb(c.matchOnlyAtLineStart, !1)), h.setRegex(i, c.regex), h.setAction(i, c.action);
          }
          a.push(h);
        }
      }
    }
    if (!e.tokenizer || typeof e.tokenizer != "object")
      throw Pt(t, "a language definition must define the 'tokenizer' attribute as an object");
    t.tokenizer = [];
    for (let r in e.tokenizer)
      if (e.tokenizer.hasOwnProperty(r)) {
        t.start || (t.start = r);
        const a = e.tokenizer[r];
        t.tokenizer[r] = new Array(), n("tokenizer." + r, t.tokenizer[r], a);
      }
    if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
      if (!Array.isArray(e.brackets))
        throw Pt(t, "the 'brackets' attribute must be defined as an array");
    } else
      e.brackets = [
        { open: "{", close: "}", token: "delimiter.curly" },
        { open: "[", close: "]", token: "delimiter.square" },
        { open: "(", close: ")", token: "delimiter.parenthesis" },
        { open: "<", close: ">", token: "delimiter.angle" }
      ];
    const o = [];
    for (let r of e.brackets) {
      let a = r;
      if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
        throw Pt(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
      if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
        o.push({
          token: a.token + t.tokenPostfix,
          open: uc(t, a.open),
          close: uc(t, a.close)
        });
      else
        throw Pt(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
    }
    return t.brackets = o, t.noThrow = !0, t;
  }
  var fhe = globalThis && globalThis.__awaiter || function(s, e, t, i) {
    function n(o) {
      return o instanceof t ? o : new t(function(r) {
        r(o);
      });
    }
    return new (t || (t = Promise))(function(o, r) {
      function a(d) {
        try {
          c(i.next(d));
        } catch (h) {
          r(h);
        }
      }
      function l(d) {
        try {
          c(i.throw(d));
        } catch (h) {
          r(h);
        }
      }
      function c(d) {
        d.done ? o(d.value) : n(d.value).then(a, l);
      }
      c((i = i.apply(s, e || [])).next());
    });
  };
  function ghe(s) {
    Lf.registerLanguage(s);
  }
  function mhe() {
    let s = [];
    return s = s.concat(Lf.getLanguages()), s;
  }
  function phe(s) {
    return Be.get(Jt).languageIdCodec.encodeLanguageId(s);
  }
  function _he(s, e) {
    const i = Be.get(Jt).onDidEncounterLanguage((n) => {
      n === s && (i.dispose(), e());
    });
    return i;
  }
  function bhe(s, e) {
    if (!Be.get(Jt).isRegisteredLanguageId(s))
      throw new Error(`Cannot set configuration for unknown language ${s}`);
    return Di.register(s, e, 100);
  }
  class vhe {
    constructor(e, t) {
      this._languageId = e, this._actual = t;
    }
    getInitialState() {
      return this._actual.getInitialState();
    }
    tokenize(e, t, i) {
      if (typeof this._actual.tokenize == "function")
        return Jp.adaptTokenize(this._languageId, this._actual, e, i);
      throw new Error("Not supported!");
    }
    tokenizeEncoded(e, t, i) {
      const n = this._actual.tokenizeEncoded(e, i);
      return new aC(n.tokens, n.endState);
    }
  }
  class Jp {
    constructor(e, t, i, n) {
      this._languageId = e, this._actual = t, this._languageService = i, this._standaloneThemeService = n;
    }
    getInitialState() {
      return this._actual.getInitialState();
    }
    static _toClassicTokens(e, t) {
      const i = [];
      let n = 0;
      for (let o = 0, r = e.length; o < r; o++) {
        const a = e[o];
        let l = a.startIndex;
        o === 0 ? l = 0 : l < n && (l = n), i[o] = new Zm(l, a.scopes, t), n = l;
      }
      return i;
    }
    static adaptTokenize(e, t, i, n) {
      const o = t.tokenize(i, n), r = Jp._toClassicTokens(o.tokens, e);
      let a;
      return o.endState.equals(n) ? a = n : a = o.endState, new dE(r, a);
    }
    tokenize(e, t, i) {
      return Jp.adaptTokenize(this._languageId, this._actual, e, i);
    }
    _toBinaryTokens(e, t) {
      const i = e.encodeLanguageId(this._languageId), n = this._standaloneThemeService.getColorTheme().tokenTheme, o = [];
      let r = 0, a = 0;
      for (let c = 0, d = t.length; c < d; c++) {
        const h = t[c], u = n.match(i, h.scopes);
        if (r > 0 && o[r - 1] === u)
          continue;
        let f = h.startIndex;
        c === 0 ? f = 0 : f < a && (f = a), o[r++] = f, o[r++] = u, a = f;
      }
      const l = new Uint32Array(r);
      for (let c = 0; c < r; c++)
        l[c] = o[c];
      return l;
    }
    tokenizeEncoded(e, t, i) {
      const n = this._actual.tokenize(e, i), o = this._toBinaryTokens(this._languageService.languageIdCodec, n.tokens);
      let r;
      return n.endState.equals(i) ? r = i : r = n.endState, new aC(o, r);
    }
  }
  function Che(s) {
    return typeof s.getInitialState == "function";
  }
  function whe(s) {
    return "tokenizeEncoded" in s;
  }
  function e6(s) {
    return s && typeof s.then == "function";
  }
  function She(s) {
    const e = Be.get(Mo);
    if (s) {
      const t = [null];
      for (let i = 1, n = s.length; i < n; i++)
        t[i] = H.fromHex(s[i]);
      e.setColorMapOverride(t);
    } else
      e.setColorMapOverride(null);
  }
  function t6(s, e) {
    return whe(e) ? new vhe(s, e) : new Jp(s, e, Be.get(Jt), Be.get(Mo));
  }
  function g2(s, e) {
    const t = {
      createTokenizationSupport: () => fhe(this, void 0, void 0, function* () {
        const i = yield Promise.resolve(e.create());
        return i ? Che(i) ? t6(s, i) : new M_(Be.get(Jt), Be.get(Mo), s, J8(s, i)) : null;
      })
    };
    return Yt.registerFactory(s, t);
  }
  function yhe(s, e) {
    if (!Be.get(Jt).isRegisteredLanguageId(s))
      throw new Error(`Cannot set tokens provider for unknown language ${s}`);
    return e6(e) ? g2(s, { create: () => e }) : Yt.register(s, t6(s, e));
  }
  function Lhe(s, e) {
    const t = (i) => new M_(Be.get(Jt), Be.get(Mo), s, J8(s, i));
    return e6(e) ? g2(s, { create: () => e }) : Yt.register(s, t(e));
  }
  function khe(s, e) {
    return Be.get(me).referenceProvider.register(s, e);
  }
  function Dhe(s, e) {
    return Be.get(me).renameProvider.register(s, e);
  }
  function xhe(s, e) {
    return Be.get(me).signatureHelpProvider.register(s, e);
  }
  function Ihe(s, e) {
    return Be.get(me).hoverProvider.register(s, {
      provideHover: (i, n, o) => {
        const r = i.getWordAtPosition(n);
        return Promise.resolve(e.provideHover(i, n, o)).then((a) => {
          if (!!a)
            return !a.range && r && (a.range = new D(n.lineNumber, r.startColumn, n.lineNumber, r.endColumn)), a.range || (a.range = new D(n.lineNumber, n.column, n.lineNumber, n.column)), a;
        });
      }
    });
  }
  function Ehe(s, e) {
    return Be.get(me).documentSymbolProvider.register(s, e);
  }
  function Nhe(s, e) {
    return Be.get(me).documentHighlightProvider.register(s, e);
  }
  function The(s, e) {
    return Be.get(me).linkedEditingRangeProvider.register(s, e);
  }
  function Mhe(s, e) {
    return Be.get(me).definitionProvider.register(s, e);
  }
  function Ahe(s, e) {
    return Be.get(me).implementationProvider.register(s, e);
  }
  function Rhe(s, e) {
    return Be.get(me).typeDefinitionProvider.register(s, e);
  }
  function Ohe(s, e) {
    return Be.get(me).codeLensProvider.register(s, e);
  }
  function Phe(s, e, t) {
    return Be.get(me).codeActionProvider.register(s, {
      providedCodeActionKinds: t?.providedCodeActionKinds,
      provideCodeActions: (n, o, r, a) => {
        const c = Be.get(wl).read({ resource: n.uri }).filter((d) => D.areIntersectingOrTouching(d, o));
        return e.provideCodeActions(n, o, { markers: c, only: r.only }, a);
      },
      resolveCodeAction: e.resolveCodeAction
    });
  }
  function Fhe(s, e) {
    return Be.get(me).documentFormattingEditProvider.register(s, e);
  }
  function Bhe(s, e) {
    return Be.get(me).documentRangeFormattingEditProvider.register(s, e);
  }
  function Whe(s, e) {
    return Be.get(me).onTypeFormattingEditProvider.register(s, e);
  }
  function Vhe(s, e) {
    return Be.get(me).linkProvider.register(s, e);
  }
  function Hhe(s, e) {
    return Be.get(me).completionProvider.register(s, e);
  }
  function zhe(s, e) {
    return Be.get(me).colorProvider.register(s, e);
  }
  function Uhe(s, e) {
    return Be.get(me).foldingRangeProvider.register(s, e);
  }
  function $he(s, e) {
    return Be.get(me).declarationProvider.register(s, e);
  }
  function jhe(s, e) {
    return Be.get(me).selectionRangeProvider.register(s, e);
  }
  function Khe(s, e) {
    return Be.get(me).documentSemanticTokensProvider.register(s, e);
  }
  function qhe(s, e) {
    return Be.get(me).documentRangeSemanticTokensProvider.register(s, e);
  }
  function Ghe(s, e) {
    return Be.get(me).inlineCompletionsProvider.register(s, e);
  }
  function Zhe(s, e) {
    return Be.get(me).inlayHintsProvider.register(s, e);
  }
  function Yhe() {
    return {
      register: ghe,
      getLanguages: mhe,
      onLanguage: _he,
      getEncodedLanguageId: phe,
      setLanguageConfiguration: bhe,
      setColorMap: She,
      registerTokensProviderFactory: g2,
      setTokensProvider: yhe,
      setMonarchTokensProvider: Lhe,
      registerReferenceProvider: khe,
      registerRenameProvider: Dhe,
      registerCompletionItemProvider: Hhe,
      registerSignatureHelpProvider: xhe,
      registerHoverProvider: Ihe,
      registerDocumentSymbolProvider: Ehe,
      registerDocumentHighlightProvider: Nhe,
      registerLinkedEditingRangeProvider: The,
      registerDefinitionProvider: Mhe,
      registerImplementationProvider: Ahe,
      registerTypeDefinitionProvider: Rhe,
      registerCodeLensProvider: Ohe,
      registerCodeActionProvider: Phe,
      registerDocumentFormattingEditProvider: Fhe,
      registerDocumentRangeFormattingEditProvider: Bhe,
      registerOnTypeFormattingEditProvider: Whe,
      registerLinkProvider: Vhe,
      registerColorProvider: zhe,
      registerFoldingRangeProvider: Uhe,
      registerDeclarationProvider: $he,
      registerSelectionRangeProvider: jhe,
      registerDocumentSemanticTokensProvider: Khe,
      registerDocumentRangeSemanticTokensProvider: qhe,
      registerInlineCompletionsProvider: Ghe,
      registerInlayHintsProvider: Zhe,
      DocumentHighlightKind: MD,
      CompletionItemKind: DD,
      CompletionItemTag: xD,
      CompletionItemInsertTextRule: kD,
      SymbolKind: tx,
      SymbolTag: ix,
      IndentAction: FD,
      CompletionTriggerKind: ID,
      SignatureHelpTriggerKind: ex,
      InlayHintKind: WD,
      InlineCompletionTriggerKind: VD,
      FoldingRangeKind: br
    };
  }
  var Oy;
  yr.wrappingIndent.defaultValue = 0;
  yr.glyphMargin.defaultValue = !1;
  yr.autoIndent.defaultValue = 3;
  yr.overviewRulerLanes.defaultValue = 2;
  fh.setFormatterSelector((s, e, t) => Promise.resolve(s[0]));
  const Xn = y8();
  Xn.editor = ahe();
  Xn.languages = Yhe();
  const Xhe = Xn.CancellationTokenSource, Qhe = Xn.Emitter, Jhe = Xn.KeyCode, eue = Xn.KeyMod, tue = Xn.Position, iue = Xn.Range, nue = Xn.Selection, sue = Xn.SelectionDirection, oue = Xn.MarkerSeverity, rue = Xn.MarkerTag, aue = Xn.Uri, lue = Xn.Token, tm = Xn.editor, cue = Xn.languages;
  (((Oy = gi.MonacoEnvironment) === null || Oy === void 0 ? void 0 : Oy.globalAPI) || typeof define == "function" && define.amd) && (self.monaco = Xn);
  typeof self.require < "u" && typeof self.require.config == "function" && self.require.config({
    ignoreDuplicateModules: [
      "vscode-languageserver-types",
      "vscode-languageserver-types/main",
      "vscode-languageserver-textdocument",
      "vscode-languageserver-textdocument/main",
      "vscode-nls",
      "vscode-nls/vscode-nls",
      "jsonc-parser",
      "jsonc-parser/main",
      "vscode-uri",
      "vscode-uri/index",
      "vs/basic-languages/typescript/typescript"
    ]
  });
  const i6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CancellationTokenSource: Xhe,
    Emitter: Qhe,
    KeyCode: Jhe,
    KeyMod: eue,
    Position: tue,
    Range: iue,
    Selection: nue,
    SelectionDirection: sue,
    MarkerSeverity: oue,
    MarkerTag: rue,
    Uri: aue,
    Token: lue,
    editor: tm,
    languages: cue
  }, Symbol.toStringTag, { value: "Module" }));
  /*!-----------------------------------------------------------------------------
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Version: 0.33.0(4b1abad427e58dbedc1215d99a0902ffc885fcd4)
   * Released under the MIT license
   * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
   *-----------------------------------------------------------------------------*/
  var due = Object.defineProperty, hue = Object.getOwnPropertyDescriptor, uue = Object.getOwnPropertyNames, fue = Object.prototype.hasOwnProperty, gue = (s, e, t, i) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let n of uue(e))
        !fue.call(s, n) && (t || n !== "default") && due(s, n, { get: () => e[n], enumerable: !(i = hue(e, n)) || i.enumerable });
    return s;
  }, O_ = {};
  gue(O_, i6);
  var mue = class {
    _onDidChange = new O_.Emitter();
    _diagnosticsOptions;
    _modeConfiguration;
    _languageId;
    constructor(s, e, t) {
      this._languageId = s, this.setDiagnosticsOptions(e), this.setModeConfiguration(t);
    }
    get onDidChange() {
      return this._onDidChange.event;
    }
    get languageId() {
      return this._languageId;
    }
    get modeConfiguration() {
      return this._modeConfiguration;
    }
    get diagnosticsOptions() {
      return this._diagnosticsOptions;
    }
    setDiagnosticsOptions(s) {
      this._diagnosticsOptions = s || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
    }
    setModeConfiguration(s) {
      this._modeConfiguration = s || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
    }
  }, pue = {
    validate: !0,
    allowComments: !0,
    schemas: [],
    enableSchemaRequest: !1,
    schemaRequest: "warning",
    schemaValidation: "warning",
    comments: "error",
    trailingCommas: "error"
  }, _ue = {
    documentFormattingEdits: !0,
    documentRangeFormattingEdits: !0,
    completionItems: !0,
    hovers: !0,
    documentSymbols: !0,
    tokens: !0,
    colors: !0,
    foldingRanges: !0,
    diagnostics: !0,
    selectionRanges: !0
  }, n6 = new mue("json", pue, _ue);
  O_.languages.json = { jsonDefaults: n6 };
  function bue() {
    return Promise.resolve().then(() => dfe);
  }
  O_.languages.register({
    id: "json",
    extensions: [".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc", ".har"],
    aliases: ["JSON", "json"],
    mimetypes: ["application/json"]
  });
  O_.languages.onLanguage("json", () => {
    bue().then((s) => s.setupMode(n6));
  });
  function vue() {
    return new Worker("/assets/editor.worker.55353356.js");
  }
  function Cue() {
    return new Worker("/assets/json.worker.2be2570f.js");
  }
  function wue() {
    return new Worker("/assets/css.worker.1bba75ea.js");
  }
  function Sue() {
    return new Worker("/assets/html.worker.3376e5b8.js");
  }
  function yue() {
    return new Worker("/assets/ts.worker.9acd5107.js");
  }
  self.MonacoEnvironment = {
    getWorker: (s, e) => {
      switch (e) {
        case "json":
          return new Cue();
        case "css":
        case "scss":
          return new wue();
        case "html":
          return new Sue();
        case "typescript":
        case "javascript":
          return new yue();
        default:
          return new vue();
      }
    }
  };
  const go = (s, e, t) => s.dispatchEvent(new CustomEvent(e, {
    composed: !0,
    bubbles: !0,
    detail: t
  })), Lue = /\s+|\r?\n|\r/g, gO = (s) => s.replace(Lue, "");
  customElements.get("v-badge") ? console.warn("WARNING: Multiple instances of PRIME being imported.") : (uB().catch((s) => console.error(s)), Promise.resolve().then(() => ffe), Promise.resolve().then(() => pfe), Promise.resolve().then(() => wfe), Promise.resolve().then(() => kfe), Promise.resolve().then(() => Ife), Promise.resolve().then(() => Tfe), Promise.resolve().then(() => Rfe), Promise.resolve().then(() => Wfe), Promise.resolve().then(() => Kfe), Promise.resolve().then(() => Zfe), Promise.resolve().then(() => Qfe), Promise.resolve().then(() => sge), Promise.resolve().then(() => age), Promise.resolve().then(() => dge), Promise.resolve().then(() => fge), Promise.resolve().then(() => pge), Promise.resolve().then(() => vge), Promise.resolve().then(() => Sge), Promise.resolve().then(() => kge), Promise.resolve().then(() => ime), Promise.resolve().then(() => ome));
  /*!-----------------------------------------------------------------------------
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Version: 0.33.0(4b1abad427e58dbedc1215d99a0902ffc885fcd4)
   * Released under the MIT license
   * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
   *-----------------------------------------------------------------------------*/
  var kue = Object.defineProperty, Due = Object.getOwnPropertyDescriptor, xue = Object.getOwnPropertyNames, Iue = Object.prototype.hasOwnProperty, Eue = (s, e, t, i) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let n of xue(e))
        !Iue.call(s, n) && (t || n !== "default") && kue(s, n, { get: () => e[n], enumerable: !(i = Due(e, n)) || i.enumerable });
    return s;
  }, mt = {};
  Eue(mt, i6);
  var Nue = 2 * 60 * 1e3, s6 = class {
    _defaults;
    _idleCheckInterval;
    _lastUsedTime;
    _configChangeListener;
    _worker;
    _client;
    constructor(s) {
      this._defaults = s, this._worker = null, this._client = null, this._idleCheckInterval = window.setInterval(() => this._checkIfIdle(), 30 * 1e3), this._lastUsedTime = 0, this._configChangeListener = this._defaults.onDidChange(() => this._stopWorker());
    }
    _stopWorker() {
      this._worker && (this._worker.dispose(), this._worker = null), this._client = null;
    }
    dispose() {
      clearInterval(this._idleCheckInterval), this._configChangeListener.dispose(), this._stopWorker();
    }
    _checkIfIdle() {
      if (!this._worker)
        return;
      Date.now() - this._lastUsedTime > Nue && this._stopWorker();
    }
    _getClient() {
      return this._lastUsedTime = Date.now(), this._client || (this._worker = mt.editor.createWebWorker({
        moduleId: "vs/language/json/jsonWorker",
        label: this._defaults.languageId,
        createData: {
          languageSettings: this._defaults.diagnosticsOptions,
          languageId: this._defaults.languageId,
          enableSchemaRequest: this._defaults.diagnosticsOptions.enableSchemaRequest
        }
      }), this._client = this._worker.getProxy()), this._client;
    }
    getLanguageServiceWorker(...s) {
      let e;
      return this._getClient().then((t) => {
        e = t;
      }).then((t) => {
        if (this._worker)
          return this._worker.withSyncedResources(s);
      }).then((t) => e);
    }
  }, mO;
  (function(s) {
    s.MIN_VALUE = -2147483648, s.MAX_VALUE = 2147483647;
  })(mO || (mO = {}));
  var pv;
  (function(s) {
    s.MIN_VALUE = 0, s.MAX_VALUE = 2147483647;
  })(pv || (pv = {}));
  var jr;
  (function(s) {
    function e(i, n) {
      return i === Number.MAX_VALUE && (i = pv.MAX_VALUE), n === Number.MAX_VALUE && (n = pv.MAX_VALUE), { line: i, character: n };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.objectLiteral(n) && ne.uinteger(n.line) && ne.uinteger(n.character);
    }
    s.is = t;
  })(jr || (jr = {}));
  var qn;
  (function(s) {
    function e(i, n, o, r) {
      if (ne.uinteger(i) && ne.uinteger(n) && ne.uinteger(o) && ne.uinteger(r))
        return { start: jr.create(i, n), end: jr.create(o, r) };
      if (jr.is(i) && jr.is(n))
        return { start: i, end: n };
      throw new Error("Range#create called with invalid arguments[" + i + ", " + n + ", " + o + ", " + r + "]");
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.objectLiteral(n) && jr.is(n.start) && jr.is(n.end);
    }
    s.is = t;
  })(qn || (qn = {}));
  var Zx;
  (function(s) {
    function e(i, n) {
      return { uri: i, range: n };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && qn.is(n.range) && (ne.string(n.uri) || ne.undefined(n.uri));
    }
    s.is = t;
  })(Zx || (Zx = {}));
  var pO;
  (function(s) {
    function e(i, n, o, r) {
      return { targetUri: i, targetRange: n, targetSelectionRange: o, originSelectionRange: r };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && qn.is(n.targetRange) && ne.string(n.targetUri) && (qn.is(n.targetSelectionRange) || ne.undefined(n.targetSelectionRange)) && (qn.is(n.originSelectionRange) || ne.undefined(n.originSelectionRange));
    }
    s.is = t;
  })(pO || (pO = {}));
  var Yx;
  (function(s) {
    function e(i, n, o, r) {
      return {
        red: i,
        green: n,
        blue: o,
        alpha: r
      };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.numberRange(n.red, 0, 1) && ne.numberRange(n.green, 0, 1) && ne.numberRange(n.blue, 0, 1) && ne.numberRange(n.alpha, 0, 1);
    }
    s.is = t;
  })(Yx || (Yx = {}));
  var _O;
  (function(s) {
    function e(i, n) {
      return {
        range: i,
        color: n
      };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return qn.is(n.range) && Yx.is(n.color);
    }
    s.is = t;
  })(_O || (_O = {}));
  var bO;
  (function(s) {
    function e(i, n, o) {
      return {
        label: i,
        textEdit: n,
        additionalTextEdits: o
      };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.string(n.label) && (ne.undefined(n.textEdit) || fc.is(n)) && (ne.undefined(n.additionalTextEdits) || ne.typedArray(n.additionalTextEdits, fc.is));
    }
    s.is = t;
  })(bO || (bO = {}));
  var Rm;
  (function(s) {
    s.Comment = "comment", s.Imports = "imports", s.Region = "region";
  })(Rm || (Rm = {}));
  var vO;
  (function(s) {
    function e(i, n, o, r, a) {
      var l = {
        startLine: i,
        endLine: n
      };
      return ne.defined(o) && (l.startCharacter = o), ne.defined(r) && (l.endCharacter = r), ne.defined(a) && (l.kind = a), l;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.uinteger(n.startLine) && ne.uinteger(n.startLine) && (ne.undefined(n.startCharacter) || ne.uinteger(n.startCharacter)) && (ne.undefined(n.endCharacter) || ne.uinteger(n.endCharacter)) && (ne.undefined(n.kind) || ne.string(n.kind));
    }
    s.is = t;
  })(vO || (vO = {}));
  var Xx;
  (function(s) {
    function e(i, n) {
      return {
        location: i,
        message: n
      };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && Zx.is(n.location) && ne.string(n.message);
    }
    s.is = t;
  })(Xx || (Xx = {}));
  var Wu;
  (function(s) {
    s.Error = 1, s.Warning = 2, s.Information = 3, s.Hint = 4;
  })(Wu || (Wu = {}));
  var CO;
  (function(s) {
    s.Unnecessary = 1, s.Deprecated = 2;
  })(CO || (CO = {}));
  var wO;
  (function(s) {
    function e(t) {
      var i = t;
      return i != null && ne.string(i.href);
    }
    s.is = e;
  })(wO || (wO = {}));
  var _v;
  (function(s) {
    function e(i, n, o, r, a, l) {
      var c = { range: i, message: n };
      return ne.defined(o) && (c.severity = o), ne.defined(r) && (c.code = r), ne.defined(a) && (c.source = a), ne.defined(l) && (c.relatedInformation = l), c;
    }
    s.create = e;
    function t(i) {
      var n, o = i;
      return ne.defined(o) && qn.is(o.range) && ne.string(o.message) && (ne.number(o.severity) || ne.undefined(o.severity)) && (ne.integer(o.code) || ne.string(o.code) || ne.undefined(o.code)) && (ne.undefined(o.codeDescription) || ne.string((n = o.codeDescription) === null || n === void 0 ? void 0 : n.href)) && (ne.string(o.source) || ne.undefined(o.source)) && (ne.undefined(o.relatedInformation) || ne.typedArray(o.relatedInformation, Xx.is));
    }
    s.is = t;
  })(_v || (_v = {}));
  var e_;
  (function(s) {
    function e(i, n) {
      for (var o = [], r = 2; r < arguments.length; r++)
        o[r - 2] = arguments[r];
      var a = { title: i, command: n };
      return ne.defined(o) && o.length > 0 && (a.arguments = o), a;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && ne.string(n.title) && ne.string(n.command);
    }
    s.is = t;
  })(e_ || (e_ = {}));
  var fc;
  (function(s) {
    function e(o, r) {
      return { range: o, newText: r };
    }
    s.replace = e;
    function t(o, r) {
      return { range: { start: o, end: o }, newText: r };
    }
    s.insert = t;
    function i(o) {
      return { range: o, newText: "" };
    }
    s.del = i;
    function n(o) {
      var r = o;
      return ne.objectLiteral(r) && ne.string(r.newText) && qn.is(r.range);
    }
    s.is = n;
  })(fc || (fc = {}));
  var df;
  (function(s) {
    function e(i, n, o) {
      var r = { label: i };
      return n !== void 0 && (r.needsConfirmation = n), o !== void 0 && (r.description = o), r;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n !== void 0 && ne.objectLiteral(n) && ne.string(n.label) && (ne.boolean(n.needsConfirmation) || n.needsConfirmation === void 0) && (ne.string(n.description) || n.description === void 0);
    }
    s.is = t;
  })(df || (df = {}));
  var as;
  (function(s) {
    function e(t) {
      var i = t;
      return typeof i == "string";
    }
    s.is = e;
  })(as || (as = {}));
  var Vl;
  (function(s) {
    function e(o, r, a) {
      return { range: o, newText: r, annotationId: a };
    }
    s.replace = e;
    function t(o, r, a) {
      return { range: { start: o, end: o }, newText: r, annotationId: a };
    }
    s.insert = t;
    function i(o, r) {
      return { range: o, newText: "", annotationId: r };
    }
    s.del = i;
    function n(o) {
      var r = o;
      return fc.is(r) && (df.is(r.annotationId) || as.is(r.annotationId));
    }
    s.is = n;
  })(Vl || (Vl = {}));
  var bv;
  (function(s) {
    function e(i, n) {
      return { textDocument: i, edits: n };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && vv.is(n.textDocument) && Array.isArray(n.edits);
    }
    s.is = t;
  })(bv || (bv = {}));
  var t_;
  (function(s) {
    function e(i, n, o) {
      var r = {
        kind: "create",
        uri: i
      };
      return n !== void 0 && (n.overwrite !== void 0 || n.ignoreIfExists !== void 0) && (r.options = n), o !== void 0 && (r.annotationId = o), r;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n && n.kind === "create" && ne.string(n.uri) && (n.options === void 0 || (n.options.overwrite === void 0 || ne.boolean(n.options.overwrite)) && (n.options.ignoreIfExists === void 0 || ne.boolean(n.options.ignoreIfExists))) && (n.annotationId === void 0 || as.is(n.annotationId));
    }
    s.is = t;
  })(t_ || (t_ = {}));
  var i_;
  (function(s) {
    function e(i, n, o, r) {
      var a = {
        kind: "rename",
        oldUri: i,
        newUri: n
      };
      return o !== void 0 && (o.overwrite !== void 0 || o.ignoreIfExists !== void 0) && (a.options = o), r !== void 0 && (a.annotationId = r), a;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n && n.kind === "rename" && ne.string(n.oldUri) && ne.string(n.newUri) && (n.options === void 0 || (n.options.overwrite === void 0 || ne.boolean(n.options.overwrite)) && (n.options.ignoreIfExists === void 0 || ne.boolean(n.options.ignoreIfExists))) && (n.annotationId === void 0 || as.is(n.annotationId));
    }
    s.is = t;
  })(i_ || (i_ = {}));
  var n_;
  (function(s) {
    function e(i, n, o) {
      var r = {
        kind: "delete",
        uri: i
      };
      return n !== void 0 && (n.recursive !== void 0 || n.ignoreIfNotExists !== void 0) && (r.options = n), o !== void 0 && (r.annotationId = o), r;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n && n.kind === "delete" && ne.string(n.uri) && (n.options === void 0 || (n.options.recursive === void 0 || ne.boolean(n.options.recursive)) && (n.options.ignoreIfNotExists === void 0 || ne.boolean(n.options.ignoreIfNotExists))) && (n.annotationId === void 0 || as.is(n.annotationId));
    }
    s.is = t;
  })(n_ || (n_ = {}));
  var Qx;
  (function(s) {
    function e(t) {
      var i = t;
      return i && (i.changes !== void 0 || i.documentChanges !== void 0) && (i.documentChanges === void 0 || i.documentChanges.every(function(n) {
        return ne.string(n.kind) ? t_.is(n) || i_.is(n) || n_.is(n) : bv.is(n);
      }));
    }
    s.is = e;
  })(Qx || (Qx = {}));
  var Gb = function() {
    function s(e, t) {
      this.edits = e, this.changeAnnotations = t;
    }
    return s.prototype.insert = function(e, t, i) {
      var n, o;
      if (i === void 0 ? n = fc.insert(e, t) : as.is(i) ? (o = i, n = Vl.insert(e, t, i)) : (this.assertChangeAnnotations(this.changeAnnotations), o = this.changeAnnotations.manage(i), n = Vl.insert(e, t, o)), this.edits.push(n), o !== void 0)
        return o;
    }, s.prototype.replace = function(e, t, i) {
      var n, o;
      if (i === void 0 ? n = fc.replace(e, t) : as.is(i) ? (o = i, n = Vl.replace(e, t, i)) : (this.assertChangeAnnotations(this.changeAnnotations), o = this.changeAnnotations.manage(i), n = Vl.replace(e, t, o)), this.edits.push(n), o !== void 0)
        return o;
    }, s.prototype.delete = function(e, t) {
      var i, n;
      if (t === void 0 ? i = fc.del(e) : as.is(t) ? (n = t, i = Vl.del(e, t)) : (this.assertChangeAnnotations(this.changeAnnotations), n = this.changeAnnotations.manage(t), i = Vl.del(e, n)), this.edits.push(i), n !== void 0)
        return n;
    }, s.prototype.add = function(e) {
      this.edits.push(e);
    }, s.prototype.all = function() {
      return this.edits;
    }, s.prototype.clear = function() {
      this.edits.splice(0, this.edits.length);
    }, s.prototype.assertChangeAnnotations = function(e) {
      if (e === void 0)
        throw new Error("Text edit change is not configured to manage change annotations.");
    }, s;
  }(), SO = function() {
    function s(e) {
      this._annotations = e === void 0 ? /* @__PURE__ */ Object.create(null) : e, this._counter = 0, this._size = 0;
    }
    return s.prototype.all = function() {
      return this._annotations;
    }, Object.defineProperty(s.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !1,
      configurable: !0
    }), s.prototype.manage = function(e, t) {
      var i;
      if (as.is(e) ? i = e : (i = this.nextId(), t = e), this._annotations[i] !== void 0)
        throw new Error("Id " + i + " is already in use.");
      if (t === void 0)
        throw new Error("No annotation provided for id " + i);
      return this._annotations[i] = t, this._size++, i;
    }, s.prototype.nextId = function() {
      return this._counter++, this._counter.toString();
    }, s;
  }();
  (function() {
    function s(e) {
      var t = this;
      this._textEditChanges = /* @__PURE__ */ Object.create(null), e !== void 0 ? (this._workspaceEdit = e, e.documentChanges ? (this._changeAnnotations = new SO(e.changeAnnotations), e.changeAnnotations = this._changeAnnotations.all(), e.documentChanges.forEach(function(i) {
        if (bv.is(i)) {
          var n = new Gb(i.edits, t._changeAnnotations);
          t._textEditChanges[i.textDocument.uri] = n;
        }
      })) : e.changes && Object.keys(e.changes).forEach(function(i) {
        var n = new Gb(e.changes[i]);
        t._textEditChanges[i] = n;
      })) : this._workspaceEdit = {};
    }
    return Object.defineProperty(s.prototype, "edit", {
      get: function() {
        return this.initDocumentChanges(), this._changeAnnotations !== void 0 && (this._changeAnnotations.size === 0 ? this._workspaceEdit.changeAnnotations = void 0 : this._workspaceEdit.changeAnnotations = this._changeAnnotations.all()), this._workspaceEdit;
      },
      enumerable: !1,
      configurable: !0
    }), s.prototype.getTextEditChange = function(e) {
      if (vv.is(e)) {
        if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
          throw new Error("Workspace edit is not configured for document changes.");
        var t = { uri: e.uri, version: e.version }, i = this._textEditChanges[t.uri];
        if (!i) {
          var n = [], o = {
            textDocument: t,
            edits: n
          };
          this._workspaceEdit.documentChanges.push(o), i = new Gb(n, this._changeAnnotations), this._textEditChanges[t.uri] = i;
        }
        return i;
      } else {
        if (this.initChanges(), this._workspaceEdit.changes === void 0)
          throw new Error("Workspace edit is not configured for normal text edit changes.");
        var i = this._textEditChanges[e];
        if (!i) {
          var n = [];
          this._workspaceEdit.changes[e] = n, i = new Gb(n), this._textEditChanges[e] = i;
        }
        return i;
      }
    }, s.prototype.initDocumentChanges = function() {
      this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0 && (this._changeAnnotations = new SO(), this._workspaceEdit.documentChanges = [], this._workspaceEdit.changeAnnotations = this._changeAnnotations.all());
    }, s.prototype.initChanges = function() {
      this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0 && (this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null));
    }, s.prototype.createFile = function(e, t, i) {
      if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
        throw new Error("Workspace edit is not configured for document changes.");
      var n;
      df.is(t) || as.is(t) ? n = t : i = t;
      var o, r;
      if (n === void 0 ? o = t_.create(e, i) : (r = as.is(n) ? n : this._changeAnnotations.manage(n), o = t_.create(e, i, r)), this._workspaceEdit.documentChanges.push(o), r !== void 0)
        return r;
    }, s.prototype.renameFile = function(e, t, i, n) {
      if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
        throw new Error("Workspace edit is not configured for document changes.");
      var o;
      df.is(i) || as.is(i) ? o = i : n = i;
      var r, a;
      if (o === void 0 ? r = i_.create(e, t, n) : (a = as.is(o) ? o : this._changeAnnotations.manage(o), r = i_.create(e, t, n, a)), this._workspaceEdit.documentChanges.push(r), a !== void 0)
        return a;
    }, s.prototype.deleteFile = function(e, t, i) {
      if (this.initDocumentChanges(), this._workspaceEdit.documentChanges === void 0)
        throw new Error("Workspace edit is not configured for document changes.");
      var n;
      df.is(t) || as.is(t) ? n = t : i = t;
      var o, r;
      if (n === void 0 ? o = n_.create(e, i) : (r = as.is(n) ? n : this._changeAnnotations.manage(n), o = n_.create(e, i, r)), this._workspaceEdit.documentChanges.push(o), r !== void 0)
        return r;
    }, s;
  })();
  var yO;
  (function(s) {
    function e(i) {
      return { uri: i };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && ne.string(n.uri);
    }
    s.is = t;
  })(yO || (yO = {}));
  var LO;
  (function(s) {
    function e(i, n) {
      return { uri: i, version: n };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && ne.string(n.uri) && ne.integer(n.version);
    }
    s.is = t;
  })(LO || (LO = {}));
  var vv;
  (function(s) {
    function e(i, n) {
      return { uri: i, version: n };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && ne.string(n.uri) && (n.version === null || ne.integer(n.version));
    }
    s.is = t;
  })(vv || (vv = {}));
  var kO;
  (function(s) {
    function e(i, n, o, r) {
      return { uri: i, languageId: n, version: o, text: r };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && ne.string(n.uri) && ne.string(n.languageId) && ne.integer(n.version) && ne.string(n.text);
    }
    s.is = t;
  })(kO || (kO = {}));
  var s_;
  (function(s) {
    s.PlainText = "plaintext", s.Markdown = "markdown";
  })(s_ || (s_ = {}));
  (function(s) {
    function e(t) {
      var i = t;
      return i === s.PlainText || i === s.Markdown;
    }
    s.is = e;
  })(s_ || (s_ = {}));
  var Jx;
  (function(s) {
    function e(t) {
      var i = t;
      return ne.objectLiteral(t) && s_.is(i.kind) && ne.string(i.value);
    }
    s.is = e;
  })(Jx || (Jx = {}));
  var hn;
  (function(s) {
    s.Text = 1, s.Method = 2, s.Function = 3, s.Constructor = 4, s.Field = 5, s.Variable = 6, s.Class = 7, s.Interface = 8, s.Module = 9, s.Property = 10, s.Unit = 11, s.Value = 12, s.Enum = 13, s.Keyword = 14, s.Snippet = 15, s.Color = 16, s.File = 17, s.Reference = 18, s.Folder = 19, s.EnumMember = 20, s.Constant = 21, s.Struct = 22, s.Event = 23, s.Operator = 24, s.TypeParameter = 25;
  })(hn || (hn = {}));
  var eI;
  (function(s) {
    s.PlainText = 1, s.Snippet = 2;
  })(eI || (eI = {}));
  var DO;
  (function(s) {
    s.Deprecated = 1;
  })(DO || (DO = {}));
  var xO;
  (function(s) {
    function e(i, n, o) {
      return { newText: i, insert: n, replace: o };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n && ne.string(n.newText) && qn.is(n.insert) && qn.is(n.replace);
    }
    s.is = t;
  })(xO || (xO = {}));
  var IO;
  (function(s) {
    s.asIs = 1, s.adjustIndentation = 2;
  })(IO || (IO = {}));
  var EO;
  (function(s) {
    function e(t) {
      return { label: t };
    }
    s.create = e;
  })(EO || (EO = {}));
  var NO;
  (function(s) {
    function e(t, i) {
      return { items: t || [], isIncomplete: !!i };
    }
    s.create = e;
  })(NO || (NO = {}));
  var Cv;
  (function(s) {
    function e(i) {
      return i.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    s.fromPlainText = e;
    function t(i) {
      var n = i;
      return ne.string(n) || ne.objectLiteral(n) && ne.string(n.language) && ne.string(n.value);
    }
    s.is = t;
  })(Cv || (Cv = {}));
  var TO;
  (function(s) {
    function e(t) {
      var i = t;
      return !!i && ne.objectLiteral(i) && (Jx.is(i.contents) || Cv.is(i.contents) || ne.typedArray(i.contents, Cv.is)) && (t.range === void 0 || qn.is(t.range));
    }
    s.is = e;
  })(TO || (TO = {}));
  var MO;
  (function(s) {
    function e(t, i) {
      return i ? { label: t, documentation: i } : { label: t };
    }
    s.create = e;
  })(MO || (MO = {}));
  var AO;
  (function(s) {
    function e(t, i) {
      for (var n = [], o = 2; o < arguments.length; o++)
        n[o - 2] = arguments[o];
      var r = { label: t };
      return ne.defined(i) && (r.documentation = i), ne.defined(n) ? r.parameters = n : r.parameters = [], r;
    }
    s.create = e;
  })(AO || (AO = {}));
  var Om;
  (function(s) {
    s.Text = 1, s.Read = 2, s.Write = 3;
  })(Om || (Om = {}));
  var RO;
  (function(s) {
    function e(t, i) {
      var n = { range: t };
      return ne.number(i) && (n.kind = i), n;
    }
    s.create = e;
  })(RO || (RO = {}));
  var un;
  (function(s) {
    s.File = 1, s.Module = 2, s.Namespace = 3, s.Package = 4, s.Class = 5, s.Method = 6, s.Property = 7, s.Field = 8, s.Constructor = 9, s.Enum = 10, s.Interface = 11, s.Function = 12, s.Variable = 13, s.Constant = 14, s.String = 15, s.Number = 16, s.Boolean = 17, s.Array = 18, s.Object = 19, s.Key = 20, s.Null = 21, s.EnumMember = 22, s.Struct = 23, s.Event = 24, s.Operator = 25, s.TypeParameter = 26;
  })(un || (un = {}));
  var OO;
  (function(s) {
    s.Deprecated = 1;
  })(OO || (OO = {}));
  var PO;
  (function(s) {
    function e(t, i, n, o, r) {
      var a = {
        name: t,
        kind: i,
        location: { uri: o, range: n }
      };
      return r && (a.containerName = r), a;
    }
    s.create = e;
  })(PO || (PO = {}));
  var FO;
  (function(s) {
    function e(i, n, o, r, a, l) {
      var c = {
        name: i,
        detail: n,
        kind: o,
        range: r,
        selectionRange: a
      };
      return l !== void 0 && (c.children = l), c;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n && ne.string(n.name) && ne.number(n.kind) && qn.is(n.range) && qn.is(n.selectionRange) && (n.detail === void 0 || ne.string(n.detail)) && (n.deprecated === void 0 || ne.boolean(n.deprecated)) && (n.children === void 0 || Array.isArray(n.children)) && (n.tags === void 0 || Array.isArray(n.tags));
    }
    s.is = t;
  })(FO || (FO = {}));
  var BO;
  (function(s) {
    s.Empty = "", s.QuickFix = "quickfix", s.Refactor = "refactor", s.RefactorExtract = "refactor.extract", s.RefactorInline = "refactor.inline", s.RefactorRewrite = "refactor.rewrite", s.Source = "source", s.SourceOrganizeImports = "source.organizeImports", s.SourceFixAll = "source.fixAll";
  })(BO || (BO = {}));
  var WO;
  (function(s) {
    function e(i, n) {
      var o = { diagnostics: i };
      return n != null && (o.only = n), o;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && ne.typedArray(n.diagnostics, _v.is) && (n.only === void 0 || ne.typedArray(n.only, ne.string));
    }
    s.is = t;
  })(WO || (WO = {}));
  var VO;
  (function(s) {
    function e(i, n, o) {
      var r = { title: i }, a = !0;
      return typeof n == "string" ? (a = !1, r.kind = n) : e_.is(n) ? r.command = n : r.edit = n, a && o !== void 0 && (r.kind = o), r;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n && ne.string(n.title) && (n.diagnostics === void 0 || ne.typedArray(n.diagnostics, _v.is)) && (n.kind === void 0 || ne.string(n.kind)) && (n.edit !== void 0 || n.command !== void 0) && (n.command === void 0 || e_.is(n.command)) && (n.isPreferred === void 0 || ne.boolean(n.isPreferred)) && (n.edit === void 0 || Qx.is(n.edit));
    }
    s.is = t;
  })(VO || (VO = {}));
  var HO;
  (function(s) {
    function e(i, n) {
      var o = { range: i };
      return ne.defined(n) && (o.data = n), o;
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && qn.is(n.range) && (ne.undefined(n.command) || e_.is(n.command));
    }
    s.is = t;
  })(HO || (HO = {}));
  var zO;
  (function(s) {
    function e(i, n) {
      return { tabSize: i, insertSpaces: n };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && ne.uinteger(n.tabSize) && ne.boolean(n.insertSpaces);
    }
    s.is = t;
  })(zO || (zO = {}));
  var UO;
  (function(s) {
    function e(i, n, o) {
      return { range: i, target: n, data: o };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return ne.defined(n) && qn.is(n.range) && (ne.undefined(n.target) || ne.string(n.target));
    }
    s.is = t;
  })(UO || (UO = {}));
  var $O;
  (function(s) {
    function e(i, n) {
      return { range: i, parent: n };
    }
    s.create = e;
    function t(i) {
      var n = i;
      return n !== void 0 && qn.is(n.range) && (n.parent === void 0 || s.is(n.parent));
    }
    s.is = t;
  })($O || ($O = {}));
  var jO;
  (function(s) {
    function e(o, r, a, l) {
      return new Tue(o, r, a, l);
    }
    s.create = e;
    function t(o) {
      var r = o;
      return !!(ne.defined(r) && ne.string(r.uri) && (ne.undefined(r.languageId) || ne.string(r.languageId)) && ne.uinteger(r.lineCount) && ne.func(r.getText) && ne.func(r.positionAt) && ne.func(r.offsetAt));
    }
    s.is = t;
    function i(o, r) {
      for (var a = o.getText(), l = n(r, function(g, _) {
        var b = g.range.start.line - _.range.start.line;
        return b === 0 ? g.range.start.character - _.range.start.character : b;
      }), c = a.length, d = l.length - 1; d >= 0; d--) {
        var h = l[d], u = o.offsetAt(h.range.start), f = o.offsetAt(h.range.end);
        if (f <= c)
          a = a.substring(0, u) + h.newText + a.substring(f, a.length);
        else
          throw new Error("Overlapping edit");
        c = u;
      }
      return a;
    }
    s.applyEdits = i;
    function n(o, r) {
      if (o.length <= 1)
        return o;
      var a = o.length / 2 | 0, l = o.slice(0, a), c = o.slice(a);
      n(l, r), n(c, r);
      for (var d = 0, h = 0, u = 0; d < l.length && h < c.length; ) {
        var f = r(l[d], c[h]);
        f <= 0 ? o[u++] = l[d++] : o[u++] = c[h++];
      }
      for (; d < l.length; )
        o[u++] = l[d++];
      for (; h < c.length; )
        o[u++] = c[h++];
      return o;
    }
  })(jO || (jO = {}));
  var Tue = function() {
    function s(e, t, i, n) {
      this._uri = e, this._languageId = t, this._version = i, this._content = n, this._lineOffsets = void 0;
    }
    return Object.defineProperty(s.prototype, "uri", {
      get: function() {
        return this._uri;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(s.prototype, "languageId", {
      get: function() {
        return this._languageId;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(s.prototype, "version", {
      get: function() {
        return this._version;
      },
      enumerable: !1,
      configurable: !0
    }), s.prototype.getText = function(e) {
      if (e) {
        var t = this.offsetAt(e.start), i = this.offsetAt(e.end);
        return this._content.substring(t, i);
      }
      return this._content;
    }, s.prototype.update = function(e, t) {
      this._content = e.text, this._version = t, this._lineOffsets = void 0;
    }, s.prototype.getLineOffsets = function() {
      if (this._lineOffsets === void 0) {
        for (var e = [], t = this._content, i = !0, n = 0; n < t.length; n++) {
          i && (e.push(n), i = !1);
          var o = t.charAt(n);
          i = o === "\r" || o === `
`, o === "\r" && n + 1 < t.length && t.charAt(n + 1) === `
` && n++;
        }
        i && t.length > 0 && e.push(t.length), this._lineOffsets = e;
      }
      return this._lineOffsets;
    }, s.prototype.positionAt = function(e) {
      e = Math.max(Math.min(e, this._content.length), 0);
      var t = this.getLineOffsets(), i = 0, n = t.length;
      if (n === 0)
        return jr.create(0, e);
      for (; i < n; ) {
        var o = Math.floor((i + n) / 2);
        t[o] > e ? n = o : i = o + 1;
      }
      var r = i - 1;
      return jr.create(r, e - t[r]);
    }, s.prototype.offsetAt = function(e) {
      var t = this.getLineOffsets();
      if (e.line >= t.length)
        return this._content.length;
      if (e.line < 0)
        return 0;
      var i = t[e.line], n = e.line + 1 < t.length ? t[e.line + 1] : this._content.length;
      return Math.max(Math.min(i + e.character, n), i);
    }, Object.defineProperty(s.prototype, "lineCount", {
      get: function() {
        return this.getLineOffsets().length;
      },
      enumerable: !1,
      configurable: !0
    }), s;
  }(), ne;
  (function(s) {
    var e = Object.prototype.toString;
    function t(f) {
      return typeof f < "u";
    }
    s.defined = t;
    function i(f) {
      return typeof f > "u";
    }
    s.undefined = i;
    function n(f) {
      return f === !0 || f === !1;
    }
    s.boolean = n;
    function o(f) {
      return e.call(f) === "[object String]";
    }
    s.string = o;
    function r(f) {
      return e.call(f) === "[object Number]";
    }
    s.number = r;
    function a(f, g, _) {
      return e.call(f) === "[object Number]" && g <= f && f <= _;
    }
    s.numberRange = a;
    function l(f) {
      return e.call(f) === "[object Number]" && -2147483648 <= f && f <= 2147483647;
    }
    s.integer = l;
    function c(f) {
      return e.call(f) === "[object Number]" && 0 <= f && f <= 2147483647;
    }
    s.uinteger = c;
    function d(f) {
      return e.call(f) === "[object Function]";
    }
    s.func = d;
    function h(f) {
      return f !== null && typeof f == "object";
    }
    s.objectLiteral = h;
    function u(f, g) {
      return Array.isArray(f) && f.every(g);
    }
    s.typedArray = u;
  })(ne || (ne = {}));
  var o6 = class {
    constructor(s, e, t) {
      this._languageId = s, this._worker = e;
      const i = (o) => {
        let r = o.getLanguageId();
        if (r !== this._languageId)
          return;
        let a;
        this._listener[o.uri.toString()] = o.onDidChangeContent(() => {
          window.clearTimeout(a), a = window.setTimeout(() => this._doValidate(o.uri, r), 500);
        }), this._doValidate(o.uri, r);
      }, n = (o) => {
        mt.editor.setModelMarkers(o, this._languageId, []);
        let r = o.uri.toString(), a = this._listener[r];
        a && (a.dispose(), delete this._listener[r]);
      };
      this._disposables.push(mt.editor.onDidCreateModel(i)), this._disposables.push(mt.editor.onWillDisposeModel(n)), this._disposables.push(mt.editor.onDidChangeModelLanguage((o) => {
        n(o.model), i(o.model);
      })), this._disposables.push(t((o) => {
        mt.editor.getModels().forEach((r) => {
          r.getLanguageId() === this._languageId && (n(r), i(r));
        });
      })), this._disposables.push({
        dispose: () => {
          mt.editor.getModels().forEach(n);
          for (let o in this._listener)
            this._listener[o].dispose();
        }
      }), mt.editor.getModels().forEach(i);
    }
    _disposables = [];
    _listener = /* @__PURE__ */ Object.create(null);
    dispose() {
      this._disposables.forEach((s) => s && s.dispose()), this._disposables.length = 0;
    }
    _doValidate(s, e) {
      this._worker(s).then((t) => t.doValidation(s.toString())).then((t) => {
        const i = t.map((o) => Aue(s, o));
        let n = mt.editor.getModel(s);
        n && n.getLanguageId() === e && mt.editor.setModelMarkers(n, e, i);
      }).then(void 0, (t) => {
        console.error(t);
      });
    }
  };
  function Mue(s) {
    switch (s) {
      case Wu.Error:
        return mt.MarkerSeverity.Error;
      case Wu.Warning:
        return mt.MarkerSeverity.Warning;
      case Wu.Information:
        return mt.MarkerSeverity.Info;
      case Wu.Hint:
        return mt.MarkerSeverity.Hint;
      default:
        return mt.MarkerSeverity.Info;
    }
  }
  function Aue(s, e) {
    let t = typeof e.code == "number" ? String(e.code) : e.code;
    return {
      severity: Mue(e.severity),
      startLineNumber: e.range.start.line + 1,
      startColumn: e.range.start.character + 1,
      endLineNumber: e.range.end.line + 1,
      endColumn: e.range.end.character + 1,
      message: e.message,
      code: t,
      source: e.source
    };
  }
  var r6 = class {
    constructor(s, e) {
      this._worker = s, this._triggerCharacters = e;
    }
    get triggerCharacters() {
      return this._triggerCharacters;
    }
    provideCompletionItems(s, e, t, i) {
      const n = s.uri;
      return this._worker(n).then((o) => o.doComplete(n.toString(), jc(e))).then((o) => {
        if (!o)
          return;
        const r = s.getWordUntilPosition(e), a = new mt.Range(e.lineNumber, r.startColumn, e.lineNumber, r.endColumn), l = o.items.map((c) => {
          const d = {
            label: c.label,
            insertText: c.insertText || c.label,
            sortText: c.sortText,
            filterText: c.filterText,
            documentation: c.documentation,
            detail: c.detail,
            command: Pue(c.command),
            range: a,
            kind: Oue(c.kind)
          };
          return c.textEdit && (Rue(c.textEdit) ? d.range = {
            insert: Ys(c.textEdit.insert),
            replace: Ys(c.textEdit.replace)
          } : d.range = Ys(c.textEdit.range), d.insertText = c.textEdit.newText), c.additionalTextEdits && (d.additionalTextEdits = c.additionalTextEdits.map(Zf)), c.insertTextFormat === eI.Snippet && (d.insertTextRules = mt.languages.CompletionItemInsertTextRule.InsertAsSnippet), d;
        });
        return {
          isIncomplete: o.isIncomplete,
          suggestions: l
        };
      });
    }
  };
  function jc(s) {
    if (!!s)
      return { character: s.column - 1, line: s.lineNumber - 1 };
  }
  function m2(s) {
    if (!!s)
      return {
        start: {
          line: s.startLineNumber - 1,
          character: s.startColumn - 1
        },
        end: { line: s.endLineNumber - 1, character: s.endColumn - 1 }
      };
  }
  function Ys(s) {
    if (!!s)
      return new mt.Range(s.start.line + 1, s.start.character + 1, s.end.line + 1, s.end.character + 1);
  }
  function Rue(s) {
    return typeof s.insert < "u" && typeof s.replace < "u";
  }
  function Oue(s) {
    const e = mt.languages.CompletionItemKind;
    switch (s) {
      case hn.Text:
        return e.Text;
      case hn.Method:
        return e.Method;
      case hn.Function:
        return e.Function;
      case hn.Constructor:
        return e.Constructor;
      case hn.Field:
        return e.Field;
      case hn.Variable:
        return e.Variable;
      case hn.Class:
        return e.Class;
      case hn.Interface:
        return e.Interface;
      case hn.Module:
        return e.Module;
      case hn.Property:
        return e.Property;
      case hn.Unit:
        return e.Unit;
      case hn.Value:
        return e.Value;
      case hn.Enum:
        return e.Enum;
      case hn.Keyword:
        return e.Keyword;
      case hn.Snippet:
        return e.Snippet;
      case hn.Color:
        return e.Color;
      case hn.File:
        return e.File;
      case hn.Reference:
        return e.Reference;
    }
    return e.Property;
  }
  function Zf(s) {
    if (!!s)
      return {
        range: Ys(s.range),
        text: s.newText
      };
  }
  function Pue(s) {
    return s && s.command === "editor.action.triggerSuggest" ? { id: s.command, title: s.title, arguments: s.arguments } : void 0;
  }
  var a6 = class {
    constructor(s) {
      this._worker = s;
    }
    provideHover(s, e, t) {
      let i = s.uri;
      return this._worker(i).then((n) => n.doHover(i.toString(), jc(e))).then((n) => {
        if (!!n)
          return {
            range: Ys(n.range),
            contents: Bue(n.contents)
          };
      });
    }
  };
  function Fue(s) {
    return s && typeof s == "object" && typeof s.kind == "string";
  }
  function KO(s) {
    return typeof s == "string" ? {
      value: s
    } : Fue(s) ? s.kind === "plaintext" ? {
      value: s.value.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&")
    } : {
      value: s.value
    } : { value: "```" + s.language + `
` + s.value + "\n```\n" };
  }
  function Bue(s) {
    if (!!s)
      return Array.isArray(s) ? s.map(KO) : [KO(s)];
  }
  var Wue = class {
    constructor(s) {
      this._worker = s;
    }
    provideDocumentHighlights(s, e, t) {
      const i = s.uri;
      return this._worker(i).then((n) => n.findDocumentHighlights(i.toString(), jc(e))).then((n) => {
        if (!!n)
          return n.map((o) => ({
            range: Ys(o.range),
            kind: Vue(o.kind)
          }));
      });
    }
  };
  function Vue(s) {
    switch (s) {
      case Om.Read:
        return mt.languages.DocumentHighlightKind.Read;
      case Om.Write:
        return mt.languages.DocumentHighlightKind.Write;
      case Om.Text:
        return mt.languages.DocumentHighlightKind.Text;
    }
    return mt.languages.DocumentHighlightKind.Text;
  }
  var Hue = class {
    constructor(s) {
      this._worker = s;
    }
    provideDefinition(s, e, t) {
      const i = s.uri;
      return this._worker(i).then((n) => n.findDefinition(i.toString(), jc(e))).then((n) => {
        if (!!n)
          return [l6(n)];
      });
    }
  };
  function l6(s) {
    return {
      uri: mt.Uri.parse(s.uri),
      range: Ys(s.range)
    };
  }
  var zue = class {
    constructor(s) {
      this._worker = s;
    }
    provideReferences(s, e, t, i) {
      const n = s.uri;
      return this._worker(n).then((o) => o.findReferences(n.toString(), jc(e))).then((o) => {
        if (!!o)
          return o.map(l6);
      });
    }
  }, Uue = class {
    constructor(s) {
      this._worker = s;
    }
    provideRenameEdits(s, e, t, i) {
      const n = s.uri;
      return this._worker(n).then((o) => o.doRename(n.toString(), jc(e), t)).then((o) => $ue(o));
    }
  };
  function $ue(s) {
    if (!s || !s.changes)
      return;
    let e = [];
    for (let t in s.changes) {
      const i = mt.Uri.parse(t);
      for (let n of s.changes[t])
        e.push({
          resource: i,
          edit: {
            range: Ys(n.range),
            text: n.newText
          }
        });
    }
    return {
      edits: e
    };
  }
  var c6 = class {
    constructor(s) {
      this._worker = s;
    }
    provideDocumentSymbols(s, e) {
      const t = s.uri;
      return this._worker(t).then((i) => i.findDocumentSymbols(t.toString())).then((i) => {
        if (!!i)
          return i.map((n) => ({
            name: n.name,
            detail: "",
            containerName: n.containerName,
            kind: jue(n.kind),
            range: Ys(n.location.range),
            selectionRange: Ys(n.location.range),
            tags: []
          }));
      });
    }
  };
  function jue(s) {
    let e = mt.languages.SymbolKind;
    switch (s) {
      case un.File:
        return e.Array;
      case un.Module:
        return e.Module;
      case un.Namespace:
        return e.Namespace;
      case un.Package:
        return e.Package;
      case un.Class:
        return e.Class;
      case un.Method:
        return e.Method;
      case un.Property:
        return e.Property;
      case un.Field:
        return e.Field;
      case un.Constructor:
        return e.Constructor;
      case un.Enum:
        return e.Enum;
      case un.Interface:
        return e.Interface;
      case un.Function:
        return e.Function;
      case un.Variable:
        return e.Variable;
      case un.Constant:
        return e.Constant;
      case un.String:
        return e.String;
      case un.Number:
        return e.Number;
      case un.Boolean:
        return e.Boolean;
      case un.Array:
        return e.Array;
    }
    return e.Function;
  }
  var Kue = class {
    constructor(s) {
      this._worker = s;
    }
    provideLinks(s, e) {
      const t = s.uri;
      return this._worker(t).then((i) => i.findDocumentLinks(t.toString())).then((i) => {
        if (!!i)
          return {
            links: i.map((n) => ({
              range: Ys(n.range),
              url: n.target
            }))
          };
      });
    }
  }, d6 = class {
    constructor(s) {
      this._worker = s;
    }
    provideDocumentFormattingEdits(s, e, t) {
      const i = s.uri;
      return this._worker(i).then((n) => n.format(i.toString(), null, u6(e)).then((o) => {
        if (!(!o || o.length === 0))
          return o.map(Zf);
      }));
    }
  }, h6 = class {
    constructor(s) {
      this._worker = s;
    }
    provideDocumentRangeFormattingEdits(s, e, t, i) {
      const n = s.uri;
      return this._worker(n).then((o) => o.format(n.toString(), m2(e), u6(t)).then((r) => {
        if (!(!r || r.length === 0))
          return r.map(Zf);
      }));
    }
  };
  function u6(s) {
    return {
      tabSize: s.tabSize,
      insertSpaces: s.insertSpaces
    };
  }
  var f6 = class {
    constructor(s) {
      this._worker = s;
    }
    provideDocumentColors(s, e) {
      const t = s.uri;
      return this._worker(t).then((i) => i.findDocumentColors(t.toString())).then((i) => {
        if (!!i)
          return i.map((n) => ({
            color: n.color,
            range: Ys(n.range)
          }));
      });
    }
    provideColorPresentations(s, e, t) {
      const i = s.uri;
      return this._worker(i).then((n) => n.getColorPresentations(i.toString(), e.color, m2(e.range))).then((n) => {
        if (!!n)
          return n.map((o) => {
            let r = {
              label: o.label
            };
            return o.textEdit && (r.textEdit = Zf(o.textEdit)), o.additionalTextEdits && (r.additionalTextEdits = o.additionalTextEdits.map(Zf)), r;
          });
      });
    }
  }, g6 = class {
    constructor(s) {
      this._worker = s;
    }
    provideFoldingRanges(s, e, t) {
      const i = s.uri;
      return this._worker(i).then((n) => n.getFoldingRanges(i.toString(), e)).then((n) => {
        if (!!n)
          return n.map((o) => {
            const r = {
              start: o.startLine + 1,
              end: o.endLine + 1
            };
            return typeof o.kind < "u" && (r.kind = que(o.kind)), r;
          });
      });
    }
  };
  function que(s) {
    switch (s) {
      case Rm.Comment:
        return mt.languages.FoldingRangeKind.Comment;
      case Rm.Imports:
        return mt.languages.FoldingRangeKind.Imports;
      case Rm.Region:
        return mt.languages.FoldingRangeKind.Region;
    }
  }
  var m6 = class {
    constructor(s) {
      this._worker = s;
    }
    provideSelectionRanges(s, e, t) {
      const i = s.uri;
      return this._worker(i).then((n) => n.getSelectionRanges(i.toString(), e.map(jc))).then((n) => {
        if (!!n)
          return n.map((o) => {
            const r = [];
            for (; o; )
              r.push({ range: Ys(o.range) }), o = o.parent;
            return r;
          });
      });
    }
  };
  function Gue(s, e) {
    e === void 0 && (e = !1);
    var t = s.length, i = 0, n = "", o = 0, r = 16, a = 0, l = 0, c = 0, d = 0, h = 0;
    function u(w, S) {
      for (var L = 0, x = 0; L < w || !S; ) {
        var y = s.charCodeAt(i);
        if (y >= 48 && y <= 57)
          x = x * 16 + y - 48;
        else if (y >= 65 && y <= 70)
          x = x * 16 + y - 65 + 10;
        else if (y >= 97 && y <= 102)
          x = x * 16 + y - 97 + 10;
        else
          break;
        i++, L++;
      }
      return L < w && (x = -1), x;
    }
    function f(w) {
      i = w, n = "", o = 0, r = 16, h = 0;
    }
    function g() {
      var w = i;
      if (s.charCodeAt(i) === 48)
        i++;
      else
        for (i++; i < s.length && gu(s.charCodeAt(i)); )
          i++;
      if (i < s.length && s.charCodeAt(i) === 46)
        if (i++, i < s.length && gu(s.charCodeAt(i)))
          for (i++; i < s.length && gu(s.charCodeAt(i)); )
            i++;
        else
          return h = 3, s.substring(w, i);
      var S = i;
      if (i < s.length && (s.charCodeAt(i) === 69 || s.charCodeAt(i) === 101))
        if (i++, (i < s.length && s.charCodeAt(i) === 43 || s.charCodeAt(i) === 45) && i++, i < s.length && gu(s.charCodeAt(i))) {
          for (i++; i < s.length && gu(s.charCodeAt(i)); )
            i++;
          S = i;
        } else
          h = 3;
      return s.substring(w, S);
    }
    function _() {
      for (var w = "", S = i; ; ) {
        if (i >= t) {
          w += s.substring(S, i), h = 2;
          break;
        }
        var L = s.charCodeAt(i);
        if (L === 34) {
          w += s.substring(S, i), i++;
          break;
        }
        if (L === 92) {
          if (w += s.substring(S, i), i++, i >= t) {
            h = 2;
            break;
          }
          var x = s.charCodeAt(i++);
          switch (x) {
            case 34:
              w += '"';
              break;
            case 92:
              w += "\\";
              break;
            case 47:
              w += "/";
              break;
            case 98:
              w += "\b";
              break;
            case 102:
              w += "\f";
              break;
            case 110:
              w += `
`;
              break;
            case 114:
              w += "\r";
              break;
            case 116:
              w += "	";
              break;
            case 117:
              var y = u(4, !0);
              y >= 0 ? w += String.fromCharCode(y) : h = 4;
              break;
            default:
              h = 5;
          }
          S = i;
          continue;
        }
        if (L >= 0 && L <= 31)
          if ($g(L)) {
            w += s.substring(S, i), h = 2;
            break;
          } else
            h = 6;
        i++;
      }
      return w;
    }
    function b() {
      if (n = "", h = 0, o = i, l = a, d = c, i >= t)
        return o = t, r = 17;
      var w = s.charCodeAt(i);
      if (Py(w)) {
        do
          i++, n += String.fromCharCode(w), w = s.charCodeAt(i);
        while (Py(w));
        return r = 15;
      }
      if ($g(w))
        return i++, n += String.fromCharCode(w), w === 13 && s.charCodeAt(i) === 10 && (i++, n += `
`), a++, c = i, r = 14;
      switch (w) {
        case 123:
          return i++, r = 1;
        case 125:
          return i++, r = 2;
        case 91:
          return i++, r = 3;
        case 93:
          return i++, r = 4;
        case 58:
          return i++, r = 6;
        case 44:
          return i++, r = 5;
        case 34:
          return i++, n = _(), r = 10;
        case 47:
          var S = i - 1;
          if (s.charCodeAt(i + 1) === 47) {
            for (i += 2; i < t && !$g(s.charCodeAt(i)); )
              i++;
            return n = s.substring(S, i), r = 12;
          }
          if (s.charCodeAt(i + 1) === 42) {
            i += 2;
            for (var L = t - 1, x = !1; i < L; ) {
              var y = s.charCodeAt(i);
              if (y === 42 && s.charCodeAt(i + 1) === 47) {
                i += 2, x = !0;
                break;
              }
              i++, $g(y) && (y === 13 && s.charCodeAt(i) === 10 && i++, a++, c = i);
            }
            return x || (i++, h = 1), n = s.substring(S, i), r = 13;
          }
          return n += String.fromCharCode(w), i++, r = 16;
        case 45:
          if (n += String.fromCharCode(w), i++, i === t || !gu(s.charCodeAt(i)))
            return r = 16;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return n += g(), r = 11;
        default:
          for (; i < t && C(w); )
            i++, w = s.charCodeAt(i);
          if (o !== i) {
            switch (n = s.substring(o, i), n) {
              case "true":
                return r = 8;
              case "false":
                return r = 9;
              case "null":
                return r = 7;
            }
            return r = 16;
          }
          return n += String.fromCharCode(w), i++, r = 16;
      }
    }
    function C(w) {
      if (Py(w) || $g(w))
        return !1;
      switch (w) {
        case 125:
        case 93:
        case 123:
        case 91:
        case 34:
        case 58:
        case 44:
        case 47:
          return !1;
      }
      return !0;
    }
    function v() {
      var w;
      do
        w = b();
      while (w >= 12 && w <= 15);
      return w;
    }
    return {
      setPosition: f,
      getPosition: function() {
        return i;
      },
      scan: e ? v : b,
      getToken: function() {
        return r;
      },
      getTokenValue: function() {
        return n;
      },
      getTokenOffset: function() {
        return o;
      },
      getTokenLength: function() {
        return i - o;
      },
      getTokenStartLine: function() {
        return l;
      },
      getTokenStartCharacter: function() {
        return o - d;
      },
      getTokenError: function() {
        return h;
      }
    };
  }
  function Py(s) {
    return s === 32 || s === 9 || s === 11 || s === 12 || s === 160 || s === 5760 || s >= 8192 && s <= 8203 || s === 8239 || s === 8287 || s === 12288 || s === 65279;
  }
  function $g(s) {
    return s === 10 || s === 13 || s === 8232 || s === 8233;
  }
  function gu(s) {
    return s >= 48 && s <= 57;
  }
  var qO;
  (function(s) {
    s.DEFAULT = {
      allowTrailingComma: !1
    };
  })(qO || (qO = {}));
  var Zue = Gue;
  function Yue(s) {
    return {
      getInitialState: () => new wv(null, null, !1, null),
      tokenize: (e, t) => rfe(s, e, t)
    };
  }
  var GO = "delimiter.bracket.json", ZO = "delimiter.array.json", Xue = "delimiter.colon.json", Que = "delimiter.comma.json", Jue = "keyword.json", efe = "keyword.json", tfe = "string.value.json", ife = "number.json", nfe = "string.key.json", sfe = "comment.block.json", ofe = "comment.line.json", Vu = class {
    constructor(s, e) {
      this.parent = s, this.type = e;
    }
    static pop(s) {
      return s ? s.parent : null;
    }
    static push(s, e) {
      return new Vu(s, e);
    }
    static equals(s, e) {
      if (!s && !e)
        return !0;
      if (!s || !e)
        return !1;
      for (; s && e; ) {
        if (s === e)
          return !0;
        if (s.type !== e.type)
          return !1;
        s = s.parent, e = e.parent;
      }
      return !0;
    }
  }, wv = class {
    _state;
    scanError;
    lastWasColon;
    parents;
    constructor(s, e, t, i) {
      this._state = s, this.scanError = e, this.lastWasColon = t, this.parents = i;
    }
    clone() {
      return new wv(this._state, this.scanError, this.lastWasColon, this.parents);
    }
    equals(s) {
      return s === this ? !0 : !s || !(s instanceof wv) ? !1 : this.scanError === s.scanError && this.lastWasColon === s.lastWasColon && Vu.equals(this.parents, s.parents);
    }
    getStateData() {
      return this._state;
    }
    setStateData(s) {
      this._state = s;
    }
  };
  function rfe(s, e, t, i = 0) {
    let n = 0, o = !1;
    switch (t.scanError) {
      case 2:
        e = '"' + e, n = 1;
        break;
      case 1:
        e = "/*" + e, n = 2;
        break;
    }
    const r = Zue(e);
    let a = t.lastWasColon, l = t.parents;
    const c = {
      tokens: [],
      endState: t.clone()
    };
    for (; ; ) {
      let d = i + r.getPosition(), h = "";
      const u = r.scan();
      if (u === 17)
        break;
      if (d === i + r.getPosition())
        throw new Error("Scanner did not advance, next 3 characters are: " + e.substr(r.getPosition(), 3));
      switch (o && (d -= n), o = n > 0, u) {
        case 1:
          l = Vu.push(l, 0), h = GO, a = !1;
          break;
        case 2:
          l = Vu.pop(l), h = GO, a = !1;
          break;
        case 3:
          l = Vu.push(l, 1), h = ZO, a = !1;
          break;
        case 4:
          l = Vu.pop(l), h = ZO, a = !1;
          break;
        case 6:
          h = Xue, a = !0;
          break;
        case 5:
          h = Que, a = !1;
          break;
        case 8:
        case 9:
          h = Jue, a = !1;
          break;
        case 7:
          h = efe, a = !1;
          break;
        case 10:
          const g = (l ? l.type : 0) === 1;
          h = a || g ? tfe : nfe, a = !1;
          break;
        case 11:
          h = ife, a = !1;
          break;
      }
      if (s)
        switch (u) {
          case 12:
            h = ofe;
            break;
          case 13:
            h = sfe;
            break;
        }
      c.endState = new wv(t.getStateData(), r.getTokenError(), a, l), c.tokens.push({
        startIndex: d,
        scopes: h
      });
    }
    return c;
  }
  var afe = class extends o6 {
    constructor(s, e, t) {
      super(s, e, t.onDidChange), this._disposables.push(mt.editor.onWillDisposeModel((i) => {
        this._resetSchema(i.uri);
      })), this._disposables.push(mt.editor.onDidChangeModelLanguage((i) => {
        this._resetSchema(i.model.uri);
      }));
    }
    _resetSchema(s) {
      this._worker().then((e) => {
        e.resetSchema(s.toString());
      });
    }
  };
  function lfe(s) {
    const e = [], t = [], i = new s6(s);
    e.push(i);
    const n = (...a) => i.getLanguageServiceWorker(...a);
    function o() {
      const { languageId: a, modeConfiguration: l } = s;
      p6(t), l.documentFormattingEdits && t.push(mt.languages.registerDocumentFormattingEditProvider(a, new d6(n))), l.documentRangeFormattingEdits && t.push(mt.languages.registerDocumentRangeFormattingEditProvider(a, new h6(n))), l.completionItems && t.push(mt.languages.registerCompletionItemProvider(a, new r6(n, [" ", ":", '"']))), l.hovers && t.push(mt.languages.registerHoverProvider(a, new a6(n))), l.documentSymbols && t.push(mt.languages.registerDocumentSymbolProvider(a, new c6(n))), l.tokens && t.push(mt.languages.setTokensProvider(a, Yue(!0))), l.colors && t.push(mt.languages.registerColorProvider(a, new f6(n))), l.foldingRanges && t.push(mt.languages.registerFoldingRangeProvider(a, new g6(n))), l.diagnostics && t.push(new afe(a, n, s)), l.selectionRanges && t.push(mt.languages.registerSelectionRangeProvider(a, new m6(n)));
    }
    o(), e.push(mt.languages.setLanguageConfiguration(s.languageId, cfe));
    let r = s.modeConfiguration;
    return s.onDidChange((a) => {
      a.modeConfiguration !== r && (r = a.modeConfiguration, o());
    }), e.push(YO(t)), YO(e);
  }
  function YO(s) {
    return { dispose: () => p6(s) };
  }
  function p6(s) {
    for (; s.length; )
      s.pop().dispose();
  }
  var cfe = {
    wordPattern: /(-?\d*\.\d\w*)|([^\[\{\]\}\:\"\,\s]+)/g,
    comments: {
      lineComment: "//",
      blockComment: ["/*", "*/"]
    },
    brackets: [
      ["{", "}"],
      ["[", "]"]
    ],
    autoClosingPairs: [
      { open: "{", close: "}", notIn: ["string"] },
      { open: "[", close: "]", notIn: ["string"] },
      { open: '"', close: '"', notIn: ["string"] }
    ]
  };
  const dfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CompletionAdapter: r6,
    DefinitionAdapter: Hue,
    DiagnosticsAdapter: o6,
    DocumentColorAdapter: f6,
    DocumentFormattingEditProvider: d6,
    DocumentHighlightAdapter: Wue,
    DocumentLinkAdapter: Kue,
    DocumentRangeFormattingEditProvider: h6,
    DocumentSymbolAdapter: c6,
    FoldingRangeAdapter: g6,
    HoverAdapter: a6,
    ReferenceAdapter: zue,
    RenameAdapter: Uue,
    SelectionRangeAdapter: m6,
    WorkerManager: s6,
    fromPosition: jc,
    fromRange: m2,
    setupMode: lfe,
    toRange: Ys,
    toTextEdit: Zf
  }, Symbol.toStringTag, { value: "Module" }));
  var _6 = { exports: {} };
  /*!
    Copyright (c) 2018 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  (function(s) {
    (function() {
      var e = {}.hasOwnProperty;
      function t() {
        for (var i = [], n = 0; n < arguments.length; n++) {
          var o = arguments[n];
          if (!!o) {
            var r = typeof o;
            if (r === "string" || r === "number")
              i.push(o);
            else if (Array.isArray(o)) {
              if (o.length) {
                var a = t.apply(null, o);
                a && i.push(a);
              }
            } else if (r === "object")
              if (o.toString === Object.prototype.toString)
                for (var l in o)
                  e.call(o, l) && o[l] && i.push(l);
              else
                i.push(o.toString());
          }
        }
        return i.join(" ");
      }
      s.exports ? (t.default = t, s.exports = t) : window.classNames = t;
    })();
  })(_6);
  const Mt = _6.exports;
  function hfe(s) {
    let e, t, i;
    return {
      c() {
        e = Ie("small"), t = Mi(s[0]), this.c = Le, X(e, "class", i = Mt("rounded-full px-3 py-0.5 text-xs", {
          "text-green-900 bg-green-200": s[1] === "green",
          "text-orange-900 bg-orange-200": s[1] === "orange",
          "text-red-900 bg-red-200": s[1] === "red",
          "text-gray-800 bg-gray-200": s[1] === "gray"
        }));
      },
      m(n, o) {
        Te(n, e, o), _e(e, t);
      },
      p(n, [o]) {
        o & 1 && Zi(t, n[0]), o & 2 && i !== (i = Mt("rounded-full px-3 py-0.5 text-xs", {
          "text-green-900 bg-green-200": n[1] === "green",
          "text-orange-900 bg-orange-200": n[1] === "orange",
          "text-red-900 bg-red-200": n[1] === "red",
          "text-gray-800 bg-gray-200": n[1] === "gray"
        })) && X(e, "class", i);
      },
      i: Le,
      o: Le,
      d(n) {
        n && Qe(e);
      }
    };
  }
  function ufe(s, e, t) {
    let { label: i = "" } = e, { variant: n = "gray" } = e;
    return dn(), s.$$set = (o) => {
      "label" in o && t(0, i = o.label), "variant" in o && t(1, n = o.variant);
    }, [i, n];
  }
  class b6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, ufe, hfe, Cn, { label: 0, variant: 1 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["label", "variant"];
    }
    get label() {
      return this.$$.ctx[0];
    }
    set label(e) {
      this.$$set({ label: e }), we();
    }
    get variant() {
      return this.$$.ctx[1];
    }
    set variant(e) {
      this.$$set({ variant: e }), we();
    }
  }
  customElements.define("v-badge", b6);
  const ffe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: b6
  }, Symbol.toStringTag, { value: "Module" }));
  function XO(s, e, t) {
    const i = s.slice();
    return i[2] = e[t], i[4] = t, i;
  }
  function QO(s) {
    let e;
    return {
      c() {
        e = Ie("div"), e.innerHTML = `<div class="w-px h-[60%] border-l border-black -rotate-[30deg] -mt-px"></div> 
        <div class="w-px h-[60%] border-l border-black rotate-[30deg] -mt-0.5"></div> 
      `;
      },
      m(t, i) {
        Te(t, e, i);
      },
      d(t) {
        t && Qe(e);
      }
    };
  }
  function JO(s, e) {
    let t, i = e[2] + "", n, o, r, a = e[4] !== e[0].length - 1 && QO();
    return {
      key: s,
      first: null,
      c() {
        t = Ie("small"), n = Mi(i), o = Kt(), a && a.c(), r = sI(), X(t, "class", "py1"), this.first = t;
      },
      m(l, c) {
        Te(l, t, c), _e(t, n), Te(l, o, c), a && a.m(l, c), Te(l, r, c);
      },
      p(l, c) {
        e = l, c & 1 && i !== (i = e[2] + "") && Zi(n, i), e[4] !== e[0].length - 1 ? a || (a = QO(), a.c(), a.m(r.parentNode, r)) : a && (a.d(1), a = null);
      },
      d(l) {
        l && Qe(t), l && Qe(o), a && a.d(l), l && Qe(r);
      }
    };
  }
  function gfe(s) {
    let e, t = [], i = /* @__PURE__ */ new Map(), n = s[0];
    const o = (r) => r[2];
    for (let r = 0; r < n.length; r += 1) {
      let a = XO(s, n, r), l = o(a);
      i.set(l, t[r] = JO(l, a));
    }
    return {
      c() {
        e = Ie("div");
        for (let r = 0; r < t.length; r += 1)
          t[r].c();
        this.c = Le, X(e, "class", "inline-flex gap-3 px-4 border border-black rounded-full");
      },
      m(r, a) {
        Te(r, e, a);
        for (let l = 0; l < t.length; l += 1)
          t[l].m(e, null);
      },
      p(r, [a]) {
        a & 1 && (n = r[0], t = rI(t, a, o, 1, r, n, i, e, oI, JO, null, XO));
      },
      i: Le,
      o: Le,
      d(r) {
        r && Qe(e);
        for (let a = 0; a < t.length; a += 1)
          t[a].d();
      }
    };
  }
  function mfe(s, e, t) {
    let { crumbs: i = "" } = e;
    dn();
    let n;
    return s.$$set = (o) => {
      "crumbs" in o && t(1, i = o.crumbs);
    }, s.$$.update = () => {
      s.$$.dirty & 2 && t(0, n = i.split(",").map((o) => o.trim()));
    }, [n, i];
  }
  class v6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, mfe, gfe, Cn, { crumbs: 1 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["crumbs"];
    }
    get crumbs() {
      return this.$$.ctx[1];
    }
    set crumbs(e) {
      this.$$set({ crumbs: e }), we();
    }
  }
  customElements.define("v-breadcrumbs", v6);
  const pfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: v6
  }, Symbol.toStringTag, { value: "Module" }));
  function e4(s) {
    let e, t;
    return {
      c() {
        e = Ie("i"), X(e, "aria-hidden", ""), X(e, "class", t = "icon-" + s[4] + " text-base");
      },
      m(i, n) {
        Te(i, e, n);
      },
      p(i, n) {
        n & 16 && t !== (t = "icon-" + i[4] + " text-base") && X(e, "class", t);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function _fe(s) {
    let e, t, i, n, o, r, a = s[4] && e4(s);
    return {
      c() {
        e = Ie("button"), a && a.c(), t = Kt(), i = Mi(s[3]), this.c = Le, X(e, "type", s[1]), X(e, "class", n = Mt("flex items-center gap-1.5 py-1.5 px-2 text-xs border", {
          "cursor-not-allowed opacity-50 pointer-events-none": s[0] === "true",
          "bg-white border-black": s[2] === "primary",
          "bg-red/90 text-white border-red/90": s[2] === "danger",
          "bg-green/90 border-green/90 text-white": s[2] === "success",
          "bg-white border-red/90 text-red/90": s[2] === "outline-danger"
        }));
      },
      m(l, c) {
        Te(l, e, c), a && a.m(e, null), _e(e, t), _e(e, i), o || (r = bi(e, "click", s[5]), o = !0);
      },
      p(l, [c]) {
        l[4] ? a ? a.p(l, c) : (a = e4(l), a.c(), a.m(e, t)) : a && (a.d(1), a = null), c & 8 && Zi(i, l[3]), c & 2 && X(e, "type", l[1]), c & 5 && n !== (n = Mt("flex items-center gap-1.5 py-1.5 px-2 text-xs border", {
          "cursor-not-allowed opacity-50 pointer-events-none": l[0] === "true",
          "bg-white border-black": l[2] === "primary",
          "bg-red/90 text-white border-red/90": l[2] === "danger",
          "bg-green/90 border-green/90 text-white": l[2] === "success",
          "bg-white border-red/90 text-red/90": l[2] === "outline-danger"
        })) && X(e, "class", n);
      },
      i: Le,
      o: Le,
      d(l) {
        l && Qe(e), a && a.d(), o = !1, r();
      }
    };
  }
  function bfe(s, e, t) {
    let { disabled: i = "false" } = e, { type: n = "button" } = e, { variant: o = "primary" } = e, { label: r = "" } = e, { icon: a = "" } = e;
    dn();
    const c = Xf().attachInternals(), d = () => {
      const { form: h } = c;
      h?.requestSubmit ? h.requestSubmit() : h?.submit();
    };
    return s.$$set = (h) => {
      "disabled" in h && t(0, i = h.disabled), "type" in h && t(1, n = h.type), "variant" in h && t(2, o = h.variant), "label" in h && t(3, r = h.label), "icon" in h && t(4, a = h.icon);
    }, [i, n, o, r, a, d];
  }
  class vfe extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, bfe, _fe, Cn, {
        disabled: 0,
        type: 1,
        variant: 2,
        label: 3,
        icon: 4
      }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["disabled", "type", "variant", "label", "icon"];
    }
    get disabled() {
      return this.$$.ctx[0];
    }
    set disabled(e) {
      this.$$set({ disabled: e }), we();
    }
    get type() {
      return this.$$.ctx[1];
    }
    set type(e) {
      this.$$set({ type: e }), we();
    }
    get variant() {
      return this.$$.ctx[2];
    }
    set variant(e) {
      this.$$set({ variant: e }), we();
    }
    get label() {
      return this.$$.ctx[3];
    }
    set label(e) {
      this.$$set({ label: e }), we();
    }
    get icon() {
      return this.$$.ctx[4];
    }
    set icon(e) {
      this.$$set({ icon: e }), we();
    }
  }
  customElements.define("v-button-internal", vfe);
  class Cfe extends customElements.get("v-button-internal") {
    static formAssociated = !0;
  }
  customElements.define("v-button", Cfe);
  const wfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null
  }, Symbol.toStringTag, { value: "Module" })), { window: Sfe } = lB;
  function yfe(s) {
    let e, t, i;
    return {
      c() {
        e = Ie("div"), this.c = Le, X(e, "class", "w-full h-full relative isolate");
      },
      m(n, o) {
        Te(n, e, o), s[9](e), t || (i = bi(Sfe, "resize", s[8]), t = !0);
      },
      p: Le,
      i: Le,
      o: Le,
      d(n) {
        n && Qe(e), s[9](null), t = !1, i();
      }
    };
  }
  function Lfe(s, e, t) {
    let { id: i } = e, { value: n } = e, { language: o } = e, { theme: r = "vs" } = e, { readonly: a = !1 } = e, { minimap: l = !1 } = e, c, d = null;
    const h = () => {
      d?.getModel()?.dispose();
      const _ = tm.createModel(n, o);
      console.log("model", _), d?.setModel(_);
    };
    dn(), tB(() => {
      t(1, d = tm.create(c, {
        value: n,
        language: o,
        theme: r,
        readOnly: a,
        minimap: { enabled: l },
        scrollbar: {
          verticalScrollbarSize: 3,
          horizontalScrollbarSize: 3,
          vertical: "auto",
          horizontal: "auto",
          alwaysConsumeMouseWheel: !1
        },
        scrollBeyondLastLine: !1
      }));
      const g = d?.getDomNode() ?? c;
      d.onDidChangeModelContent(() => go(g, "input", { value: d?.getValue() })), d.onDidBlurEditorWidget(() => {
        const _ = tm.getModelMarkers({});
        go(g, "updateMarkers", { markers: _ }), go(g, "blur", { value: d?.getValue() });
      }), d.layout(), h(), window.setTimeout(() => {
        const _ = tm.getModelMarkers({});
        go(g, "updateMarkers", _);
      });
    }), nB(() => {
      d?.getModel()?.dispose(), d?.dispose();
    }), iB(() => {
      h();
      let g = d?.getValue() ?? "";
      const _ = gO(n), b = gO(g);
      console.log("update", { originalFormatted: _, updatedFormatted: b }), b !== _ && d?.setValue(g);
    });
    const u = () => d?.layout();
    function f(g) {
      ds[g ? "unshift" : "push"](() => {
        c = g, t(0, c);
      });
    }
    return s.$$set = (g) => {
      "id" in g && t(2, i = g.id), "value" in g && t(3, n = g.value), "language" in g && t(4, o = g.language), "theme" in g && t(5, r = g.theme), "readonly" in g && t(6, a = g.readonly), "minimap" in g && t(7, l = g.minimap);
    }, [
      c,
      d,
      i,
      n,
      o,
      r,
      a,
      l,
      u,
      f
    ];
  }
  class C6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, Lfe, yfe, Cn, {
        id: 2,
        value: 3,
        language: 4,
        theme: 5,
        readonly: 6,
        minimap: 7
      }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["id", "value", "language", "theme", "readonly", "minimap"];
    }
    get id() {
      return this.$$.ctx[2];
    }
    set id(e) {
      this.$$set({ id: e }), we();
    }
    get value() {
      return this.$$.ctx[3];
    }
    set value(e) {
      this.$$set({ value: e }), we();
    }
    get language() {
      return this.$$.ctx[4];
    }
    set language(e) {
      this.$$set({ language: e }), we();
    }
    get theme() {
      return this.$$.ctx[5];
    }
    set theme(e) {
      this.$$set({ theme: e }), we();
    }
    get readonly() {
      return this.$$.ctx[6];
    }
    set readonly(e) {
      this.$$set({ readonly: e }), we();
    }
    get minimap() {
      return this.$$.ctx[7];
    }
    set minimap(e) {
      this.$$set({ minimap: e }), we();
    }
  }
  customElements.define("v-code-editor", C6);
  const kfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: C6
  }, Symbol.toStringTag, { value: "Module" }));
  function t4(s) {
    let e, t;
    return {
      c() {
        e = Ie("h2"), t = Mi(s[1]), X(e, "class", "text-sm");
      },
      m(i, n) {
        Te(i, e, n), _e(e, t);
      },
      p(i, n) {
        n & 2 && Zi(t, i[1]);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function Dfe(s) {
    let e, t, i, n, o, r, a, l, c, d, h, u, f, g, _, b, C, v, w = s[1] && t4(s);
    return {
      c() {
        e = Ie("div"), t = Ie("div"), i = Ie("div"), w && w.c(), n = Kt(), o = Ie("slot"), r = Kt(), a = Ie("div"), l = Ie("slot"), c = Kt(), d = Hd("svg"), h = Hd("polyline"), f = Kt(), g = Ie("div"), _ = Ie("slot"), this.c = Le, X(o, "name", "title"), X(i, "class", "flex items-center gap-2"), X(l, "name", "header"), X(h, "points", "6 9 12 15 18 9"), X(d, "class", u = Mt("transition-transform duration-200", {
          "rotate-0": !s[0],
          "rotate-180": s[0]
        })), X(d, "width", "24"), X(d, "height", "24"), X(d, "viewBox", "0 0 24 24"), X(d, "stroke", "currentColor"), X(d, "stroke-linejoin", "round"), X(d, "stroke-linecap", "round"), X(d, "fill", "none"), X(a, "class", "h-full flex items-center gap-3"), X(t, "class", "w-full py-1.5 px-4 flex items-center justify-between border text-black border-black bg-white cursor-pointer"), X(g, "class", b = Mt("bg-white text-black overflow-hidden transition-all duration-500", {
          "max-h-0": !s[0],
          "max-h-fit": s[0]
        })), X(e, "class", "relative w-full overflow-hidden");
      },
      m(S, L) {
        Te(S, e, L), _e(e, t), _e(t, i), w && w.m(i, null), _e(i, n), _e(i, o), _e(t, r), _e(t, a), _e(a, l), _e(a, c), _e(a, d), _e(d, h), _e(e, f), _e(e, g), _e(g, _), s[4](e), C || (v = bi(t, "click", s[3]), C = !0);
      },
      p(S, [L]) {
        S[1] ? w ? w.p(S, L) : (w = t4(S), w.c(), w.m(i, n)) : w && (w.d(1), w = null), L & 1 && u !== (u = Mt("transition-transform duration-200", {
          "rotate-0": !S[0],
          "rotate-180": S[0]
        })) && X(d, "class", u), L & 1 && b !== (b = Mt("bg-white text-black overflow-hidden transition-all duration-500", {
          "max-h-0": !S[0],
          "max-h-fit": S[0]
        })) && X(g, "class", b);
      },
      i: Le,
      o: Le,
      d(S) {
        S && Qe(e), w && w.d(), s[4](null), C = !1, v();
      }
    };
  }
  function xfe(s, e, t) {
    let { title: i = "" } = e, { open: n = !1 } = e, o;
    dn();
    const r = (l) => {
      l.target.getAttribute("slot") !== "header" && (t(0, n = !n), go(o, "toggle", { open: n }));
    };
    function a(l) {
      ds[l ? "unshift" : "push"](() => {
        o = l, t(2, o);
      });
    }
    return s.$$set = (l) => {
      "title" in l && t(1, i = l.title), "open" in l && t(0, n = l.open);
    }, [n, i, o, r, a];
  }
  class w6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, xfe, Dfe, Cn, { title: 1, open: 0 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["title", "open"];
    }
    get title() {
      return this.$$.ctx[1];
    }
    set title(e) {
      this.$$set({ title: e }), we();
    }
    get open() {
      return this.$$.ctx[0];
    }
    set open(e) {
      this.$$set({ open: e }), we();
    }
  }
  customElements.define("v-collapse", w6);
  const Ife = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: w6
  }, Symbol.toStringTag, { value: "Module" }));
  function Efe(s) {
    let e, t, i, n, o, r, a, l;
    return {
      c() {
        e = Ie("div"), t = Ie("div"), t.innerHTML = '<slot name="target"></slot>', i = Kt(), n = Ie("div"), o = Ie("slot"), this.c = Le, X(t, "class", "inline-block"), X(o, "name", "content"), X(n, "class", r = Mt("absolute z-10", {
          "left-0": s[1],
          "right-0": s[1],
          "overflow-hidden": s[1],
          invisible: !s[0]
        })), X(e, "class", "relative inline-block");
      },
      m(c, d) {
        Te(c, e, d), _e(e, t), _e(e, i), _e(e, n), _e(n, o), s[4](e), a || (l = bi(t, "click", s[3]), a = !0);
      },
      p(c, [d]) {
        d & 3 && r !== (r = Mt("absolute z-10", {
          "left-0": c[1],
          "right-0": c[1],
          "overflow-hidden": c[1],
          invisible: !c[0]
        })) && X(n, "class", r);
      },
      i: Le,
      o: Le,
      d(c) {
        c && Qe(e), s[4](null), a = !1, l();
      }
    };
  }
  function Nfe(s, e, t) {
    let { open: i = null } = e, { match: n = null } = e, o;
    dn();
    const r = () => {
      t(0, i = !i), go(o, "toggle", { open: i });
    };
    function a(l) {
      ds[l ? "unshift" : "push"](() => {
        o = l, t(2, o);
      });
    }
    return s.$$set = (l) => {
      "open" in l && t(0, i = l.open), "match" in l && t(1, n = l.match);
    }, s.$$.update = () => {
      s.$$.dirty & 2 && t(1, n = n === ""), s.$$.dirty & 1 && t(0, i = i === "" || i);
    }, [i, n, o, r, a];
  }
  class S6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, Nfe, Efe, Cn, { open: 0, match: 1 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["open", "match"];
    }
    get open() {
      return this.$$.ctx[0];
    }
    set open(e) {
      this.$$set({ open: e }), we();
    }
    get match() {
      return this.$$.ctx[1];
    }
    set match(e) {
      this.$$set({ match: e }), we();
    }
  }
  customElements.define("v-dropdown", S6);
  const Tfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: S6
  }, Symbol.toStringTag, { value: "Module" }));
  function Mfe(s) {
    let e, t;
    return {
      c() {
        e = Ie("i"), this.c = Le, X(e, "aria-hidden", ""), X(e, "class", t = "icon-" + s[0] + " text-" + s[1]);
      },
      m(i, n) {
        Te(i, e, n);
      },
      p(i, [n]) {
        n & 3 && t !== (t = "icon-" + i[0] + " text-" + i[1]) && X(e, "class", t);
      },
      i: Le,
      o: Le,
      d(i) {
        i && Qe(e);
      }
    };
  }
  function Afe(s, e, t) {
    let { name: i = "" } = e, { size: n = "base" } = e;
    return dn(), s.$$set = (o) => {
      "name" in o && t(0, i = o.name), "size" in o && t(1, n = o.size);
    }, [i, n];
  }
  class y6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, Afe, Mfe, Cn, { name: 0, size: 1 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["name", "size"];
    }
    get name() {
      return this.$$.ctx[0];
    }
    set name(e) {
      this.$$set({ name: e }), we();
    }
    get size() {
      return this.$$.ctx[1];
    }
    set size(e) {
      this.$$set({ size: e }), we();
    }
  }
  customElements.define("v-icon", y6);
  const Rfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: y6
  }, Symbol.toStringTag, { value: "Module" }));
  function i4(s) {
    let e, t, i;
    return {
      c() {
        e = Ie("p"), t = Mi(s[3]), X(e, "class", i = Mt("text-xs", {
          "inline whitespace-nowrap": s[5] === "left"
        }));
      },
      m(n, o) {
        Te(n, e, o), _e(e, t);
      },
      p(n, o) {
        o & 8 && Zi(t, n[3]), o & 32 && i !== (i = Mt("text-xs", {
          "inline whitespace-nowrap": n[5] === "left"
        })) && X(e, "class", i);
      },
      d(n) {
        n && Qe(e);
      }
    };
  }
  function n4(s) {
    let e, t, i, n, o, r, a, l;
    return {
      c() {
        e = Ie("div"), t = Ie("button"), n = Kt(), o = Ie("button"), X(t, "aria-label", i = "Increment up by " + s[9]), X(t, "class", "icon-chevron-down rotate-180 text-[15px]"), X(o, "aria-label", r = "Increment down by " + s[9]), X(o, "class", "icon-chevron-down text-[15px]"), X(e, "class", "absolute right-0.5 bottom-0 cursor-pointer select-none flex flex-col");
      },
      m(c, d) {
        Te(c, e, d), _e(e, t), _e(e, n), _e(e, o), a || (l = [
          bi(t, "click", s[15]),
          bi(o, "click", s[16])
        ], a = !0);
      },
      p(c, d) {
        d & 512 && i !== (i = "Increment up by " + c[9]) && X(t, "aria-label", i), d & 512 && r !== (r = "Increment down by " + c[9]) && X(o, "aria-label", r);
      },
      d(c) {
        c && Qe(e), a = !1, Cl(l);
      }
    };
  }
  function Ofe(s) {
    let e, t, i, n, o, r, a, l = s[3] && i4(s), c = s[1] === "number" && n4(s);
    return {
      c() {
        e = Ie("label"), l && l.c(), t = Kt(), i = Ie("input"), n = Kt(), c && c.c(), this.c = Le, X(i, "type", s[1]), X(i, "placeholder", s[2]), X(i, "name", s[4]), i.value = s[0], i.readOnly = s[8], X(i, "class", "w-full py-1.5 px-2.5 border text-xs border-black bg-white outline-none appearance-none"), X(e, "class", o = Mt("relative flex gap-1 max-w-[14rem]", {
          "flex-col": s[5] === "top",
          "items-center": s[5] === "left"
        }));
      },
      m(d, h) {
        Te(d, e, h), l && l.m(e, null), _e(e, t), _e(e, i), s[14](i), _e(e, n), c && c.m(e, null), s[17](e), r || (a = bi(i, "input", s[10]), r = !0);
      },
      p(d, [h]) {
        d[3] ? l ? l.p(d, h) : (l = i4(d), l.c(), l.m(e, t)) : l && (l.d(1), l = null), h & 2 && X(i, "type", d[1]), h & 4 && X(i, "placeholder", d[2]), h & 16 && X(i, "name", d[4]), h & 1 && i.value !== d[0] && (i.value = d[0]), h & 256 && (i.readOnly = d[8]), d[1] === "number" ? c ? c.p(d, h) : (c = n4(d), c.c(), c.m(e, null)) : c && (c.d(1), c = null), h & 32 && o !== (o = Mt("relative flex gap-1 max-w-[14rem]", {
          "flex-col": d[5] === "top",
          "items-center": d[5] === "left"
        })) && X(e, "class", o);
      },
      i: Le,
      o: Le,
      d(d) {
        d && Qe(e), l && l.d(), s[14](null), c && c.d(), s[17](null), r = !1, a();
      }
    };
  }
  function Pfe(s, e, t) {
    const n = Xf().attachInternals();
    let { type: o = "text" } = e, { placeholder: r = "" } = e, { readonly: a = "false" } = e, { label: l = "" } = e, { value: c = "" } = e, { step: d = "1" } = e, { name: h = "" } = e, { labelposition: u = "top" } = e, f, g, _, b;
    dn();
    const C = (y) => {
      y.preventDefault(), y.stopImmediatePropagation(), t(0, c = g.value), n.setFormValue(c), go(f, "input", { value: c });
    }, v = (y) => {
      const k = Number.parseFloat(c || "0");
      t(0, c = t(7, g.value = String(k + b * y), g)), n.setFormValue(c), go(f, "input", { value: c });
    };
    function w(y) {
      ds[y ? "unshift" : "push"](() => {
        g = y, t(7, g);
      });
    }
    const S = () => v(1), L = () => v(-1);
    function x(y) {
      ds[y ? "unshift" : "push"](() => {
        f = y, t(6, f);
      });
    }
    return s.$$set = (y) => {
      "type" in y && t(1, o = y.type), "placeholder" in y && t(2, r = y.placeholder), "readonly" in y && t(12, a = y.readonly), "label" in y && t(3, l = y.label), "value" in y && t(0, c = y.value), "step" in y && t(13, d = y.step), "name" in y && t(4, h = y.name), "labelposition" in y && t(5, u = y.labelposition);
    }, s.$$.update = () => {
      s.$$.dirty & 4096 && t(8, _ = a === "readonly" || a === ""), s.$$.dirty & 8192 && t(9, b = Number.parseFloat(d));
    }, [
      c,
      o,
      r,
      l,
      h,
      u,
      f,
      g,
      _,
      b,
      C,
      v,
      a,
      d,
      w,
      S,
      L,
      x
    ];
  }
  class Ffe extends Yi {
    constructor(e) {
      super(), this.shadowRoot.innerHTML = "<style>input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}input[type=number]{-moz-appearance:textfield}</style>", cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, Pfe, Ofe, Cn, {
        type: 1,
        placeholder: 2,
        readonly: 12,
        label: 3,
        value: 0,
        step: 13,
        name: 4,
        labelposition: 5
      }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return [
        "type",
        "placeholder",
        "readonly",
        "label",
        "value",
        "step",
        "name",
        "labelposition"
      ];
    }
    get type() {
      return this.$$.ctx[1];
    }
    set type(e) {
      this.$$set({ type: e }), we();
    }
    get placeholder() {
      return this.$$.ctx[2];
    }
    set placeholder(e) {
      this.$$set({ placeholder: e }), we();
    }
    get readonly() {
      return this.$$.ctx[12];
    }
    set readonly(e) {
      this.$$set({ readonly: e }), we();
    }
    get label() {
      return this.$$.ctx[3];
    }
    set label(e) {
      this.$$set({ label: e }), we();
    }
    get value() {
      return this.$$.ctx[0];
    }
    set value(e) {
      this.$$set({ value: e }), we();
    }
    get step() {
      return this.$$.ctx[13];
    }
    set step(e) {
      this.$$set({ step: e }), we();
    }
    get name() {
      return this.$$.ctx[4];
    }
    set name(e) {
      this.$$set({ name: e }), we();
    }
    get labelposition() {
      return this.$$.ctx[5];
    }
    set labelposition(e) {
      this.$$set({ labelposition: e }), we();
    }
  }
  customElements.define("v-input-internal", Ffe);
  class Bfe extends customElements.get("v-input-internal") {
    static formAssociated = !0;
  }
  customElements.define("v-input", Bfe);
  const Wfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null
  }, Symbol.toStringTag, { value: "Module" }));
  function Vfe(s) {
    let e;
    return {
      c() {
        e = Hd("path"), X(e, "d", "M6.33 3.66667H7.66666V5H6.33333V3.66667ZM6.33 6.33333H7.66666V10.3333H6.33333V6.33333ZM7 0.333334C3.31999 0.333334 0.333328 3.32 0.333328 7C0.333328 10.68 3.31999 13.6667 7 13.6667C10.68 13.6667 13.6667 10.68 13.6667 7C13.6667 3.32 10.68 0.333334 7 0.333334ZM7 12.3333C4.06 12.3333 1.66666 9.94 1.66666 7C1.66666 4.06 4.06 1.66667 7 1.66667C9.93999 1.66667 12.3333 4.06 12.3333 7C12.3333 9.94 9.93999 12.3333 7 12.3333Z"), X(e, "fill", "#045681");
      },
      m(t, i) {
        Te(t, e, i);
      },
      d(t) {
        t && Qe(e);
      }
    };
  }
  function Hfe(s) {
    let e;
    return {
      c() {
        e = Hd("path"), X(e, "d", "M4 7.78L1.22 5L0.273331 5.94L4 9.66667L12 1.66667L11.06 0.726665L4 7.78Z"), X(e, "fill", "#397F48");
      },
      m(t, i) {
        Te(t, e, i);
      },
      d(t) {
        t && Qe(e);
      }
    };
  }
  function zfe(s) {
    let e;
    return {
      c() {
        e = Hd("path"), X(e, "d", "M8 2.99333L13.02 11.6667H2.98L8 2.99333ZM8 0.333328L0.666672 13H15.3333L8 0.333328ZM8.66667 9.66666H7.33334V11H8.66667V9.66666ZM8.66667 5.66666H7.33334V8.33333H8.66667V5.66666Z"), X(e, "fill", "#FF9900");
      },
      m(t, i) {
        Te(t, e, i);
      },
      d(t) {
        t && Qe(e);
      }
    };
  }
  function Ufe(s) {
    let e;
    return {
      c() {
        e = Hd("path"), X(e, "d", "M6.33 9H7.66666V10.3333H6.33333V9ZM6.33 3.66666H7.66666V7.66666H6.33333V3.66666ZM6.99333 0.333328C3.31333 0.333328 0.333328 3.31999 0.333328 7C0.333328 10.68 3.31333 13.6667 6.99333 13.6667C10.68 13.6667 13.6667 10.68 13.6667 7C13.6667 3.31999 10.68 0.333328 6.99333 0.333328ZM7 12.3333C4.05333 12.3333 1.66666 9.94666 1.66666 7C1.66666 4.05333 4.05333 1.66666 7 1.66666C9.94666 1.66666 12.3333 4.05333 12.3333 7C12.3333 9.94666 9.94666 12.3333 7 12.3333Z"), X(e, "fill", "#BE3026");
      },
      m(t, i) {
        Te(t, e, i);
      },
      d(t) {
        t && Qe(e);
      }
    };
  }
  function s4(s) {
    let e, t;
    return {
      c() {
        e = Ie("p"), t = Mi(s[1]), X(e, "class", "text-xs");
      },
      m(i, n) {
        Te(i, e, n), _e(e, t);
      },
      p(i, n) {
        n & 2 && Zi(t, i[1]);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function $fe(s) {
    let e, t, i, n, o, r, a, l, c;
    function d(g, _) {
      if (g[2] === "error")
        return Ufe;
      if (g[2] === "warning")
        return zfe;
      if (g[2] === "success")
        return Hfe;
      if (g[2] === "info")
        return Vfe;
    }
    let h = d(s), u = h && h(s), f = s[1] && s4(s);
    return {
      c() {
        e = Ie("div"), t = Ie("div"), i = Hd("svg"), u && u.c(), n = Kt(), o = Ie("figure"), r = Ie("figcaption"), a = Mi(s[0]), l = Kt(), f && f.c(), this.c = Le, X(i, "width", "14"), X(i, "height", "14"), X(i, "viewBox", "0 0 15 15"), X(i, "fill", "none"), X(i, "xmlns", "http://www.w3.org/2000/svg"), X(t, "class", "mt-1"), X(r, "class", "text-sm"), X(e, "class", c = Mt("flex gap-2 border-l-4 py-2 px-2", {
          "bg-gray-100": s[3] === "gray",
          "bg-white": s[3] === "white",
          "border-red/90": s[2] === "error",
          "border-orange/90": s[2] === "warning",
          "border-green/90": s[2] === "success",
          "border-blue/90": s[2] === "info"
        }));
      },
      m(g, _) {
        Te(g, e, _), _e(e, t), _e(t, i), u && u.m(i, null), _e(e, n), _e(e, o), _e(o, r), _e(r, a), _e(o, l), f && f.m(o, null);
      },
      p(g, [_]) {
        h !== (h = d(g)) && (u && u.d(1), u = h && h(g), u && (u.c(), u.m(i, null))), _ & 1 && Zi(a, g[0]), g[1] ? f ? f.p(g, _) : (f = s4(g), f.c(), f.m(o, null)) : f && (f.d(1), f = null), _ & 12 && c !== (c = Mt("flex gap-2 border-l-4 py-2 px-2", {
          "bg-gray-100": g[3] === "gray",
          "bg-white": g[3] === "white",
          "border-red/90": g[2] === "error",
          "border-orange/90": g[2] === "warning",
          "border-green/90": g[2] === "success",
          "border-blue/90": g[2] === "info"
        })) && X(e, "class", c);
      },
      i: Le,
      o: Le,
      d(g) {
        g && Qe(e), u && u.d(), f && f.d();
      }
    };
  }
  function jfe(s, e, t) {
    let { title: i = "" } = e, { message: n = "" } = e, { variant: o = "info" } = e, { background: r = "gray" } = e;
    return dn(), s.$$set = (a) => {
      "title" in a && t(0, i = a.title), "message" in a && t(1, n = a.message), "variant" in a && t(2, o = a.variant), "background" in a && t(3, r = a.background);
    }, [i, n, o, r];
  }
  class L6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, jfe, $fe, Cn, {
        title: 0,
        message: 1,
        variant: 2,
        background: 3
      }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["title", "message", "variant", "background"];
    }
    get title() {
      return this.$$.ctx[0];
    }
    set title(e) {
      this.$$set({ title: e }), we();
    }
    get message() {
      return this.$$.ctx[1];
    }
    set message(e) {
      this.$$set({ message: e }), we();
    }
    get variant() {
      return this.$$.ctx[2];
    }
    set variant(e) {
      this.$$set({ variant: e }), we();
    }
    get background() {
      return this.$$.ctx[3];
    }
    set background(e) {
      this.$$set({ background: e }), we();
    }
  }
  customElements.define("v-notify", L6);
  const Kfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: L6
  }, Symbol.toStringTag, { value: "Module" }));
  function o4(s, e, t) {
    const i = s.slice();
    return i[9] = e[t], i;
  }
  function r4(s) {
    let e, t, i;
    return {
      c() {
        e = Ie("p"), t = Mi(s[1]), X(e, "class", i = Mt("text-xs", {
          "pb-1": s[2] === "top",
          inline: s[2] === "left"
        }));
      },
      m(n, o) {
        Te(n, e, o), _e(e, t);
      },
      p(n, o) {
        o & 2 && Zi(t, n[1]), o & 4 && i !== (i = Mt("text-xs", {
          "pb-1": n[2] === "top",
          inline: n[2] === "left"
        })) && X(e, "class", i);
      },
      d(n) {
        n && Qe(e);
      }
    };
  }
  function a4(s) {
    let e, t = s[9] + "", i, n, o, r, a;
    function l() {
      return s[8](s[9]);
    }
    return {
      c() {
        e = Ie("button"), i = Mi(t), n = Kt(), X(e, "class", o = Mt("border-y border-l last:border-r border-black px-2 py-1 text-sm", {
          "bg-white": s[9] !== s[0],
          "bg-black text-white": s[9] === s[0]
        }));
      },
      m(c, d) {
        Te(c, e, d), _e(e, i), _e(e, n), s[7](e), r || (a = bi(e, "click", l), r = !0);
      },
      p(c, d) {
        s = c, d & 16 && t !== (t = s[9] + "") && Zi(i, t), d & 17 && o !== (o = Mt("border-y border-l last:border-r border-black px-2 py-1 text-sm", {
          "bg-white": s[9] !== s[0],
          "bg-black text-white": s[9] === s[0]
        })) && X(e, "class", o);
      },
      d(c) {
        c && Qe(e), s[7](null), r = !1, a();
      }
    };
  }
  function qfe(s) {
    let e, t, i = s[1] && r4(s), n = s[4], o = [];
    for (let r = 0; r < n.length; r += 1)
      o[r] = a4(o4(s, n, r));
    return {
      c() {
        e = Ie("label"), i && i.c(), t = Kt();
        for (let r = 0; r < o.length; r += 1)
          o[r].c();
        this.c = Le;
      },
      m(r, a) {
        Te(r, e, a), i && i.m(e, null), _e(e, t);
        for (let l = 0; l < o.length; l += 1)
          o[l].m(e, null);
      },
      p(r, [a]) {
        if (r[1] ? i ? i.p(r, a) : (i = r4(r), i.c(), i.m(e, t)) : i && (i.d(1), i = null), a & 57) {
          n = r[4];
          let l;
          for (l = 0; l < n.length; l += 1) {
            const c = o4(r, n, l);
            o[l] ? o[l].p(c, a) : (o[l] = a4(c), o[l].c(), o[l].m(e, null));
          }
          for (; l < o.length; l += 1)
            o[l].d(1);
          o.length = n.length;
        }
      },
      i: Le,
      o: Le,
      d(r) {
        r && Qe(e), i && i.d(), xv(o, r);
      }
    };
  }
  function Gfe(s, e, t) {
    let { label: i = "" } = e, { options: n = "" } = e, { selected: o = "" } = e, { labelposition: r = "top" } = e;
    dn();
    let a, l;
    const c = (u) => {
      t(0, o = u), go(a, "input", { value: u });
    };
    function d(u) {
      ds[u ? "unshift" : "push"](() => {
        a = u, t(3, a);
      });
    }
    const h = (u) => c(u);
    return s.$$set = (u) => {
      "label" in u && t(1, i = u.label), "options" in u && t(6, n = u.options), "selected" in u && t(0, o = u.selected), "labelposition" in u && t(2, r = u.labelposition);
    }, s.$$.update = () => {
      s.$$.dirty & 64 && t(4, l = n.split(",").map((u) => u.trim()));
    }, [
      o,
      i,
      r,
      a,
      l,
      c,
      n,
      d,
      h
    ];
  }
  class k6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, Gfe, qfe, Cn, {
        label: 1,
        options: 6,
        selected: 0,
        labelposition: 2
      }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["label", "options", "selected", "labelposition"];
    }
    get label() {
      return this.$$.ctx[1];
    }
    set label(e) {
      this.$$set({ label: e }), we();
    }
    get options() {
      return this.$$.ctx[6];
    }
    set options(e) {
      this.$$set({ options: e }), we();
    }
    get selected() {
      return this.$$.ctx[0];
    }
    set selected(e) {
      this.$$set({ selected: e }), we();
    }
    get labelposition() {
      return this.$$.ctx[2];
    }
    set labelposition(e) {
      this.$$set({ labelposition: e }), we();
    }
  }
  customElements.define("v-radio", k6);
  const Zfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: k6
  }, Symbol.toStringTag, { value: "Module" }));
  function l4(s, e, t) {
    const i = s.slice();
    return i[12] = e[t], i;
  }
  function c4(s) {
    let e, t, i;
    return {
      c() {
        e = Ie("p"), t = Mi(s[1]), X(e, "class", i = Mt("text-xs pb-1", {
          "pb-1": s[2] === "top",
          inline: s[2] === "left"
        }));
      },
      m(n, o) {
        Te(n, e, o), _e(e, t);
      },
      p(n, o) {
        o & 2 && Zi(t, n[1]), o & 4 && i !== (i = Mt("text-xs pb-1", {
          "pb-1": n[2] === "top",
          inline: n[2] === "left"
        })) && X(e, "class", i);
      },
      d(n) {
        n && Qe(e);
      }
    };
  }
  function d4(s, e) {
    let t, i = e[12] + "", n, o, r, a;
    return {
      key: s,
      first: null,
      c() {
        t = Ie("option"), n = Mi(i), o = Kt(), t.selected = r = e[6] === e[12], t.__value = a = `
        ` + e[12] + `
      `, t.value = t.__value, this.first = t;
      },
      m(l, c) {
        Te(l, t, c), _e(t, n), _e(t, o);
      },
      p(l, c) {
        e = l, c & 8 && i !== (i = e[12] + "") && Zi(n, i), c & 72 && r !== (r = e[6] === e[12]) && (t.selected = r), c & 8 && a !== (a = `
        ` + e[12] + `
      `) && (t.__value = a, t.value = t.__value);
      },
      d(l) {
        l && Qe(t);
      }
    };
  }
  function Yfe(s) {
    let e, t, i, n, o = (s[0] || "Please select") + "", r, a, l = [], c = /* @__PURE__ */ new Map(), d, h, u = s[1] && c4(s), f = s[3];
    const g = (_) => _[12];
    for (let _ = 0; _ < f.length; _ += 1) {
      let b = l4(s, f, _), C = g(b);
      c.set(C, l[_] = d4(C, b));
    }
    return {
      c() {
        e = Ie("label"), u && u.c(), t = Kt(), i = Ie("select"), n = Ie("option"), r = Mi(o), a = Kt();
        for (let _ = 0; _ < l.length; _ += 1)
          l[_].c();
        this.c = Le, n.__value = "", n.value = n.__value, X(i, "class", Mt(h4, "py-1 px-2.5 text-xs border border-black appearance-none rounded-none")), X(e, "class", Mt(h4, "relative"));
      },
      m(_, b) {
        Te(_, e, b), u && u.m(e, null), _e(e, t), _e(e, i), _e(i, n), _e(n, r), _e(n, a);
        for (let C = 0; C < l.length; C += 1)
          l[C].m(i, null);
        s[10](i), s[11](e), d || (h = bi(i, "input", s[7]), d = !0);
      },
      p(_, [b]) {
        _[1] ? u ? u.p(_, b) : (u = c4(_), u.c(), u.m(e, t)) : u && (u.d(1), u = null), b & 1 && o !== (o = (_[0] || "Please select") + "") && Zi(r, o), b & 72 && (f = _[3], l = rI(l, b, g, 1, _, f, c, i, oI, d4, null, l4));
      },
      i: Le,
      o: Le,
      d(_) {
        _ && Qe(e), u && u.d();
        for (let b = 0; b < l.length; b += 1)
          l[b].d();
        s[10](null), s[11](null), d = !1, h();
      }
    };
  }
  const h4 = "max-w-[14rem] w-full";
  function Xfe(s, e, t) {
    let { options: i = "" } = e, { value: n = "" } = e, { placeholder: o = "" } = e, { label: r = "" } = e, { labelposition: a = "top" } = e, l, c, d, h;
    dn();
    const u = (_) => {
      _.preventDefault(), _.stopImmediatePropagation(), t(8, n = c.value.trim()), go(l, "input", { value: n });
    };
    function f(_) {
      ds[_ ? "unshift" : "push"](() => {
        c = _, t(5, c), t(3, d), t(9, i);
      });
    }
    function g(_) {
      ds[_ ? "unshift" : "push"](() => {
        l = _, t(4, l);
      });
    }
    return s.$$set = (_) => {
      "options" in _ && t(9, i = _.options), "value" in _ && t(8, n = _.value), "placeholder" in _ && t(0, o = _.placeholder), "label" in _ && t(1, r = _.label), "labelposition" in _ && t(2, a = _.labelposition);
    }, s.$$.update = () => {
      s.$$.dirty & 512 && t(3, d = i.split(",").map((_) => _.trim())), s.$$.dirty & 264 && t(6, h = d.find((_) => _ === n) ?? "");
    }, [
      o,
      r,
      a,
      d,
      l,
      c,
      h,
      u,
      n,
      i,
      f,
      g
    ];
  }
  class D6 extends Yi {
    constructor(e) {
      super(), this.shadowRoot.innerHTML = "<style>label{--select-chevron-color:black;--select-chevron-size:15px}label::after{content:'';position:absolute;background-color:var(--select-chevron-color);clip-path:polygon(25% 25%, 17.5% 32.5%, 40% 55%, 50% 65%, 60% 55%, 82.5% 32.5%, 75% 25%, 50% 50%);width:var(--select-chevron-size);height:var(--select-chevron-size);right:2px;bottom:2px}</style>", cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, Xfe, Yfe, Cn, {
        options: 9,
        value: 8,
        placeholder: 0,
        label: 1,
        labelposition: 2
      }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["options", "value", "placeholder", "label", "labelposition"];
    }
    get options() {
      return this.$$.ctx[9];
    }
    set options(e) {
      this.$$set({ options: e }), we();
    }
    get value() {
      return this.$$.ctx[8];
    }
    set value(e) {
      this.$$set({ value: e }), we();
    }
    get placeholder() {
      return this.$$.ctx[0];
    }
    set placeholder(e) {
      this.$$set({ placeholder: e }), we();
    }
    get label() {
      return this.$$.ctx[1];
    }
    set label(e) {
      this.$$set({ label: e }), we();
    }
    get labelposition() {
      return this.$$.ctx[2];
    }
    set labelposition(e) {
      this.$$set({ labelposition: e }), we();
    }
  }
  customElements.define("v-select", D6);
  const Qfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: D6
  }, Symbol.toStringTag, { value: "Module" })), mu = [];
  function Jfe(s, e = Le) {
    let t;
    const i = /* @__PURE__ */ new Set();
    function n(a) {
      if (F4(s, a) && (s = a, t)) {
        const l = !mu.length;
        for (const c of i)
          c[1](), mu.push(c, s);
        if (l) {
          for (let c = 0; c < mu.length; c += 2)
            mu[c][0](mu[c + 1]);
          mu.length = 0;
        }
      }
    }
    function o(a) {
      n(a(s));
    }
    function r(a, l = Le) {
      const c = [a, l];
      return i.add(c), i.size === 1 && (t = e(n) || Le), a(s), () => {
        i.delete(c), i.size === 0 && (t(), t = null);
      };
    }
    return { set: n, update: o, subscribe: r };
  }
  function u4(s) {
    return Object.prototype.toString.call(s) === "[object Date]";
  }
  function tI(s, e, t, i) {
    if (typeof t == "number" || u4(t)) {
      const n = i - t, o = (t - e) / (s.dt || 1 / 60), r = s.opts.stiffness * n, a = s.opts.damping * o, l = (r - a) * s.inv_mass, c = (o + l) * s.dt;
      return Math.abs(c) < s.opts.precision && Math.abs(n) < s.opts.precision ? i : (s.settled = !1, u4(t) ? new Date(t.getTime() + c) : t + c);
    } else {
      if (Array.isArray(t))
        return t.map((n, o) => tI(s, e[o], t[o], i[o]));
      if (typeof t == "object") {
        const n = {};
        for (const o in t)
          n[o] = tI(s, e[o], t[o], i[o]);
        return n;
      } else
        throw new Error(`Cannot spring ${typeof t} values`);
    }
  }
  function ege(s, e = {}) {
    const t = Jfe(s), { stiffness: i = 0.15, damping: n = 0.8, precision: o = 0.01 } = e;
    let r, a, l, c = s, d = s, h = 1, u = 0, f = !1;
    function g(b, C = {}) {
      d = b;
      const v = l = {};
      if (s == null || C.hard || _.stiffness >= 1 && _.damping >= 1)
        return f = !0, r = w2(), c = b, t.set(s = d), Promise.resolve();
      if (C.soft) {
        const w = C.soft === !0 ? 0.5 : +C.soft;
        u = 1 / (w * 60), h = 0;
      }
      return a || (r = w2(), f = !1, a = J6((w) => {
        if (f)
          return f = !1, a = null, !1;
        h = Math.min(h + u, 1);
        const S = {
          inv_mass: h,
          opts: _,
          settled: !0,
          dt: (w - r) * 60 / 1e3
        }, L = tI(S, c, s, d);
        return r = w, c = s, t.set(s = L), S.settled && (a = null), !S.settled;
      })), new Promise((w) => {
        a.promise.then(() => {
          v === l && w();
        });
      });
    }
    const _ = {
      set: g,
      update: (b, C) => g(b(d, s), C),
      subscribe: t.subscribe,
      stiffness: i,
      damping: n,
      precision: o
    };
    return _;
  }
  const tge = (s, e, t) => s <= e ? e : s >= t ? t : s, Sv = (s, e, t, i) => {
    const n = (s - e) / (t - e) * 100;
    return Number.isNaN(n) || n <= 0 ? 0 : n >= 100 ? 100 : Number.parseFloat(n.toFixed(i));
  };
  function f4(s, e, t) {
    const i = s.slice();
    return i[53] = e[t], i[55] = t, i;
  }
  function g4(s, e, t) {
    const i = s.slice();
    return i[6] = e[t], i[57] = t, i;
  }
  function m4(s) {
    let e, t;
    return {
      c() {
        e = Ie("p"), t = Mi(s[4]), X(e, "class", "text-xs");
      },
      m(i, n) {
        Te(i, e, n), _e(e, t);
      },
      p(i, n) {
        n[0] & 16 && Zi(t, i[4]);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function p4(s) {
    let e, t;
    return {
      c() {
        e = Ie("span"), t = Mi(s[5]), X(e, "class", "floating-suffix");
      },
      m(i, n) {
        Te(i, e, n), _e(e, t);
      },
      p(i, n) {
        n[0] & 32 && Zi(t, i[5]);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function _4(s) {
    let e, t, i, n, o, r, a = s[6] + "", l, c, d, h, u, f, g, _, b, C, v, w = s[5] && p4(s);
    function S() {
      return s[37](s[57]);
    }
    return {
      c() {
        e = Ie("span"), t = Ie("span"), i = Kt(), n = Ie("span"), o = Kt(), r = Ie("span"), l = Mi(a), c = Kt(), w && w.c(), X(t, "class", "handle-bg absolute left-0 bottom-1 rounded-full opacity-50 h-full w-full transition-transform bg-gray-400"), X(n, "class", "absolute left-0 bottom-1 block rounded-full h-full w-full border border-black bg-white"), X(r, "class", d = Mt("floating block absolute left-1/2 bottom-full -translate-x-1/2 -translate-y-1/2", "py-1 px-1.5 text-sm text-center opacity-0 pointer-events-none whitespace-nowrap transition duration-200 border border-black bg-white", {
          "-translate-y-1.5": !s[13] || s[15] !== s[57]
        })), X(e, "role", "slider"), X(e, "class", "range absolute block h-5 w-5 top-1 bottom-auto -translate-x-1/2 -translate-y-1/2 z-[2]"), X(e, "data-handle", h = s[57]), co(e, "left", s[17][s[57]] + "%"), co(e, "z-index", s[15] === s[57] ? 3 : 2), X(e, "aria-valuemin", u = s[0] === !0 && s[57] === 1 ? s[9] : s[7]), X(e, "aria-valuemax", f = s[0] === !0 && s[57] === 0 ? s[10] : s[8]), X(e, "aria-valuenow", g = s[6]), X(e, "aria-valuetext", _ = s[6]?.toString()), X(e, "aria-orientation", "horizontal"), X(e, "aria-disabled", s[2]), X(e, "disabled", s[2]), X(e, "tabindex", b = s[2] ? -1 : 0), ji(e, "active", s[13] && s[15] === s[57]), ji(e, "press", s[14] && s[15] === s[57]);
      },
      m(L, x) {
        Te(L, e, x), _e(e, t), _e(e, i), _e(e, n), _e(e, o), _e(e, r), _e(r, l), _e(r, c), w && w.m(r, null), C || (v = [
          bi(e, "blur", s[20]),
          bi(e, "focus", S)
        ], C = !0);
      },
      p(L, x) {
        s = L, x[0] & 1536 && a !== (a = s[6] + "") && Zi(l, a), s[5] ? w ? w.p(s, x) : (w = p4(s), w.c(), w.m(r, null)) : w && (w.d(1), w = null), x[0] & 40960 && d !== (d = Mt("floating block absolute left-1/2 bottom-full -translate-x-1/2 -translate-y-1/2", "py-1 px-1.5 text-sm text-center opacity-0 pointer-events-none whitespace-nowrap transition duration-200 border border-black bg-white", {
          "-translate-y-1.5": !s[13] || s[15] !== s[57]
        })) && X(r, "class", d), x[0] & 131072 && co(e, "left", s[17][s[57]] + "%"), x[0] & 32768 && co(e, "z-index", s[15] === s[57] ? 3 : 2), x[0] & 641 && u !== (u = s[0] === !0 && s[57] === 1 ? s[9] : s[7]) && X(e, "aria-valuemin", u), x[0] & 1281 && f !== (f = s[0] === !0 && s[57] === 0 ? s[10] : s[8]) && X(e, "aria-valuemax", f), x[0] & 1536 && g !== (g = s[6]) && X(e, "aria-valuenow", g), x[0] & 1536 && _ !== (_ = s[6]?.toString()) && X(e, "aria-valuetext", _), x[0] & 4 && X(e, "aria-disabled", s[2]), x[0] & 4 && X(e, "disabled", s[2]), x[0] & 4 && b !== (b = s[2] ? -1 : 0) && X(e, "tabindex", b), x[0] & 40960 && ji(e, "active", s[13] && s[15] === s[57]), x[0] & 49152 && ji(e, "press", s[14] && s[15] === s[57]);
      },
      d(L) {
        L && Qe(e), w && w.d(), C = !1, Cl(v);
      }
    };
  }
  function b4(s) {
    let e;
    return {
      c() {
        e = Ie("span"), X(e, "class", "absolute block transition duration-200 h-1 -top-0.5 select-none z-[1] bg-black"), co(e, "left", s[18](s[17]) + "%"), co(e, "right", s[19](s[17]) + "%");
      },
      m(t, i) {
        Te(t, e, i);
      },
      p(t, i) {
        i[0] & 131072 && co(e, "left", t[18](t[17]) + "%"), i[0] & 131072 && co(e, "right", t[19](t[17]) + "%");
      },
      d(t) {
        t && Qe(e);
      }
    };
  }
  function v4(s) {
    let e, t;
    return {
      c() {
        e = Ie("span"), t = Mi(s[5]), X(e, "class", "pipVal-suffix");
      },
      m(i, n) {
        Te(i, e, n), _e(e, t);
      },
      p(i, n) {
        n[0] & 32 && Zi(t, i[5]);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function C4(s) {
    let e, t = Array.from({ length: s[12] + 1 }), i = [];
    for (let n = 0; n < t.length; n += 1)
      i[n] = S4(f4(s, t, n));
    return {
      c() {
        for (let n = 0; n < i.length; n += 1)
          i[n].c();
        e = sI();
      },
      m(n, o) {
        for (let r = 0; r < i.length; r += 1)
          i[r].m(n, o);
        Te(n, e, o);
      },
      p(n, o) {
        if (o[0] & 70016) {
          t = Array.from({ length: n[12] + 1 });
          let r;
          for (r = 0; r < t.length; r += 1) {
            const a = f4(n, t, r);
            i[r] ? i[r].p(a, o) : (i[r] = S4(a), i[r].c(), i[r].m(e.parentNode, e));
          }
          for (; r < i.length; r += 1)
            i[r].d(1);
          i.length = t.length;
        }
      },
      d(n) {
        xv(i, n), n && Qe(e);
      }
    };
  }
  function w4(s) {
    let e;
    return {
      c() {
        e = Ie("span"), X(e, "class", "absolute h-[4px] w-[1px] top-[calc(50%-9px)] whitespace-nowrap transition bg-black/50"), co(e, "left", Sv(s[16](s[55]), s[7], s[8], 2) + "%");
      },
      m(t, i) {
        Te(t, e, i);
      },
      p(t, i) {
        i[0] & 65920 && co(e, "left", Sv(t[16](t[55]), t[7], t[8], 2) + "%");
      },
      d(t) {
        t && Qe(e);
      }
    };
  }
  function S4(s) {
    let e = s[16](s[55]) !== s[7] && s[16](s[55]) !== s[8], t, i = e && w4(s);
    return {
      c() {
        i && i.c(), t = sI();
      },
      m(n, o) {
        i && i.m(n, o), Te(n, t, o);
      },
      p(n, o) {
        o[0] & 65920 && (e = n[16](n[55]) !== n[7] && n[16](n[55]) !== n[8]), e ? i ? i.p(n, o) : (i = w4(n), i.c(), i.m(t.parentNode, t)) : i && (i.d(1), i = null);
      },
      d(n) {
        i && i.d(n), n && Qe(t);
      }
    };
  }
  function y4(s) {
    let e, t;
    return {
      c() {
        e = Ie("span"), t = Mi(s[5]), X(e, "class", "pipVal-suffix");
      },
      m(i, n) {
        Te(i, e, n), _e(e, t);
      },
      p(i, n) {
        n[0] & 32 && Zi(t, i[5]);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function ige(s) {
    let e, t, i, n, o, r, a, l, c, d, h, u, f, g, _, b, C, v = s[4] && m4(s), w = s[10] ? [s[9], s[10]] : [s[9]], S = [];
    for (let I = 0; I < w.length; I += 1)
      S[I] = _4(g4(s, w, I));
    let L = s[0] && b4(s), x = s[5] && v4(s), y = s[3] && C4(s), k = s[5] && y4(s);
    return {
      c() {
        e = Ie("label"), v && v.c(), t = Kt(), i = Ie("div");
        for (let I = 0; I < S.length; I += 1)
          S[I].c();
        n = Kt(), L && L.c(), o = Kt(), r = Ie("div"), a = Ie("small"), l = Mi(s[7]), c = Kt(), x && x.c(), d = Kt(), y && y.c(), h = Kt(), u = Ie("small"), f = Mi(s[8]), g = Kt(), k && k.c(), this.c = Le, X(a, "class", "absolute bottom-full left-0 -translate-x-1/2 mb-3 whitespace-nowrap"), X(u, "class", "absolute bottom-full right-0 translate-x-1/2 mb-3 whitespace-nowrap"), X(r, "class", "absolute h-2 left-0 right-0"), ji(r, "disabled", s[2]), ji(r, "focus", s[13]), X(i, "class", _ = Mt("slider relative h-0.5 mt-7 transition-opacity duration-200 select-none pip-labels bg-black/50", { "opacity-50": s[2] })), ji(i, "range", s[0]), ji(i, "focus", s[13]), ji(i, "min", s[0] === "min"), ji(i, "max", s[0] === "max"), X(e, "class", "flex flex-col gap-2");
      },
      m(I, F) {
        Te(I, e, F), v && v.m(e, null), _e(e, t), _e(e, i);
        for (let R = 0; R < S.length; R += 1)
          S[R].m(i, null);
        _e(i, n), L && L.m(i, null), _e(i, o), _e(i, r), _e(r, a), _e(a, l), _e(a, c), x && x.m(a, null), _e(r, d), y && y.m(r, null), _e(r, h), _e(r, u), _e(u, f), _e(u, g), k && k.m(u, null), s[38](i), b || (C = [
          bi(window, "mousedown", s[24]),
          bi(window, "touchstart", s[24]),
          bi(window, "mousemove", s[25]),
          bi(window, "touchmove", s[25]),
          bi(window, "mouseup", s[26]),
          bi(window, "touchend", s[27]),
          bi(window, "keydown", s[28]),
          bi(i, "mousedown", s[22]),
          bi(i, "mouseup", s[23]),
          bi(i, "touchstart", S2(s[22])),
          bi(i, "touchend", S2(s[23]))
        ], b = !0);
      },
      p(I, F) {
        if (I[4] ? v ? v.p(I, F) : (v = m4(I), v.c(), v.m(e, t)) : v && (v.d(1), v = null), F[0] & 3336101) {
          w = I[10] ? [I[9], I[10]] : [I[9]];
          let R;
          for (R = 0; R < w.length; R += 1) {
            const $ = g4(I, w, R);
            S[R] ? S[R].p($, F) : (S[R] = _4($), S[R].c(), S[R].m(i, n));
          }
          for (; R < S.length; R += 1)
            S[R].d(1);
          S.length = w.length;
        }
        I[0] ? L ? L.p(I, F) : (L = b4(I), L.c(), L.m(i, o)) : L && (L.d(1), L = null), F[0] & 128 && Zi(l, I[7]), I[5] ? x ? x.p(I, F) : (x = v4(I), x.c(), x.m(a, null)) : x && (x.d(1), x = null), I[3] ? y ? y.p(I, F) : (y = C4(I), y.c(), y.m(r, h)) : y && (y.d(1), y = null), F[0] & 256 && Zi(f, I[8]), I[5] ? k ? k.p(I, F) : (k = y4(I), k.c(), k.m(u, null)) : k && (k.d(1), k = null), F[0] & 4 && ji(r, "disabled", I[2]), F[0] & 8192 && ji(r, "focus", I[13]), F[0] & 4 && _ !== (_ = Mt("slider relative h-0.5 mt-7 transition-opacity duration-200 select-none pip-labels bg-black/50", { "opacity-50": I[2] })) && X(i, "class", _), F[0] & 5 && ji(i, "range", I[0]), F[0] & 8196 && ji(i, "focus", I[13]), F[0] & 5 && ji(i, "min", I[0] === "min"), F[0] & 5 && ji(i, "max", I[0] === "max");
      },
      i: Le,
      o: Le,
      d(I) {
        I && Qe(e), v && v.d(), xv(S, I), L && L.d(), x && x.d(), y && y.d(), k && k.d(), s[38](null), b = !1, Cl(C);
      }
    };
  }
  function nge(s, e, t) {
    let i, n, o = Le, r = () => (o(), o = Q6(Ve, (O) => t(17, n = O)), Ve);
    s.$$.on_destroy.push(() => o());
    let { slider: a } = e, { range: l = !1 } = e, { min: c } = e, { max: d } = e, { step: h } = e, { value: u } = e, { start: f } = e, { end: g } = e, { disabled: _ = !1 } = e, { discrete: b = !0 } = e, { label: C = "" } = e, { suffix: v = "" } = e;
    dn();
    const w = { stiffness: 0.1, damping: 0.4 };
    let S, L, x, y, k, I, F, R = 0, $ = !1, j = !1, le = !1, he = !1, Ce = -1, Ne, xe, Ve;
    const Ct = (O, E, N) => {
      if (O <= E)
        return E;
      if (O >= N)
        return N;
      const W = (O - E) % x;
      let P = O - W;
      return Math.abs(W) * 2 >= x && (P += W > 0 ? x : -x), P = tge(P, E, N), Number.parseFloat(P.toFixed(2));
    }, bt = (O) => O.type.includes("touch") ? O.touches[0] : O, ve = (O) => {
      const E = [...a.querySelectorAll(".handle")], N = E.includes(O), W = E.some((P) => P.contains(O));
      return N || W;
    }, pe = (O) => l === "min" || l === "max" ? O.slice(0, 1) : l ? O.slice(0, 2) : O, ft = () => {
      xe = a.getBoundingClientRect();
    }, Hi = (O) => {
      const N = (O.clientX - xe.left) / xe.width * 100, W = (L - S) / 100 * N + S;
      let P = 0;
      return l && y === k ? W > k ? 1 : 0 : (l && (P = [y, k].indexOf([y, k].sort((Q, re) => Math.abs(W - Q) - Math.abs(W - re))[0])), P);
    }, Ri = (O) => {
      const N = (O.clientX - xe.left) / xe.width * 100, W = (L - S) / 100 * N + S;
      ms(Ce, W);
    }, ms = (O, E) => {
      let N = O;
      const W = Ct(E, S, L);
      return typeof N > "u" && (N = Ce), l && (N === 0 && W > k ? t(10, k = W) : N === 1 && W < y && t(9, y = W)), N === 0 && y !== W && t(9, y = W), N === 1 && k !== W && t(10, k = W), Ne !== W && (Ei(), Ne = W), N === 0 ? t(29, f = y.toString()) : N === 1 && t(30, g = k.toString()), W;
    }, Ao = (O) => l === "min" ? 0 : O[0], Ia = (O) => l === "max" ? 0 : l === "min" ? 100 - O[0] : 100 - O[1], Ro = () => {
      he && (t(13, $ = !1), j = !1, t(14, le = !1));
    }, Y = (O) => {
      _ || (t(15, Ce = O), t(13, $ = !0));
    }, G = (O) => {
      if (_)
        return;
      ft();
      const E = O.target, N = bt(O);
      t(13, $ = !0), j = !0, t(14, le = !0), t(15, Ce = Hi(N)), Ne = Ct(Ce === 0 ? y : k, S, L), O.type === "touchstart" && !E.matches(".pipVal") && Ri(N);
    }, de = () => {
      t(14, le = !1);
    }, Ae = (O) => {
      he = !1, $ && O.target !== a && !a.contains(O.target) && t(13, $ = !1);
    }, yt = (O) => {
      _ || !j || (t(13, $ = !0), Ri(bt(O)));
    }, mi = (O) => {
      if (!_) {
        const E = O.target;
        (j && E && E === a || a.contains(E)) && (t(13, $ = !0), !ve(E) && !E.matches(".pipVal") && Ri(bt(O)));
      }
      j = !1, t(14, le = !1);
    }, ei = () => {
      j = !1, t(14, le = !1);
    }, ti = (O) => {
      _ || (O.target === a || a.contains(O.target)) && (he = !0);
    }, Ei = () => {
      _ || go(a, "input", {
        activeHandle: Ce,
        previousValue: Ne,
        value: Ce === 0 ? y : k,
        values: k ? [y, k].map((O) => Ct(O, S, L)) : void 0
      });
    }, K = (O) => Y(O);
    function U(O) {
      ds[O ? "unshift" : "push"](() => {
        a = O, t(1, a);
      });
    }
    return s.$$set = (O) => {
      "slider" in O && t(1, a = O.slider), "range" in O && t(0, l = O.range), "min" in O && t(31, c = O.min), "max" in O && t(32, d = O.max), "step" in O && t(33, h = O.step), "value" in O && t(6, u = O.value), "start" in O && t(29, f = O.start), "end" in O && t(30, g = O.end), "disabled" in O && t(2, _ = O.disabled), "discrete" in O && t(3, b = O.discrete), "label" in O && t(4, C = O.label), "suffix" in O && t(5, v = O.suffix);
    }, s.$$.update = () => {
      if (s.$$.dirty[1] & 2 && t(8, L = Number.parseFloat(d || "100")), s.$$.dirty[1] & 1 && t(7, S = Number.parseFloat(c || "0")), s.$$.dirty[1] & 4 && t(34, x = Number.parseFloat(h || "1")), s.$$.dirty[0] & 384 | s.$$.dirty[1] & 8 && t(35, I = (L - S) / x >= 100 ? (L - S) / 20 : 1), s.$$.dirty[0] & 384 | s.$$.dirty[1] & 8 && t(12, F = (L - S) / x), s.$$.dirty[0] & 128 | s.$$.dirty[1] & 24 && t(16, i = (O) => S + O * x * I), s.$$.dirty[0] & 536870976 | s.$$.dirty[1] & 3 && t(9, y = f || u ? Number.parseFloat(f || u) : (Number.parseFloat(c || "0") + Number.parseFloat(d || "100")) / 2), s.$$.dirty[0] & 1073741824 && t(10, k = g ? Number.parseFloat(g) : void 0), s.$$.dirty[0] & 1073741825 && t(0, l = typeof l == "string" ? l : g !== void 0), s.$$.dirty[0] & 3968 | s.$$.dirty[1] & 32) {
        t(9, y = Ct(y, S, L));
        let O = [y];
        k && (t(10, k = Ct(k, S, L)), O.push(k)), O = pe(O), R !== O.length ? r(t(11, Ve = ege(O.map((E) => Sv(E, S, L, 2)), w))) : Ve.set(O.map((E) => Sv(E, S, L, 2))).catch((E) => console.error(E)), t(36, R = O.length);
      }
    }, [
      l,
      a,
      _,
      b,
      C,
      v,
      u,
      S,
      L,
      y,
      k,
      Ve,
      F,
      $,
      le,
      Ce,
      i,
      n,
      Ao,
      Ia,
      Ro,
      Y,
      G,
      de,
      Ae,
      yt,
      mi,
      ei,
      ti,
      f,
      g,
      c,
      d,
      h,
      x,
      I,
      R,
      K,
      U
    ];
  }
  class x6 extends Yi {
    constructor(e) {
      super(), this.shadowRoot.innerHTML = "<style>.slider .range:hover .handle-bg{transform:scale(1.5)}.slider .range.active .handle-bg{transform:scale(2.0)}.slider .range.active .floating,.slider .range:hover .floating{opacity:1}</style>", cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, nge, ige, F4, {
        slider: 1,
        range: 0,
        min: 31,
        max: 32,
        step: 33,
        value: 6,
        start: 29,
        end: 30,
        disabled: 2,
        discrete: 3,
        label: 4,
        suffix: 5
      }, null, [-1, -1]), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return [
        "slider",
        "range",
        "min",
        "max",
        "step",
        "value",
        "start",
        "end",
        "disabled",
        "discrete",
        "label",
        "suffix"
      ];
    }
    get slider() {
      return this.$$.ctx[1];
    }
    set slider(e) {
      this.$$set({ slider: e }), we();
    }
    get range() {
      return this.$$.ctx[0];
    }
    set range(e) {
      this.$$set({ range: e }), we();
    }
    get min() {
      return this.$$.ctx[31];
    }
    set min(e) {
      this.$$set({ min: e }), we();
    }
    get max() {
      return this.$$.ctx[32];
    }
    set max(e) {
      this.$$set({ max: e }), we();
    }
    get step() {
      return this.$$.ctx[33];
    }
    set step(e) {
      this.$$set({ step: e }), we();
    }
    get value() {
      return this.$$.ctx[6];
    }
    set value(e) {
      this.$$set({ value: e }), we();
    }
    get start() {
      return this.$$.ctx[29];
    }
    set start(e) {
      this.$$set({ start: e }), we();
    }
    get end() {
      return this.$$.ctx[30];
    }
    set end(e) {
      this.$$set({ end: e }), we();
    }
    get disabled() {
      return this.$$.ctx[2];
    }
    set disabled(e) {
      this.$$set({ disabled: e }), we();
    }
    get discrete() {
      return this.$$.ctx[3];
    }
    set discrete(e) {
      this.$$set({ discrete: e }), we();
    }
    get label() {
      return this.$$.ctx[4];
    }
    set label(e) {
      this.$$set({ label: e }), we();
    }
    get suffix() {
      return this.$$.ctx[5];
    }
    set suffix(e) {
      this.$$set({ suffix: e }), we();
    }
  }
  customElements.define("v-slider", x6);
  const sge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: x6
  }, Symbol.toStringTag, { value: "Module" }));
  function L4(s) {
    let e, t;
    return {
      c() {
        e = Ie("p"), t = Mi(s[0]), X(e, "class", "capitalize text-xs");
      },
      m(i, n) {
        Te(i, e, n), _e(e, t);
      },
      p(i, n) {
        n & 1 && Zi(t, i[0]);
      },
      d(i) {
        i && Qe(e);
      }
    };
  }
  function oge(s) {
    let e, t, i, n, o, r, a, l, c, d, h, u = s[3] === "labeled" && L4(s);
    return {
      c() {
        e = Ie("label"), t = Ie("button"), i = Ie("span"), n = Kt(), o = Ie("input"), l = Kt(), u && u.c(), this.c = Le, X(i, "class", "pointer-events-none relative inline-block border border-green/100 h-4 w-4 mt-px ml-px bg-white shadow transform ring-0 motion-safe:transition-transform ease-in-out duration-200"), ji(i, "translate-x-0", !s[6]), ji(i, "translate-x-6", s[6]), X(o, "name", s[2]), o.value = s[0], X(o, "class", "hidden"), X(o, "type", "checkbox"), o.checked = s[6], X(t, "type", "button"), X(t, "class", r = Mt("relative inline-flex flex-shrink-0 h-5 w-11 border border-black/70 bg-black/50 cursor-pointer motion-safe:transition-colors ease-in-out duration-200 focus:outline-none", { "bg-green/80": s[6] })), X(t, "role", "switch"), X(t, "aria-label", s[1]), X(t, "aria-checked", a = s[6] ? "true" : "false"), X(e, "class", c = Mt("flex items-center gap-1.5", {
          "opacity-50 pointer-events-none": s[7]
        }));
      },
      m(f, g) {
        Te(f, e, g), _e(e, t), _e(t, i), _e(t, n), _e(t, o), s[10](o), _e(e, l), u && u.m(e, null), s[11](e), d || (h = bi(t, "click", s[8]), d = !0);
      },
      p(f, [g]) {
        g & 64 && ji(i, "translate-x-0", !f[6]), g & 64 && ji(i, "translate-x-6", f[6]), g & 4 && X(o, "name", f[2]), g & 1 && (o.value = f[0]), g & 64 && (o.checked = f[6]), g & 64 && r !== (r = Mt("relative inline-flex flex-shrink-0 h-5 w-11 border border-black/70 bg-black/50 cursor-pointer motion-safe:transition-colors ease-in-out duration-200 focus:outline-none", { "bg-green/80": f[6] })) && X(t, "class", r), g & 2 && X(t, "aria-label", f[1]), g & 64 && a !== (a = f[6] ? "true" : "false") && X(t, "aria-checked", a), f[3] === "labeled" ? u ? u.p(f, g) : (u = L4(f), u.c(), u.m(e, null)) : u && (u.d(1), u = null), g & 128 && c !== (c = Mt("flex items-center gap-1.5", {
          "opacity-50 pointer-events-none": f[7]
        })) && X(e, "class", c);
      },
      i: Le,
      o: Le,
      d(f) {
        f && Qe(e), s[10](null), u && u.d(), s[11](null), d = !1, h();
      }
    };
  }
  function rge(s, e, t) {
    let { label: i = "" } = e, { name: n = "" } = e, { value: o = "off" } = e, { variant: r = "default" } = e, { disabled: a = "false" } = e;
    dn();
    let l, c, d, h;
    const u = () => {
      t(0, o = d ? "off" : "on"), t(5, c.checked = d, c), go(l, "input", { value: c.checked });
    };
    function f(_) {
      ds[_ ? "unshift" : "push"](() => {
        c = _, t(5, c);
      });
    }
    function g(_) {
      ds[_ ? "unshift" : "push"](() => {
        l = _, t(4, l);
      });
    }
    return s.$$set = (_) => {
      "label" in _ && t(1, i = _.label), "name" in _ && t(2, n = _.name), "value" in _ && t(0, o = _.value), "variant" in _ && t(3, r = _.variant), "disabled" in _ && t(9, a = _.disabled);
    }, s.$$.update = () => {
      s.$$.dirty & 1 && t(6, d = o === "on"), s.$$.dirty & 512 && t(7, h = a === "true");
    }, [
      o,
      i,
      n,
      r,
      l,
      c,
      d,
      h,
      u,
      a,
      f,
      g
    ];
  }
  class I6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, rge, oge, Cn, {
        label: 1,
        name: 2,
        value: 0,
        variant: 3,
        disabled: 9
      }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["label", "name", "value", "variant", "disabled"];
    }
    get label() {
      return this.$$.ctx[1];
    }
    set label(e) {
      this.$$set({ label: e }), we();
    }
    get name() {
      return this.$$.ctx[2];
    }
    set name(e) {
      this.$$set({ name: e }), we();
    }
    get value() {
      return this.$$.ctx[0];
    }
    set value(e) {
      this.$$set({ value: e }), we();
    }
    get variant() {
      return this.$$.ctx[3];
    }
    set variant(e) {
      this.$$set({ variant: e }), we();
    }
    get disabled() {
      return this.$$.ctx[9];
    }
    set disabled(e) {
      this.$$set({ disabled: e }), we();
    }
  }
  customElements.define("v-switch", I6);
  const age = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: I6
  }, Symbol.toStringTag, { value: "Module" }));
  function k4(s, e, t) {
    const i = s.slice();
    return i[3] = e[t], i;
  }
  function D4(s) {
    let e;
    return {
      c() {
        e = Ie("col"), co(e, "width", s[3]);
      },
      m(t, i) {
        Te(t, e, i);
      },
      p: Le,
      d(t) {
        t && Qe(e);
      }
    };
  }
  function lge(s) {
    let e, t, i, n, o, r = s[1], a = [];
    for (let l = 0; l < r.length; l += 1)
      a[l] = D4(k4(s, r, l));
    return {
      c() {
        e = Ie("table"), t = Ie("colgroup");
        for (let l = 0; l < a.length; l += 1)
          a[l].c();
        i = Kt(), n = Ie("slot"), this.c = Le, X(e, "class", o = Mt("bg-white text-xs w-full", {
          "table-fixed": s[0] === "fixed"
        }));
      },
      m(l, c) {
        Te(l, e, c), _e(e, t);
        for (let d = 0; d < a.length; d += 1)
          a[d].m(t, null);
        _e(e, i), _e(e, n);
      },
      p(l, [c]) {
        if (c & 2) {
          r = l[1];
          let d;
          for (d = 0; d < r.length; d += 1) {
            const h = k4(l, r, d);
            a[d] ? a[d].p(h, c) : (a[d] = D4(h), a[d].c(), a[d].m(t, null));
          }
          for (; d < a.length; d += 1)
            a[d].d(1);
          a.length = r.length;
        }
        c & 1 && o !== (o = Mt("bg-white text-xs w-full", {
          "table-fixed": l[0] === "fixed"
        })) && X(e, "class", o);
      },
      i: Le,
      o: Le,
      d(l) {
        l && Qe(e), xv(a, l);
      }
    };
  }
  function cge(s, e, t) {
    dn();
    let { variant: i = "" } = e, { cols: n = "" } = e;
    const o = n.split(",").map((r) => r.trim());
    return s.$$set = (r) => {
      "variant" in r && t(0, i = r.variant), "cols" in r && t(2, n = r.cols);
    }, [i, o, n];
  }
  class E6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, cge, lge, Cn, { variant: 0, cols: 2 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["variant", "cols"];
    }
    get variant() {
      return this.$$.ctx[0];
    }
    set variant(e) {
      this.$$set({ variant: e }), we();
    }
    get cols() {
      return this.$$.ctx[2];
    }
    set cols(e) {
      this.$$set({ cols: e }), we();
    }
  }
  customElements.define("v-table", E6);
  const dge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: E6
  }, Symbol.toStringTag, { value: "Module" }));
  function x4(s, e, t) {
    const i = s.slice();
    return i[8] = e[t], i[10] = t, i;
  }
  function I4(s, e) {
    let t, i = e[8] + "", n, o, r, a, l;
    function c() {
      return e[6](e[8]);
    }
    return {
      key: s,
      first: null,
      c() {
        t = Ie("button"), n = Mi(i), o = Kt(), X(t, "class", r = Mt("px-4 py-1 uppercase text-sm first:ml-4", {
          "bg-white border border-x-black border-t-black border-b-white font-bold": e[8] === e[0],
          "text-black/70": e[8] !== e[0],
          "border-l border-l-gray-300": e[3] > e[10],
          "border-r border-r-gray-300": e[3] < e[10]
        })), this.first = t;
      },
      m(d, h) {
        Te(d, t, h), _e(t, n), _e(t, o), a || (l = bi(t, "click", c), a = !0);
      },
      p(d, h) {
        e = d, h & 2 && i !== (i = e[8] + "") && Zi(n, i), h & 11 && r !== (r = Mt("px-4 py-1 uppercase text-sm first:ml-4", {
          "bg-white border border-x-black border-t-black border-b-white font-bold": e[8] === e[0],
          "text-black/70": e[8] !== e[0],
          "border-l border-l-gray-300": e[3] > e[10],
          "border-r border-r-gray-300": e[3] < e[10]
        })) && X(t, "class", r);
      },
      d(d) {
        d && Qe(t), a = !1, l();
      }
    };
  }
  function hge(s) {
    let e, t = [], i = /* @__PURE__ */ new Map(), n = s[1];
    const o = (r) => r[8];
    for (let r = 0; r < n.length; r += 1) {
      let a = x4(s, n, r), l = o(a);
      i.set(l, t[r] = I4(l, a));
    }
    return {
      c() {
        e = Ie("div");
        for (let r = 0; r < t.length; r += 1)
          t[r].c();
        this.c = Le, X(e, "class", "w-full flex bg-black/20");
      },
      m(r, a) {
        Te(r, e, a);
        for (let l = 0; l < t.length; l += 1)
          t[l].m(e, null);
        s[7](e);
      },
      p(r, [a]) {
        a & 27 && (n = r[1], t = rI(t, a, o, 1, r, n, i, e, oI, I4, null, x4));
      },
      i: Le,
      o: Le,
      d(r) {
        r && Qe(e);
        for (let a = 0; a < t.length; a += 1)
          t[a].d();
        s[7](null);
      }
    };
  }
  function uge(s, e, t) {
    let i, n, { tabs: o = "" } = e, { selected: r = "" } = e, a;
    dn();
    const l = (h) => {
      t(0, r = h), go(a, "input", { value: r });
    }, c = (h) => l(h);
    function d(h) {
      ds[h ? "unshift" : "push"](() => {
        a = h, t(2, a);
      });
    }
    return s.$$set = (h) => {
      "tabs" in h && t(5, o = h.tabs), "selected" in h && t(0, r = h.selected);
    }, s.$$.update = () => {
      s.$$.dirty & 32 && t(1, i = o.split(",").map((h) => h.trim())), s.$$.dirty & 3 && t(3, n = i.indexOf(r));
    }, [
      r,
      i,
      a,
      n,
      l,
      o,
      c,
      d
    ];
  }
  class N6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, uge, hge, Cn, { tabs: 5, selected: 0 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["tabs", "selected"];
    }
    get tabs() {
      return this.$$.ctx[5];
    }
    set tabs(e) {
      this.$$set({ tabs: e }), we();
    }
    get selected() {
      return this.$$.ctx[0];
    }
    set selected(e) {
      this.$$set({ selected: e }), we();
    }
  }
  customElements.define("v-tabs", N6);
  const fge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: N6
  }, Symbol.toStringTag, { value: "Module" }));
  function gge(s) {
    let e;
    return {
      c() {
        e = Ie("tbody"), e.innerHTML = "<slot></slot>", this.c = Le;
      },
      m(t, i) {
        Te(t, e, i);
      },
      p: Le,
      i: Le,
      o: Le,
      d(t) {
        t && Qe(e);
      }
    };
  }
  function mge(s) {
    return dn(), [];
  }
  class T6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, mge, gge, Cn, {}, null), e && e.target && Te(e.target, this, e.anchor);
    }
  }
  customElements.define("v-tbody", T6);
  const pge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: T6
  }, Symbol.toStringTag, { value: "Module" }));
  function _ge(s) {
    let e;
    return {
      c() {
        e = Ie("th"), e.innerHTML = "<slot></slot>", this.c = Le, X(e, "class", "p-2 text-neutral-600 font-normal overflow-hidden");
      },
      m(t, i) {
        Te(t, e, i);
      },
      p: Le,
      i: Le,
      o: Le,
      d(t) {
        t && Qe(e);
      }
    };
  }
  function bge(s) {
    return dn(), [];
  }
  class M6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, bge, _ge, Cn, {}, null), e && e.target && Te(e.target, this, e.anchor);
    }
  }
  customElements.define("v-th", M6);
  const vge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: M6
  }, Symbol.toStringTag, { value: "Module" }));
  function Cge(s) {
    let e;
    return {
      c() {
        e = Ie("td"), e.innerHTML = "<slot></slot>", this.c = Le, X(e, "class", "p-2 overflow-hidden");
      },
      m(t, i) {
        Te(t, e, i);
      },
      p: Le,
      i: Le,
      o: Le,
      d(t) {
        t && Qe(e);
      }
    };
  }
  function wge(s) {
    return dn(), [];
  }
  class A6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, wge, Cge, Cn, {}, null), e && e.target && Te(e.target, this, e.anchor);
    }
  }
  customElements.define("v-td", A6);
  const Sge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: A6
  }, Symbol.toStringTag, { value: "Module" }));
  function yge(s) {
    let e;
    return {
      c() {
        e = Ie("thead"), e.innerHTML = "<slot></slot>", this.c = Le, X(e, "class", "border-b border-black");
      },
      m(t, i) {
        Te(t, e, i);
      },
      p: Le,
      i: Le,
      o: Le,
      d(t) {
        t && Qe(e);
      }
    };
  }
  function Lge(s) {
    return dn(), [];
  }
  class R6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, Lge, yge, Cn, {}, null), e && e.target && Te(e.target, this, e.anchor);
    }
  }
  customElements.define("v-thead", R6);
  const kge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: R6
  }, Symbol.toStringTag, { value: "Module" }));
  function P_(s) {
    return s.split("-")[0];
  }
  function p2(s) {
    return s.split("-")[1];
  }
  function ww(s) {
    return ["top", "bottom"].includes(P_(s)) ? "x" : "y";
  }
  function O6(s) {
    return s === "y" ? "height" : "width";
  }
  function E4(s, e, t) {
    let {
      reference: i,
      floating: n
    } = s;
    const o = i.x + i.width / 2 - n.width / 2, r = i.y + i.height / 2 - n.height / 2, a = ww(e), l = O6(a), c = i[l] / 2 - n[l] / 2, d = P_(e), h = a === "x";
    let u;
    switch (d) {
      case "top":
        u = {
          x: o,
          y: i.y - n.height
        };
        break;
      case "bottom":
        u = {
          x: o,
          y: i.y + i.height
        };
        break;
      case "right":
        u = {
          x: i.x + i.width,
          y: r
        };
        break;
      case "left":
        u = {
          x: i.x - n.width,
          y: r
        };
        break;
      default:
        u = {
          x: i.x,
          y: i.y
        };
    }
    switch (p2(e)) {
      case "start":
        u[a] -= c * (t && h ? -1 : 1);
        break;
      case "end":
        u[a] += c * (t && h ? -1 : 1);
        break;
    }
    return u;
  }
  const Dge = async (s, e, t) => {
    const {
      placement: i = "bottom",
      strategy: n = "absolute",
      middleware: o = [],
      platform: r
    } = t, a = await (r.isRTL == null ? void 0 : r.isRTL(e));
    let l = await r.getElementRects({
      reference: s,
      floating: e,
      strategy: n
    }), {
      x: c,
      y: d
    } = E4(l, i, a), h = i, u = {}, f = 0;
    for (let g = 0; g < o.length; g++) {
      const {
        name: _,
        fn: b
      } = o[g], {
        x: C,
        y: v,
        data: w,
        reset: S
      } = await b({
        x: c,
        y: d,
        initialPlacement: i,
        placement: h,
        strategy: n,
        middlewareData: u,
        rects: l,
        platform: r,
        elements: {
          reference: s,
          floating: e
        }
      });
      if (c = C ?? c, d = v ?? d, u = {
        ...u,
        [_]: {
          ...u[_],
          ...w
        }
      }, S && f <= 50) {
        f++, typeof S == "object" && (S.placement && (h = S.placement), S.rects && (l = S.rects === !0 ? await r.getElementRects({
          reference: s,
          floating: e,
          strategy: n
        }) : S.rects), {
          x: c,
          y: d
        } = E4(l, h, a)), g = -1;
        continue;
      }
    }
    return {
      x: c,
      y: d,
      placement: h,
      strategy: n,
      middlewareData: u
    };
  };
  function xge(s) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...s
    };
  }
  function Ige(s) {
    return typeof s != "number" ? xge(s) : {
      top: s,
      right: s,
      bottom: s,
      left: s
    };
  }
  function yv(s) {
    return {
      ...s,
      top: s.y,
      left: s.x,
      right: s.x + s.width,
      bottom: s.y + s.height
    };
  }
  async function P6(s, e) {
    var t;
    e === void 0 && (e = {});
    const {
      x: i,
      y: n,
      platform: o,
      rects: r,
      elements: a,
      strategy: l
    } = s, {
      boundary: c = "clippingAncestors",
      rootBoundary: d = "viewport",
      elementContext: h = "floating",
      altBoundary: u = !1,
      padding: f = 0
    } = e, g = Ige(f), b = a[u ? h === "floating" ? "reference" : "floating" : h], C = yv(await o.getClippingRect({
      element: (t = await (o.isElement == null ? void 0 : o.isElement(b))) == null || t ? b : b.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
      boundary: c,
      rootBoundary: d,
      strategy: l
    })), v = yv(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
      rect: h === "floating" ? {
        ...r.floating,
        x: i,
        y: n
      } : r.reference,
      offsetParent: await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)),
      strategy: l
    }) : r[h]);
    return {
      top: C.top - v.top + g.top,
      bottom: v.bottom - C.bottom + g.bottom,
      left: C.left - v.left + g.left,
      right: v.right - C.right + g.right
    };
  }
  const Ege = Math.min, Nge = Math.max;
  function N4(s, e, t) {
    return Nge(s, Ege(e, t));
  }
  const Tge = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Lv(s) {
    return s.replace(/left|right|bottom|top/g, (e) => Tge[e]);
  }
  function Mge(s, e, t) {
    t === void 0 && (t = !1);
    const i = p2(s), n = ww(s), o = O6(n);
    let r = n === "x" ? i === (t ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
    return e.reference[o] > e.floating[o] && (r = Lv(r)), {
      main: r,
      cross: Lv(r)
    };
  }
  const Age = {
    start: "end",
    end: "start"
  };
  function T4(s) {
    return s.replace(/start|end/g, (e) => Age[e]);
  }
  function Rge(s) {
    const e = Lv(s);
    return [T4(s), e, T4(e)];
  }
  const Oge = function(s) {
    return s === void 0 && (s = {}), {
      name: "flip",
      options: s,
      async fn(e) {
        var t;
        const {
          placement: i,
          middlewareData: n,
          rects: o,
          initialPlacement: r,
          platform: a,
          elements: l
        } = e, {
          mainAxis: c = !0,
          crossAxis: d = !0,
          fallbackPlacements: h,
          fallbackStrategy: u = "bestFit",
          flipAlignment: f = !0,
          ...g
        } = s, _ = P_(i), C = h || (_ === r || !f ? [Lv(r)] : Rge(r)), v = [r, ...C], w = await P6(e, g), S = [];
        let L = ((t = n.flip) == null ? void 0 : t.overflows) || [];
        if (c && S.push(w[_]), d) {
          const {
            main: I,
            cross: F
          } = Mge(i, o, await (a.isRTL == null ? void 0 : a.isRTL(l.floating)));
          S.push(w[I], w[F]);
        }
        if (L = [...L, {
          placement: i,
          overflows: S
        }], !S.every((I) => I <= 0)) {
          var x, y;
          const I = ((x = (y = n.flip) == null ? void 0 : y.index) != null ? x : 0) + 1, F = v[I];
          if (F)
            return {
              data: {
                index: I,
                overflows: L
              },
              reset: {
                placement: F
              }
            };
          let R = "bottom";
          switch (u) {
            case "bestFit": {
              var k;
              const $ = (k = L.map((j) => [j, j.overflows.filter((le) => le > 0).reduce((le, he) => le + he, 0)]).sort((j, le) => j[1] - le[1])[0]) == null ? void 0 : k[0].placement;
              $ && (R = $);
              break;
            }
            case "initialPlacement":
              R = r;
              break;
          }
          if (i !== R)
            return {
              reset: {
                placement: R
              }
            };
        }
        return {};
      }
    };
  };
  async function Pge(s, e) {
    const {
      placement: t,
      platform: i,
      elements: n
    } = s, o = await (i.isRTL == null ? void 0 : i.isRTL(n.floating)), r = P_(t), a = p2(t), l = ww(t) === "x", c = ["left", "top"].includes(r) ? -1 : 1, d = o && l ? -1 : 1, h = typeof e == "function" ? e(s) : e;
    let {
      mainAxis: u,
      crossAxis: f,
      alignmentAxis: g
    } = typeof h == "number" ? {
      mainAxis: h,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null,
      ...h
    };
    return a && typeof g == "number" && (f = a === "end" ? g * -1 : g), l ? {
      x: f * d,
      y: u * c
    } : {
      x: u * c,
      y: f * d
    };
  }
  const Fge = function(s) {
    return s === void 0 && (s = 0), {
      name: "offset",
      options: s,
      async fn(e) {
        const {
          x: t,
          y: i
        } = e, n = await Pge(e, s);
        return {
          x: t + n.x,
          y: i + n.y,
          data: n
        };
      }
    };
  };
  function Bge(s) {
    return s === "x" ? "y" : "x";
  }
  const Wge = function(s) {
    return s === void 0 && (s = {}), {
      name: "shift",
      options: s,
      async fn(e) {
        const {
          x: t,
          y: i,
          placement: n
        } = e, {
          mainAxis: o = !0,
          crossAxis: r = !1,
          limiter: a = {
            fn: (b) => {
              let {
                x: C,
                y: v
              } = b;
              return {
                x: C,
                y: v
              };
            }
          },
          ...l
        } = s, c = {
          x: t,
          y: i
        }, d = await P6(e, l), h = ww(P_(n)), u = Bge(h);
        let f = c[h], g = c[u];
        if (o) {
          const b = h === "y" ? "top" : "left", C = h === "y" ? "bottom" : "right", v = f + d[b], w = f - d[C];
          f = N4(v, f, w);
        }
        if (r) {
          const b = u === "y" ? "top" : "left", C = u === "y" ? "bottom" : "right", v = g + d[b], w = g - d[C];
          g = N4(v, g, w);
        }
        const _ = a.fn({
          ...e,
          [h]: f,
          [u]: g
        });
        return {
          ..._,
          data: {
            x: _.x - t,
            y: _.y - i
          }
        };
      }
    };
  };
  function F6(s) {
    return s && s.document && s.location && s.alert && s.setInterval;
  }
  function yl(s) {
    if (s == null)
      return window;
    if (!F6(s)) {
      const e = s.ownerDocument;
      return e && e.defaultView || window;
    }
    return s;
  }
  function F_(s) {
    return yl(s).getComputedStyle(s);
  }
  function vl(s) {
    return F6(s) ? "" : s ? (s.nodeName || "").toLowerCase() : "";
  }
  function B6() {
    const s = navigator.userAgentData;
    return s != null && s.brands ? s.brands.map((e) => e.brand + "/" + e.version).join(" ") : navigator.userAgent;
  }
  function ba(s) {
    return s instanceof yl(s).HTMLElement;
  }
  function Yf(s) {
    return s instanceof yl(s).Element;
  }
  function Vge(s) {
    return s instanceof yl(s).Node;
  }
  function _2(s) {
    if (typeof ShadowRoot > "u")
      return !1;
    const e = yl(s).ShadowRoot;
    return s instanceof e || s instanceof ShadowRoot;
  }
  function Sw(s) {
    const {
      overflow: e,
      overflowX: t,
      overflowY: i
    } = F_(s);
    return /auto|scroll|overlay|hidden/.test(e + i + t);
  }
  function Hge(s) {
    return ["table", "td", "th"].includes(vl(s));
  }
  function W6(s) {
    const e = /firefox/i.test(B6()), t = F_(s);
    return t.transform !== "none" || t.perspective !== "none" || t.contain === "paint" || ["transform", "perspective"].includes(t.willChange) || e && t.willChange === "filter" || e && (t.filter ? t.filter !== "none" : !1);
  }
  function V6() {
    return !/^((?!chrome|android).)*safari/i.test(B6());
  }
  const M4 = Math.min, Pm = Math.max, kv = Math.round;
  function kh(s, e, t) {
    var i, n, o, r;
    e === void 0 && (e = !1), t === void 0 && (t = !1);
    const a = s.getBoundingClientRect();
    let l = 1, c = 1;
    e && ba(s) && (l = s.offsetWidth > 0 && kv(a.width) / s.offsetWidth || 1, c = s.offsetHeight > 0 && kv(a.height) / s.offsetHeight || 1);
    const d = Yf(s) ? yl(s) : window, h = !V6() && t, u = (a.left + (h && (i = (n = d.visualViewport) == null ? void 0 : n.offsetLeft) != null ? i : 0)) / l, f = (a.top + (h && (o = (r = d.visualViewport) == null ? void 0 : r.offsetTop) != null ? o : 0)) / c, g = a.width / l, _ = a.height / c;
    return {
      width: g,
      height: _,
      top: f,
      right: u + g,
      bottom: f + _,
      left: u,
      x: u,
      y: f
    };
  }
  function Kc(s) {
    return ((Vge(s) ? s.ownerDocument : s.document) || window.document).documentElement;
  }
  function yw(s) {
    return Yf(s) ? {
      scrollLeft: s.scrollLeft,
      scrollTop: s.scrollTop
    } : {
      scrollLeft: s.pageXOffset,
      scrollTop: s.pageYOffset
    };
  }
  function H6(s) {
    return kh(Kc(s)).left + yw(s).scrollLeft;
  }
  function zge(s) {
    const e = kh(s);
    return kv(e.width) !== s.offsetWidth || kv(e.height) !== s.offsetHeight;
  }
  function Uge(s, e, t) {
    const i = ba(e), n = Kc(e), o = kh(s, i && zge(e), t === "fixed");
    let r = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const a = {
      x: 0,
      y: 0
    };
    if (i || !i && t !== "fixed")
      if ((vl(e) !== "body" || Sw(n)) && (r = yw(e)), ba(e)) {
        const l = kh(e, !0);
        a.x = l.x + e.clientLeft, a.y = l.y + e.clientTop;
      } else
        n && (a.x = H6(n));
    return {
      x: o.left + r.scrollLeft - a.x,
      y: o.top + r.scrollTop - a.y,
      width: o.width,
      height: o.height
    };
  }
  function z6(s) {
    return vl(s) === "html" ? s : s.assignedSlot || s.parentNode || (_2(s) ? s.host : null) || Kc(s);
  }
  function A4(s) {
    return !ba(s) || getComputedStyle(s).position === "fixed" ? null : s.offsetParent;
  }
  function $ge(s) {
    let e = z6(s);
    for (_2(e) && (e = e.host); ba(e) && !["html", "body"].includes(vl(e)); ) {
      if (W6(e))
        return e;
      e = e.parentNode;
    }
    return null;
  }
  function iI(s) {
    const e = yl(s);
    let t = A4(s);
    for (; t && Hge(t) && getComputedStyle(t).position === "static"; )
      t = A4(t);
    return t && (vl(t) === "html" || vl(t) === "body" && getComputedStyle(t).position === "static" && !W6(t)) ? e : t || $ge(s) || e;
  }
  function R4(s) {
    if (ba(s))
      return {
        width: s.offsetWidth,
        height: s.offsetHeight
      };
    const e = kh(s);
    return {
      width: e.width,
      height: e.height
    };
  }
  function jge(s) {
    let {
      rect: e,
      offsetParent: t,
      strategy: i
    } = s;
    const n = ba(t), o = Kc(t);
    if (t === o)
      return e;
    let r = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const a = {
      x: 0,
      y: 0
    };
    if ((n || !n && i !== "fixed") && ((vl(t) !== "body" || Sw(o)) && (r = yw(t)), ba(t))) {
      const l = kh(t, !0);
      a.x = l.x + t.clientLeft, a.y = l.y + t.clientTop;
    }
    return {
      ...e,
      x: e.x - r.scrollLeft + a.x,
      y: e.y - r.scrollTop + a.y
    };
  }
  function Kge(s, e) {
    const t = yl(s), i = Kc(s), n = t.visualViewport;
    let o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
    if (n) {
      o = n.width, r = n.height;
      const c = V6();
      (c || !c && e === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
    }
    return {
      width: o,
      height: r,
      x: a,
      y: l
    };
  }
  function qge(s) {
    var e;
    const t = Kc(s), i = yw(s), n = (e = s.ownerDocument) == null ? void 0 : e.body, o = Pm(t.scrollWidth, t.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = Pm(t.scrollHeight, t.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0);
    let a = -i.scrollLeft + H6(s);
    const l = -i.scrollTop;
    return F_(n || t).direction === "rtl" && (a += Pm(t.clientWidth, n ? n.clientWidth : 0) - o), {
      width: o,
      height: r,
      x: a,
      y: l
    };
  }
  function U6(s) {
    const e = z6(s);
    return ["html", "body", "#document"].includes(vl(e)) ? s.ownerDocument.body : ba(e) && Sw(e) ? e : U6(e);
  }
  function $6(s, e) {
    var t;
    e === void 0 && (e = []);
    const i = U6(s), n = i === ((t = s.ownerDocument) == null ? void 0 : t.body), o = yl(i), r = n ? [o].concat(o.visualViewport || [], Sw(i) ? i : []) : i, a = e.concat(r);
    return n ? a : a.concat($6(r));
  }
  function Gge(s, e) {
    const t = e.getRootNode == null ? void 0 : e.getRootNode();
    if (s.contains(e))
      return !0;
    if (t && _2(t)) {
      let i = e;
      do {
        if (i && s === i)
          return !0;
        i = i.parentNode || i.host;
      } while (i);
    }
    return !1;
  }
  function Zge(s, e) {
    const t = kh(s, !1, e === "fixed"), i = t.top + s.clientTop, n = t.left + s.clientLeft;
    return {
      top: i,
      left: n,
      x: n,
      y: i,
      right: n + s.clientWidth,
      bottom: i + s.clientHeight,
      width: s.clientWidth,
      height: s.clientHeight
    };
  }
  function O4(s, e, t) {
    return e === "viewport" ? yv(Kge(s, t)) : Yf(e) ? Zge(e, t) : yv(qge(Kc(s)));
  }
  function Yge(s) {
    const e = $6(s), i = ["absolute", "fixed"].includes(F_(s).position) && ba(s) ? iI(s) : s;
    return Yf(i) ? e.filter((n) => Yf(n) && Gge(n, i) && vl(n) !== "body") : [];
  }
  function Xge(s) {
    let {
      element: e,
      boundary: t,
      rootBoundary: i,
      strategy: n
    } = s;
    const r = [...t === "clippingAncestors" ? Yge(e) : [].concat(t), i], a = r[0], l = r.reduce((c, d) => {
      const h = O4(e, d, n);
      return c.top = Pm(h.top, c.top), c.right = M4(h.right, c.right), c.bottom = M4(h.bottom, c.bottom), c.left = Pm(h.left, c.left), c;
    }, O4(e, a, n));
    return {
      width: l.right - l.left,
      height: l.bottom - l.top,
      x: l.left,
      y: l.top
    };
  }
  const Qge = {
    getClippingRect: Xge,
    convertOffsetParentRelativeRectToViewportRelativeRect: jge,
    isElement: Yf,
    getDimensions: R4,
    getOffsetParent: iI,
    getDocumentElement: Kc,
    getElementRects: (s) => {
      let {
        reference: e,
        floating: t,
        strategy: i
      } = s;
      return {
        reference: Uge(e, iI(t), i),
        floating: {
          ...R4(t),
          x: 0,
          y: 0
        }
      };
    },
    getClientRects: (s) => Array.from(s.getClientRects()),
    isRTL: (s) => F_(s).direction === "rtl"
  }, Jge = (s, e, t) => Dge(s, e, {
    platform: Qge,
    ...t
  });
  function eme(s) {
    let e, t, i, n, o, r, a;
    return {
      c() {
        e = Ie("div"), t = Ie("slot"), i = Kt(), n = Ie("div"), o = Mi(s[0]), this.c = Le, X(n, "role", "tooltip"), X(n, "class", `
      absolute
      top-0
      left-0
      bg-white
      text-black
      text-left
      text-xs
      p-3
      border
      z-10
    `), co(n, "transform", "translate(" + s[4] + "px, " + s[5] + "px)"), ji(n, "invisible", s[3]), X(e, "class", "relative"), X(e, "aria-describedby", "tooltip");
      },
      m(l, c) {
        Te(l, e, c), _e(e, t), _e(e, i), _e(e, n), _e(n, o), s[9](n), s[10](e), r || (a = [
          bi(e, "mouseenter", s[6]),
          bi(e, "mouseleave", s[7])
        ], r = !0);
      },
      p(l, [c]) {
        c & 1 && Zi(o, l[0]), c & 48 && co(n, "transform", "translate(" + l[4] + "px, " + l[5] + "px)"), c & 8 && ji(n, "invisible", l[3]);
      },
      i: Le,
      o: Le,
      d(l) {
        l && Qe(e), s[9](null), s[10](null), r = !1, Cl(a);
      }
    };
  }
  function tme(s, e, t) {
    let { text: i = "" } = e, { location: n = "top" } = e, o, r, a = !0, l = 0, c = 0;
    const d = async () => {
      const _ = await Jge(o, r, {
        placement: n,
        middleware: [Oge(), Wge({ padding: 5 }), Fge(10)]
      });
      t(4, l = _.x), t(5, c = _.y);
    }, h = async () => {
      await d(), t(3, a = !1);
    }, u = () => {
      t(3, a = !0);
    };
    dn();
    function f(_) {
      ds[_ ? "unshift" : "push"](() => {
        r = _, t(2, r);
      });
    }
    function g(_) {
      ds[_ ? "unshift" : "push"](() => {
        o = _, t(1, o);
      });
    }
    return s.$$set = (_) => {
      "text" in _ && t(0, i = _.text), "location" in _ && t(8, n = _.location);
    }, [
      i,
      o,
      r,
      a,
      l,
      c,
      h,
      u,
      n,
      f,
      g
    ];
  }
  class j6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, tme, eme, Cn, { text: 0, location: 8 }, null), e && (e.target && Te(e.target, this, e.anchor), e.props && (this.$set(e.props), we()));
    }
    static get observedAttributes() {
      return ["text", "location"];
    }
    get text() {
      return this.$$.ctx[0];
    }
    set text(e) {
      this.$$set({ text: e }), we();
    }
    get location() {
      return this.$$.ctx[8];
    }
    set location(e) {
      this.$$set({ location: e }), we();
    }
  }
  customElements.define("v-tooltip", j6);
  const ime = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: j6
  }, Symbol.toStringTag, { value: "Module" }));
  function nme(s) {
    let e;
    return {
      c() {
        e = Ie("tr"), e.innerHTML = "<slot></slot>", this.c = Le, X(e, "class", "border-b");
      },
      m(t, i) {
        Te(t, e, i);
      },
      p: Le,
      i: Le,
      o: Le,
      d(t) {
        t && Qe(e);
      }
    };
  }
  function sme(s) {
    return dn(), [];
  }
  class K6 extends Yi {
    constructor(e) {
      super(), cn(this, {
        target: this.shadowRoot,
        props: ln(this.attributes),
        customElement: !0
      }, sme, nme, Cn, {}, null), e && e.target && Te(e.target, this, e.anchor);
    }
  }
  customElements.define("v-tr", K6);
  const ome = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: K6
  }, Symbol.toStringTag, { value: "Module" }));
});
export default rme();
